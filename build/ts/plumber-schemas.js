/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const protos = $root.protos = (() => {

    /**
     * Namespace protos.
     * @exports protos
     * @namespace
     */
    const protos = {};

    protos.args = (function() {

        /**
         * Namespace args.
         * @memberof protos
         * @namespace
         */
        const args = {};

        args.ActiveMQConn = (function() {

            /**
             * Properties of an ActiveMQConn.
             * @memberof protos.args
             * @interface IActiveMQConn
             * @property {string|null} [address] ActiveMQConn address
             */

            /**
             * Constructs a new ActiveMQConn.
             * @memberof protos.args
             * @classdesc Represents an ActiveMQConn.
             * @implements IActiveMQConn
             * @constructor
             * @param {protos.args.IActiveMQConn=} [properties] Properties to set
             */
            function ActiveMQConn(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActiveMQConn address.
             * @member {string} address
             * @memberof protos.args.ActiveMQConn
             * @instance
             */
            ActiveMQConn.prototype.address = "";

            /**
             * Creates a new ActiveMQConn instance using the specified properties.
             * @function create
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {protos.args.IActiveMQConn=} [properties] Properties to set
             * @returns {protos.args.ActiveMQConn} ActiveMQConn instance
             */
            ActiveMQConn.create = function create(properties) {
                return new ActiveMQConn(properties);
            };

            /**
             * Encodes the specified ActiveMQConn message. Does not implicitly {@link protos.args.ActiveMQConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {protos.args.IActiveMQConn} message ActiveMQConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                return writer;
            };

            /**
             * Encodes the specified ActiveMQConn message, length delimited. Does not implicitly {@link protos.args.ActiveMQConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {protos.args.IActiveMQConn} message ActiveMQConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ActiveMQConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.ActiveMQConn} ActiveMQConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.ActiveMQConn();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ActiveMQConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.ActiveMQConn} ActiveMQConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ActiveMQConn message.
             * @function verify
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActiveMQConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                return null;
            };

            /**
             * Creates an ActiveMQConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.ActiveMQConn} ActiveMQConn
             */
            ActiveMQConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.ActiveMQConn)
                    return object;
                let message = new $root.protos.args.ActiveMQConn();
                if (object.address != null)
                    message.address = String(object.address);
                return message;
            };

            /**
             * Creates a plain object from an ActiveMQConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {protos.args.ActiveMQConn} message ActiveMQConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ActiveMQConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.address = "";
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                return object;
            };

            /**
             * Converts this ActiveMQConn to JSON.
             * @function toJSON
             * @memberof protos.args.ActiveMQConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ActiveMQConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ActiveMQConn;
        })();

        args.ActiveMQReadArgs = (function() {

            /**
             * Properties of an ActiveMQReadArgs.
             * @memberof protos.args
             * @interface IActiveMQReadArgs
             * @property {string|null} [topic] ActiveMQReadArgs topic
             * @property {string|null} [queue] ActiveMQReadArgs queue
             */

            /**
             * Constructs a new ActiveMQReadArgs.
             * @memberof protos.args
             * @classdesc Represents an ActiveMQReadArgs.
             * @implements IActiveMQReadArgs
             * @constructor
             * @param {protos.args.IActiveMQReadArgs=} [properties] Properties to set
             */
            function ActiveMQReadArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActiveMQReadArgs topic.
             * @member {string} topic
             * @memberof protos.args.ActiveMQReadArgs
             * @instance
             */
            ActiveMQReadArgs.prototype.topic = "";

            /**
             * ActiveMQReadArgs queue.
             * @member {string} queue
             * @memberof protos.args.ActiveMQReadArgs
             * @instance
             */
            ActiveMQReadArgs.prototype.queue = "";

            /**
             * Creates a new ActiveMQReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {protos.args.IActiveMQReadArgs=} [properties] Properties to set
             * @returns {protos.args.ActiveMQReadArgs} ActiveMQReadArgs instance
             */
            ActiveMQReadArgs.create = function create(properties) {
                return new ActiveMQReadArgs(properties);
            };

            /**
             * Encodes the specified ActiveMQReadArgs message. Does not implicitly {@link protos.args.ActiveMQReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {protos.args.IActiveMQReadArgs} message ActiveMQReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.queue != null && Object.hasOwnProperty.call(message, "queue"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.queue);
                return writer;
            };

            /**
             * Encodes the specified ActiveMQReadArgs message, length delimited. Does not implicitly {@link protos.args.ActiveMQReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {protos.args.IActiveMQReadArgs} message ActiveMQReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ActiveMQReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.ActiveMQReadArgs} ActiveMQReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.ActiveMQReadArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.queue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ActiveMQReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.ActiveMQReadArgs} ActiveMQReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ActiveMQReadArgs message.
             * @function verify
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActiveMQReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.queue != null && message.hasOwnProperty("queue"))
                    if (!$util.isString(message.queue))
                        return "queue: string expected";
                return null;
            };

            /**
             * Creates an ActiveMQReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.ActiveMQReadArgs} ActiveMQReadArgs
             */
            ActiveMQReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.ActiveMQReadArgs)
                    return object;
                let message = new $root.protos.args.ActiveMQReadArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.queue != null)
                    message.queue = String(object.queue);
                return message;
            };

            /**
             * Creates a plain object from an ActiveMQReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {protos.args.ActiveMQReadArgs} message ActiveMQReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ActiveMQReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.queue = "";
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.queue != null && message.hasOwnProperty("queue"))
                    object.queue = message.queue;
                return object;
            };

            /**
             * Converts this ActiveMQReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.ActiveMQReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ActiveMQReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ActiveMQReadArgs;
        })();

        args.ActiveMQWriteArgs = (function() {

            /**
             * Properties of an ActiveMQWriteArgs.
             * @memberof protos.args
             * @interface IActiveMQWriteArgs
             * @property {string|null} [topic] ActiveMQWriteArgs topic
             * @property {string|null} [queue] ActiveMQWriteArgs queue
             */

            /**
             * Constructs a new ActiveMQWriteArgs.
             * @memberof protos.args
             * @classdesc Represents an ActiveMQWriteArgs.
             * @implements IActiveMQWriteArgs
             * @constructor
             * @param {protos.args.IActiveMQWriteArgs=} [properties] Properties to set
             */
            function ActiveMQWriteArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActiveMQWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.ActiveMQWriteArgs
             * @instance
             */
            ActiveMQWriteArgs.prototype.topic = "";

            /**
             * ActiveMQWriteArgs queue.
             * @member {string} queue
             * @memberof protos.args.ActiveMQWriteArgs
             * @instance
             */
            ActiveMQWriteArgs.prototype.queue = "";

            /**
             * Creates a new ActiveMQWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {protos.args.IActiveMQWriteArgs=} [properties] Properties to set
             * @returns {protos.args.ActiveMQWriteArgs} ActiveMQWriteArgs instance
             */
            ActiveMQWriteArgs.create = function create(properties) {
                return new ActiveMQWriteArgs(properties);
            };

            /**
             * Encodes the specified ActiveMQWriteArgs message. Does not implicitly {@link protos.args.ActiveMQWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {protos.args.IActiveMQWriteArgs} message ActiveMQWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.queue != null && Object.hasOwnProperty.call(message, "queue"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.queue);
                return writer;
            };

            /**
             * Encodes the specified ActiveMQWriteArgs message, length delimited. Does not implicitly {@link protos.args.ActiveMQWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {protos.args.IActiveMQWriteArgs} message ActiveMQWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ActiveMQWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.ActiveMQWriteArgs} ActiveMQWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.ActiveMQWriteArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.queue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ActiveMQWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.ActiveMQWriteArgs} ActiveMQWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ActiveMQWriteArgs message.
             * @function verify
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActiveMQWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.queue != null && message.hasOwnProperty("queue"))
                    if (!$util.isString(message.queue))
                        return "queue: string expected";
                return null;
            };

            /**
             * Creates an ActiveMQWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.ActiveMQWriteArgs} ActiveMQWriteArgs
             */
            ActiveMQWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.ActiveMQWriteArgs)
                    return object;
                let message = new $root.protos.args.ActiveMQWriteArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.queue != null)
                    message.queue = String(object.queue);
                return message;
            };

            /**
             * Creates a plain object from an ActiveMQWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {protos.args.ActiveMQWriteArgs} message ActiveMQWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ActiveMQWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.queue = "";
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.queue != null && message.hasOwnProperty("queue"))
                    object.queue = message.queue;
                return object;
            };

            /**
             * Converts this ActiveMQWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.ActiveMQWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ActiveMQWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ActiveMQWriteArgs;
        })();

        args.AWSSNSConn = (function() {

            /**
             * Properties of a AWSSNSConn.
             * @memberof protos.args
             * @interface IAWSSNSConn
             * @property {string|null} [awsRegion] AWSSNSConn awsRegion
             * @property {string|null} [awsAccessKeyId] AWSSNSConn awsAccessKeyId
             * @property {string|null} [awsSecretAccessKey] AWSSNSConn awsSecretAccessKey
             */

            /**
             * Constructs a new AWSSNSConn.
             * @memberof protos.args
             * @classdesc Represents a AWSSNSConn.
             * @implements IAWSSNSConn
             * @constructor
             * @param {protos.args.IAWSSNSConn=} [properties] Properties to set
             */
            function AWSSNSConn(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSNSConn awsRegion.
             * @member {string} awsRegion
             * @memberof protos.args.AWSSNSConn
             * @instance
             */
            AWSSNSConn.prototype.awsRegion = "";

            /**
             * AWSSNSConn awsAccessKeyId.
             * @member {string} awsAccessKeyId
             * @memberof protos.args.AWSSNSConn
             * @instance
             */
            AWSSNSConn.prototype.awsAccessKeyId = "";

            /**
             * AWSSNSConn awsSecretAccessKey.
             * @member {string} awsSecretAccessKey
             * @memberof protos.args.AWSSNSConn
             * @instance
             */
            AWSSNSConn.prototype.awsSecretAccessKey = "";

            /**
             * Creates a new AWSSNSConn instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {protos.args.IAWSSNSConn=} [properties] Properties to set
             * @returns {protos.args.AWSSNSConn} AWSSNSConn instance
             */
            AWSSNSConn.create = function create(properties) {
                return new AWSSNSConn(properties);
            };

            /**
             * Encodes the specified AWSSNSConn message. Does not implicitly {@link protos.args.AWSSNSConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {protos.args.IAWSSNSConn} message AWSSNSConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSNSConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.awsRegion != null && Object.hasOwnProperty.call(message, "awsRegion"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.awsRegion);
                if (message.awsAccessKeyId != null && Object.hasOwnProperty.call(message, "awsAccessKeyId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.awsAccessKeyId);
                if (message.awsSecretAccessKey != null && Object.hasOwnProperty.call(message, "awsSecretAccessKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.awsSecretAccessKey);
                return writer;
            };

            /**
             * Encodes the specified AWSSNSConn message, length delimited. Does not implicitly {@link protos.args.AWSSNSConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {protos.args.IAWSSNSConn} message AWSSNSConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSNSConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSNSConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSNSConn} AWSSNSConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSNSConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSNSConn();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.awsRegion = reader.string();
                        break;
                    case 2:
                        message.awsAccessKeyId = reader.string();
                        break;
                    case 3:
                        message.awsSecretAccessKey = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSNSConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSNSConn} AWSSNSConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSNSConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSNSConn message.
             * @function verify
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSNSConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.awsRegion != null && message.hasOwnProperty("awsRegion"))
                    if (!$util.isString(message.awsRegion))
                        return "awsRegion: string expected";
                if (message.awsAccessKeyId != null && message.hasOwnProperty("awsAccessKeyId"))
                    if (!$util.isString(message.awsAccessKeyId))
                        return "awsAccessKeyId: string expected";
                if (message.awsSecretAccessKey != null && message.hasOwnProperty("awsSecretAccessKey"))
                    if (!$util.isString(message.awsSecretAccessKey))
                        return "awsSecretAccessKey: string expected";
                return null;
            };

            /**
             * Creates a AWSSNSConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSNSConn} AWSSNSConn
             */
            AWSSNSConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSNSConn)
                    return object;
                let message = new $root.protos.args.AWSSNSConn();
                if (object.awsRegion != null)
                    message.awsRegion = String(object.awsRegion);
                if (object.awsAccessKeyId != null)
                    message.awsAccessKeyId = String(object.awsAccessKeyId);
                if (object.awsSecretAccessKey != null)
                    message.awsSecretAccessKey = String(object.awsSecretAccessKey);
                return message;
            };

            /**
             * Creates a plain object from a AWSSNSConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {protos.args.AWSSNSConn} message AWSSNSConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSNSConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.awsRegion = "";
                    object.awsAccessKeyId = "";
                    object.awsSecretAccessKey = "";
                }
                if (message.awsRegion != null && message.hasOwnProperty("awsRegion"))
                    object.awsRegion = message.awsRegion;
                if (message.awsAccessKeyId != null && message.hasOwnProperty("awsAccessKeyId"))
                    object.awsAccessKeyId = message.awsAccessKeyId;
                if (message.awsSecretAccessKey != null && message.hasOwnProperty("awsSecretAccessKey"))
                    object.awsSecretAccessKey = message.awsSecretAccessKey;
                return object;
            };

            /**
             * Converts this AWSSNSConn to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSNSConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSNSConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSNSConn;
        })();

        args.AWSSNSWriteArgs = (function() {

            /**
             * Properties of a AWSSNSWriteArgs.
             * @memberof protos.args
             * @interface IAWSSNSWriteArgs
             * @property {string|null} [topic] AWSSNSWriteArgs topic
             */

            /**
             * Constructs a new AWSSNSWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a AWSSNSWriteArgs.
             * @implements IAWSSNSWriteArgs
             * @constructor
             * @param {protos.args.IAWSSNSWriteArgs=} [properties] Properties to set
             */
            function AWSSNSWriteArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSNSWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.AWSSNSWriteArgs
             * @instance
             */
            AWSSNSWriteArgs.prototype.topic = "";

            /**
             * Creates a new AWSSNSWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {protos.args.IAWSSNSWriteArgs=} [properties] Properties to set
             * @returns {protos.args.AWSSNSWriteArgs} AWSSNSWriteArgs instance
             */
            AWSSNSWriteArgs.create = function create(properties) {
                return new AWSSNSWriteArgs(properties);
            };

            /**
             * Encodes the specified AWSSNSWriteArgs message. Does not implicitly {@link protos.args.AWSSNSWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {protos.args.IAWSSNSWriteArgs} message AWSSNSWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSNSWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                return writer;
            };

            /**
             * Encodes the specified AWSSNSWriteArgs message, length delimited. Does not implicitly {@link protos.args.AWSSNSWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {protos.args.IAWSSNSWriteArgs} message AWSSNSWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSNSWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSNSWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSNSWriteArgs} AWSSNSWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSNSWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSNSWriteArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSNSWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSNSWriteArgs} AWSSNSWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSNSWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSNSWriteArgs message.
             * @function verify
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSNSWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                return null;
            };

            /**
             * Creates a AWSSNSWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSNSWriteArgs} AWSSNSWriteArgs
             */
            AWSSNSWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSNSWriteArgs)
                    return object;
                let message = new $root.protos.args.AWSSNSWriteArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                return message;
            };

            /**
             * Creates a plain object from a AWSSNSWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {protos.args.AWSSNSWriteArgs} message AWSSNSWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSNSWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.topic = "";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                return object;
            };

            /**
             * Converts this AWSSNSWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSNSWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSNSWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSNSWriteArgs;
        })();

        args.AWSSQSConn = (function() {

            /**
             * Properties of a AWSSQSConn.
             * @memberof protos.args
             * @interface IAWSSQSConn
             * @property {string|null} [awsRegion] AWSSQSConn awsRegion
             * @property {string|null} [awsAccessKeyId] AWSSQSConn awsAccessKeyId
             * @property {string|null} [awsSecretAccessKey] AWSSQSConn awsSecretAccessKey
             */

            /**
             * Constructs a new AWSSQSConn.
             * @memberof protos.args
             * @classdesc Represents a AWSSQSConn.
             * @implements IAWSSQSConn
             * @constructor
             * @param {protos.args.IAWSSQSConn=} [properties] Properties to set
             */
            function AWSSQSConn(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSQSConn awsRegion.
             * @member {string} awsRegion
             * @memberof protos.args.AWSSQSConn
             * @instance
             */
            AWSSQSConn.prototype.awsRegion = "";

            /**
             * AWSSQSConn awsAccessKeyId.
             * @member {string} awsAccessKeyId
             * @memberof protos.args.AWSSQSConn
             * @instance
             */
            AWSSQSConn.prototype.awsAccessKeyId = "";

            /**
             * AWSSQSConn awsSecretAccessKey.
             * @member {string} awsSecretAccessKey
             * @memberof protos.args.AWSSQSConn
             * @instance
             */
            AWSSQSConn.prototype.awsSecretAccessKey = "";

            /**
             * Creates a new AWSSQSConn instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {protos.args.IAWSSQSConn=} [properties] Properties to set
             * @returns {protos.args.AWSSQSConn} AWSSQSConn instance
             */
            AWSSQSConn.create = function create(properties) {
                return new AWSSQSConn(properties);
            };

            /**
             * Encodes the specified AWSSQSConn message. Does not implicitly {@link protos.args.AWSSQSConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {protos.args.IAWSSQSConn} message AWSSQSConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.awsRegion != null && Object.hasOwnProperty.call(message, "awsRegion"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.awsRegion);
                if (message.awsAccessKeyId != null && Object.hasOwnProperty.call(message, "awsAccessKeyId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.awsAccessKeyId);
                if (message.awsSecretAccessKey != null && Object.hasOwnProperty.call(message, "awsSecretAccessKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.awsSecretAccessKey);
                return writer;
            };

            /**
             * Encodes the specified AWSSQSConn message, length delimited. Does not implicitly {@link protos.args.AWSSQSConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {protos.args.IAWSSQSConn} message AWSSQSConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSQSConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSQSConn} AWSSQSConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSQSConn();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.awsRegion = reader.string();
                        break;
                    case 2:
                        message.awsAccessKeyId = reader.string();
                        break;
                    case 3:
                        message.awsSecretAccessKey = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSQSConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSQSConn} AWSSQSConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSQSConn message.
             * @function verify
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSQSConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.awsRegion != null && message.hasOwnProperty("awsRegion"))
                    if (!$util.isString(message.awsRegion))
                        return "awsRegion: string expected";
                if (message.awsAccessKeyId != null && message.hasOwnProperty("awsAccessKeyId"))
                    if (!$util.isString(message.awsAccessKeyId))
                        return "awsAccessKeyId: string expected";
                if (message.awsSecretAccessKey != null && message.hasOwnProperty("awsSecretAccessKey"))
                    if (!$util.isString(message.awsSecretAccessKey))
                        return "awsSecretAccessKey: string expected";
                return null;
            };

            /**
             * Creates a AWSSQSConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSQSConn} AWSSQSConn
             */
            AWSSQSConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSQSConn)
                    return object;
                let message = new $root.protos.args.AWSSQSConn();
                if (object.awsRegion != null)
                    message.awsRegion = String(object.awsRegion);
                if (object.awsAccessKeyId != null)
                    message.awsAccessKeyId = String(object.awsAccessKeyId);
                if (object.awsSecretAccessKey != null)
                    message.awsSecretAccessKey = String(object.awsSecretAccessKey);
                return message;
            };

            /**
             * Creates a plain object from a AWSSQSConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {protos.args.AWSSQSConn} message AWSSQSConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSQSConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.awsRegion = "";
                    object.awsAccessKeyId = "";
                    object.awsSecretAccessKey = "";
                }
                if (message.awsRegion != null && message.hasOwnProperty("awsRegion"))
                    object.awsRegion = message.awsRegion;
                if (message.awsAccessKeyId != null && message.hasOwnProperty("awsAccessKeyId"))
                    object.awsAccessKeyId = message.awsAccessKeyId;
                if (message.awsSecretAccessKey != null && message.hasOwnProperty("awsSecretAccessKey"))
                    object.awsSecretAccessKey = message.awsSecretAccessKey;
                return object;
            };

            /**
             * Converts this AWSSQSConn to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSQSConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSQSConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSQSConn;
        })();

        args.AWSSQSReadArgs = (function() {

            /**
             * Properties of a AWSSQSReadArgs.
             * @memberof protos.args
             * @interface IAWSSQSReadArgs
             * @property {string|null} [queueName] AWSSQSReadArgs queueName
             * @property {string|null} [remoteAccountId] AWSSQSReadArgs remoteAccountId
             * @property {number|null} [maxNumMessages] AWSSQSReadArgs maxNumMessages
             * @property {string|null} [receiveRequestAttemptId] AWSSQSReadArgs receiveRequestAttemptId
             * @property {boolean|null} [autoDelete] AWSSQSReadArgs autoDelete
             * @property {number|null} [waitTimeSeconds] AWSSQSReadArgs waitTimeSeconds
             */

            /**
             * Constructs a new AWSSQSReadArgs.
             * @memberof protos.args
             * @classdesc Represents a AWSSQSReadArgs.
             * @implements IAWSSQSReadArgs
             * @constructor
             * @param {protos.args.IAWSSQSReadArgs=} [properties] Properties to set
             */
            function AWSSQSReadArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSQSReadArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.queueName = "";

            /**
             * AWSSQSReadArgs remoteAccountId.
             * @member {string} remoteAccountId
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.remoteAccountId = "";

            /**
             * AWSSQSReadArgs maxNumMessages.
             * @member {number} maxNumMessages
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.maxNumMessages = 0;

            /**
             * AWSSQSReadArgs receiveRequestAttemptId.
             * @member {string} receiveRequestAttemptId
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.receiveRequestAttemptId = "";

            /**
             * AWSSQSReadArgs autoDelete.
             * @member {boolean} autoDelete
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.autoDelete = false;

            /**
             * AWSSQSReadArgs waitTimeSeconds.
             * @member {number} waitTimeSeconds
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.waitTimeSeconds = 0;

            /**
             * Creates a new AWSSQSReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {protos.args.IAWSSQSReadArgs=} [properties] Properties to set
             * @returns {protos.args.AWSSQSReadArgs} AWSSQSReadArgs instance
             */
            AWSSQSReadArgs.create = function create(properties) {
                return new AWSSQSReadArgs(properties);
            };

            /**
             * Encodes the specified AWSSQSReadArgs message. Does not implicitly {@link protos.args.AWSSQSReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {protos.args.IAWSSQSReadArgs} message AWSSQSReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queueName);
                if (message.remoteAccountId != null && Object.hasOwnProperty.call(message, "remoteAccountId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.remoteAccountId);
                if (message.maxNumMessages != null && Object.hasOwnProperty.call(message, "maxNumMessages"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.maxNumMessages);
                if (message.receiveRequestAttemptId != null && Object.hasOwnProperty.call(message, "receiveRequestAttemptId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.receiveRequestAttemptId);
                if (message.autoDelete != null && Object.hasOwnProperty.call(message, "autoDelete"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.autoDelete);
                if (message.waitTimeSeconds != null && Object.hasOwnProperty.call(message, "waitTimeSeconds"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.waitTimeSeconds);
                return writer;
            };

            /**
             * Encodes the specified AWSSQSReadArgs message, length delimited. Does not implicitly {@link protos.args.AWSSQSReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {protos.args.IAWSSQSReadArgs} message AWSSQSReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSQSReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSQSReadArgs} AWSSQSReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSQSReadArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queueName = reader.string();
                        break;
                    case 2:
                        message.remoteAccountId = reader.string();
                        break;
                    case 3:
                        message.maxNumMessages = reader.uint32();
                        break;
                    case 4:
                        message.receiveRequestAttemptId = reader.string();
                        break;
                    case 5:
                        message.autoDelete = reader.bool();
                        break;
                    case 6:
                        message.waitTimeSeconds = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSQSReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSQSReadArgs} AWSSQSReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSQSReadArgs message.
             * @function verify
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSQSReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    if (!$util.isString(message.remoteAccountId))
                        return "remoteAccountId: string expected";
                if (message.maxNumMessages != null && message.hasOwnProperty("maxNumMessages"))
                    if (!$util.isInteger(message.maxNumMessages))
                        return "maxNumMessages: integer expected";
                if (message.receiveRequestAttemptId != null && message.hasOwnProperty("receiveRequestAttemptId"))
                    if (!$util.isString(message.receiveRequestAttemptId))
                        return "receiveRequestAttemptId: string expected";
                if (message.autoDelete != null && message.hasOwnProperty("autoDelete"))
                    if (typeof message.autoDelete !== "boolean")
                        return "autoDelete: boolean expected";
                if (message.waitTimeSeconds != null && message.hasOwnProperty("waitTimeSeconds"))
                    if (!$util.isInteger(message.waitTimeSeconds))
                        return "waitTimeSeconds: integer expected";
                return null;
            };

            /**
             * Creates a AWSSQSReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSQSReadArgs} AWSSQSReadArgs
             */
            AWSSQSReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSQSReadArgs)
                    return object;
                let message = new $root.protos.args.AWSSQSReadArgs();
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                if (object.remoteAccountId != null)
                    message.remoteAccountId = String(object.remoteAccountId);
                if (object.maxNumMessages != null)
                    message.maxNumMessages = object.maxNumMessages >>> 0;
                if (object.receiveRequestAttemptId != null)
                    message.receiveRequestAttemptId = String(object.receiveRequestAttemptId);
                if (object.autoDelete != null)
                    message.autoDelete = Boolean(object.autoDelete);
                if (object.waitTimeSeconds != null)
                    message.waitTimeSeconds = object.waitTimeSeconds >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a AWSSQSReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {protos.args.AWSSQSReadArgs} message AWSSQSReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSQSReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.queueName = "";
                    object.remoteAccountId = "";
                    object.maxNumMessages = 0;
                    object.receiveRequestAttemptId = "";
                    object.autoDelete = false;
                    object.waitTimeSeconds = 0;
                }
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    object.remoteAccountId = message.remoteAccountId;
                if (message.maxNumMessages != null && message.hasOwnProperty("maxNumMessages"))
                    object.maxNumMessages = message.maxNumMessages;
                if (message.receiveRequestAttemptId != null && message.hasOwnProperty("receiveRequestAttemptId"))
                    object.receiveRequestAttemptId = message.receiveRequestAttemptId;
                if (message.autoDelete != null && message.hasOwnProperty("autoDelete"))
                    object.autoDelete = message.autoDelete;
                if (message.waitTimeSeconds != null && message.hasOwnProperty("waitTimeSeconds"))
                    object.waitTimeSeconds = message.waitTimeSeconds;
                return object;
            };

            /**
             * Converts this AWSSQSReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSQSReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSQSReadArgs;
        })();

        args.AWSSQSWriteArgs = (function() {

            /**
             * Properties of a AWSSQSWriteArgs.
             * @memberof protos.args
             * @interface IAWSSQSWriteArgs
             * @property {string|null} [queueName] AWSSQSWriteArgs queueName
             * @property {string|null} [remoteAccountId] AWSSQSWriteArgs remoteAccountId
             * @property {number|null} [delaySeconds] AWSSQSWriteArgs delaySeconds
             * @property {Object.<string,string>|null} [attributes] AWSSQSWriteArgs attributes
             * @property {string|null} [messageGroupId] AWSSQSWriteArgs messageGroupId
             * @property {string|null} [messageDeduplicationId] AWSSQSWriteArgs messageDeduplicationId
             */

            /**
             * Constructs a new AWSSQSWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a AWSSQSWriteArgs.
             * @implements IAWSSQSWriteArgs
             * @constructor
             * @param {protos.args.IAWSSQSWriteArgs=} [properties] Properties to set
             */
            function AWSSQSWriteArgs(properties) {
                this.attributes = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSQSWriteArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.queueName = "";

            /**
             * AWSSQSWriteArgs remoteAccountId.
             * @member {string} remoteAccountId
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.remoteAccountId = "";

            /**
             * AWSSQSWriteArgs delaySeconds.
             * @member {number} delaySeconds
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.delaySeconds = 0;

            /**
             * AWSSQSWriteArgs attributes.
             * @member {Object.<string,string>} attributes
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.attributes = $util.emptyObject;

            /**
             * AWSSQSWriteArgs messageGroupId.
             * @member {string} messageGroupId
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.messageGroupId = "";

            /**
             * AWSSQSWriteArgs messageDeduplicationId.
             * @member {string} messageDeduplicationId
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.messageDeduplicationId = "";

            /**
             * Creates a new AWSSQSWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {protos.args.IAWSSQSWriteArgs=} [properties] Properties to set
             * @returns {protos.args.AWSSQSWriteArgs} AWSSQSWriteArgs instance
             */
            AWSSQSWriteArgs.create = function create(properties) {
                return new AWSSQSWriteArgs(properties);
            };

            /**
             * Encodes the specified AWSSQSWriteArgs message. Does not implicitly {@link protos.args.AWSSQSWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {protos.args.IAWSSQSWriteArgs} message AWSSQSWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queueName);
                if (message.remoteAccountId != null && Object.hasOwnProperty.call(message, "remoteAccountId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.remoteAccountId);
                if (message.delaySeconds != null && Object.hasOwnProperty.call(message, "delaySeconds"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.delaySeconds);
                if (message.attributes != null && Object.hasOwnProperty.call(message, "attributes"))
                    for (let keys = Object.keys(message.attributes), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.attributes[keys[i]]).ldelim();
                if (message.messageGroupId != null && Object.hasOwnProperty.call(message, "messageGroupId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.messageGroupId);
                if (message.messageDeduplicationId != null && Object.hasOwnProperty.call(message, "messageDeduplicationId"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.messageDeduplicationId);
                return writer;
            };

            /**
             * Encodes the specified AWSSQSWriteArgs message, length delimited. Does not implicitly {@link protos.args.AWSSQSWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {protos.args.IAWSSQSWriteArgs} message AWSSQSWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSQSWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSQSWriteArgs} AWSSQSWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSQSWriteArgs(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queueName = reader.string();
                        break;
                    case 2:
                        message.remoteAccountId = reader.string();
                        break;
                    case 3:
                        message.delaySeconds = reader.uint32();
                        break;
                    case 4:
                        if (message.attributes === $util.emptyObject)
                            message.attributes = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.attributes[key] = value;
                        break;
                    case 5:
                        message.messageGroupId = reader.string();
                        break;
                    case 6:
                        message.messageDeduplicationId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSQSWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSQSWriteArgs} AWSSQSWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSQSWriteArgs message.
             * @function verify
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSQSWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    if (!$util.isString(message.remoteAccountId))
                        return "remoteAccountId: string expected";
                if (message.delaySeconds != null && message.hasOwnProperty("delaySeconds"))
                    if (!$util.isInteger(message.delaySeconds))
                        return "delaySeconds: integer expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    if (!$util.isObject(message.attributes))
                        return "attributes: object expected";
                    let key = Object.keys(message.attributes);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isString(message.attributes[key[i]]))
                            return "attributes: string{k:string} expected";
                }
                if (message.messageGroupId != null && message.hasOwnProperty("messageGroupId"))
                    if (!$util.isString(message.messageGroupId))
                        return "messageGroupId: string expected";
                if (message.messageDeduplicationId != null && message.hasOwnProperty("messageDeduplicationId"))
                    if (!$util.isString(message.messageDeduplicationId))
                        return "messageDeduplicationId: string expected";
                return null;
            };

            /**
             * Creates a AWSSQSWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSQSWriteArgs} AWSSQSWriteArgs
             */
            AWSSQSWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSQSWriteArgs)
                    return object;
                let message = new $root.protos.args.AWSSQSWriteArgs();
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                if (object.remoteAccountId != null)
                    message.remoteAccountId = String(object.remoteAccountId);
                if (object.delaySeconds != null)
                    message.delaySeconds = object.delaySeconds >>> 0;
                if (object.attributes) {
                    if (typeof object.attributes !== "object")
                        throw TypeError(".protos.args.AWSSQSWriteArgs.attributes: object expected");
                    message.attributes = {};
                    for (let keys = Object.keys(object.attributes), i = 0; i < keys.length; ++i)
                        message.attributes[keys[i]] = String(object.attributes[keys[i]]);
                }
                if (object.messageGroupId != null)
                    message.messageGroupId = String(object.messageGroupId);
                if (object.messageDeduplicationId != null)
                    message.messageDeduplicationId = String(object.messageDeduplicationId);
                return message;
            };

            /**
             * Creates a plain object from a AWSSQSWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {protos.args.AWSSQSWriteArgs} message AWSSQSWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSQSWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults)
                    object.attributes = {};
                if (options.defaults) {
                    object.queueName = "";
                    object.remoteAccountId = "";
                    object.delaySeconds = 0;
                    object.messageGroupId = "";
                    object.messageDeduplicationId = "";
                }
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    object.remoteAccountId = message.remoteAccountId;
                if (message.delaySeconds != null && message.hasOwnProperty("delaySeconds"))
                    object.delaySeconds = message.delaySeconds;
                let keys2;
                if (message.attributes && (keys2 = Object.keys(message.attributes)).length) {
                    object.attributes = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.attributes[keys2[j]] = message.attributes[keys2[j]];
                }
                if (message.messageGroupId != null && message.hasOwnProperty("messageGroupId"))
                    object.messageGroupId = message.messageGroupId;
                if (message.messageDeduplicationId != null && message.hasOwnProperty("messageDeduplicationId"))
                    object.messageDeduplicationId = message.messageDeduplicationId;
                return object;
            };

            /**
             * Converts this AWSSQSWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSQSWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSQSWriteArgs;
        })();

        args.AWSSQSRelayArgs = (function() {

            /**
             * Properties of a AWSSQSRelayArgs.
             * @memberof protos.args
             * @interface IAWSSQSRelayArgs
             * @property {string|null} [queueName] AWSSQSRelayArgs queueName
             * @property {string|null} [remoteAccountId] AWSSQSRelayArgs remoteAccountId
             * @property {number|null} [maxNumMessages] AWSSQSRelayArgs maxNumMessages
             * @property {string|null} [receiveRequestAttemptId] AWSSQSRelayArgs receiveRequestAttemptId
             * @property {boolean|null} [autoDelete] AWSSQSRelayArgs autoDelete
             * @property {number|null} [waitTimeSeconds] AWSSQSRelayArgs waitTimeSeconds
             */

            /**
             * Constructs a new AWSSQSRelayArgs.
             * @memberof protos.args
             * @classdesc Represents a AWSSQSRelayArgs.
             * @implements IAWSSQSRelayArgs
             * @constructor
             * @param {protos.args.IAWSSQSRelayArgs=} [properties] Properties to set
             */
            function AWSSQSRelayArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSQSRelayArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.queueName = "";

            /**
             * AWSSQSRelayArgs remoteAccountId.
             * @member {string} remoteAccountId
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.remoteAccountId = "";

            /**
             * AWSSQSRelayArgs maxNumMessages.
             * @member {number} maxNumMessages
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.maxNumMessages = 0;

            /**
             * AWSSQSRelayArgs receiveRequestAttemptId.
             * @member {string} receiveRequestAttemptId
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.receiveRequestAttemptId = "";

            /**
             * AWSSQSRelayArgs autoDelete.
             * @member {boolean} autoDelete
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.autoDelete = false;

            /**
             * AWSSQSRelayArgs waitTimeSeconds.
             * @member {number} waitTimeSeconds
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.waitTimeSeconds = 0;

            /**
             * Creates a new AWSSQSRelayArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {protos.args.IAWSSQSRelayArgs=} [properties] Properties to set
             * @returns {protos.args.AWSSQSRelayArgs} AWSSQSRelayArgs instance
             */
            AWSSQSRelayArgs.create = function create(properties) {
                return new AWSSQSRelayArgs(properties);
            };

            /**
             * Encodes the specified AWSSQSRelayArgs message. Does not implicitly {@link protos.args.AWSSQSRelayArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {protos.args.IAWSSQSRelayArgs} message AWSSQSRelayArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSRelayArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queueName);
                if (message.remoteAccountId != null && Object.hasOwnProperty.call(message, "remoteAccountId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.remoteAccountId);
                if (message.maxNumMessages != null && Object.hasOwnProperty.call(message, "maxNumMessages"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.maxNumMessages);
                if (message.receiveRequestAttemptId != null && Object.hasOwnProperty.call(message, "receiveRequestAttemptId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.receiveRequestAttemptId);
                if (message.autoDelete != null && Object.hasOwnProperty.call(message, "autoDelete"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.autoDelete);
                if (message.waitTimeSeconds != null && Object.hasOwnProperty.call(message, "waitTimeSeconds"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.waitTimeSeconds);
                return writer;
            };

            /**
             * Encodes the specified AWSSQSRelayArgs message, length delimited. Does not implicitly {@link protos.args.AWSSQSRelayArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {protos.args.IAWSSQSRelayArgs} message AWSSQSRelayArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSRelayArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSQSRelayArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSQSRelayArgs} AWSSQSRelayArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSRelayArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSQSRelayArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queueName = reader.string();
                        break;
                    case 2:
                        message.remoteAccountId = reader.string();
                        break;
                    case 3:
                        message.maxNumMessages = reader.uint32();
                        break;
                    case 4:
                        message.receiveRequestAttemptId = reader.string();
                        break;
                    case 5:
                        message.autoDelete = reader.bool();
                        break;
                    case 6:
                        message.waitTimeSeconds = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSQSRelayArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSQSRelayArgs} AWSSQSRelayArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSRelayArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSQSRelayArgs message.
             * @function verify
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSQSRelayArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    if (!$util.isString(message.remoteAccountId))
                        return "remoteAccountId: string expected";
                if (message.maxNumMessages != null && message.hasOwnProperty("maxNumMessages"))
                    if (!$util.isInteger(message.maxNumMessages))
                        return "maxNumMessages: integer expected";
                if (message.receiveRequestAttemptId != null && message.hasOwnProperty("receiveRequestAttemptId"))
                    if (!$util.isString(message.receiveRequestAttemptId))
                        return "receiveRequestAttemptId: string expected";
                if (message.autoDelete != null && message.hasOwnProperty("autoDelete"))
                    if (typeof message.autoDelete !== "boolean")
                        return "autoDelete: boolean expected";
                if (message.waitTimeSeconds != null && message.hasOwnProperty("waitTimeSeconds"))
                    if (!$util.isInteger(message.waitTimeSeconds))
                        return "waitTimeSeconds: integer expected";
                return null;
            };

            /**
             * Creates a AWSSQSRelayArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSQSRelayArgs} AWSSQSRelayArgs
             */
            AWSSQSRelayArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSQSRelayArgs)
                    return object;
                let message = new $root.protos.args.AWSSQSRelayArgs();
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                if (object.remoteAccountId != null)
                    message.remoteAccountId = String(object.remoteAccountId);
                if (object.maxNumMessages != null)
                    message.maxNumMessages = object.maxNumMessages >>> 0;
                if (object.receiveRequestAttemptId != null)
                    message.receiveRequestAttemptId = String(object.receiveRequestAttemptId);
                if (object.autoDelete != null)
                    message.autoDelete = Boolean(object.autoDelete);
                if (object.waitTimeSeconds != null)
                    message.waitTimeSeconds = object.waitTimeSeconds | 0;
                return message;
            };

            /**
             * Creates a plain object from a AWSSQSRelayArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {protos.args.AWSSQSRelayArgs} message AWSSQSRelayArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSQSRelayArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.queueName = "";
                    object.remoteAccountId = "";
                    object.maxNumMessages = 0;
                    object.receiveRequestAttemptId = "";
                    object.autoDelete = false;
                    object.waitTimeSeconds = 0;
                }
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    object.remoteAccountId = message.remoteAccountId;
                if (message.maxNumMessages != null && message.hasOwnProperty("maxNumMessages"))
                    object.maxNumMessages = message.maxNumMessages;
                if (message.receiveRequestAttemptId != null && message.hasOwnProperty("receiveRequestAttemptId"))
                    object.receiveRequestAttemptId = message.receiveRequestAttemptId;
                if (message.autoDelete != null && message.hasOwnProperty("autoDelete"))
                    object.autoDelete = message.autoDelete;
                if (message.waitTimeSeconds != null && message.hasOwnProperty("waitTimeSeconds"))
                    object.waitTimeSeconds = message.waitTimeSeconds;
                return object;
            };

            /**
             * Converts this AWSSQSRelayArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSQSRelayArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSQSRelayArgs;
        })();

        args.AzureEventHubConn = (function() {

            /**
             * Properties of an AzureEventHubConn.
             * @memberof protos.args
             * @interface IAzureEventHubConn
             * @property {string|null} [connectionString] AzureEventHubConn connectionString
             */

            /**
             * Constructs a new AzureEventHubConn.
             * @memberof protos.args
             * @classdesc Represents an AzureEventHubConn.
             * @implements IAzureEventHubConn
             * @constructor
             * @param {protos.args.IAzureEventHubConn=} [properties] Properties to set
             */
            function AzureEventHubConn(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureEventHubConn connectionString.
             * @member {string} connectionString
             * @memberof protos.args.AzureEventHubConn
             * @instance
             */
            AzureEventHubConn.prototype.connectionString = "";

            /**
             * Creates a new AzureEventHubConn instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {protos.args.IAzureEventHubConn=} [properties] Properties to set
             * @returns {protos.args.AzureEventHubConn} AzureEventHubConn instance
             */
            AzureEventHubConn.create = function create(properties) {
                return new AzureEventHubConn(properties);
            };

            /**
             * Encodes the specified AzureEventHubConn message. Does not implicitly {@link protos.args.AzureEventHubConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {protos.args.IAzureEventHubConn} message AzureEventHubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.connectionString != null && Object.hasOwnProperty.call(message, "connectionString"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionString);
                return writer;
            };

            /**
             * Encodes the specified AzureEventHubConn message, length delimited. Does not implicitly {@link protos.args.AzureEventHubConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {protos.args.IAzureEventHubConn} message AzureEventHubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureEventHubConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureEventHubConn} AzureEventHubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureEventHubConn();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.connectionString = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureEventHubConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureEventHubConn} AzureEventHubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureEventHubConn message.
             * @function verify
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureEventHubConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.connectionString != null && message.hasOwnProperty("connectionString"))
                    if (!$util.isString(message.connectionString))
                        return "connectionString: string expected";
                return null;
            };

            /**
             * Creates an AzureEventHubConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureEventHubConn} AzureEventHubConn
             */
            AzureEventHubConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureEventHubConn)
                    return object;
                let message = new $root.protos.args.AzureEventHubConn();
                if (object.connectionString != null)
                    message.connectionString = String(object.connectionString);
                return message;
            };

            /**
             * Creates a plain object from an AzureEventHubConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {protos.args.AzureEventHubConn} message AzureEventHubConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureEventHubConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.connectionString = "";
                if (message.connectionString != null && message.hasOwnProperty("connectionString"))
                    object.connectionString = message.connectionString;
                return object;
            };

            /**
             * Converts this AzureEventHubConn to JSON.
             * @function toJSON
             * @memberof protos.args.AzureEventHubConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureEventHubConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureEventHubConn;
        })();

        args.AzureEventHubReadArgs = (function() {

            /**
             * Properties of an AzureEventHubReadArgs.
             * @memberof protos.args
             * @interface IAzureEventHubReadArgs
             */

            /**
             * Constructs a new AzureEventHubReadArgs.
             * @memberof protos.args
             * @classdesc Represents an AzureEventHubReadArgs.
             * @implements IAzureEventHubReadArgs
             * @constructor
             * @param {protos.args.IAzureEventHubReadArgs=} [properties] Properties to set
             */
            function AzureEventHubReadArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new AzureEventHubReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {protos.args.IAzureEventHubReadArgs=} [properties] Properties to set
             * @returns {protos.args.AzureEventHubReadArgs} AzureEventHubReadArgs instance
             */
            AzureEventHubReadArgs.create = function create(properties) {
                return new AzureEventHubReadArgs(properties);
            };

            /**
             * Encodes the specified AzureEventHubReadArgs message. Does not implicitly {@link protos.args.AzureEventHubReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {protos.args.IAzureEventHubReadArgs} message AzureEventHubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified AzureEventHubReadArgs message, length delimited. Does not implicitly {@link protos.args.AzureEventHubReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {protos.args.IAzureEventHubReadArgs} message AzureEventHubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureEventHubReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureEventHubReadArgs} AzureEventHubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureEventHubReadArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureEventHubReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureEventHubReadArgs} AzureEventHubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureEventHubReadArgs message.
             * @function verify
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureEventHubReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an AzureEventHubReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureEventHubReadArgs} AzureEventHubReadArgs
             */
            AzureEventHubReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureEventHubReadArgs)
                    return object;
                return new $root.protos.args.AzureEventHubReadArgs();
            };

            /**
             * Creates a plain object from an AzureEventHubReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {protos.args.AzureEventHubReadArgs} message AzureEventHubReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureEventHubReadArgs.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this AzureEventHubReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AzureEventHubReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureEventHubReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureEventHubReadArgs;
        })();

        args.AzureEventHubWriteArgs = (function() {

            /**
             * Properties of an AzureEventHubWriteArgs.
             * @memberof protos.args
             * @interface IAzureEventHubWriteArgs
             * @property {string|null} [messageId] AzureEventHubWriteArgs messageId
             * @property {string|null} [partitionKey] AzureEventHubWriteArgs partitionKey
             */

            /**
             * Constructs a new AzureEventHubWriteArgs.
             * @memberof protos.args
             * @classdesc Represents an AzureEventHubWriteArgs.
             * @implements IAzureEventHubWriteArgs
             * @constructor
             * @param {protos.args.IAzureEventHubWriteArgs=} [properties] Properties to set
             */
            function AzureEventHubWriteArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureEventHubWriteArgs messageId.
             * @member {string} messageId
             * @memberof protos.args.AzureEventHubWriteArgs
             * @instance
             */
            AzureEventHubWriteArgs.prototype.messageId = "";

            /**
             * AzureEventHubWriteArgs partitionKey.
             * @member {string} partitionKey
             * @memberof protos.args.AzureEventHubWriteArgs
             * @instance
             */
            AzureEventHubWriteArgs.prototype.partitionKey = "";

            /**
             * Creates a new AzureEventHubWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {protos.args.IAzureEventHubWriteArgs=} [properties] Properties to set
             * @returns {protos.args.AzureEventHubWriteArgs} AzureEventHubWriteArgs instance
             */
            AzureEventHubWriteArgs.create = function create(properties) {
                return new AzureEventHubWriteArgs(properties);
            };

            /**
             * Encodes the specified AzureEventHubWriteArgs message. Does not implicitly {@link protos.args.AzureEventHubWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {protos.args.IAzureEventHubWriteArgs} message AzureEventHubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.messageId);
                if (message.partitionKey != null && Object.hasOwnProperty.call(message, "partitionKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.partitionKey);
                return writer;
            };

            /**
             * Encodes the specified AzureEventHubWriteArgs message, length delimited. Does not implicitly {@link protos.args.AzureEventHubWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {protos.args.IAzureEventHubWriteArgs} message AzureEventHubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureEventHubWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureEventHubWriteArgs} AzureEventHubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureEventHubWriteArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageId = reader.string();
                        break;
                    case 2:
                        message.partitionKey = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureEventHubWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureEventHubWriteArgs} AzureEventHubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureEventHubWriteArgs message.
             * @function verify
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureEventHubWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    if (!$util.isString(message.partitionKey))
                        return "partitionKey: string expected";
                return null;
            };

            /**
             * Creates an AzureEventHubWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureEventHubWriteArgs} AzureEventHubWriteArgs
             */
            AzureEventHubWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureEventHubWriteArgs)
                    return object;
                let message = new $root.protos.args.AzureEventHubWriteArgs();
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.partitionKey != null)
                    message.partitionKey = String(object.partitionKey);
                return message;
            };

            /**
             * Creates a plain object from an AzureEventHubWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {protos.args.AzureEventHubWriteArgs} message AzureEventHubWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureEventHubWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.messageId = "";
                    object.partitionKey = "";
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    object.partitionKey = message.partitionKey;
                return object;
            };

            /**
             * Converts this AzureEventHubWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AzureEventHubWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureEventHubWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureEventHubWriteArgs;
        })();

        args.AzureServiceBusConn = (function() {

            /**
             * Properties of an AzureServiceBusConn.
             * @memberof protos.args
             * @interface IAzureServiceBusConn
             * @property {string|null} [connectionString] AzureServiceBusConn connectionString
             */

            /**
             * Constructs a new AzureServiceBusConn.
             * @memberof protos.args
             * @classdesc Represents an AzureServiceBusConn.
             * @implements IAzureServiceBusConn
             * @constructor
             * @param {protos.args.IAzureServiceBusConn=} [properties] Properties to set
             */
            function AzureServiceBusConn(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureServiceBusConn connectionString.
             * @member {string} connectionString
             * @memberof protos.args.AzureServiceBusConn
             * @instance
             */
            AzureServiceBusConn.prototype.connectionString = "";

            /**
             * Creates a new AzureServiceBusConn instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {protos.args.IAzureServiceBusConn=} [properties] Properties to set
             * @returns {protos.args.AzureServiceBusConn} AzureServiceBusConn instance
             */
            AzureServiceBusConn.create = function create(properties) {
                return new AzureServiceBusConn(properties);
            };

            /**
             * Encodes the specified AzureServiceBusConn message. Does not implicitly {@link protos.args.AzureServiceBusConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {protos.args.IAzureServiceBusConn} message AzureServiceBusConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.connectionString != null && Object.hasOwnProperty.call(message, "connectionString"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionString);
                return writer;
            };

            /**
             * Encodes the specified AzureServiceBusConn message, length delimited. Does not implicitly {@link protos.args.AzureServiceBusConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {protos.args.IAzureServiceBusConn} message AzureServiceBusConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureServiceBusConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureServiceBusConn} AzureServiceBusConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureServiceBusConn();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.connectionString = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureServiceBusConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureServiceBusConn} AzureServiceBusConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureServiceBusConn message.
             * @function verify
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureServiceBusConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.connectionString != null && message.hasOwnProperty("connectionString"))
                    if (!$util.isString(message.connectionString))
                        return "connectionString: string expected";
                return null;
            };

            /**
             * Creates an AzureServiceBusConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureServiceBusConn} AzureServiceBusConn
             */
            AzureServiceBusConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureServiceBusConn)
                    return object;
                let message = new $root.protos.args.AzureServiceBusConn();
                if (object.connectionString != null)
                    message.connectionString = String(object.connectionString);
                return message;
            };

            /**
             * Creates a plain object from an AzureServiceBusConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {protos.args.AzureServiceBusConn} message AzureServiceBusConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureServiceBusConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.connectionString = "";
                if (message.connectionString != null && message.hasOwnProperty("connectionString"))
                    object.connectionString = message.connectionString;
                return object;
            };

            /**
             * Converts this AzureServiceBusConn to JSON.
             * @function toJSON
             * @memberof protos.args.AzureServiceBusConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureServiceBusConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureServiceBusConn;
        })();

        args.AzureServiceBusReadArgs = (function() {

            /**
             * Properties of an AzureServiceBusReadArgs.
             * @memberof protos.args
             * @interface IAzureServiceBusReadArgs
             * @property {string|null} [queue] AzureServiceBusReadArgs queue
             * @property {string|null} [topic] AzureServiceBusReadArgs topic
             * @property {string|null} [subscriptionName] AzureServiceBusReadArgs subscriptionName
             */

            /**
             * Constructs a new AzureServiceBusReadArgs.
             * @memberof protos.args
             * @classdesc Represents an AzureServiceBusReadArgs.
             * @implements IAzureServiceBusReadArgs
             * @constructor
             * @param {protos.args.IAzureServiceBusReadArgs=} [properties] Properties to set
             */
            function AzureServiceBusReadArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureServiceBusReadArgs queue.
             * @member {string} queue
             * @memberof protos.args.AzureServiceBusReadArgs
             * @instance
             */
            AzureServiceBusReadArgs.prototype.queue = "";

            /**
             * AzureServiceBusReadArgs topic.
             * @member {string} topic
             * @memberof protos.args.AzureServiceBusReadArgs
             * @instance
             */
            AzureServiceBusReadArgs.prototype.topic = "";

            /**
             * AzureServiceBusReadArgs subscriptionName.
             * @member {string} subscriptionName
             * @memberof protos.args.AzureServiceBusReadArgs
             * @instance
             */
            AzureServiceBusReadArgs.prototype.subscriptionName = "";

            /**
             * Creates a new AzureServiceBusReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {protos.args.IAzureServiceBusReadArgs=} [properties] Properties to set
             * @returns {protos.args.AzureServiceBusReadArgs} AzureServiceBusReadArgs instance
             */
            AzureServiceBusReadArgs.create = function create(properties) {
                return new AzureServiceBusReadArgs(properties);
            };

            /**
             * Encodes the specified AzureServiceBusReadArgs message. Does not implicitly {@link protos.args.AzureServiceBusReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {protos.args.IAzureServiceBusReadArgs} message AzureServiceBusReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queue != null && Object.hasOwnProperty.call(message, "queue"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queue);
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.topic);
                if (message.subscriptionName != null && Object.hasOwnProperty.call(message, "subscriptionName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.subscriptionName);
                return writer;
            };

            /**
             * Encodes the specified AzureServiceBusReadArgs message, length delimited. Does not implicitly {@link protos.args.AzureServiceBusReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {protos.args.IAzureServiceBusReadArgs} message AzureServiceBusReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureServiceBusReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureServiceBusReadArgs} AzureServiceBusReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureServiceBusReadArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queue = reader.string();
                        break;
                    case 2:
                        message.topic = reader.string();
                        break;
                    case 3:
                        message.subscriptionName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureServiceBusReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureServiceBusReadArgs} AzureServiceBusReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureServiceBusReadArgs message.
             * @function verify
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureServiceBusReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queue != null && message.hasOwnProperty("queue"))
                    if (!$util.isString(message.queue))
                        return "queue: string expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.subscriptionName != null && message.hasOwnProperty("subscriptionName"))
                    if (!$util.isString(message.subscriptionName))
                        return "subscriptionName: string expected";
                return null;
            };

            /**
             * Creates an AzureServiceBusReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureServiceBusReadArgs} AzureServiceBusReadArgs
             */
            AzureServiceBusReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureServiceBusReadArgs)
                    return object;
                let message = new $root.protos.args.AzureServiceBusReadArgs();
                if (object.queue != null)
                    message.queue = String(object.queue);
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.subscriptionName != null)
                    message.subscriptionName = String(object.subscriptionName);
                return message;
            };

            /**
             * Creates a plain object from an AzureServiceBusReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {protos.args.AzureServiceBusReadArgs} message AzureServiceBusReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureServiceBusReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.queue = "";
                    object.topic = "";
                    object.subscriptionName = "";
                }
                if (message.queue != null && message.hasOwnProperty("queue"))
                    object.queue = message.queue;
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.subscriptionName != null && message.hasOwnProperty("subscriptionName"))
                    object.subscriptionName = message.subscriptionName;
                return object;
            };

            /**
             * Converts this AzureServiceBusReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AzureServiceBusReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureServiceBusReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureServiceBusReadArgs;
        })();

        args.AzureServiceBusWriteArgs = (function() {

            /**
             * Properties of an AzureServiceBusWriteArgs.
             * @memberof protos.args
             * @interface IAzureServiceBusWriteArgs
             * @property {string|null} [queue] AzureServiceBusWriteArgs queue
             * @property {string|null} [topic] AzureServiceBusWriteArgs topic
             */

            /**
             * Constructs a new AzureServiceBusWriteArgs.
             * @memberof protos.args
             * @classdesc Represents an AzureServiceBusWriteArgs.
             * @implements IAzureServiceBusWriteArgs
             * @constructor
             * @param {protos.args.IAzureServiceBusWriteArgs=} [properties] Properties to set
             */
            function AzureServiceBusWriteArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureServiceBusWriteArgs queue.
             * @member {string} queue
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @instance
             */
            AzureServiceBusWriteArgs.prototype.queue = "";

            /**
             * AzureServiceBusWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @instance
             */
            AzureServiceBusWriteArgs.prototype.topic = "";

            /**
             * Creates a new AzureServiceBusWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {protos.args.IAzureServiceBusWriteArgs=} [properties] Properties to set
             * @returns {protos.args.AzureServiceBusWriteArgs} AzureServiceBusWriteArgs instance
             */
            AzureServiceBusWriteArgs.create = function create(properties) {
                return new AzureServiceBusWriteArgs(properties);
            };

            /**
             * Encodes the specified AzureServiceBusWriteArgs message. Does not implicitly {@link protos.args.AzureServiceBusWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {protos.args.IAzureServiceBusWriteArgs} message AzureServiceBusWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queue != null && Object.hasOwnProperty.call(message, "queue"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queue);
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.topic);
                return writer;
            };

            /**
             * Encodes the specified AzureServiceBusWriteArgs message, length delimited. Does not implicitly {@link protos.args.AzureServiceBusWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {protos.args.IAzureServiceBusWriteArgs} message AzureServiceBusWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureServiceBusWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureServiceBusWriteArgs} AzureServiceBusWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureServiceBusWriteArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queue = reader.string();
                        break;
                    case 2:
                        message.topic = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureServiceBusWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureServiceBusWriteArgs} AzureServiceBusWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureServiceBusWriteArgs message.
             * @function verify
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureServiceBusWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queue != null && message.hasOwnProperty("queue"))
                    if (!$util.isString(message.queue))
                        return "queue: string expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                return null;
            };

            /**
             * Creates an AzureServiceBusWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureServiceBusWriteArgs} AzureServiceBusWriteArgs
             */
            AzureServiceBusWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureServiceBusWriteArgs)
                    return object;
                let message = new $root.protos.args.AzureServiceBusWriteArgs();
                if (object.queue != null)
                    message.queue = String(object.queue);
                if (object.topic != null)
                    message.topic = String(object.topic);
                return message;
            };

            /**
             * Creates a plain object from an AzureServiceBusWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {protos.args.AzureServiceBusWriteArgs} message AzureServiceBusWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureServiceBusWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.queue = "";
                    object.topic = "";
                }
                if (message.queue != null && message.hasOwnProperty("queue"))
                    object.queue = message.queue;
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                return object;
            };

            /**
             * Converts this AzureServiceBusWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureServiceBusWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureServiceBusWriteArgs;
        })();

        args.GCPPubSubConn = (function() {

            /**
             * Properties of a GCPPubSubConn.
             * @memberof protos.args
             * @interface IGCPPubSubConn
             * @property {string|null} [projectId] GCPPubSubConn projectId
             */

            /**
             * Constructs a new GCPPubSubConn.
             * @memberof protos.args
             * @classdesc Represents a GCPPubSubConn.
             * @implements IGCPPubSubConn
             * @constructor
             * @param {protos.args.IGCPPubSubConn=} [properties] Properties to set
             */
            function GCPPubSubConn(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GCPPubSubConn projectId.
             * @member {string} projectId
             * @memberof protos.args.GCPPubSubConn
             * @instance
             */
            GCPPubSubConn.prototype.projectId = "";

            /**
             * Creates a new GCPPubSubConn instance using the specified properties.
             * @function create
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {protos.args.IGCPPubSubConn=} [properties] Properties to set
             * @returns {protos.args.GCPPubSubConn} GCPPubSubConn instance
             */
            GCPPubSubConn.create = function create(properties) {
                return new GCPPubSubConn(properties);
            };

            /**
             * Encodes the specified GCPPubSubConn message. Does not implicitly {@link protos.args.GCPPubSubConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {protos.args.IGCPPubSubConn} message GCPPubSubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.projectId != null && Object.hasOwnProperty.call(message, "projectId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.projectId);
                return writer;
            };

            /**
             * Encodes the specified GCPPubSubConn message, length delimited. Does not implicitly {@link protos.args.GCPPubSubConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {protos.args.IGCPPubSubConn} message GCPPubSubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GCPPubSubConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.GCPPubSubConn} GCPPubSubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.GCPPubSubConn();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.projectId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GCPPubSubConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.GCPPubSubConn} GCPPubSubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GCPPubSubConn message.
             * @function verify
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GCPPubSubConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.projectId != null && message.hasOwnProperty("projectId"))
                    if (!$util.isString(message.projectId))
                        return "projectId: string expected";
                return null;
            };

            /**
             * Creates a GCPPubSubConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.GCPPubSubConn} GCPPubSubConn
             */
            GCPPubSubConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.GCPPubSubConn)
                    return object;
                let message = new $root.protos.args.GCPPubSubConn();
                if (object.projectId != null)
                    message.projectId = String(object.projectId);
                return message;
            };

            /**
             * Creates a plain object from a GCPPubSubConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {protos.args.GCPPubSubConn} message GCPPubSubConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GCPPubSubConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.projectId = "";
                if (message.projectId != null && message.hasOwnProperty("projectId"))
                    object.projectId = message.projectId;
                return object;
            };

            /**
             * Converts this GCPPubSubConn to JSON.
             * @function toJSON
             * @memberof protos.args.GCPPubSubConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GCPPubSubConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GCPPubSubConn;
        })();

        args.GCPPubSubReadArgs = (function() {

            /**
             * Properties of a GCPPubSubReadArgs.
             * @memberof protos.args
             * @interface IGCPPubSubReadArgs
             * @property {string|null} [subscriptionId] GCPPubSubReadArgs subscriptionId
             * @property {boolean|null} [ackMessages] GCPPubSubReadArgs ackMessages
             */

            /**
             * Constructs a new GCPPubSubReadArgs.
             * @memberof protos.args
             * @classdesc Represents a GCPPubSubReadArgs.
             * @implements IGCPPubSubReadArgs
             * @constructor
             * @param {protos.args.IGCPPubSubReadArgs=} [properties] Properties to set
             */
            function GCPPubSubReadArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GCPPubSubReadArgs subscriptionId.
             * @member {string} subscriptionId
             * @memberof protos.args.GCPPubSubReadArgs
             * @instance
             */
            GCPPubSubReadArgs.prototype.subscriptionId = "";

            /**
             * GCPPubSubReadArgs ackMessages.
             * @member {boolean} ackMessages
             * @memberof protos.args.GCPPubSubReadArgs
             * @instance
             */
            GCPPubSubReadArgs.prototype.ackMessages = false;

            /**
             * Creates a new GCPPubSubReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {protos.args.IGCPPubSubReadArgs=} [properties] Properties to set
             * @returns {protos.args.GCPPubSubReadArgs} GCPPubSubReadArgs instance
             */
            GCPPubSubReadArgs.create = function create(properties) {
                return new GCPPubSubReadArgs(properties);
            };

            /**
             * Encodes the specified GCPPubSubReadArgs message. Does not implicitly {@link protos.args.GCPPubSubReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {protos.args.IGCPPubSubReadArgs} message GCPPubSubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subscriptionId != null && Object.hasOwnProperty.call(message, "subscriptionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.subscriptionId);
                if (message.ackMessages != null && Object.hasOwnProperty.call(message, "ackMessages"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.ackMessages);
                return writer;
            };

            /**
             * Encodes the specified GCPPubSubReadArgs message, length delimited. Does not implicitly {@link protos.args.GCPPubSubReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {protos.args.IGCPPubSubReadArgs} message GCPPubSubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GCPPubSubReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.GCPPubSubReadArgs} GCPPubSubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.GCPPubSubReadArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subscriptionId = reader.string();
                        break;
                    case 2:
                        message.ackMessages = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GCPPubSubReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.GCPPubSubReadArgs} GCPPubSubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GCPPubSubReadArgs message.
             * @function verify
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GCPPubSubReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subscriptionId != null && message.hasOwnProperty("subscriptionId"))
                    if (!$util.isString(message.subscriptionId))
                        return "subscriptionId: string expected";
                if (message.ackMessages != null && message.hasOwnProperty("ackMessages"))
                    if (typeof message.ackMessages !== "boolean")
                        return "ackMessages: boolean expected";
                return null;
            };

            /**
             * Creates a GCPPubSubReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.GCPPubSubReadArgs} GCPPubSubReadArgs
             */
            GCPPubSubReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.GCPPubSubReadArgs)
                    return object;
                let message = new $root.protos.args.GCPPubSubReadArgs();
                if (object.subscriptionId != null)
                    message.subscriptionId = String(object.subscriptionId);
                if (object.ackMessages != null)
                    message.ackMessages = Boolean(object.ackMessages);
                return message;
            };

            /**
             * Creates a plain object from a GCPPubSubReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {protos.args.GCPPubSubReadArgs} message GCPPubSubReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GCPPubSubReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.subscriptionId = "";
                    object.ackMessages = false;
                }
                if (message.subscriptionId != null && message.hasOwnProperty("subscriptionId"))
                    object.subscriptionId = message.subscriptionId;
                if (message.ackMessages != null && message.hasOwnProperty("ackMessages"))
                    object.ackMessages = message.ackMessages;
                return object;
            };

            /**
             * Converts this GCPPubSubReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.GCPPubSubReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GCPPubSubReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GCPPubSubReadArgs;
        })();

        args.GCPPubSubWriteArgs = (function() {

            /**
             * Properties of a GCPPubSubWriteArgs.
             * @memberof protos.args
             * @interface IGCPPubSubWriteArgs
             * @property {string|null} [topicId] GCPPubSubWriteArgs topicId
             */

            /**
             * Constructs a new GCPPubSubWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a GCPPubSubWriteArgs.
             * @implements IGCPPubSubWriteArgs
             * @constructor
             * @param {protos.args.IGCPPubSubWriteArgs=} [properties] Properties to set
             */
            function GCPPubSubWriteArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GCPPubSubWriteArgs topicId.
             * @member {string} topicId
             * @memberof protos.args.GCPPubSubWriteArgs
             * @instance
             */
            GCPPubSubWriteArgs.prototype.topicId = "";

            /**
             * Creates a new GCPPubSubWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {protos.args.IGCPPubSubWriteArgs=} [properties] Properties to set
             * @returns {protos.args.GCPPubSubWriteArgs} GCPPubSubWriteArgs instance
             */
            GCPPubSubWriteArgs.create = function create(properties) {
                return new GCPPubSubWriteArgs(properties);
            };

            /**
             * Encodes the specified GCPPubSubWriteArgs message. Does not implicitly {@link protos.args.GCPPubSubWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {protos.args.IGCPPubSubWriteArgs} message GCPPubSubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topicId != null && Object.hasOwnProperty.call(message, "topicId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topicId);
                return writer;
            };

            /**
             * Encodes the specified GCPPubSubWriteArgs message, length delimited. Does not implicitly {@link protos.args.GCPPubSubWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {protos.args.IGCPPubSubWriteArgs} message GCPPubSubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GCPPubSubWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.GCPPubSubWriteArgs} GCPPubSubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.GCPPubSubWriteArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topicId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GCPPubSubWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.GCPPubSubWriteArgs} GCPPubSubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GCPPubSubWriteArgs message.
             * @function verify
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GCPPubSubWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topicId != null && message.hasOwnProperty("topicId"))
                    if (!$util.isString(message.topicId))
                        return "topicId: string expected";
                return null;
            };

            /**
             * Creates a GCPPubSubWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.GCPPubSubWriteArgs} GCPPubSubWriteArgs
             */
            GCPPubSubWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.GCPPubSubWriteArgs)
                    return object;
                let message = new $root.protos.args.GCPPubSubWriteArgs();
                if (object.topicId != null)
                    message.topicId = String(object.topicId);
                return message;
            };

            /**
             * Creates a plain object from a GCPPubSubWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {protos.args.GCPPubSubWriteArgs} message GCPPubSubWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GCPPubSubWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.topicId = "";
                if (message.topicId != null && message.hasOwnProperty("topicId"))
                    object.topicId = message.topicId;
                return object;
            };

            /**
             * Converts this GCPPubSubWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.GCPPubSubWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GCPPubSubWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GCPPubSubWriteArgs;
        })();

        /**
         * SASLType enum.
         * @name protos.args.SASLType
         * @enum {number}
         * @property {number} NONE=0 NONE value
         * @property {number} PLAIN=1 PLAIN value
         * @property {number} SCRAM=2 SCRAM value
         */
        args.SASLType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NONE"] = 0;
            values[valuesById[1] = "PLAIN"] = 1;
            values[valuesById[2] = "SCRAM"] = 2;
            return values;
        })();

        args.KafkaConn = (function() {

            /**
             * Properties of a KafkaConn.
             * @memberof protos.args
             * @interface IKafkaConn
             * @property {Array.<string>|null} [address] KafkaConn address
             * @property {number|null} [timeoutSeconds] KafkaConn timeoutSeconds
             * @property {boolean|null} [useTls] KafkaConn useTls
             * @property {boolean|null} [insecureTls] KafkaConn insecureTls
             * @property {protos.args.SASLType|null} [saslType] KafkaConn saslType
             * @property {string|null} [saslUsername] KafkaConn saslUsername
             * @property {string|null} [saslPassword] KafkaConn saslPassword
             */

            /**
             * Constructs a new KafkaConn.
             * @memberof protos.args
             * @classdesc Represents a KafkaConn.
             * @implements IKafkaConn
             * @constructor
             * @param {protos.args.IKafkaConn=} [properties] Properties to set
             */
            function KafkaConn(properties) {
                this.address = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KafkaConn address.
             * @member {Array.<string>} address
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.address = $util.emptyArray;

            /**
             * KafkaConn timeoutSeconds.
             * @member {number} timeoutSeconds
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.timeoutSeconds = 0;

            /**
             * KafkaConn useTls.
             * @member {boolean} useTls
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.useTls = false;

            /**
             * KafkaConn insecureTls.
             * @member {boolean} insecureTls
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.insecureTls = false;

            /**
             * KafkaConn saslType.
             * @member {protos.args.SASLType} saslType
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.saslType = 0;

            /**
             * KafkaConn saslUsername.
             * @member {string} saslUsername
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.saslUsername = "";

            /**
             * KafkaConn saslPassword.
             * @member {string} saslPassword
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.saslPassword = "";

            /**
             * Creates a new KafkaConn instance using the specified properties.
             * @function create
             * @memberof protos.args.KafkaConn
             * @static
             * @param {protos.args.IKafkaConn=} [properties] Properties to set
             * @returns {protos.args.KafkaConn} KafkaConn instance
             */
            KafkaConn.create = function create(properties) {
                return new KafkaConn(properties);
            };

            /**
             * Encodes the specified KafkaConn message. Does not implicitly {@link protos.args.KafkaConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KafkaConn
             * @static
             * @param {protos.args.IKafkaConn} message KafkaConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && message.address.length)
                    for (let i = 0; i < message.address.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.address[i]);
                if (message.timeoutSeconds != null && Object.hasOwnProperty.call(message, "timeoutSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.timeoutSeconds);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.useTls);
                if (message.insecureTls != null && Object.hasOwnProperty.call(message, "insecureTls"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.insecureTls);
                if (message.saslType != null && Object.hasOwnProperty.call(message, "saslType"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.saslType);
                if (message.saslUsername != null && Object.hasOwnProperty.call(message, "saslUsername"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.saslUsername);
                if (message.saslPassword != null && Object.hasOwnProperty.call(message, "saslPassword"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.saslPassword);
                return writer;
            };

            /**
             * Encodes the specified KafkaConn message, length delimited. Does not implicitly {@link protos.args.KafkaConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KafkaConn
             * @static
             * @param {protos.args.IKafkaConn} message KafkaConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KafkaConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KafkaConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KafkaConn} KafkaConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KafkaConn();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.address && message.address.length))
                            message.address = [];
                        message.address.push(reader.string());
                        break;
                    case 2:
                        message.timeoutSeconds = reader.int32();
                        break;
                    case 3:
                        message.useTls = reader.bool();
                        break;
                    case 4:
                        message.insecureTls = reader.bool();
                        break;
                    case 5:
                        message.saslType = reader.int32();
                        break;
                    case 6:
                        message.saslUsername = reader.string();
                        break;
                    case 7:
                        message.saslPassword = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KafkaConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KafkaConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KafkaConn} KafkaConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KafkaConn message.
             * @function verify
             * @memberof protos.args.KafkaConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address")) {
                    if (!Array.isArray(message.address))
                        return "address: array expected";
                    for (let i = 0; i < message.address.length; ++i)
                        if (!$util.isString(message.address[i]))
                            return "address: string[] expected";
                }
                if (message.timeoutSeconds != null && message.hasOwnProperty("timeoutSeconds"))
                    if (!$util.isInteger(message.timeoutSeconds))
                        return "timeoutSeconds: integer expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    if (typeof message.insecureTls !== "boolean")
                        return "insecureTls: boolean expected";
                if (message.saslType != null && message.hasOwnProperty("saslType"))
                    switch (message.saslType) {
                    default:
                        return "saslType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.saslUsername != null && message.hasOwnProperty("saslUsername"))
                    if (!$util.isString(message.saslUsername))
                        return "saslUsername: string expected";
                if (message.saslPassword != null && message.hasOwnProperty("saslPassword"))
                    if (!$util.isString(message.saslPassword))
                        return "saslPassword: string expected";
                return null;
            };

            /**
             * Creates a KafkaConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KafkaConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KafkaConn} KafkaConn
             */
            KafkaConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KafkaConn)
                    return object;
                let message = new $root.protos.args.KafkaConn();
                if (object.address) {
                    if (!Array.isArray(object.address))
                        throw TypeError(".protos.args.KafkaConn.address: array expected");
                    message.address = [];
                    for (let i = 0; i < object.address.length; ++i)
                        message.address[i] = String(object.address[i]);
                }
                if (object.timeoutSeconds != null)
                    message.timeoutSeconds = object.timeoutSeconds | 0;
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.insecureTls != null)
                    message.insecureTls = Boolean(object.insecureTls);
                switch (object.saslType) {
                case "NONE":
                case 0:
                    message.saslType = 0;
                    break;
                case "PLAIN":
                case 1:
                    message.saslType = 1;
                    break;
                case "SCRAM":
                case 2:
                    message.saslType = 2;
                    break;
                }
                if (object.saslUsername != null)
                    message.saslUsername = String(object.saslUsername);
                if (object.saslPassword != null)
                    message.saslPassword = String(object.saslPassword);
                return message;
            };

            /**
             * Creates a plain object from a KafkaConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KafkaConn
             * @static
             * @param {protos.args.KafkaConn} message KafkaConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.address = [];
                if (options.defaults) {
                    object.timeoutSeconds = 0;
                    object.useTls = false;
                    object.insecureTls = false;
                    object.saslType = options.enums === String ? "NONE" : 0;
                    object.saslUsername = "";
                    object.saslPassword = "";
                }
                if (message.address && message.address.length) {
                    object.address = [];
                    for (let j = 0; j < message.address.length; ++j)
                        object.address[j] = message.address[j];
                }
                if (message.timeoutSeconds != null && message.hasOwnProperty("timeoutSeconds"))
                    object.timeoutSeconds = message.timeoutSeconds;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    object.insecureTls = message.insecureTls;
                if (message.saslType != null && message.hasOwnProperty("saslType"))
                    object.saslType = options.enums === String ? $root.protos.args.SASLType[message.saslType] : message.saslType;
                if (message.saslUsername != null && message.hasOwnProperty("saslUsername"))
                    object.saslUsername = message.saslUsername;
                if (message.saslPassword != null && message.hasOwnProperty("saslPassword"))
                    object.saslPassword = message.saslPassword;
                return object;
            };

            /**
             * Converts this KafkaConn to JSON.
             * @function toJSON
             * @memberof protos.args.KafkaConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KafkaConn;
        })();

        args.KafkaReadArgs = (function() {

            /**
             * Properties of a KafkaReadArgs.
             * @memberof protos.args
             * @interface IKafkaReadArgs
             * @property {Array.<string>|null} [topics] KafkaReadArgs topics
             * @property {number|Long|null} [readOffset] KafkaReadArgs readOffset
             * @property {boolean|null} [useConsumerGroup] KafkaReadArgs useConsumerGroup
             * @property {string|null} [consumerGroupName] KafkaReadArgs consumerGroupName
             * @property {number|null} [maxWaitSeconds] KafkaReadArgs maxWaitSeconds
             * @property {number|null} [minBytes] KafkaReadArgs minBytes
             * @property {number|null} [maxBytes] KafkaReadArgs maxBytes
             * @property {number|null} [commitIntervalSeconds] KafkaReadArgs commitIntervalSeconds
             * @property {number|null} [rebalanceTimeoutSeconds] KafkaReadArgs rebalanceTimeoutSeconds
             * @property {number|null} [queueCapacity] KafkaReadArgs queueCapacity
             * @property {boolean|null} [includeOffsetInfo] KafkaReadArgs includeOffsetInfo
             * @property {boolean|null} [lag] KafkaReadArgs lag
             * @property {string|null} [lagConsumerGroup] KafkaReadArgs lagConsumerGroup
             */

            /**
             * Constructs a new KafkaReadArgs.
             * @memberof protos.args
             * @classdesc Represents a KafkaReadArgs.
             * @implements IKafkaReadArgs
             * @constructor
             * @param {protos.args.IKafkaReadArgs=} [properties] Properties to set
             */
            function KafkaReadArgs(properties) {
                this.topics = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KafkaReadArgs topics.
             * @member {Array.<string>} topics
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.topics = $util.emptyArray;

            /**
             * KafkaReadArgs readOffset.
             * @member {number|Long} readOffset
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.readOffset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * KafkaReadArgs useConsumerGroup.
             * @member {boolean} useConsumerGroup
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.useConsumerGroup = false;

            /**
             * KafkaReadArgs consumerGroupName.
             * @member {string} consumerGroupName
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.consumerGroupName = "";

            /**
             * KafkaReadArgs maxWaitSeconds.
             * @member {number} maxWaitSeconds
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.maxWaitSeconds = 0;

            /**
             * KafkaReadArgs minBytes.
             * @member {number} minBytes
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.minBytes = 0;

            /**
             * KafkaReadArgs maxBytes.
             * @member {number} maxBytes
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.maxBytes = 0;

            /**
             * KafkaReadArgs commitIntervalSeconds.
             * @member {number} commitIntervalSeconds
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.commitIntervalSeconds = 0;

            /**
             * KafkaReadArgs rebalanceTimeoutSeconds.
             * @member {number} rebalanceTimeoutSeconds
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.rebalanceTimeoutSeconds = 0;

            /**
             * KafkaReadArgs queueCapacity.
             * @member {number} queueCapacity
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.queueCapacity = 0;

            /**
             * KafkaReadArgs includeOffsetInfo.
             * @member {boolean} includeOffsetInfo
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.includeOffsetInfo = false;

            /**
             * KafkaReadArgs lag.
             * @member {boolean} lag
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.lag = false;

            /**
             * KafkaReadArgs lagConsumerGroup.
             * @member {string} lagConsumerGroup
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.lagConsumerGroup = "";

            /**
             * Creates a new KafkaReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {protos.args.IKafkaReadArgs=} [properties] Properties to set
             * @returns {protos.args.KafkaReadArgs} KafkaReadArgs instance
             */
            KafkaReadArgs.create = function create(properties) {
                return new KafkaReadArgs(properties);
            };

            /**
             * Encodes the specified KafkaReadArgs message. Does not implicitly {@link protos.args.KafkaReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {protos.args.IKafkaReadArgs} message KafkaReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topics != null && message.topics.length)
                    for (let i = 0; i < message.topics.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.topics[i]);
                if (message.readOffset != null && Object.hasOwnProperty.call(message, "readOffset"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.readOffset);
                if (message.useConsumerGroup != null && Object.hasOwnProperty.call(message, "useConsumerGroup"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.useConsumerGroup);
                if (message.consumerGroupName != null && Object.hasOwnProperty.call(message, "consumerGroupName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.consumerGroupName);
                if (message.maxWaitSeconds != null && Object.hasOwnProperty.call(message, "maxWaitSeconds"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.maxWaitSeconds);
                if (message.minBytes != null && Object.hasOwnProperty.call(message, "minBytes"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.minBytes);
                if (message.maxBytes != null && Object.hasOwnProperty.call(message, "maxBytes"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.maxBytes);
                if (message.commitIntervalSeconds != null && Object.hasOwnProperty.call(message, "commitIntervalSeconds"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.commitIntervalSeconds);
                if (message.rebalanceTimeoutSeconds != null && Object.hasOwnProperty.call(message, "rebalanceTimeoutSeconds"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.rebalanceTimeoutSeconds);
                if (message.queueCapacity != null && Object.hasOwnProperty.call(message, "queueCapacity"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.queueCapacity);
                if (message.includeOffsetInfo != null && Object.hasOwnProperty.call(message, "includeOffsetInfo"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.includeOffsetInfo);
                if (message.lag != null && Object.hasOwnProperty.call(message, "lag"))
                    writer.uint32(/* id 12, wireType 0 =*/96).bool(message.lag);
                if (message.lagConsumerGroup != null && Object.hasOwnProperty.call(message, "lagConsumerGroup"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.lagConsumerGroup);
                return writer;
            };

            /**
             * Encodes the specified KafkaReadArgs message, length delimited. Does not implicitly {@link protos.args.KafkaReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {protos.args.IKafkaReadArgs} message KafkaReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KafkaReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KafkaReadArgs} KafkaReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KafkaReadArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.topics && message.topics.length))
                            message.topics = [];
                        message.topics.push(reader.string());
                        break;
                    case 2:
                        message.readOffset = reader.int64();
                        break;
                    case 3:
                        message.useConsumerGroup = reader.bool();
                        break;
                    case 4:
                        message.consumerGroupName = reader.string();
                        break;
                    case 5:
                        message.maxWaitSeconds = reader.int32();
                        break;
                    case 6:
                        message.minBytes = reader.int32();
                        break;
                    case 7:
                        message.maxBytes = reader.int32();
                        break;
                    case 8:
                        message.commitIntervalSeconds = reader.int32();
                        break;
                    case 9:
                        message.rebalanceTimeoutSeconds = reader.int32();
                        break;
                    case 10:
                        message.queueCapacity = reader.int32();
                        break;
                    case 11:
                        message.includeOffsetInfo = reader.bool();
                        break;
                    case 12:
                        message.lag = reader.bool();
                        break;
                    case 13:
                        message.lagConsumerGroup = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KafkaReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KafkaReadArgs} KafkaReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KafkaReadArgs message.
             * @function verify
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topics != null && message.hasOwnProperty("topics")) {
                    if (!Array.isArray(message.topics))
                        return "topics: array expected";
                    for (let i = 0; i < message.topics.length; ++i)
                        if (!$util.isString(message.topics[i]))
                            return "topics: string[] expected";
                }
                if (message.readOffset != null && message.hasOwnProperty("readOffset"))
                    if (!$util.isInteger(message.readOffset) && !(message.readOffset && $util.isInteger(message.readOffset.low) && $util.isInteger(message.readOffset.high)))
                        return "readOffset: integer|Long expected";
                if (message.useConsumerGroup != null && message.hasOwnProperty("useConsumerGroup"))
                    if (typeof message.useConsumerGroup !== "boolean")
                        return "useConsumerGroup: boolean expected";
                if (message.consumerGroupName != null && message.hasOwnProperty("consumerGroupName"))
                    if (!$util.isString(message.consumerGroupName))
                        return "consumerGroupName: string expected";
                if (message.maxWaitSeconds != null && message.hasOwnProperty("maxWaitSeconds"))
                    if (!$util.isInteger(message.maxWaitSeconds))
                        return "maxWaitSeconds: integer expected";
                if (message.minBytes != null && message.hasOwnProperty("minBytes"))
                    if (!$util.isInteger(message.minBytes))
                        return "minBytes: integer expected";
                if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
                    if (!$util.isInteger(message.maxBytes))
                        return "maxBytes: integer expected";
                if (message.commitIntervalSeconds != null && message.hasOwnProperty("commitIntervalSeconds"))
                    if (!$util.isInteger(message.commitIntervalSeconds))
                        return "commitIntervalSeconds: integer expected";
                if (message.rebalanceTimeoutSeconds != null && message.hasOwnProperty("rebalanceTimeoutSeconds"))
                    if (!$util.isInteger(message.rebalanceTimeoutSeconds))
                        return "rebalanceTimeoutSeconds: integer expected";
                if (message.queueCapacity != null && message.hasOwnProperty("queueCapacity"))
                    if (!$util.isInteger(message.queueCapacity))
                        return "queueCapacity: integer expected";
                if (message.includeOffsetInfo != null && message.hasOwnProperty("includeOffsetInfo"))
                    if (typeof message.includeOffsetInfo !== "boolean")
                        return "includeOffsetInfo: boolean expected";
                if (message.lag != null && message.hasOwnProperty("lag"))
                    if (typeof message.lag !== "boolean")
                        return "lag: boolean expected";
                if (message.lagConsumerGroup != null && message.hasOwnProperty("lagConsumerGroup"))
                    if (!$util.isString(message.lagConsumerGroup))
                        return "lagConsumerGroup: string expected";
                return null;
            };

            /**
             * Creates a KafkaReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KafkaReadArgs} KafkaReadArgs
             */
            KafkaReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KafkaReadArgs)
                    return object;
                let message = new $root.protos.args.KafkaReadArgs();
                if (object.topics) {
                    if (!Array.isArray(object.topics))
                        throw TypeError(".protos.args.KafkaReadArgs.topics: array expected");
                    message.topics = [];
                    for (let i = 0; i < object.topics.length; ++i)
                        message.topics[i] = String(object.topics[i]);
                }
                if (object.readOffset != null)
                    if ($util.Long)
                        (message.readOffset = $util.Long.fromValue(object.readOffset)).unsigned = false;
                    else if (typeof object.readOffset === "string")
                        message.readOffset = parseInt(object.readOffset, 10);
                    else if (typeof object.readOffset === "number")
                        message.readOffset = object.readOffset;
                    else if (typeof object.readOffset === "object")
                        message.readOffset = new $util.LongBits(object.readOffset.low >>> 0, object.readOffset.high >>> 0).toNumber();
                if (object.useConsumerGroup != null)
                    message.useConsumerGroup = Boolean(object.useConsumerGroup);
                if (object.consumerGroupName != null)
                    message.consumerGroupName = String(object.consumerGroupName);
                if (object.maxWaitSeconds != null)
                    message.maxWaitSeconds = object.maxWaitSeconds | 0;
                if (object.minBytes != null)
                    message.minBytes = object.minBytes | 0;
                if (object.maxBytes != null)
                    message.maxBytes = object.maxBytes | 0;
                if (object.commitIntervalSeconds != null)
                    message.commitIntervalSeconds = object.commitIntervalSeconds | 0;
                if (object.rebalanceTimeoutSeconds != null)
                    message.rebalanceTimeoutSeconds = object.rebalanceTimeoutSeconds | 0;
                if (object.queueCapacity != null)
                    message.queueCapacity = object.queueCapacity | 0;
                if (object.includeOffsetInfo != null)
                    message.includeOffsetInfo = Boolean(object.includeOffsetInfo);
                if (object.lag != null)
                    message.lag = Boolean(object.lag);
                if (object.lagConsumerGroup != null)
                    message.lagConsumerGroup = String(object.lagConsumerGroup);
                return message;
            };

            /**
             * Creates a plain object from a KafkaReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {protos.args.KafkaReadArgs} message KafkaReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.topics = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.readOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.readOffset = options.longs === String ? "0" : 0;
                    object.useConsumerGroup = false;
                    object.consumerGroupName = "";
                    object.maxWaitSeconds = 0;
                    object.minBytes = 0;
                    object.maxBytes = 0;
                    object.commitIntervalSeconds = 0;
                    object.rebalanceTimeoutSeconds = 0;
                    object.queueCapacity = 0;
                    object.includeOffsetInfo = false;
                    object.lag = false;
                    object.lagConsumerGroup = "";
                }
                if (message.topics && message.topics.length) {
                    object.topics = [];
                    for (let j = 0; j < message.topics.length; ++j)
                        object.topics[j] = message.topics[j];
                }
                if (message.readOffset != null && message.hasOwnProperty("readOffset"))
                    if (typeof message.readOffset === "number")
                        object.readOffset = options.longs === String ? String(message.readOffset) : message.readOffset;
                    else
                        object.readOffset = options.longs === String ? $util.Long.prototype.toString.call(message.readOffset) : options.longs === Number ? new $util.LongBits(message.readOffset.low >>> 0, message.readOffset.high >>> 0).toNumber() : message.readOffset;
                if (message.useConsumerGroup != null && message.hasOwnProperty("useConsumerGroup"))
                    object.useConsumerGroup = message.useConsumerGroup;
                if (message.consumerGroupName != null && message.hasOwnProperty("consumerGroupName"))
                    object.consumerGroupName = message.consumerGroupName;
                if (message.maxWaitSeconds != null && message.hasOwnProperty("maxWaitSeconds"))
                    object.maxWaitSeconds = message.maxWaitSeconds;
                if (message.minBytes != null && message.hasOwnProperty("minBytes"))
                    object.minBytes = message.minBytes;
                if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
                    object.maxBytes = message.maxBytes;
                if (message.commitIntervalSeconds != null && message.hasOwnProperty("commitIntervalSeconds"))
                    object.commitIntervalSeconds = message.commitIntervalSeconds;
                if (message.rebalanceTimeoutSeconds != null && message.hasOwnProperty("rebalanceTimeoutSeconds"))
                    object.rebalanceTimeoutSeconds = message.rebalanceTimeoutSeconds;
                if (message.queueCapacity != null && message.hasOwnProperty("queueCapacity"))
                    object.queueCapacity = message.queueCapacity;
                if (message.includeOffsetInfo != null && message.hasOwnProperty("includeOffsetInfo"))
                    object.includeOffsetInfo = message.includeOffsetInfo;
                if (message.lag != null && message.hasOwnProperty("lag"))
                    object.lag = message.lag;
                if (message.lagConsumerGroup != null && message.hasOwnProperty("lagConsumerGroup"))
                    object.lagConsumerGroup = message.lagConsumerGroup;
                return object;
            };

            /**
             * Converts this KafkaReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.KafkaReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KafkaReadArgs;
        })();

        args.KafkaWriteArgs = (function() {

            /**
             * Properties of a KafkaWriteArgs.
             * @memberof protos.args
             * @interface IKafkaWriteArgs
             * @property {string|null} [key] KafkaWriteArgs key
             * @property {Object.<string,string>|null} [headers] KafkaWriteArgs headers
             * @property {Array.<string>|null} [topics] KafkaWriteArgs topics
             */

            /**
             * Constructs a new KafkaWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a KafkaWriteArgs.
             * @implements IKafkaWriteArgs
             * @constructor
             * @param {protos.args.IKafkaWriteArgs=} [properties] Properties to set
             */
            function KafkaWriteArgs(properties) {
                this.headers = {};
                this.topics = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KafkaWriteArgs key.
             * @member {string} key
             * @memberof protos.args.KafkaWriteArgs
             * @instance
             */
            KafkaWriteArgs.prototype.key = "";

            /**
             * KafkaWriteArgs headers.
             * @member {Object.<string,string>} headers
             * @memberof protos.args.KafkaWriteArgs
             * @instance
             */
            KafkaWriteArgs.prototype.headers = $util.emptyObject;

            /**
             * KafkaWriteArgs topics.
             * @member {Array.<string>} topics
             * @memberof protos.args.KafkaWriteArgs
             * @instance
             */
            KafkaWriteArgs.prototype.topics = $util.emptyArray;

            /**
             * Creates a new KafkaWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {protos.args.IKafkaWriteArgs=} [properties] Properties to set
             * @returns {protos.args.KafkaWriteArgs} KafkaWriteArgs instance
             */
            KafkaWriteArgs.create = function create(properties) {
                return new KafkaWriteArgs(properties);
            };

            /**
             * Encodes the specified KafkaWriteArgs message. Does not implicitly {@link protos.args.KafkaWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {protos.args.IKafkaWriteArgs} message KafkaWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.headers != null && Object.hasOwnProperty.call(message, "headers"))
                    for (let keys = Object.keys(message.headers), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.headers[keys[i]]).ldelim();
                if (message.topics != null && message.topics.length)
                    for (let i = 0; i < message.topics.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.topics[i]);
                return writer;
            };

            /**
             * Encodes the specified KafkaWriteArgs message, length delimited. Does not implicitly {@link protos.args.KafkaWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {protos.args.IKafkaWriteArgs} message KafkaWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KafkaWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KafkaWriteArgs} KafkaWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KafkaWriteArgs(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        if (message.headers === $util.emptyObject)
                            message.headers = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.headers[key] = value;
                        break;
                    case 3:
                        if (!(message.topics && message.topics.length))
                            message.topics = [];
                        message.topics.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KafkaWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KafkaWriteArgs} KafkaWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KafkaWriteArgs message.
             * @function verify
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    if (!$util.isObject(message.headers))
                        return "headers: object expected";
                    let key = Object.keys(message.headers);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isString(message.headers[key[i]]))
                            return "headers: string{k:string} expected";
                }
                if (message.topics != null && message.hasOwnProperty("topics")) {
                    if (!Array.isArray(message.topics))
                        return "topics: array expected";
                    for (let i = 0; i < message.topics.length; ++i)
                        if (!$util.isString(message.topics[i]))
                            return "topics: string[] expected";
                }
                return null;
            };

            /**
             * Creates a KafkaWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KafkaWriteArgs} KafkaWriteArgs
             */
            KafkaWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KafkaWriteArgs)
                    return object;
                let message = new $root.protos.args.KafkaWriteArgs();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.headers) {
                    if (typeof object.headers !== "object")
                        throw TypeError(".protos.args.KafkaWriteArgs.headers: object expected");
                    message.headers = {};
                    for (let keys = Object.keys(object.headers), i = 0; i < keys.length; ++i)
                        message.headers[keys[i]] = String(object.headers[keys[i]]);
                }
                if (object.topics) {
                    if (!Array.isArray(object.topics))
                        throw TypeError(".protos.args.KafkaWriteArgs.topics: array expected");
                    message.topics = [];
                    for (let i = 0; i < object.topics.length; ++i)
                        message.topics[i] = String(object.topics[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a KafkaWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {protos.args.KafkaWriteArgs} message KafkaWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.topics = [];
                if (options.objects || options.defaults)
                    object.headers = {};
                if (options.defaults)
                    object.key = "";
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                let keys2;
                if (message.headers && (keys2 = Object.keys(message.headers)).length) {
                    object.headers = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.headers[keys2[j]] = message.headers[keys2[j]];
                }
                if (message.topics && message.topics.length) {
                    object.topics = [];
                    for (let j = 0; j < message.topics.length; ++j)
                        object.topics[j] = message.topics[j];
                }
                return object;
            };

            /**
             * Converts this KafkaWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.KafkaWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KafkaWriteArgs;
        })();

        args.KafkaRelayArgs = (function() {

            /**
             * Properties of a KafkaRelayArgs.
             * @memberof protos.args
             * @interface IKafkaRelayArgs
             * @property {Array.<string>|null} [topics] KafkaRelayArgs topics
             * @property {number|Long|null} [readOffset] KafkaRelayArgs readOffset
             * @property {boolean|null} [useConsumerGroup] KafkaRelayArgs useConsumerGroup
             * @property {string|null} [consumerGroupName] KafkaRelayArgs consumerGroupName
             * @property {number|null} [maxWaitSeconds] KafkaRelayArgs maxWaitSeconds
             * @property {number|null} [minBytes] KafkaRelayArgs minBytes
             * @property {number|null} [maxBytes] KafkaRelayArgs maxBytes
             * @property {number|null} [commitIntervalSeconds] KafkaRelayArgs commitIntervalSeconds
             * @property {number|null} [rebalanceTimeoutSeconds] KafkaRelayArgs rebalanceTimeoutSeconds
             * @property {number|null} [queueCapacity] KafkaRelayArgs queueCapacity
             */

            /**
             * Constructs a new KafkaRelayArgs.
             * @memberof protos.args
             * @classdesc Represents a KafkaRelayArgs.
             * @implements IKafkaRelayArgs
             * @constructor
             * @param {protos.args.IKafkaRelayArgs=} [properties] Properties to set
             */
            function KafkaRelayArgs(properties) {
                this.topics = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KafkaRelayArgs topics.
             * @member {Array.<string>} topics
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.topics = $util.emptyArray;

            /**
             * KafkaRelayArgs readOffset.
             * @member {number|Long} readOffset
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.readOffset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * KafkaRelayArgs useConsumerGroup.
             * @member {boolean} useConsumerGroup
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.useConsumerGroup = false;

            /**
             * KafkaRelayArgs consumerGroupName.
             * @member {string} consumerGroupName
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.consumerGroupName = "";

            /**
             * KafkaRelayArgs maxWaitSeconds.
             * @member {number} maxWaitSeconds
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.maxWaitSeconds = 0;

            /**
             * KafkaRelayArgs minBytes.
             * @member {number} minBytes
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.minBytes = 0;

            /**
             * KafkaRelayArgs maxBytes.
             * @member {number} maxBytes
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.maxBytes = 0;

            /**
             * KafkaRelayArgs commitIntervalSeconds.
             * @member {number} commitIntervalSeconds
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.commitIntervalSeconds = 0;

            /**
             * KafkaRelayArgs rebalanceTimeoutSeconds.
             * @member {number} rebalanceTimeoutSeconds
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.rebalanceTimeoutSeconds = 0;

            /**
             * KafkaRelayArgs queueCapacity.
             * @member {number} queueCapacity
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.queueCapacity = 0;

            /**
             * Creates a new KafkaRelayArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {protos.args.IKafkaRelayArgs=} [properties] Properties to set
             * @returns {protos.args.KafkaRelayArgs} KafkaRelayArgs instance
             */
            KafkaRelayArgs.create = function create(properties) {
                return new KafkaRelayArgs(properties);
            };

            /**
             * Encodes the specified KafkaRelayArgs message. Does not implicitly {@link protos.args.KafkaRelayArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {protos.args.IKafkaRelayArgs} message KafkaRelayArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaRelayArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topics != null && message.topics.length)
                    for (let i = 0; i < message.topics.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.topics[i]);
                if (message.readOffset != null && Object.hasOwnProperty.call(message, "readOffset"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.readOffset);
                if (message.useConsumerGroup != null && Object.hasOwnProperty.call(message, "useConsumerGroup"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.useConsumerGroup);
                if (message.consumerGroupName != null && Object.hasOwnProperty.call(message, "consumerGroupName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.consumerGroupName);
                if (message.maxWaitSeconds != null && Object.hasOwnProperty.call(message, "maxWaitSeconds"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.maxWaitSeconds);
                if (message.minBytes != null && Object.hasOwnProperty.call(message, "minBytes"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.minBytes);
                if (message.maxBytes != null && Object.hasOwnProperty.call(message, "maxBytes"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.maxBytes);
                if (message.commitIntervalSeconds != null && Object.hasOwnProperty.call(message, "commitIntervalSeconds"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.commitIntervalSeconds);
                if (message.rebalanceTimeoutSeconds != null && Object.hasOwnProperty.call(message, "rebalanceTimeoutSeconds"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.rebalanceTimeoutSeconds);
                if (message.queueCapacity != null && Object.hasOwnProperty.call(message, "queueCapacity"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.queueCapacity);
                return writer;
            };

            /**
             * Encodes the specified KafkaRelayArgs message, length delimited. Does not implicitly {@link protos.args.KafkaRelayArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {protos.args.IKafkaRelayArgs} message KafkaRelayArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaRelayArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KafkaRelayArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KafkaRelayArgs} KafkaRelayArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaRelayArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KafkaRelayArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.topics && message.topics.length))
                            message.topics = [];
                        message.topics.push(reader.string());
                        break;
                    case 2:
                        message.readOffset = reader.int64();
                        break;
                    case 3:
                        message.useConsumerGroup = reader.bool();
                        break;
                    case 4:
                        message.consumerGroupName = reader.string();
                        break;
                    case 5:
                        message.maxWaitSeconds = reader.int32();
                        break;
                    case 6:
                        message.minBytes = reader.int32();
                        break;
                    case 7:
                        message.maxBytes = reader.int32();
                        break;
                    case 8:
                        message.commitIntervalSeconds = reader.int32();
                        break;
                    case 9:
                        message.rebalanceTimeoutSeconds = reader.int32();
                        break;
                    case 10:
                        message.queueCapacity = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KafkaRelayArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KafkaRelayArgs} KafkaRelayArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaRelayArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KafkaRelayArgs message.
             * @function verify
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaRelayArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topics != null && message.hasOwnProperty("topics")) {
                    if (!Array.isArray(message.topics))
                        return "topics: array expected";
                    for (let i = 0; i < message.topics.length; ++i)
                        if (!$util.isString(message.topics[i]))
                            return "topics: string[] expected";
                }
                if (message.readOffset != null && message.hasOwnProperty("readOffset"))
                    if (!$util.isInteger(message.readOffset) && !(message.readOffset && $util.isInteger(message.readOffset.low) && $util.isInteger(message.readOffset.high)))
                        return "readOffset: integer|Long expected";
                if (message.useConsumerGroup != null && message.hasOwnProperty("useConsumerGroup"))
                    if (typeof message.useConsumerGroup !== "boolean")
                        return "useConsumerGroup: boolean expected";
                if (message.consumerGroupName != null && message.hasOwnProperty("consumerGroupName"))
                    if (!$util.isString(message.consumerGroupName))
                        return "consumerGroupName: string expected";
                if (message.maxWaitSeconds != null && message.hasOwnProperty("maxWaitSeconds"))
                    if (!$util.isInteger(message.maxWaitSeconds))
                        return "maxWaitSeconds: integer expected";
                if (message.minBytes != null && message.hasOwnProperty("minBytes"))
                    if (!$util.isInteger(message.minBytes))
                        return "minBytes: integer expected";
                if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
                    if (!$util.isInteger(message.maxBytes))
                        return "maxBytes: integer expected";
                if (message.commitIntervalSeconds != null && message.hasOwnProperty("commitIntervalSeconds"))
                    if (!$util.isInteger(message.commitIntervalSeconds))
                        return "commitIntervalSeconds: integer expected";
                if (message.rebalanceTimeoutSeconds != null && message.hasOwnProperty("rebalanceTimeoutSeconds"))
                    if (!$util.isInteger(message.rebalanceTimeoutSeconds))
                        return "rebalanceTimeoutSeconds: integer expected";
                if (message.queueCapacity != null && message.hasOwnProperty("queueCapacity"))
                    if (!$util.isInteger(message.queueCapacity))
                        return "queueCapacity: integer expected";
                return null;
            };

            /**
             * Creates a KafkaRelayArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KafkaRelayArgs} KafkaRelayArgs
             */
            KafkaRelayArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KafkaRelayArgs)
                    return object;
                let message = new $root.protos.args.KafkaRelayArgs();
                if (object.topics) {
                    if (!Array.isArray(object.topics))
                        throw TypeError(".protos.args.KafkaRelayArgs.topics: array expected");
                    message.topics = [];
                    for (let i = 0; i < object.topics.length; ++i)
                        message.topics[i] = String(object.topics[i]);
                }
                if (object.readOffset != null)
                    if ($util.Long)
                        (message.readOffset = $util.Long.fromValue(object.readOffset)).unsigned = false;
                    else if (typeof object.readOffset === "string")
                        message.readOffset = parseInt(object.readOffset, 10);
                    else if (typeof object.readOffset === "number")
                        message.readOffset = object.readOffset;
                    else if (typeof object.readOffset === "object")
                        message.readOffset = new $util.LongBits(object.readOffset.low >>> 0, object.readOffset.high >>> 0).toNumber();
                if (object.useConsumerGroup != null)
                    message.useConsumerGroup = Boolean(object.useConsumerGroup);
                if (object.consumerGroupName != null)
                    message.consumerGroupName = String(object.consumerGroupName);
                if (object.maxWaitSeconds != null)
                    message.maxWaitSeconds = object.maxWaitSeconds | 0;
                if (object.minBytes != null)
                    message.minBytes = object.minBytes | 0;
                if (object.maxBytes != null)
                    message.maxBytes = object.maxBytes | 0;
                if (object.commitIntervalSeconds != null)
                    message.commitIntervalSeconds = object.commitIntervalSeconds | 0;
                if (object.rebalanceTimeoutSeconds != null)
                    message.rebalanceTimeoutSeconds = object.rebalanceTimeoutSeconds | 0;
                if (object.queueCapacity != null)
                    message.queueCapacity = object.queueCapacity | 0;
                return message;
            };

            /**
             * Creates a plain object from a KafkaRelayArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {protos.args.KafkaRelayArgs} message KafkaRelayArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaRelayArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.topics = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.readOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.readOffset = options.longs === String ? "0" : 0;
                    object.useConsumerGroup = false;
                    object.consumerGroupName = "";
                    object.maxWaitSeconds = 0;
                    object.minBytes = 0;
                    object.maxBytes = 0;
                    object.commitIntervalSeconds = 0;
                    object.rebalanceTimeoutSeconds = 0;
                    object.queueCapacity = 0;
                }
                if (message.topics && message.topics.length) {
                    object.topics = [];
                    for (let j = 0; j < message.topics.length; ++j)
                        object.topics[j] = message.topics[j];
                }
                if (message.readOffset != null && message.hasOwnProperty("readOffset"))
                    if (typeof message.readOffset === "number")
                        object.readOffset = options.longs === String ? String(message.readOffset) : message.readOffset;
                    else
                        object.readOffset = options.longs === String ? $util.Long.prototype.toString.call(message.readOffset) : options.longs === Number ? new $util.LongBits(message.readOffset.low >>> 0, message.readOffset.high >>> 0).toNumber() : message.readOffset;
                if (message.useConsumerGroup != null && message.hasOwnProperty("useConsumerGroup"))
                    object.useConsumerGroup = message.useConsumerGroup;
                if (message.consumerGroupName != null && message.hasOwnProperty("consumerGroupName"))
                    object.consumerGroupName = message.consumerGroupName;
                if (message.maxWaitSeconds != null && message.hasOwnProperty("maxWaitSeconds"))
                    object.maxWaitSeconds = message.maxWaitSeconds;
                if (message.minBytes != null && message.hasOwnProperty("minBytes"))
                    object.minBytes = message.minBytes;
                if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
                    object.maxBytes = message.maxBytes;
                if (message.commitIntervalSeconds != null && message.hasOwnProperty("commitIntervalSeconds"))
                    object.commitIntervalSeconds = message.commitIntervalSeconds;
                if (message.rebalanceTimeoutSeconds != null && message.hasOwnProperty("rebalanceTimeoutSeconds"))
                    object.rebalanceTimeoutSeconds = message.rebalanceTimeoutSeconds;
                if (message.queueCapacity != null && message.hasOwnProperty("queueCapacity"))
                    object.queueCapacity = message.queueCapacity;
                return object;
            };

            /**
             * Converts this KafkaRelayArgs to JSON.
             * @function toJSON
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaRelayArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KafkaRelayArgs;
        })();

        args.KubeMQQueueConn = (function() {

            /**
             * Properties of a KubeMQQueueConn.
             * @memberof protos.args
             * @interface IKubeMQQueueConn
             * @property {string|null} [address] KubeMQQueueConn address
             * @property {string|null} [authToken] KubeMQQueueConn authToken
             * @property {string|null} [tlsCertFile] KubeMQQueueConn tlsCertFile
             */

            /**
             * Constructs a new KubeMQQueueConn.
             * @memberof protos.args
             * @classdesc Represents a KubeMQQueueConn.
             * @implements IKubeMQQueueConn
             * @constructor
             * @param {protos.args.IKubeMQQueueConn=} [properties] Properties to set
             */
            function KubeMQQueueConn(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KubeMQQueueConn address.
             * @member {string} address
             * @memberof protos.args.KubeMQQueueConn
             * @instance
             */
            KubeMQQueueConn.prototype.address = "";

            /**
             * KubeMQQueueConn authToken.
             * @member {string} authToken
             * @memberof protos.args.KubeMQQueueConn
             * @instance
             */
            KubeMQQueueConn.prototype.authToken = "";

            /**
             * KubeMQQueueConn tlsCertFile.
             * @member {string} tlsCertFile
             * @memberof protos.args.KubeMQQueueConn
             * @instance
             */
            KubeMQQueueConn.prototype.tlsCertFile = "";

            /**
             * Creates a new KubeMQQueueConn instance using the specified properties.
             * @function create
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {protos.args.IKubeMQQueueConn=} [properties] Properties to set
             * @returns {protos.args.KubeMQQueueConn} KubeMQQueueConn instance
             */
            KubeMQQueueConn.create = function create(properties) {
                return new KubeMQQueueConn(properties);
            };

            /**
             * Encodes the specified KubeMQQueueConn message. Does not implicitly {@link protos.args.KubeMQQueueConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {protos.args.IKubeMQQueueConn} message KubeMQQueueConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.authToken != null && Object.hasOwnProperty.call(message, "authToken"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.authToken);
                if (message.tlsCertFile != null && Object.hasOwnProperty.call(message, "tlsCertFile"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.tlsCertFile);
                return writer;
            };

            /**
             * Encodes the specified KubeMQQueueConn message, length delimited. Does not implicitly {@link protos.args.KubeMQQueueConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {protos.args.IKubeMQQueueConn} message KubeMQQueueConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KubeMQQueueConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KubeMQQueueConn} KubeMQQueueConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KubeMQQueueConn();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.authToken = reader.string();
                        break;
                    case 3:
                        message.tlsCertFile = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KubeMQQueueConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KubeMQQueueConn} KubeMQQueueConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KubeMQQueueConn message.
             * @function verify
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KubeMQQueueConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.authToken != null && message.hasOwnProperty("authToken"))
                    if (!$util.isString(message.authToken))
                        return "authToken: string expected";
                if (message.tlsCertFile != null && message.hasOwnProperty("tlsCertFile"))
                    if (!$util.isString(message.tlsCertFile))
                        return "tlsCertFile: string expected";
                return null;
            };

            /**
             * Creates a KubeMQQueueConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KubeMQQueueConn} KubeMQQueueConn
             */
            KubeMQQueueConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KubeMQQueueConn)
                    return object;
                let message = new $root.protos.args.KubeMQQueueConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.authToken != null)
                    message.authToken = String(object.authToken);
                if (object.tlsCertFile != null)
                    message.tlsCertFile = String(object.tlsCertFile);
                return message;
            };

            /**
             * Creates a plain object from a KubeMQQueueConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {protos.args.KubeMQQueueConn} message KubeMQQueueConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KubeMQQueueConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.address = "";
                    object.authToken = "";
                    object.tlsCertFile = "";
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.authToken != null && message.hasOwnProperty("authToken"))
                    object.authToken = message.authToken;
                if (message.tlsCertFile != null && message.hasOwnProperty("tlsCertFile"))
                    object.tlsCertFile = message.tlsCertFile;
                return object;
            };

            /**
             * Converts this KubeMQQueueConn to JSON.
             * @function toJSON
             * @memberof protos.args.KubeMQQueueConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KubeMQQueueConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KubeMQQueueConn;
        })();

        args.KubeMQQueueReadArgs = (function() {

            /**
             * Properties of a KubeMQQueueReadArgs.
             * @memberof protos.args
             * @interface IKubeMQQueueReadArgs
             * @property {string|null} [clientId] KubeMQQueueReadArgs clientId
             * @property {string|null} [queueName] KubeMQQueueReadArgs queueName
             */

            /**
             * Constructs a new KubeMQQueueReadArgs.
             * @memberof protos.args
             * @classdesc Represents a KubeMQQueueReadArgs.
             * @implements IKubeMQQueueReadArgs
             * @constructor
             * @param {protos.args.IKubeMQQueueReadArgs=} [properties] Properties to set
             */
            function KubeMQQueueReadArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KubeMQQueueReadArgs clientId.
             * @member {string} clientId
             * @memberof protos.args.KubeMQQueueReadArgs
             * @instance
             */
            KubeMQQueueReadArgs.prototype.clientId = "";

            /**
             * KubeMQQueueReadArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.KubeMQQueueReadArgs
             * @instance
             */
            KubeMQQueueReadArgs.prototype.queueName = "";

            /**
             * Creates a new KubeMQQueueReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {protos.args.IKubeMQQueueReadArgs=} [properties] Properties to set
             * @returns {protos.args.KubeMQQueueReadArgs} KubeMQQueueReadArgs instance
             */
            KubeMQQueueReadArgs.create = function create(properties) {
                return new KubeMQQueueReadArgs(properties);
            };

            /**
             * Encodes the specified KubeMQQueueReadArgs message. Does not implicitly {@link protos.args.KubeMQQueueReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {protos.args.IKubeMQQueueReadArgs} message KubeMQQueueReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientId);
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.queueName);
                return writer;
            };

            /**
             * Encodes the specified KubeMQQueueReadArgs message, length delimited. Does not implicitly {@link protos.args.KubeMQQueueReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {protos.args.IKubeMQQueueReadArgs} message KubeMQQueueReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KubeMQQueueReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KubeMQQueueReadArgs} KubeMQQueueReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KubeMQQueueReadArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.clientId = reader.string();
                        break;
                    case 3:
                        message.queueName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KubeMQQueueReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KubeMQQueueReadArgs} KubeMQQueueReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KubeMQQueueReadArgs message.
             * @function verify
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KubeMQQueueReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                return null;
            };

            /**
             * Creates a KubeMQQueueReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KubeMQQueueReadArgs} KubeMQQueueReadArgs
             */
            KubeMQQueueReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KubeMQQueueReadArgs)
                    return object;
                let message = new $root.protos.args.KubeMQQueueReadArgs();
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                return message;
            };

            /**
             * Creates a plain object from a KubeMQQueueReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {protos.args.KubeMQQueueReadArgs} message KubeMQQueueReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KubeMQQueueReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.clientId = "";
                    object.queueName = "";
                }
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                return object;
            };

            /**
             * Converts this KubeMQQueueReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.KubeMQQueueReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KubeMQQueueReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KubeMQQueueReadArgs;
        })();

        args.KubeMQQueueWriteArgs = (function() {

            /**
             * Properties of a KubeMQQueueWriteArgs.
             * @memberof protos.args
             * @interface IKubeMQQueueWriteArgs
             * @property {string|null} [clientId] KubeMQQueueWriteArgs clientId
             * @property {string|null} [queueName] KubeMQQueueWriteArgs queueName
             */

            /**
             * Constructs a new KubeMQQueueWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a KubeMQQueueWriteArgs.
             * @implements IKubeMQQueueWriteArgs
             * @constructor
             * @param {protos.args.IKubeMQQueueWriteArgs=} [properties] Properties to set
             */
            function KubeMQQueueWriteArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KubeMQQueueWriteArgs clientId.
             * @member {string} clientId
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @instance
             */
            KubeMQQueueWriteArgs.prototype.clientId = "";

            /**
             * KubeMQQueueWriteArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @instance
             */
            KubeMQQueueWriteArgs.prototype.queueName = "";

            /**
             * Creates a new KubeMQQueueWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {protos.args.IKubeMQQueueWriteArgs=} [properties] Properties to set
             * @returns {protos.args.KubeMQQueueWriteArgs} KubeMQQueueWriteArgs instance
             */
            KubeMQQueueWriteArgs.create = function create(properties) {
                return new KubeMQQueueWriteArgs(properties);
            };

            /**
             * Encodes the specified KubeMQQueueWriteArgs message. Does not implicitly {@link protos.args.KubeMQQueueWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {protos.args.IKubeMQQueueWriteArgs} message KubeMQQueueWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.clientId);
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.queueName);
                return writer;
            };

            /**
             * Encodes the specified KubeMQQueueWriteArgs message, length delimited. Does not implicitly {@link protos.args.KubeMQQueueWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {protos.args.IKubeMQQueueWriteArgs} message KubeMQQueueWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KubeMQQueueWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KubeMQQueueWriteArgs} KubeMQQueueWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KubeMQQueueWriteArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.clientId = reader.string();
                        break;
                    case 2:
                        message.queueName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KubeMQQueueWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KubeMQQueueWriteArgs} KubeMQQueueWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KubeMQQueueWriteArgs message.
             * @function verify
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KubeMQQueueWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                return null;
            };

            /**
             * Creates a KubeMQQueueWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KubeMQQueueWriteArgs} KubeMQQueueWriteArgs
             */
            KubeMQQueueWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KubeMQQueueWriteArgs)
                    return object;
                let message = new $root.protos.args.KubeMQQueueWriteArgs();
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                return message;
            };

            /**
             * Creates a plain object from a KubeMQQueueWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {protos.args.KubeMQQueueWriteArgs} message KubeMQQueueWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KubeMQQueueWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.clientId = "";
                    object.queueName = "";
                }
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                return object;
            };

            /**
             * Converts this KubeMQQueueWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KubeMQQueueWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KubeMQQueueWriteArgs;
        })();

        args.MongoConn = (function() {

            /**
             * Properties of a MongoConn.
             * @memberof protos.args
             * @interface IMongoConn
             * @property {string|null} [dsn] MongoConn dsn
             */

            /**
             * Constructs a new MongoConn.
             * @memberof protos.args
             * @classdesc Represents a MongoConn.
             * @implements IMongoConn
             * @constructor
             * @param {protos.args.IMongoConn=} [properties] Properties to set
             */
            function MongoConn(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MongoConn dsn.
             * @member {string} dsn
             * @memberof protos.args.MongoConn
             * @instance
             */
            MongoConn.prototype.dsn = "";

            /**
             * Creates a new MongoConn instance using the specified properties.
             * @function create
             * @memberof protos.args.MongoConn
             * @static
             * @param {protos.args.IMongoConn=} [properties] Properties to set
             * @returns {protos.args.MongoConn} MongoConn instance
             */
            MongoConn.create = function create(properties) {
                return new MongoConn(properties);
            };

            /**
             * Encodes the specified MongoConn message. Does not implicitly {@link protos.args.MongoConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MongoConn
             * @static
             * @param {protos.args.IMongoConn} message MongoConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MongoConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                return writer;
            };

            /**
             * Encodes the specified MongoConn message, length delimited. Does not implicitly {@link protos.args.MongoConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MongoConn
             * @static
             * @param {protos.args.IMongoConn} message MongoConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MongoConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MongoConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MongoConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MongoConn} MongoConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MongoConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MongoConn();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MongoConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MongoConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MongoConn} MongoConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MongoConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MongoConn message.
             * @function verify
             * @memberof protos.args.MongoConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MongoConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                return null;
            };

            /**
             * Creates a MongoConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MongoConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MongoConn} MongoConn
             */
            MongoConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MongoConn)
                    return object;
                let message = new $root.protos.args.MongoConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                return message;
            };

            /**
             * Creates a plain object from a MongoConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MongoConn
             * @static
             * @param {protos.args.MongoConn} message MongoConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MongoConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.dsn = "";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                return object;
            };

            /**
             * Converts this MongoConn to JSON.
             * @function toJSON
             * @memberof protos.args.MongoConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MongoConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MongoConn;
        })();

        args.MongoReadArgs = (function() {

            /**
             * Properties of a MongoReadArgs.
             * @memberof protos.args
             * @interface IMongoReadArgs
             * @property {string|null} [database] MongoReadArgs database
             * @property {string|null} [collection] MongoReadArgs collection
             * @property {boolean|null} [includeFullDocument] MongoReadArgs includeFullDocument
             */

            /**
             * Constructs a new MongoReadArgs.
             * @memberof protos.args
             * @classdesc Represents a MongoReadArgs.
             * @implements IMongoReadArgs
             * @constructor
             * @param {protos.args.IMongoReadArgs=} [properties] Properties to set
             */
            function MongoReadArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MongoReadArgs database.
             * @member {string} database
             * @memberof protos.args.MongoReadArgs
             * @instance
             */
            MongoReadArgs.prototype.database = "";

            /**
             * MongoReadArgs collection.
             * @member {string} collection
             * @memberof protos.args.MongoReadArgs
             * @instance
             */
            MongoReadArgs.prototype.collection = "";

            /**
             * MongoReadArgs includeFullDocument.
             * @member {boolean} includeFullDocument
             * @memberof protos.args.MongoReadArgs
             * @instance
             */
            MongoReadArgs.prototype.includeFullDocument = false;

            /**
             * Creates a new MongoReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {protos.args.IMongoReadArgs=} [properties] Properties to set
             * @returns {protos.args.MongoReadArgs} MongoReadArgs instance
             */
            MongoReadArgs.create = function create(properties) {
                return new MongoReadArgs(properties);
            };

            /**
             * Encodes the specified MongoReadArgs message. Does not implicitly {@link protos.args.MongoReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {protos.args.IMongoReadArgs} message MongoReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MongoReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.database);
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.collection);
                if (message.includeFullDocument != null && Object.hasOwnProperty.call(message, "includeFullDocument"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.includeFullDocument);
                return writer;
            };

            /**
             * Encodes the specified MongoReadArgs message, length delimited. Does not implicitly {@link protos.args.MongoReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {protos.args.IMongoReadArgs} message MongoReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MongoReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MongoReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MongoReadArgs} MongoReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MongoReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MongoReadArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.database = reader.string();
                        break;
                    case 2:
                        message.collection = reader.string();
                        break;
                    case 3:
                        message.includeFullDocument = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MongoReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MongoReadArgs} MongoReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MongoReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MongoReadArgs message.
             * @function verify
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MongoReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                if (message.includeFullDocument != null && message.hasOwnProperty("includeFullDocument"))
                    if (typeof message.includeFullDocument !== "boolean")
                        return "includeFullDocument: boolean expected";
                return null;
            };

            /**
             * Creates a MongoReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MongoReadArgs} MongoReadArgs
             */
            MongoReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MongoReadArgs)
                    return object;
                let message = new $root.protos.args.MongoReadArgs();
                if (object.database != null)
                    message.database = String(object.database);
                if (object.collection != null)
                    message.collection = String(object.collection);
                if (object.includeFullDocument != null)
                    message.includeFullDocument = Boolean(object.includeFullDocument);
                return message;
            };

            /**
             * Creates a plain object from a MongoReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {protos.args.MongoReadArgs} message MongoReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MongoReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.database = "";
                    object.collection = "";
                    object.includeFullDocument = false;
                }
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                if (message.includeFullDocument != null && message.hasOwnProperty("includeFullDocument"))
                    object.includeFullDocument = message.includeFullDocument;
                return object;
            };

            /**
             * Converts this MongoReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.MongoReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MongoReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MongoReadArgs;
        })();

        /**
         * MQTTQoSLevel enum.
         * @name protos.args.MQTTQoSLevel
         * @enum {number}
         * @property {number} MQTT_QOS_LEVEL_AT_MOST_ONCE=0 MQTT_QOS_LEVEL_AT_MOST_ONCE value
         * @property {number} MQTT_QOS_LEVEL_AT_LEAST_ONCE=1 MQTT_QOS_LEVEL_AT_LEAST_ONCE value
         * @property {number} MQTT_QOS_LEVEL_EXACTLY_ONCE=2 MQTT_QOS_LEVEL_EXACTLY_ONCE value
         */
        args.MQTTQoSLevel = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "MQTT_QOS_LEVEL_AT_MOST_ONCE"] = 0;
            values[valuesById[1] = "MQTT_QOS_LEVEL_AT_LEAST_ONCE"] = 1;
            values[valuesById[2] = "MQTT_QOS_LEVEL_EXACTLY_ONCE"] = 2;
            return values;
        })();

        args.MQTTTLSOptions = (function() {

            /**
             * Properties of a MQTTTLSOptions.
             * @memberof protos.args
             * @interface IMQTTTLSOptions
             * @property {string|null} [caFile] MQTTTLSOptions caFile
             * @property {string|null} [certFile] MQTTTLSOptions certFile
             * @property {string|null} [keyFile] MQTTTLSOptions keyFile
             * @property {boolean|null} [skipVerify] MQTTTLSOptions skipVerify
             */

            /**
             * Constructs a new MQTTTLSOptions.
             * @memberof protos.args
             * @classdesc Represents a MQTTTLSOptions.
             * @implements IMQTTTLSOptions
             * @constructor
             * @param {protos.args.IMQTTTLSOptions=} [properties] Properties to set
             */
            function MQTTTLSOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MQTTTLSOptions caFile.
             * @member {string} caFile
             * @memberof protos.args.MQTTTLSOptions
             * @instance
             */
            MQTTTLSOptions.prototype.caFile = "";

            /**
             * MQTTTLSOptions certFile.
             * @member {string} certFile
             * @memberof protos.args.MQTTTLSOptions
             * @instance
             */
            MQTTTLSOptions.prototype.certFile = "";

            /**
             * MQTTTLSOptions keyFile.
             * @member {string} keyFile
             * @memberof protos.args.MQTTTLSOptions
             * @instance
             */
            MQTTTLSOptions.prototype.keyFile = "";

            /**
             * MQTTTLSOptions skipVerify.
             * @member {boolean} skipVerify
             * @memberof protos.args.MQTTTLSOptions
             * @instance
             */
            MQTTTLSOptions.prototype.skipVerify = false;

            /**
             * Creates a new MQTTTLSOptions instance using the specified properties.
             * @function create
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {protos.args.IMQTTTLSOptions=} [properties] Properties to set
             * @returns {protos.args.MQTTTLSOptions} MQTTTLSOptions instance
             */
            MQTTTLSOptions.create = function create(properties) {
                return new MQTTTLSOptions(properties);
            };

            /**
             * Encodes the specified MQTTTLSOptions message. Does not implicitly {@link protos.args.MQTTTLSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {protos.args.IMQTTTLSOptions} message MQTTTLSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTTLSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.caFile != null && Object.hasOwnProperty.call(message, "caFile"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.caFile);
                if (message.certFile != null && Object.hasOwnProperty.call(message, "certFile"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.certFile);
                if (message.keyFile != null && Object.hasOwnProperty.call(message, "keyFile"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.keyFile);
                if (message.skipVerify != null && Object.hasOwnProperty.call(message, "skipVerify"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.skipVerify);
                return writer;
            };

            /**
             * Encodes the specified MQTTTLSOptions message, length delimited. Does not implicitly {@link protos.args.MQTTTLSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {protos.args.IMQTTTLSOptions} message MQTTTLSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTTLSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MQTTTLSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MQTTTLSOptions} MQTTTLSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTTLSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MQTTTLSOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.caFile = reader.string();
                        break;
                    case 2:
                        message.certFile = reader.string();
                        break;
                    case 3:
                        message.keyFile = reader.string();
                        break;
                    case 4:
                        message.skipVerify = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MQTTTLSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MQTTTLSOptions} MQTTTLSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTTLSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MQTTTLSOptions message.
             * @function verify
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MQTTTLSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.caFile != null && message.hasOwnProperty("caFile"))
                    if (!$util.isString(message.caFile))
                        return "caFile: string expected";
                if (message.certFile != null && message.hasOwnProperty("certFile"))
                    if (!$util.isString(message.certFile))
                        return "certFile: string expected";
                if (message.keyFile != null && message.hasOwnProperty("keyFile"))
                    if (!$util.isString(message.keyFile))
                        return "keyFile: string expected";
                if (message.skipVerify != null && message.hasOwnProperty("skipVerify"))
                    if (typeof message.skipVerify !== "boolean")
                        return "skipVerify: boolean expected";
                return null;
            };

            /**
             * Creates a MQTTTLSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MQTTTLSOptions} MQTTTLSOptions
             */
            MQTTTLSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MQTTTLSOptions)
                    return object;
                let message = new $root.protos.args.MQTTTLSOptions();
                if (object.caFile != null)
                    message.caFile = String(object.caFile);
                if (object.certFile != null)
                    message.certFile = String(object.certFile);
                if (object.keyFile != null)
                    message.keyFile = String(object.keyFile);
                if (object.skipVerify != null)
                    message.skipVerify = Boolean(object.skipVerify);
                return message;
            };

            /**
             * Creates a plain object from a MQTTTLSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {protos.args.MQTTTLSOptions} message MQTTTLSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MQTTTLSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.caFile = "";
                    object.certFile = "";
                    object.keyFile = "";
                    object.skipVerify = false;
                }
                if (message.caFile != null && message.hasOwnProperty("caFile"))
                    object.caFile = message.caFile;
                if (message.certFile != null && message.hasOwnProperty("certFile"))
                    object.certFile = message.certFile;
                if (message.keyFile != null && message.hasOwnProperty("keyFile"))
                    object.keyFile = message.keyFile;
                if (message.skipVerify != null && message.hasOwnProperty("skipVerify"))
                    object.skipVerify = message.skipVerify;
                return object;
            };

            /**
             * Converts this MQTTTLSOptions to JSON.
             * @function toJSON
             * @memberof protos.args.MQTTTLSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MQTTTLSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MQTTTLSOptions;
        })();

        args.MQTTConn = (function() {

            /**
             * Properties of a MQTTConn.
             * @memberof protos.args
             * @interface IMQTTConn
             * @property {string|null} [address] MQTTConn address
             * @property {number|null} [connTimeoutSeconds] MQTTConn connTimeoutSeconds
             * @property {string|null} [clientId] MQTTConn clientId
             * @property {protos.args.MQTTQoSLevel|null} [qosLevel] MQTTConn qosLevel
             * @property {protos.args.IMQTTTLSOptions|null} [tlsOptions] MQTTConn tlsOptions
             */

            /**
             * Constructs a new MQTTConn.
             * @memberof protos.args
             * @classdesc Represents a MQTTConn.
             * @implements IMQTTConn
             * @constructor
             * @param {protos.args.IMQTTConn=} [properties] Properties to set
             */
            function MQTTConn(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MQTTConn address.
             * @member {string} address
             * @memberof protos.args.MQTTConn
             * @instance
             */
            MQTTConn.prototype.address = "";

            /**
             * MQTTConn connTimeoutSeconds.
             * @member {number} connTimeoutSeconds
             * @memberof protos.args.MQTTConn
             * @instance
             */
            MQTTConn.prototype.connTimeoutSeconds = 0;

            /**
             * MQTTConn clientId.
             * @member {string} clientId
             * @memberof protos.args.MQTTConn
             * @instance
             */
            MQTTConn.prototype.clientId = "";

            /**
             * MQTTConn qosLevel.
             * @member {protos.args.MQTTQoSLevel} qosLevel
             * @memberof protos.args.MQTTConn
             * @instance
             */
            MQTTConn.prototype.qosLevel = 0;

            /**
             * MQTTConn tlsOptions.
             * @member {protos.args.IMQTTTLSOptions|null|undefined} tlsOptions
             * @memberof protos.args.MQTTConn
             * @instance
             */
            MQTTConn.prototype.tlsOptions = null;

            /**
             * Creates a new MQTTConn instance using the specified properties.
             * @function create
             * @memberof protos.args.MQTTConn
             * @static
             * @param {protos.args.IMQTTConn=} [properties] Properties to set
             * @returns {protos.args.MQTTConn} MQTTConn instance
             */
            MQTTConn.create = function create(properties) {
                return new MQTTConn(properties);
            };

            /**
             * Encodes the specified MQTTConn message. Does not implicitly {@link protos.args.MQTTConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MQTTConn
             * @static
             * @param {protos.args.IMQTTConn} message MQTTConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.connTimeoutSeconds != null && Object.hasOwnProperty.call(message, "connTimeoutSeconds"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.connTimeoutSeconds);
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.clientId);
                if (message.qosLevel != null && Object.hasOwnProperty.call(message, "qosLevel"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.qosLevel);
                if (message.tlsOptions != null && Object.hasOwnProperty.call(message, "tlsOptions"))
                    $root.protos.args.MQTTTLSOptions.encode(message.tlsOptions, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MQTTConn message, length delimited. Does not implicitly {@link protos.args.MQTTConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MQTTConn
             * @static
             * @param {protos.args.IMQTTConn} message MQTTConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MQTTConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MQTTConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MQTTConn} MQTTConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MQTTConn();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 3:
                        message.connTimeoutSeconds = reader.uint32();
                        break;
                    case 4:
                        message.clientId = reader.string();
                        break;
                    case 5:
                        message.qosLevel = reader.int32();
                        break;
                    case 6:
                        message.tlsOptions = $root.protos.args.MQTTTLSOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MQTTConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MQTTConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MQTTConn} MQTTConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MQTTConn message.
             * @function verify
             * @memberof protos.args.MQTTConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MQTTConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.connTimeoutSeconds != null && message.hasOwnProperty("connTimeoutSeconds"))
                    if (!$util.isInteger(message.connTimeoutSeconds))
                        return "connTimeoutSeconds: integer expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                if (message.qosLevel != null && message.hasOwnProperty("qosLevel"))
                    switch (message.qosLevel) {
                    default:
                        return "qosLevel: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.tlsOptions != null && message.hasOwnProperty("tlsOptions")) {
                    let error = $root.protos.args.MQTTTLSOptions.verify(message.tlsOptions);
                    if (error)
                        return "tlsOptions." + error;
                }
                return null;
            };

            /**
             * Creates a MQTTConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MQTTConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MQTTConn} MQTTConn
             */
            MQTTConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MQTTConn)
                    return object;
                let message = new $root.protos.args.MQTTConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.connTimeoutSeconds != null)
                    message.connTimeoutSeconds = object.connTimeoutSeconds >>> 0;
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                switch (object.qosLevel) {
                case "MQTT_QOS_LEVEL_AT_MOST_ONCE":
                case 0:
                    message.qosLevel = 0;
                    break;
                case "MQTT_QOS_LEVEL_AT_LEAST_ONCE":
                case 1:
                    message.qosLevel = 1;
                    break;
                case "MQTT_QOS_LEVEL_EXACTLY_ONCE":
                case 2:
                    message.qosLevel = 2;
                    break;
                }
                if (object.tlsOptions != null) {
                    if (typeof object.tlsOptions !== "object")
                        throw TypeError(".protos.args.MQTTConn.tlsOptions: object expected");
                    message.tlsOptions = $root.protos.args.MQTTTLSOptions.fromObject(object.tlsOptions);
                }
                return message;
            };

            /**
             * Creates a plain object from a MQTTConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MQTTConn
             * @static
             * @param {protos.args.MQTTConn} message MQTTConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MQTTConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.address = "";
                    object.connTimeoutSeconds = 0;
                    object.clientId = "";
                    object.qosLevel = options.enums === String ? "MQTT_QOS_LEVEL_AT_MOST_ONCE" : 0;
                    object.tlsOptions = null;
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.connTimeoutSeconds != null && message.hasOwnProperty("connTimeoutSeconds"))
                    object.connTimeoutSeconds = message.connTimeoutSeconds;
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                if (message.qosLevel != null && message.hasOwnProperty("qosLevel"))
                    object.qosLevel = options.enums === String ? $root.protos.args.MQTTQoSLevel[message.qosLevel] : message.qosLevel;
                if (message.tlsOptions != null && message.hasOwnProperty("tlsOptions"))
                    object.tlsOptions = $root.protos.args.MQTTTLSOptions.toObject(message.tlsOptions, options);
                return object;
            };

            /**
             * Converts this MQTTConn to JSON.
             * @function toJSON
             * @memberof protos.args.MQTTConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MQTTConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MQTTConn;
        })();

        args.MQTTReadArgs = (function() {

            /**
             * Properties of a MQTTReadArgs.
             * @memberof protos.args
             * @interface IMQTTReadArgs
             * @property {string|null} [topic] MQTTReadArgs topic
             * @property {number|null} [readTimeoutSeconds] MQTTReadArgs readTimeoutSeconds
             */

            /**
             * Constructs a new MQTTReadArgs.
             * @memberof protos.args
             * @classdesc Represents a MQTTReadArgs.
             * @implements IMQTTReadArgs
             * @constructor
             * @param {protos.args.IMQTTReadArgs=} [properties] Properties to set
             */
            function MQTTReadArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MQTTReadArgs topic.
             * @member {string} topic
             * @memberof protos.args.MQTTReadArgs
             * @instance
             */
            MQTTReadArgs.prototype.topic = "";

            /**
             * MQTTReadArgs readTimeoutSeconds.
             * @member {number} readTimeoutSeconds
             * @memberof protos.args.MQTTReadArgs
             * @instance
             */
            MQTTReadArgs.prototype.readTimeoutSeconds = 0;

            /**
             * Creates a new MQTTReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {protos.args.IMQTTReadArgs=} [properties] Properties to set
             * @returns {protos.args.MQTTReadArgs} MQTTReadArgs instance
             */
            MQTTReadArgs.create = function create(properties) {
                return new MQTTReadArgs(properties);
            };

            /**
             * Encodes the specified MQTTReadArgs message. Does not implicitly {@link protos.args.MQTTReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {protos.args.IMQTTReadArgs} message MQTTReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.readTimeoutSeconds != null && Object.hasOwnProperty.call(message, "readTimeoutSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.readTimeoutSeconds);
                return writer;
            };

            /**
             * Encodes the specified MQTTReadArgs message, length delimited. Does not implicitly {@link protos.args.MQTTReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {protos.args.IMQTTReadArgs} message MQTTReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MQTTReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MQTTReadArgs} MQTTReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MQTTReadArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.readTimeoutSeconds = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MQTTReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MQTTReadArgs} MQTTReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MQTTReadArgs message.
             * @function verify
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MQTTReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.readTimeoutSeconds != null && message.hasOwnProperty("readTimeoutSeconds"))
                    if (!$util.isInteger(message.readTimeoutSeconds))
                        return "readTimeoutSeconds: integer expected";
                return null;
            };

            /**
             * Creates a MQTTReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MQTTReadArgs} MQTTReadArgs
             */
            MQTTReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MQTTReadArgs)
                    return object;
                let message = new $root.protos.args.MQTTReadArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.readTimeoutSeconds != null)
                    message.readTimeoutSeconds = object.readTimeoutSeconds >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a MQTTReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {protos.args.MQTTReadArgs} message MQTTReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MQTTReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.readTimeoutSeconds = 0;
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.readTimeoutSeconds != null && message.hasOwnProperty("readTimeoutSeconds"))
                    object.readTimeoutSeconds = message.readTimeoutSeconds;
                return object;
            };

            /**
             * Converts this MQTTReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.MQTTReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MQTTReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MQTTReadArgs;
        })();

        args.MQTTWriteArgs = (function() {

            /**
             * Properties of a MQTTWriteArgs.
             * @memberof protos.args
             * @interface IMQTTWriteArgs
             * @property {string|null} [topic] MQTTWriteArgs topic
             * @property {number|null} [writeTimeoutSeconds] MQTTWriteArgs writeTimeoutSeconds
             */

            /**
             * Constructs a new MQTTWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a MQTTWriteArgs.
             * @implements IMQTTWriteArgs
             * @constructor
             * @param {protos.args.IMQTTWriteArgs=} [properties] Properties to set
             */
            function MQTTWriteArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MQTTWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.MQTTWriteArgs
             * @instance
             */
            MQTTWriteArgs.prototype.topic = "";

            /**
             * MQTTWriteArgs writeTimeoutSeconds.
             * @member {number} writeTimeoutSeconds
             * @memberof protos.args.MQTTWriteArgs
             * @instance
             */
            MQTTWriteArgs.prototype.writeTimeoutSeconds = 0;

            /**
             * Creates a new MQTTWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {protos.args.IMQTTWriteArgs=} [properties] Properties to set
             * @returns {protos.args.MQTTWriteArgs} MQTTWriteArgs instance
             */
            MQTTWriteArgs.create = function create(properties) {
                return new MQTTWriteArgs(properties);
            };

            /**
             * Encodes the specified MQTTWriteArgs message. Does not implicitly {@link protos.args.MQTTWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {protos.args.IMQTTWriteArgs} message MQTTWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.writeTimeoutSeconds != null && Object.hasOwnProperty.call(message, "writeTimeoutSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.writeTimeoutSeconds);
                return writer;
            };

            /**
             * Encodes the specified MQTTWriteArgs message, length delimited. Does not implicitly {@link protos.args.MQTTWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {protos.args.IMQTTWriteArgs} message MQTTWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MQTTWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MQTTWriteArgs} MQTTWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MQTTWriteArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.writeTimeoutSeconds = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MQTTWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MQTTWriteArgs} MQTTWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MQTTWriteArgs message.
             * @function verify
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MQTTWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.writeTimeoutSeconds != null && message.hasOwnProperty("writeTimeoutSeconds"))
                    if (!$util.isInteger(message.writeTimeoutSeconds))
                        return "writeTimeoutSeconds: integer expected";
                return null;
            };

            /**
             * Creates a MQTTWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MQTTWriteArgs} MQTTWriteArgs
             */
            MQTTWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MQTTWriteArgs)
                    return object;
                let message = new $root.protos.args.MQTTWriteArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.writeTimeoutSeconds != null)
                    message.writeTimeoutSeconds = object.writeTimeoutSeconds >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a MQTTWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {protos.args.MQTTWriteArgs} message MQTTWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MQTTWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.writeTimeoutSeconds = 0;
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.writeTimeoutSeconds != null && message.hasOwnProperty("writeTimeoutSeconds"))
                    object.writeTimeoutSeconds = message.writeTimeoutSeconds;
                return object;
            };

            /**
             * Converts this MQTTWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.MQTTWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MQTTWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MQTTWriteArgs;
        })();

        args.NatsConn = (function() {

            /**
             * Properties of a NatsConn.
             * @memberof protos.args
             * @interface INatsConn
             * @property {string|null} [dsn] NatsConn dsn
             * @property {boolean|null} [insecureTls] NatsConn insecureTls
             * @property {Uint8Array|null} [tlsCaCert] NatsConn tlsCaCert
             * @property {Uint8Array|null} [tlsClientCert] NatsConn tlsClientCert
             * @property {Uint8Array|null} [tlsClientKey] NatsConn tlsClientKey
             * @property {Uint8Array|null} [userCredentials] NatsConn userCredentials
             */

            /**
             * Constructs a new NatsConn.
             * @memberof protos.args
             * @classdesc Represents a NatsConn.
             * @implements INatsConn
             * @constructor
             * @param {protos.args.INatsConn=} [properties] Properties to set
             */
            function NatsConn(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsConn dsn.
             * @member {string} dsn
             * @memberof protos.args.NatsConn
             * @instance
             */
            NatsConn.prototype.dsn = "";

            /**
             * NatsConn insecureTls.
             * @member {boolean} insecureTls
             * @memberof protos.args.NatsConn
             * @instance
             */
            NatsConn.prototype.insecureTls = false;

            /**
             * NatsConn tlsCaCert.
             * @member {Uint8Array} tlsCaCert
             * @memberof protos.args.NatsConn
             * @instance
             */
            NatsConn.prototype.tlsCaCert = $util.newBuffer([]);

            /**
             * NatsConn tlsClientCert.
             * @member {Uint8Array} tlsClientCert
             * @memberof protos.args.NatsConn
             * @instance
             */
            NatsConn.prototype.tlsClientCert = $util.newBuffer([]);

            /**
             * NatsConn tlsClientKey.
             * @member {Uint8Array} tlsClientKey
             * @memberof protos.args.NatsConn
             * @instance
             */
            NatsConn.prototype.tlsClientKey = $util.newBuffer([]);

            /**
             * NatsConn userCredentials.
             * @member {Uint8Array} userCredentials
             * @memberof protos.args.NatsConn
             * @instance
             */
            NatsConn.prototype.userCredentials = $util.newBuffer([]);

            /**
             * Creates a new NatsConn instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsConn
             * @static
             * @param {protos.args.INatsConn=} [properties] Properties to set
             * @returns {protos.args.NatsConn} NatsConn instance
             */
            NatsConn.create = function create(properties) {
                return new NatsConn(properties);
            };

            /**
             * Encodes the specified NatsConn message. Does not implicitly {@link protos.args.NatsConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsConn
             * @static
             * @param {protos.args.INatsConn} message NatsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                if (message.insecureTls != null && Object.hasOwnProperty.call(message, "insecureTls"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.insecureTls);
                if (message.tlsCaCert != null && Object.hasOwnProperty.call(message, "tlsCaCert"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.tlsCaCert);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.tlsClientCert);
                if (message.tlsClientKey != null && Object.hasOwnProperty.call(message, "tlsClientKey"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.tlsClientKey);
                if (message.userCredentials != null && Object.hasOwnProperty.call(message, "userCredentials"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.userCredentials);
                return writer;
            };

            /**
             * Encodes the specified NatsConn message, length delimited. Does not implicitly {@link protos.args.NatsConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsConn
             * @static
             * @param {protos.args.INatsConn} message NatsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsConn} NatsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsConn();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    case 2:
                        message.insecureTls = reader.bool();
                        break;
                    case 3:
                        message.tlsCaCert = reader.bytes();
                        break;
                    case 4:
                        message.tlsClientCert = reader.bytes();
                        break;
                    case 5:
                        message.tlsClientKey = reader.bytes();
                        break;
                    case 6:
                        message.userCredentials = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsConn} NatsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsConn message.
             * @function verify
             * @memberof protos.args.NatsConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    if (typeof message.insecureTls !== "boolean")
                        return "insecureTls: boolean expected";
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    if (!(message.tlsCaCert && typeof message.tlsCaCert.length === "number" || $util.isString(message.tlsCaCert)))
                        return "tlsCaCert: buffer expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!(message.tlsClientCert && typeof message.tlsClientCert.length === "number" || $util.isString(message.tlsClientCert)))
                        return "tlsClientCert: buffer expected";
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    if (!(message.tlsClientKey && typeof message.tlsClientKey.length === "number" || $util.isString(message.tlsClientKey)))
                        return "tlsClientKey: buffer expected";
                if (message.userCredentials != null && message.hasOwnProperty("userCredentials"))
                    if (!(message.userCredentials && typeof message.userCredentials.length === "number" || $util.isString(message.userCredentials)))
                        return "userCredentials: buffer expected";
                return null;
            };

            /**
             * Creates a NatsConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsConn} NatsConn
             */
            NatsConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsConn)
                    return object;
                let message = new $root.protos.args.NatsConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                if (object.insecureTls != null)
                    message.insecureTls = Boolean(object.insecureTls);
                if (object.tlsCaCert != null)
                    if (typeof object.tlsCaCert === "string")
                        $util.base64.decode(object.tlsCaCert, message.tlsCaCert = $util.newBuffer($util.base64.length(object.tlsCaCert)), 0);
                    else if (object.tlsCaCert.length)
                        message.tlsCaCert = object.tlsCaCert;
                if (object.tlsClientCert != null)
                    if (typeof object.tlsClientCert === "string")
                        $util.base64.decode(object.tlsClientCert, message.tlsClientCert = $util.newBuffer($util.base64.length(object.tlsClientCert)), 0);
                    else if (object.tlsClientCert.length)
                        message.tlsClientCert = object.tlsClientCert;
                if (object.tlsClientKey != null)
                    if (typeof object.tlsClientKey === "string")
                        $util.base64.decode(object.tlsClientKey, message.tlsClientKey = $util.newBuffer($util.base64.length(object.tlsClientKey)), 0);
                    else if (object.tlsClientKey.length)
                        message.tlsClientKey = object.tlsClientKey;
                if (object.userCredentials != null)
                    if (typeof object.userCredentials === "string")
                        $util.base64.decode(object.userCredentials, message.userCredentials = $util.newBuffer($util.base64.length(object.userCredentials)), 0);
                    else if (object.userCredentials.length)
                        message.userCredentials = object.userCredentials;
                return message;
            };

            /**
             * Creates a plain object from a NatsConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsConn
             * @static
             * @param {protos.args.NatsConn} message NatsConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.dsn = "";
                    object.insecureTls = false;
                    if (options.bytes === String)
                        object.tlsCaCert = "";
                    else {
                        object.tlsCaCert = [];
                        if (options.bytes !== Array)
                            object.tlsCaCert = $util.newBuffer(object.tlsCaCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientCert = "";
                    else {
                        object.tlsClientCert = [];
                        if (options.bytes !== Array)
                            object.tlsClientCert = $util.newBuffer(object.tlsClientCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientKey = "";
                    else {
                        object.tlsClientKey = [];
                        if (options.bytes !== Array)
                            object.tlsClientKey = $util.newBuffer(object.tlsClientKey);
                    }
                    if (options.bytes === String)
                        object.userCredentials = "";
                    else {
                        object.userCredentials = [];
                        if (options.bytes !== Array)
                            object.userCredentials = $util.newBuffer(object.userCredentials);
                    }
                }
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    object.insecureTls = message.insecureTls;
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    object.tlsCaCert = options.bytes === String ? $util.base64.encode(message.tlsCaCert, 0, message.tlsCaCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsCaCert) : message.tlsCaCert;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = options.bytes === String ? $util.base64.encode(message.tlsClientCert, 0, message.tlsClientCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientCert) : message.tlsClientCert;
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    object.tlsClientKey = options.bytes === String ? $util.base64.encode(message.tlsClientKey, 0, message.tlsClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientKey) : message.tlsClientKey;
                if (message.userCredentials != null && message.hasOwnProperty("userCredentials"))
                    object.userCredentials = options.bytes === String ? $util.base64.encode(message.userCredentials, 0, message.userCredentials.length) : options.bytes === Array ? Array.prototype.slice.call(message.userCredentials) : message.userCredentials;
                return object;
            };

            /**
             * Converts this NatsConn to JSON.
             * @function toJSON
             * @memberof protos.args.NatsConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsConn;
        })();

        args.NatsReadArgs = (function() {

            /**
             * Properties of a NatsReadArgs.
             * @memberof protos.args
             * @interface INatsReadArgs
             * @property {string|null} [subject] NatsReadArgs subject
             */

            /**
             * Constructs a new NatsReadArgs.
             * @memberof protos.args
             * @classdesc Represents a NatsReadArgs.
             * @implements INatsReadArgs
             * @constructor
             * @param {protos.args.INatsReadArgs=} [properties] Properties to set
             */
            function NatsReadArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsReadArgs subject.
             * @member {string} subject
             * @memberof protos.args.NatsReadArgs
             * @instance
             */
            NatsReadArgs.prototype.subject = "";

            /**
             * Creates a new NatsReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {protos.args.INatsReadArgs=} [properties] Properties to set
             * @returns {protos.args.NatsReadArgs} NatsReadArgs instance
             */
            NatsReadArgs.create = function create(properties) {
                return new NatsReadArgs(properties);
            };

            /**
             * Encodes the specified NatsReadArgs message. Does not implicitly {@link protos.args.NatsReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {protos.args.INatsReadArgs} message NatsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.subject);
                return writer;
            };

            /**
             * Encodes the specified NatsReadArgs message, length delimited. Does not implicitly {@link protos.args.NatsReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {protos.args.INatsReadArgs} message NatsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsReadArgs} NatsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsReadArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subject = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsReadArgs} NatsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsReadArgs message.
             * @function verify
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    if (!$util.isString(message.subject))
                        return "subject: string expected";
                return null;
            };

            /**
             * Creates a NatsReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsReadArgs} NatsReadArgs
             */
            NatsReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsReadArgs)
                    return object;
                let message = new $root.protos.args.NatsReadArgs();
                if (object.subject != null)
                    message.subject = String(object.subject);
                return message;
            };

            /**
             * Creates a plain object from a NatsReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {protos.args.NatsReadArgs} message NatsReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.subject = "";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    object.subject = message.subject;
                return object;
            };

            /**
             * Converts this NatsReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NatsReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsReadArgs;
        })();

        args.NatsWriteArgs = (function() {

            /**
             * Properties of a NatsWriteArgs.
             * @memberof protos.args
             * @interface INatsWriteArgs
             * @property {string|null} [subject] NatsWriteArgs subject
             */

            /**
             * Constructs a new NatsWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a NatsWriteArgs.
             * @implements INatsWriteArgs
             * @constructor
             * @param {protos.args.INatsWriteArgs=} [properties] Properties to set
             */
            function NatsWriteArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsWriteArgs subject.
             * @member {string} subject
             * @memberof protos.args.NatsWriteArgs
             * @instance
             */
            NatsWriteArgs.prototype.subject = "";

            /**
             * Creates a new NatsWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {protos.args.INatsWriteArgs=} [properties] Properties to set
             * @returns {protos.args.NatsWriteArgs} NatsWriteArgs instance
             */
            NatsWriteArgs.create = function create(properties) {
                return new NatsWriteArgs(properties);
            };

            /**
             * Encodes the specified NatsWriteArgs message. Does not implicitly {@link protos.args.NatsWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {protos.args.INatsWriteArgs} message NatsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.subject);
                return writer;
            };

            /**
             * Encodes the specified NatsWriteArgs message, length delimited. Does not implicitly {@link protos.args.NatsWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {protos.args.INatsWriteArgs} message NatsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsWriteArgs} NatsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsWriteArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subject = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsWriteArgs} NatsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsWriteArgs message.
             * @function verify
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    if (!$util.isString(message.subject))
                        return "subject: string expected";
                return null;
            };

            /**
             * Creates a NatsWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsWriteArgs} NatsWriteArgs
             */
            NatsWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsWriteArgs)
                    return object;
                let message = new $root.protos.args.NatsWriteArgs();
                if (object.subject != null)
                    message.subject = String(object.subject);
                return message;
            };

            /**
             * Creates a plain object from a NatsWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {protos.args.NatsWriteArgs} message NatsWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.subject = "";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    object.subject = message.subject;
                return object;
            };

            /**
             * Converts this NatsWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NatsWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsWriteArgs;
        })();

        args.NatsStreamingConn = (function() {

            /**
             * Properties of a NatsStreamingConn.
             * @memberof protos.args
             * @interface INatsStreamingConn
             * @property {string|null} [dsn] NatsStreamingConn dsn
             * @property {boolean|null} [insecureTls] NatsStreamingConn insecureTls
             * @property {Uint8Array|null} [tlsCaCert] NatsStreamingConn tlsCaCert
             * @property {Uint8Array|null} [tlsClientCert] NatsStreamingConn tlsClientCert
             * @property {Uint8Array|null} [tlsClientKey] NatsStreamingConn tlsClientKey
             * @property {Uint8Array|null} [userCredentials] NatsStreamingConn userCredentials
             * @property {string|null} [clusterId] NatsStreamingConn clusterId
             * @property {string|null} [clientId] NatsStreamingConn clientId
             */

            /**
             * Constructs a new NatsStreamingConn.
             * @memberof protos.args
             * @classdesc Represents a NatsStreamingConn.
             * @implements INatsStreamingConn
             * @constructor
             * @param {protos.args.INatsStreamingConn=} [properties] Properties to set
             */
            function NatsStreamingConn(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsStreamingConn dsn.
             * @member {string} dsn
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.dsn = "";

            /**
             * NatsStreamingConn insecureTls.
             * @member {boolean} insecureTls
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.insecureTls = false;

            /**
             * NatsStreamingConn tlsCaCert.
             * @member {Uint8Array} tlsCaCert
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.tlsCaCert = $util.newBuffer([]);

            /**
             * NatsStreamingConn tlsClientCert.
             * @member {Uint8Array} tlsClientCert
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.tlsClientCert = $util.newBuffer([]);

            /**
             * NatsStreamingConn tlsClientKey.
             * @member {Uint8Array} tlsClientKey
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.tlsClientKey = $util.newBuffer([]);

            /**
             * NatsStreamingConn userCredentials.
             * @member {Uint8Array} userCredentials
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.userCredentials = $util.newBuffer([]);

            /**
             * NatsStreamingConn clusterId.
             * @member {string} clusterId
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.clusterId = "";

            /**
             * NatsStreamingConn clientId.
             * @member {string} clientId
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.clientId = "";

            /**
             * Creates a new NatsStreamingConn instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {protos.args.INatsStreamingConn=} [properties] Properties to set
             * @returns {protos.args.NatsStreamingConn} NatsStreamingConn instance
             */
            NatsStreamingConn.create = function create(properties) {
                return new NatsStreamingConn(properties);
            };

            /**
             * Encodes the specified NatsStreamingConn message. Does not implicitly {@link protos.args.NatsStreamingConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {protos.args.INatsStreamingConn} message NatsStreamingConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                if (message.insecureTls != null && Object.hasOwnProperty.call(message, "insecureTls"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.insecureTls);
                if (message.tlsCaCert != null && Object.hasOwnProperty.call(message, "tlsCaCert"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.tlsCaCert);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.tlsClientCert);
                if (message.tlsClientKey != null && Object.hasOwnProperty.call(message, "tlsClientKey"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.tlsClientKey);
                if (message.userCredentials != null && Object.hasOwnProperty.call(message, "userCredentials"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.userCredentials);
                if (message.clusterId != null && Object.hasOwnProperty.call(message, "clusterId"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.clusterId);
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.clientId);
                return writer;
            };

            /**
             * Encodes the specified NatsStreamingConn message, length delimited. Does not implicitly {@link protos.args.NatsStreamingConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {protos.args.INatsStreamingConn} message NatsStreamingConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsStreamingConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsStreamingConn} NatsStreamingConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsStreamingConn();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    case 2:
                        message.insecureTls = reader.bool();
                        break;
                    case 3:
                        message.tlsCaCert = reader.bytes();
                        break;
                    case 4:
                        message.tlsClientCert = reader.bytes();
                        break;
                    case 5:
                        message.tlsClientKey = reader.bytes();
                        break;
                    case 6:
                        message.userCredentials = reader.bytes();
                        break;
                    case 7:
                        message.clusterId = reader.string();
                        break;
                    case 8:
                        message.clientId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsStreamingConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsStreamingConn} NatsStreamingConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsStreamingConn message.
             * @function verify
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsStreamingConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    if (typeof message.insecureTls !== "boolean")
                        return "insecureTls: boolean expected";
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    if (!(message.tlsCaCert && typeof message.tlsCaCert.length === "number" || $util.isString(message.tlsCaCert)))
                        return "tlsCaCert: buffer expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!(message.tlsClientCert && typeof message.tlsClientCert.length === "number" || $util.isString(message.tlsClientCert)))
                        return "tlsClientCert: buffer expected";
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    if (!(message.tlsClientKey && typeof message.tlsClientKey.length === "number" || $util.isString(message.tlsClientKey)))
                        return "tlsClientKey: buffer expected";
                if (message.userCredentials != null && message.hasOwnProperty("userCredentials"))
                    if (!(message.userCredentials && typeof message.userCredentials.length === "number" || $util.isString(message.userCredentials)))
                        return "userCredentials: buffer expected";
                if (message.clusterId != null && message.hasOwnProperty("clusterId"))
                    if (!$util.isString(message.clusterId))
                        return "clusterId: string expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                return null;
            };

            /**
             * Creates a NatsStreamingConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsStreamingConn} NatsStreamingConn
             */
            NatsStreamingConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsStreamingConn)
                    return object;
                let message = new $root.protos.args.NatsStreamingConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                if (object.insecureTls != null)
                    message.insecureTls = Boolean(object.insecureTls);
                if (object.tlsCaCert != null)
                    if (typeof object.tlsCaCert === "string")
                        $util.base64.decode(object.tlsCaCert, message.tlsCaCert = $util.newBuffer($util.base64.length(object.tlsCaCert)), 0);
                    else if (object.tlsCaCert.length)
                        message.tlsCaCert = object.tlsCaCert;
                if (object.tlsClientCert != null)
                    if (typeof object.tlsClientCert === "string")
                        $util.base64.decode(object.tlsClientCert, message.tlsClientCert = $util.newBuffer($util.base64.length(object.tlsClientCert)), 0);
                    else if (object.tlsClientCert.length)
                        message.tlsClientCert = object.tlsClientCert;
                if (object.tlsClientKey != null)
                    if (typeof object.tlsClientKey === "string")
                        $util.base64.decode(object.tlsClientKey, message.tlsClientKey = $util.newBuffer($util.base64.length(object.tlsClientKey)), 0);
                    else if (object.tlsClientKey.length)
                        message.tlsClientKey = object.tlsClientKey;
                if (object.userCredentials != null)
                    if (typeof object.userCredentials === "string")
                        $util.base64.decode(object.userCredentials, message.userCredentials = $util.newBuffer($util.base64.length(object.userCredentials)), 0);
                    else if (object.userCredentials.length)
                        message.userCredentials = object.userCredentials;
                if (object.clusterId != null)
                    message.clusterId = String(object.clusterId);
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                return message;
            };

            /**
             * Creates a plain object from a NatsStreamingConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {protos.args.NatsStreamingConn} message NatsStreamingConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsStreamingConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.dsn = "";
                    object.insecureTls = false;
                    if (options.bytes === String)
                        object.tlsCaCert = "";
                    else {
                        object.tlsCaCert = [];
                        if (options.bytes !== Array)
                            object.tlsCaCert = $util.newBuffer(object.tlsCaCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientCert = "";
                    else {
                        object.tlsClientCert = [];
                        if (options.bytes !== Array)
                            object.tlsClientCert = $util.newBuffer(object.tlsClientCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientKey = "";
                    else {
                        object.tlsClientKey = [];
                        if (options.bytes !== Array)
                            object.tlsClientKey = $util.newBuffer(object.tlsClientKey);
                    }
                    if (options.bytes === String)
                        object.userCredentials = "";
                    else {
                        object.userCredentials = [];
                        if (options.bytes !== Array)
                            object.userCredentials = $util.newBuffer(object.userCredentials);
                    }
                    object.clusterId = "";
                    object.clientId = "";
                }
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    object.insecureTls = message.insecureTls;
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    object.tlsCaCert = options.bytes === String ? $util.base64.encode(message.tlsCaCert, 0, message.tlsCaCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsCaCert) : message.tlsCaCert;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = options.bytes === String ? $util.base64.encode(message.tlsClientCert, 0, message.tlsClientCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientCert) : message.tlsClientCert;
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    object.tlsClientKey = options.bytes === String ? $util.base64.encode(message.tlsClientKey, 0, message.tlsClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientKey) : message.tlsClientKey;
                if (message.userCredentials != null && message.hasOwnProperty("userCredentials"))
                    object.userCredentials = options.bytes === String ? $util.base64.encode(message.userCredentials, 0, message.userCredentials.length) : options.bytes === Array ? Array.prototype.slice.call(message.userCredentials) : message.userCredentials;
                if (message.clusterId != null && message.hasOwnProperty("clusterId"))
                    object.clusterId = message.clusterId;
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                return object;
            };

            /**
             * Converts this NatsStreamingConn to JSON.
             * @function toJSON
             * @memberof protos.args.NatsStreamingConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsStreamingConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsStreamingConn;
        })();

        args.NatsStreamingReadArgs = (function() {

            /**
             * Properties of a NatsStreamingReadArgs.
             * @memberof protos.args
             * @interface INatsStreamingReadArgs
             * @property {string|null} [channel] NatsStreamingReadArgs channel
             * @property {string|null} [durableName] NatsStreamingReadArgs durableName
             * @property {boolean|null} [readLastAvailable] NatsStreamingReadArgs readLastAvailable
             * @property {number|null} [readSequenceNumber] NatsStreamingReadArgs readSequenceNumber
             * @property {string|null} [readSince] NatsStreamingReadArgs readSince
             * @property {boolean|null} [readAll] NatsStreamingReadArgs readAll
             */

            /**
             * Constructs a new NatsStreamingReadArgs.
             * @memberof protos.args
             * @classdesc Represents a NatsStreamingReadArgs.
             * @implements INatsStreamingReadArgs
             * @constructor
             * @param {protos.args.INatsStreamingReadArgs=} [properties] Properties to set
             */
            function NatsStreamingReadArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsStreamingReadArgs channel.
             * @member {string} channel
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.channel = "";

            /**
             * NatsStreamingReadArgs durableName.
             * @member {string} durableName
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.durableName = "";

            /**
             * NatsStreamingReadArgs readLastAvailable.
             * @member {boolean} readLastAvailable
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.readLastAvailable = false;

            /**
             * NatsStreamingReadArgs readSequenceNumber.
             * @member {number} readSequenceNumber
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.readSequenceNumber = 0;

            /**
             * NatsStreamingReadArgs readSince.
             * @member {string} readSince
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.readSince = "";

            /**
             * NatsStreamingReadArgs readAll.
             * @member {boolean} readAll
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.readAll = false;

            /**
             * Creates a new NatsStreamingReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {protos.args.INatsStreamingReadArgs=} [properties] Properties to set
             * @returns {protos.args.NatsStreamingReadArgs} NatsStreamingReadArgs instance
             */
            NatsStreamingReadArgs.create = function create(properties) {
                return new NatsStreamingReadArgs(properties);
            };

            /**
             * Encodes the specified NatsStreamingReadArgs message. Does not implicitly {@link protos.args.NatsStreamingReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {protos.args.INatsStreamingReadArgs} message NatsStreamingReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);
                if (message.durableName != null && Object.hasOwnProperty.call(message, "durableName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.durableName);
                if (message.readLastAvailable != null && Object.hasOwnProperty.call(message, "readLastAvailable"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.readLastAvailable);
                if (message.readSequenceNumber != null && Object.hasOwnProperty.call(message, "readSequenceNumber"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.readSequenceNumber);
                if (message.readSince != null && Object.hasOwnProperty.call(message, "readSince"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.readSince);
                if (message.readAll != null && Object.hasOwnProperty.call(message, "readAll"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.readAll);
                return writer;
            };

            /**
             * Encodes the specified NatsStreamingReadArgs message, length delimited. Does not implicitly {@link protos.args.NatsStreamingReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {protos.args.INatsStreamingReadArgs} message NatsStreamingReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsStreamingReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsStreamingReadArgs} NatsStreamingReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsStreamingReadArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = reader.string();
                        break;
                    case 2:
                        message.durableName = reader.string();
                        break;
                    case 3:
                        message.readLastAvailable = reader.bool();
                        break;
                    case 4:
                        message.readSequenceNumber = reader.uint32();
                        break;
                    case 5:
                        message.readSince = reader.string();
                        break;
                    case 6:
                        message.readAll = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsStreamingReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsStreamingReadArgs} NatsStreamingReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsStreamingReadArgs message.
             * @function verify
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsStreamingReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                if (message.durableName != null && message.hasOwnProperty("durableName"))
                    if (!$util.isString(message.durableName))
                        return "durableName: string expected";
                if (message.readLastAvailable != null && message.hasOwnProperty("readLastAvailable"))
                    if (typeof message.readLastAvailable !== "boolean")
                        return "readLastAvailable: boolean expected";
                if (message.readSequenceNumber != null && message.hasOwnProperty("readSequenceNumber"))
                    if (!$util.isInteger(message.readSequenceNumber))
                        return "readSequenceNumber: integer expected";
                if (message.readSince != null && message.hasOwnProperty("readSince"))
                    if (!$util.isString(message.readSince))
                        return "readSince: string expected";
                if (message.readAll != null && message.hasOwnProperty("readAll"))
                    if (typeof message.readAll !== "boolean")
                        return "readAll: boolean expected";
                return null;
            };

            /**
             * Creates a NatsStreamingReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsStreamingReadArgs} NatsStreamingReadArgs
             */
            NatsStreamingReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsStreamingReadArgs)
                    return object;
                let message = new $root.protos.args.NatsStreamingReadArgs();
                if (object.channel != null)
                    message.channel = String(object.channel);
                if (object.durableName != null)
                    message.durableName = String(object.durableName);
                if (object.readLastAvailable != null)
                    message.readLastAvailable = Boolean(object.readLastAvailable);
                if (object.readSequenceNumber != null)
                    message.readSequenceNumber = object.readSequenceNumber >>> 0;
                if (object.readSince != null)
                    message.readSince = String(object.readSince);
                if (object.readAll != null)
                    message.readAll = Boolean(object.readAll);
                return message;
            };

            /**
             * Creates a plain object from a NatsStreamingReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {protos.args.NatsStreamingReadArgs} message NatsStreamingReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsStreamingReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.channel = "";
                    object.durableName = "";
                    object.readLastAvailable = false;
                    object.readSequenceNumber = 0;
                    object.readSince = "";
                    object.readAll = false;
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.durableName != null && message.hasOwnProperty("durableName"))
                    object.durableName = message.durableName;
                if (message.readLastAvailable != null && message.hasOwnProperty("readLastAvailable"))
                    object.readLastAvailable = message.readLastAvailable;
                if (message.readSequenceNumber != null && message.hasOwnProperty("readSequenceNumber"))
                    object.readSequenceNumber = message.readSequenceNumber;
                if (message.readSince != null && message.hasOwnProperty("readSince"))
                    object.readSince = message.readSince;
                if (message.readAll != null && message.hasOwnProperty("readAll"))
                    object.readAll = message.readAll;
                return object;
            };

            /**
             * Converts this NatsStreamingReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsStreamingReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsStreamingReadArgs;
        })();

        args.NatsStreamingWriteArgs = (function() {

            /**
             * Properties of a NatsStreamingWriteArgs.
             * @memberof protos.args
             * @interface INatsStreamingWriteArgs
             * @property {string|null} [channel] NatsStreamingWriteArgs channel
             */

            /**
             * Constructs a new NatsStreamingWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a NatsStreamingWriteArgs.
             * @implements INatsStreamingWriteArgs
             * @constructor
             * @param {protos.args.INatsStreamingWriteArgs=} [properties] Properties to set
             */
            function NatsStreamingWriteArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsStreamingWriteArgs channel.
             * @member {string} channel
             * @memberof protos.args.NatsStreamingWriteArgs
             * @instance
             */
            NatsStreamingWriteArgs.prototype.channel = "";

            /**
             * Creates a new NatsStreamingWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {protos.args.INatsStreamingWriteArgs=} [properties] Properties to set
             * @returns {protos.args.NatsStreamingWriteArgs} NatsStreamingWriteArgs instance
             */
            NatsStreamingWriteArgs.create = function create(properties) {
                return new NatsStreamingWriteArgs(properties);
            };

            /**
             * Encodes the specified NatsStreamingWriteArgs message. Does not implicitly {@link protos.args.NatsStreamingWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {protos.args.INatsStreamingWriteArgs} message NatsStreamingWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);
                return writer;
            };

            /**
             * Encodes the specified NatsStreamingWriteArgs message, length delimited. Does not implicitly {@link protos.args.NatsStreamingWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {protos.args.INatsStreamingWriteArgs} message NatsStreamingWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsStreamingWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsStreamingWriteArgs} NatsStreamingWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsStreamingWriteArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsStreamingWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsStreamingWriteArgs} NatsStreamingWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsStreamingWriteArgs message.
             * @function verify
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsStreamingWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                return null;
            };

            /**
             * Creates a NatsStreamingWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsStreamingWriteArgs} NatsStreamingWriteArgs
             */
            NatsStreamingWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsStreamingWriteArgs)
                    return object;
                let message = new $root.protos.args.NatsStreamingWriteArgs();
                if (object.channel != null)
                    message.channel = String(object.channel);
                return message;
            };

            /**
             * Creates a plain object from a NatsStreamingWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {protos.args.NatsStreamingWriteArgs} message NatsStreamingWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsStreamingWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.channel = "";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                return object;
            };

            /**
             * Converts this NatsStreamingWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NatsStreamingWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsStreamingWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsStreamingWriteArgs;
        })();

        args.NSQConn = (function() {

            /**
             * Properties of a NSQConn.
             * @memberof protos.args
             * @interface INSQConn
             * @property {string|null} [nsqdAddress] NSQConn nsqdAddress
             * @property {string|null} [lookupdAddress] NSQConn lookupdAddress
             * @property {boolean|null} [useTls] NSQConn useTls
             * @property {boolean|null} [insecureTls] NSQConn insecureTls
             * @property {Uint8Array|null} [tlsCaCert] NSQConn tlsCaCert
             * @property {Uint8Array|null} [tlsClientCert] NSQConn tlsClientCert
             * @property {Uint8Array|null} [tlsClientKey] NSQConn tlsClientKey
             * @property {string|null} [authSecret] NSQConn authSecret
             * @property {string|null} [clientId] NSQConn clientId
             */

            /**
             * Constructs a new NSQConn.
             * @memberof protos.args
             * @classdesc Represents a NSQConn.
             * @implements INSQConn
             * @constructor
             * @param {protos.args.INSQConn=} [properties] Properties to set
             */
            function NSQConn(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NSQConn nsqdAddress.
             * @member {string} nsqdAddress
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.nsqdAddress = "";

            /**
             * NSQConn lookupdAddress.
             * @member {string} lookupdAddress
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.lookupdAddress = "";

            /**
             * NSQConn useTls.
             * @member {boolean} useTls
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.useTls = false;

            /**
             * NSQConn insecureTls.
             * @member {boolean} insecureTls
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.insecureTls = false;

            /**
             * NSQConn tlsCaCert.
             * @member {Uint8Array} tlsCaCert
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.tlsCaCert = $util.newBuffer([]);

            /**
             * NSQConn tlsClientCert.
             * @member {Uint8Array} tlsClientCert
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.tlsClientCert = $util.newBuffer([]);

            /**
             * NSQConn tlsClientKey.
             * @member {Uint8Array} tlsClientKey
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.tlsClientKey = $util.newBuffer([]);

            /**
             * NSQConn authSecret.
             * @member {string} authSecret
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.authSecret = "";

            /**
             * NSQConn clientId.
             * @member {string} clientId
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.clientId = "";

            /**
             * Creates a new NSQConn instance using the specified properties.
             * @function create
             * @memberof protos.args.NSQConn
             * @static
             * @param {protos.args.INSQConn=} [properties] Properties to set
             * @returns {protos.args.NSQConn} NSQConn instance
             */
            NSQConn.create = function create(properties) {
                return new NSQConn(properties);
            };

            /**
             * Encodes the specified NSQConn message. Does not implicitly {@link protos.args.NSQConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NSQConn
             * @static
             * @param {protos.args.INSQConn} message NSQConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nsqdAddress != null && Object.hasOwnProperty.call(message, "nsqdAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nsqdAddress);
                if (message.lookupdAddress != null && Object.hasOwnProperty.call(message, "lookupdAddress"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.lookupdAddress);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.useTls);
                if (message.insecureTls != null && Object.hasOwnProperty.call(message, "insecureTls"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.insecureTls);
                if (message.tlsCaCert != null && Object.hasOwnProperty.call(message, "tlsCaCert"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.tlsCaCert);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.tlsClientCert);
                if (message.tlsClientKey != null && Object.hasOwnProperty.call(message, "tlsClientKey"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.tlsClientKey);
                if (message.authSecret != null && Object.hasOwnProperty.call(message, "authSecret"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.authSecret);
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.clientId);
                return writer;
            };

            /**
             * Encodes the specified NSQConn message, length delimited. Does not implicitly {@link protos.args.NSQConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NSQConn
             * @static
             * @param {protos.args.INSQConn} message NSQConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NSQConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NSQConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NSQConn} NSQConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NSQConn();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nsqdAddress = reader.string();
                        break;
                    case 2:
                        message.lookupdAddress = reader.string();
                        break;
                    case 3:
                        message.useTls = reader.bool();
                        break;
                    case 4:
                        message.insecureTls = reader.bool();
                        break;
                    case 5:
                        message.tlsCaCert = reader.bytes();
                        break;
                    case 6:
                        message.tlsClientCert = reader.bytes();
                        break;
                    case 7:
                        message.tlsClientKey = reader.bytes();
                        break;
                    case 8:
                        message.authSecret = reader.string();
                        break;
                    case 9:
                        message.clientId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NSQConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NSQConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NSQConn} NSQConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NSQConn message.
             * @function verify
             * @memberof protos.args.NSQConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NSQConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nsqdAddress != null && message.hasOwnProperty("nsqdAddress"))
                    if (!$util.isString(message.nsqdAddress))
                        return "nsqdAddress: string expected";
                if (message.lookupdAddress != null && message.hasOwnProperty("lookupdAddress"))
                    if (!$util.isString(message.lookupdAddress))
                        return "lookupdAddress: string expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    if (typeof message.insecureTls !== "boolean")
                        return "insecureTls: boolean expected";
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    if (!(message.tlsCaCert && typeof message.tlsCaCert.length === "number" || $util.isString(message.tlsCaCert)))
                        return "tlsCaCert: buffer expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!(message.tlsClientCert && typeof message.tlsClientCert.length === "number" || $util.isString(message.tlsClientCert)))
                        return "tlsClientCert: buffer expected";
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    if (!(message.tlsClientKey && typeof message.tlsClientKey.length === "number" || $util.isString(message.tlsClientKey)))
                        return "tlsClientKey: buffer expected";
                if (message.authSecret != null && message.hasOwnProperty("authSecret"))
                    if (!$util.isString(message.authSecret))
                        return "authSecret: string expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                return null;
            };

            /**
             * Creates a NSQConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NSQConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NSQConn} NSQConn
             */
            NSQConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NSQConn)
                    return object;
                let message = new $root.protos.args.NSQConn();
                if (object.nsqdAddress != null)
                    message.nsqdAddress = String(object.nsqdAddress);
                if (object.lookupdAddress != null)
                    message.lookupdAddress = String(object.lookupdAddress);
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.insecureTls != null)
                    message.insecureTls = Boolean(object.insecureTls);
                if (object.tlsCaCert != null)
                    if (typeof object.tlsCaCert === "string")
                        $util.base64.decode(object.tlsCaCert, message.tlsCaCert = $util.newBuffer($util.base64.length(object.tlsCaCert)), 0);
                    else if (object.tlsCaCert.length)
                        message.tlsCaCert = object.tlsCaCert;
                if (object.tlsClientCert != null)
                    if (typeof object.tlsClientCert === "string")
                        $util.base64.decode(object.tlsClientCert, message.tlsClientCert = $util.newBuffer($util.base64.length(object.tlsClientCert)), 0);
                    else if (object.tlsClientCert.length)
                        message.tlsClientCert = object.tlsClientCert;
                if (object.tlsClientKey != null)
                    if (typeof object.tlsClientKey === "string")
                        $util.base64.decode(object.tlsClientKey, message.tlsClientKey = $util.newBuffer($util.base64.length(object.tlsClientKey)), 0);
                    else if (object.tlsClientKey.length)
                        message.tlsClientKey = object.tlsClientKey;
                if (object.authSecret != null)
                    message.authSecret = String(object.authSecret);
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                return message;
            };

            /**
             * Creates a plain object from a NSQConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NSQConn
             * @static
             * @param {protos.args.NSQConn} message NSQConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NSQConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.nsqdAddress = "";
                    object.lookupdAddress = "";
                    object.useTls = false;
                    object.insecureTls = false;
                    if (options.bytes === String)
                        object.tlsCaCert = "";
                    else {
                        object.tlsCaCert = [];
                        if (options.bytes !== Array)
                            object.tlsCaCert = $util.newBuffer(object.tlsCaCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientCert = "";
                    else {
                        object.tlsClientCert = [];
                        if (options.bytes !== Array)
                            object.tlsClientCert = $util.newBuffer(object.tlsClientCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientKey = "";
                    else {
                        object.tlsClientKey = [];
                        if (options.bytes !== Array)
                            object.tlsClientKey = $util.newBuffer(object.tlsClientKey);
                    }
                    object.authSecret = "";
                    object.clientId = "";
                }
                if (message.nsqdAddress != null && message.hasOwnProperty("nsqdAddress"))
                    object.nsqdAddress = message.nsqdAddress;
                if (message.lookupdAddress != null && message.hasOwnProperty("lookupdAddress"))
                    object.lookupdAddress = message.lookupdAddress;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    object.insecureTls = message.insecureTls;
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    object.tlsCaCert = options.bytes === String ? $util.base64.encode(message.tlsCaCert, 0, message.tlsCaCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsCaCert) : message.tlsCaCert;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = options.bytes === String ? $util.base64.encode(message.tlsClientCert, 0, message.tlsClientCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientCert) : message.tlsClientCert;
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    object.tlsClientKey = options.bytes === String ? $util.base64.encode(message.tlsClientKey, 0, message.tlsClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientKey) : message.tlsClientKey;
                if (message.authSecret != null && message.hasOwnProperty("authSecret"))
                    object.authSecret = message.authSecret;
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                return object;
            };

            /**
             * Converts this NSQConn to JSON.
             * @function toJSON
             * @memberof protos.args.NSQConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NSQConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NSQConn;
        })();

        args.NSQReadArgs = (function() {

            /**
             * Properties of a NSQReadArgs.
             * @memberof protos.args
             * @interface INSQReadArgs
             * @property {string|null} [topic] NSQReadArgs topic
             * @property {string|null} [channel] NSQReadArgs channel
             */

            /**
             * Constructs a new NSQReadArgs.
             * @memberof protos.args
             * @classdesc Represents a NSQReadArgs.
             * @implements INSQReadArgs
             * @constructor
             * @param {protos.args.INSQReadArgs=} [properties] Properties to set
             */
            function NSQReadArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NSQReadArgs topic.
             * @member {string} topic
             * @memberof protos.args.NSQReadArgs
             * @instance
             */
            NSQReadArgs.prototype.topic = "";

            /**
             * NSQReadArgs channel.
             * @member {string} channel
             * @memberof protos.args.NSQReadArgs
             * @instance
             */
            NSQReadArgs.prototype.channel = "";

            /**
             * Creates a new NSQReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {protos.args.INSQReadArgs=} [properties] Properties to set
             * @returns {protos.args.NSQReadArgs} NSQReadArgs instance
             */
            NSQReadArgs.create = function create(properties) {
                return new NSQReadArgs(properties);
            };

            /**
             * Encodes the specified NSQReadArgs message. Does not implicitly {@link protos.args.NSQReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {protos.args.INSQReadArgs} message NSQReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.channel);
                return writer;
            };

            /**
             * Encodes the specified NSQReadArgs message, length delimited. Does not implicitly {@link protos.args.NSQReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {protos.args.INSQReadArgs} message NSQReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NSQReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NSQReadArgs} NSQReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NSQReadArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.channel = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NSQReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NSQReadArgs} NSQReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NSQReadArgs message.
             * @function verify
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NSQReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                return null;
            };

            /**
             * Creates a NSQReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NSQReadArgs} NSQReadArgs
             */
            NSQReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NSQReadArgs)
                    return object;
                let message = new $root.protos.args.NSQReadArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.channel != null)
                    message.channel = String(object.channel);
                return message;
            };

            /**
             * Creates a plain object from a NSQReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {protos.args.NSQReadArgs} message NSQReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NSQReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.channel = "";
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                return object;
            };

            /**
             * Converts this NSQReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NSQReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NSQReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NSQReadArgs;
        })();

        args.NSQWriteArgs = (function() {

            /**
             * Properties of a NSQWriteArgs.
             * @memberof protos.args
             * @interface INSQWriteArgs
             * @property {string|null} [topic] NSQWriteArgs topic
             */

            /**
             * Constructs a new NSQWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a NSQWriteArgs.
             * @implements INSQWriteArgs
             * @constructor
             * @param {protos.args.INSQWriteArgs=} [properties] Properties to set
             */
            function NSQWriteArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NSQWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.NSQWriteArgs
             * @instance
             */
            NSQWriteArgs.prototype.topic = "";

            /**
             * Creates a new NSQWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {protos.args.INSQWriteArgs=} [properties] Properties to set
             * @returns {protos.args.NSQWriteArgs} NSQWriteArgs instance
             */
            NSQWriteArgs.create = function create(properties) {
                return new NSQWriteArgs(properties);
            };

            /**
             * Encodes the specified NSQWriteArgs message. Does not implicitly {@link protos.args.NSQWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {protos.args.INSQWriteArgs} message NSQWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                return writer;
            };

            /**
             * Encodes the specified NSQWriteArgs message, length delimited. Does not implicitly {@link protos.args.NSQWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {protos.args.INSQWriteArgs} message NSQWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NSQWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NSQWriteArgs} NSQWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NSQWriteArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NSQWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NSQWriteArgs} NSQWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NSQWriteArgs message.
             * @function verify
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NSQWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                return null;
            };

            /**
             * Creates a NSQWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NSQWriteArgs} NSQWriteArgs
             */
            NSQWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NSQWriteArgs)
                    return object;
                let message = new $root.protos.args.NSQWriteArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                return message;
            };

            /**
             * Creates a plain object from a NSQWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {protos.args.NSQWriteArgs} message NSQWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NSQWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.topic = "";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                return object;
            };

            /**
             * Converts this NSQWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NSQWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NSQWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NSQWriteArgs;
        })();

        args.PostgresConn = (function() {

            /**
             * Properties of a PostgresConn.
             * @memberof protos.args
             * @interface IPostgresConn
             * @property {string|null} [address] PostgresConn address
             * @property {number|null} [port] PostgresConn port
             * @property {string|null} [username] PostgresConn username
             * @property {string|null} [password] PostgresConn password
             * @property {string|null} [database] PostgresConn database
             * @property {boolean|null} [useTls] PostgresConn useTls
             * @property {boolean|null} [insecureTls] PostgresConn insecureTls
             */

            /**
             * Constructs a new PostgresConn.
             * @memberof protos.args
             * @classdesc Represents a PostgresConn.
             * @implements IPostgresConn
             * @constructor
             * @param {protos.args.IPostgresConn=} [properties] Properties to set
             */
            function PostgresConn(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PostgresConn address.
             * @member {string} address
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.address = "";

            /**
             * PostgresConn port.
             * @member {number} port
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.port = 0;

            /**
             * PostgresConn username.
             * @member {string} username
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.username = "";

            /**
             * PostgresConn password.
             * @member {string} password
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.password = "";

            /**
             * PostgresConn database.
             * @member {string} database
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.database = "";

            /**
             * PostgresConn useTls.
             * @member {boolean} useTls
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.useTls = false;

            /**
             * PostgresConn insecureTls.
             * @member {boolean} insecureTls
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.insecureTls = false;

            /**
             * Creates a new PostgresConn instance using the specified properties.
             * @function create
             * @memberof protos.args.PostgresConn
             * @static
             * @param {protos.args.IPostgresConn=} [properties] Properties to set
             * @returns {protos.args.PostgresConn} PostgresConn instance
             */
            PostgresConn.create = function create(properties) {
                return new PostgresConn(properties);
            };

            /**
             * Encodes the specified PostgresConn message. Does not implicitly {@link protos.args.PostgresConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.PostgresConn
             * @static
             * @param {protos.args.IPostgresConn} message PostgresConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PostgresConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.username);
                if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.password);
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.database);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.useTls);
                if (message.insecureTls != null && Object.hasOwnProperty.call(message, "insecureTls"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.insecureTls);
                return writer;
            };

            /**
             * Encodes the specified PostgresConn message, length delimited. Does not implicitly {@link protos.args.PostgresConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.PostgresConn
             * @static
             * @param {protos.args.IPostgresConn} message PostgresConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PostgresConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PostgresConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.PostgresConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.PostgresConn} PostgresConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PostgresConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.PostgresConn();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.port = reader.uint32();
                        break;
                    case 3:
                        message.username = reader.string();
                        break;
                    case 4:
                        message.password = reader.string();
                        break;
                    case 5:
                        message.database = reader.string();
                        break;
                    case 6:
                        message.useTls = reader.bool();
                        break;
                    case 7:
                        message.insecureTls = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PostgresConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.PostgresConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.PostgresConn} PostgresConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PostgresConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PostgresConn message.
             * @function verify
             * @memberof protos.args.PostgresConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PostgresConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!$util.isString(message.password))
                        return "password: string expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    if (typeof message.insecureTls !== "boolean")
                        return "insecureTls: boolean expected";
                return null;
            };

            /**
             * Creates a PostgresConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.PostgresConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.PostgresConn} PostgresConn
             */
            PostgresConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.PostgresConn)
                    return object;
                let message = new $root.protos.args.PostgresConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.port != null)
                    message.port = object.port >>> 0;
                if (object.username != null)
                    message.username = String(object.username);
                if (object.password != null)
                    message.password = String(object.password);
                if (object.database != null)
                    message.database = String(object.database);
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.insecureTls != null)
                    message.insecureTls = Boolean(object.insecureTls);
                return message;
            };

            /**
             * Creates a plain object from a PostgresConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.PostgresConn
             * @static
             * @param {protos.args.PostgresConn} message PostgresConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PostgresConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.address = "";
                    object.port = 0;
                    object.username = "";
                    object.password = "";
                    object.database = "";
                    object.useTls = false;
                    object.insecureTls = false;
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = message.password;
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    object.insecureTls = message.insecureTls;
                return object;
            };

            /**
             * Converts this PostgresConn to JSON.
             * @function toJSON
             * @memberof protos.args.PostgresConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PostgresConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PostgresConn;
        })();

        args.PostgresReadArgs = (function() {

            /**
             * Properties of a PostgresReadArgs.
             * @memberof protos.args
             * @interface IPostgresReadArgs
             * @property {string|null} [replicationSlotName] PostgresReadArgs replicationSlotName
             * @property {string|null} [publisherName] PostgresReadArgs publisherName
             */

            /**
             * Constructs a new PostgresReadArgs.
             * @memberof protos.args
             * @classdesc Represents a PostgresReadArgs.
             * @implements IPostgresReadArgs
             * @constructor
             * @param {protos.args.IPostgresReadArgs=} [properties] Properties to set
             */
            function PostgresReadArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PostgresReadArgs replicationSlotName.
             * @member {string} replicationSlotName
             * @memberof protos.args.PostgresReadArgs
             * @instance
             */
            PostgresReadArgs.prototype.replicationSlotName = "";

            /**
             * PostgresReadArgs publisherName.
             * @member {string} publisherName
             * @memberof protos.args.PostgresReadArgs
             * @instance
             */
            PostgresReadArgs.prototype.publisherName = "";

            /**
             * Creates a new PostgresReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {protos.args.IPostgresReadArgs=} [properties] Properties to set
             * @returns {protos.args.PostgresReadArgs} PostgresReadArgs instance
             */
            PostgresReadArgs.create = function create(properties) {
                return new PostgresReadArgs(properties);
            };

            /**
             * Encodes the specified PostgresReadArgs message. Does not implicitly {@link protos.args.PostgresReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {protos.args.IPostgresReadArgs} message PostgresReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PostgresReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.replicationSlotName != null && Object.hasOwnProperty.call(message, "replicationSlotName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.replicationSlotName);
                if (message.publisherName != null && Object.hasOwnProperty.call(message, "publisherName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.publisherName);
                return writer;
            };

            /**
             * Encodes the specified PostgresReadArgs message, length delimited. Does not implicitly {@link protos.args.PostgresReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {protos.args.IPostgresReadArgs} message PostgresReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PostgresReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PostgresReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.PostgresReadArgs} PostgresReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PostgresReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.PostgresReadArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.replicationSlotName = reader.string();
                        break;
                    case 3:
                        message.publisherName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PostgresReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.PostgresReadArgs} PostgresReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PostgresReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PostgresReadArgs message.
             * @function verify
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PostgresReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.replicationSlotName != null && message.hasOwnProperty("replicationSlotName"))
                    if (!$util.isString(message.replicationSlotName))
                        return "replicationSlotName: string expected";
                if (message.publisherName != null && message.hasOwnProperty("publisherName"))
                    if (!$util.isString(message.publisherName))
                        return "publisherName: string expected";
                return null;
            };

            /**
             * Creates a PostgresReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.PostgresReadArgs} PostgresReadArgs
             */
            PostgresReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.PostgresReadArgs)
                    return object;
                let message = new $root.protos.args.PostgresReadArgs();
                if (object.replicationSlotName != null)
                    message.replicationSlotName = String(object.replicationSlotName);
                if (object.publisherName != null)
                    message.publisherName = String(object.publisherName);
                return message;
            };

            /**
             * Creates a plain object from a PostgresReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {protos.args.PostgresReadArgs} message PostgresReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PostgresReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.replicationSlotName = "";
                    object.publisherName = "";
                }
                if (message.replicationSlotName != null && message.hasOwnProperty("replicationSlotName"))
                    object.replicationSlotName = message.replicationSlotName;
                if (message.publisherName != null && message.hasOwnProperty("publisherName"))
                    object.publisherName = message.publisherName;
                return object;
            };

            /**
             * Converts this PostgresReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.PostgresReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PostgresReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PostgresReadArgs;
        })();

        /**
         * SubscriptionType enum.
         * @name protos.args.SubscriptionType
         * @enum {number}
         * @property {number} SHARED=0 SHARED value
         * @property {number} EXCLUSIVE=1 EXCLUSIVE value
         * @property {number} FAILOVER=2 FAILOVER value
         * @property {number} KEYSHARED=3 KEYSHARED value
         */
        args.SubscriptionType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SHARED"] = 0;
            values[valuesById[1] = "EXCLUSIVE"] = 1;
            values[valuesById[2] = "FAILOVER"] = 2;
            values[valuesById[3] = "KEYSHARED"] = 3;
            return values;
        })();

        args.PulsarConn = (function() {

            /**
             * Properties of a PulsarConn.
             * @memberof protos.args
             * @interface IPulsarConn
             * @property {string|null} [dsn] PulsarConn dsn
             * @property {number|null} [connectTimeoutSeconds] PulsarConn connectTimeoutSeconds
             * @property {boolean|null} [insecureTls] PulsarConn insecureTls
             * @property {Uint8Array|null} [tlsClientCert] PulsarConn tlsClientCert
             * @property {Uint8Array|null} [tlsClientKey] PulsarConn tlsClientKey
             */

            /**
             * Constructs a new PulsarConn.
             * @memberof protos.args
             * @classdesc Represents a PulsarConn.
             * @implements IPulsarConn
             * @constructor
             * @param {protos.args.IPulsarConn=} [properties] Properties to set
             */
            function PulsarConn(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PulsarConn dsn.
             * @member {string} dsn
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.dsn = "";

            /**
             * PulsarConn connectTimeoutSeconds.
             * @member {number} connectTimeoutSeconds
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.connectTimeoutSeconds = 0;

            /**
             * PulsarConn insecureTls.
             * @member {boolean} insecureTls
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.insecureTls = false;

            /**
             * PulsarConn tlsClientCert.
             * @member {Uint8Array} tlsClientCert
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.tlsClientCert = $util.newBuffer([]);

            /**
             * PulsarConn tlsClientKey.
             * @member {Uint8Array} tlsClientKey
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.tlsClientKey = $util.newBuffer([]);

            /**
             * Creates a new PulsarConn instance using the specified properties.
             * @function create
             * @memberof protos.args.PulsarConn
             * @static
             * @param {protos.args.IPulsarConn=} [properties] Properties to set
             * @returns {protos.args.PulsarConn} PulsarConn instance
             */
            PulsarConn.create = function create(properties) {
                return new PulsarConn(properties);
            };

            /**
             * Encodes the specified PulsarConn message. Does not implicitly {@link protos.args.PulsarConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.PulsarConn
             * @static
             * @param {protos.args.IPulsarConn} message PulsarConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                if (message.connectTimeoutSeconds != null && Object.hasOwnProperty.call(message, "connectTimeoutSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.connectTimeoutSeconds);
                if (message.insecureTls != null && Object.hasOwnProperty.call(message, "insecureTls"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.insecureTls);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.tlsClientCert);
                if (message.tlsClientKey != null && Object.hasOwnProperty.call(message, "tlsClientKey"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.tlsClientKey);
                return writer;
            };

            /**
             * Encodes the specified PulsarConn message, length delimited. Does not implicitly {@link protos.args.PulsarConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.PulsarConn
             * @static
             * @param {protos.args.IPulsarConn} message PulsarConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PulsarConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.PulsarConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.PulsarConn} PulsarConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.PulsarConn();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    case 2:
                        message.connectTimeoutSeconds = reader.uint32();
                        break;
                    case 3:
                        message.insecureTls = reader.bool();
                        break;
                    case 4:
                        message.tlsClientCert = reader.bytes();
                        break;
                    case 5:
                        message.tlsClientKey = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PulsarConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.PulsarConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.PulsarConn} PulsarConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PulsarConn message.
             * @function verify
             * @memberof protos.args.PulsarConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PulsarConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                if (message.connectTimeoutSeconds != null && message.hasOwnProperty("connectTimeoutSeconds"))
                    if (!$util.isInteger(message.connectTimeoutSeconds))
                        return "connectTimeoutSeconds: integer expected";
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    if (typeof message.insecureTls !== "boolean")
                        return "insecureTls: boolean expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!(message.tlsClientCert && typeof message.tlsClientCert.length === "number" || $util.isString(message.tlsClientCert)))
                        return "tlsClientCert: buffer expected";
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    if (!(message.tlsClientKey && typeof message.tlsClientKey.length === "number" || $util.isString(message.tlsClientKey)))
                        return "tlsClientKey: buffer expected";
                return null;
            };

            /**
             * Creates a PulsarConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.PulsarConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.PulsarConn} PulsarConn
             */
            PulsarConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.PulsarConn)
                    return object;
                let message = new $root.protos.args.PulsarConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                if (object.connectTimeoutSeconds != null)
                    message.connectTimeoutSeconds = object.connectTimeoutSeconds >>> 0;
                if (object.insecureTls != null)
                    message.insecureTls = Boolean(object.insecureTls);
                if (object.tlsClientCert != null)
                    if (typeof object.tlsClientCert === "string")
                        $util.base64.decode(object.tlsClientCert, message.tlsClientCert = $util.newBuffer($util.base64.length(object.tlsClientCert)), 0);
                    else if (object.tlsClientCert.length)
                        message.tlsClientCert = object.tlsClientCert;
                if (object.tlsClientKey != null)
                    if (typeof object.tlsClientKey === "string")
                        $util.base64.decode(object.tlsClientKey, message.tlsClientKey = $util.newBuffer($util.base64.length(object.tlsClientKey)), 0);
                    else if (object.tlsClientKey.length)
                        message.tlsClientKey = object.tlsClientKey;
                return message;
            };

            /**
             * Creates a plain object from a PulsarConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.PulsarConn
             * @static
             * @param {protos.args.PulsarConn} message PulsarConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PulsarConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.dsn = "";
                    object.connectTimeoutSeconds = 0;
                    object.insecureTls = false;
                    if (options.bytes === String)
                        object.tlsClientCert = "";
                    else {
                        object.tlsClientCert = [];
                        if (options.bytes !== Array)
                            object.tlsClientCert = $util.newBuffer(object.tlsClientCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientKey = "";
                    else {
                        object.tlsClientKey = [];
                        if (options.bytes !== Array)
                            object.tlsClientKey = $util.newBuffer(object.tlsClientKey);
                    }
                }
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                if (message.connectTimeoutSeconds != null && message.hasOwnProperty("connectTimeoutSeconds"))
                    object.connectTimeoutSeconds = message.connectTimeoutSeconds;
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    object.insecureTls = message.insecureTls;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = options.bytes === String ? $util.base64.encode(message.tlsClientCert, 0, message.tlsClientCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientCert) : message.tlsClientCert;
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    object.tlsClientKey = options.bytes === String ? $util.base64.encode(message.tlsClientKey, 0, message.tlsClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientKey) : message.tlsClientKey;
                return object;
            };

            /**
             * Converts this PulsarConn to JSON.
             * @function toJSON
             * @memberof protos.args.PulsarConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PulsarConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PulsarConn;
        })();

        args.PulsarReadArgs = (function() {

            /**
             * Properties of a PulsarReadArgs.
             * @memberof protos.args
             * @interface IPulsarReadArgs
             * @property {string|null} [topic] PulsarReadArgs topic
             * @property {string|null} [subscriptionName] PulsarReadArgs subscriptionName
             * @property {protos.args.SubscriptionType|null} [subscriptionType] PulsarReadArgs subscriptionType
             */

            /**
             * Constructs a new PulsarReadArgs.
             * @memberof protos.args
             * @classdesc Represents a PulsarReadArgs.
             * @implements IPulsarReadArgs
             * @constructor
             * @param {protos.args.IPulsarReadArgs=} [properties] Properties to set
             */
            function PulsarReadArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PulsarReadArgs topic.
             * @member {string} topic
             * @memberof protos.args.PulsarReadArgs
             * @instance
             */
            PulsarReadArgs.prototype.topic = "";

            /**
             * PulsarReadArgs subscriptionName.
             * @member {string} subscriptionName
             * @memberof protos.args.PulsarReadArgs
             * @instance
             */
            PulsarReadArgs.prototype.subscriptionName = "";

            /**
             * PulsarReadArgs subscriptionType.
             * @member {protos.args.SubscriptionType} subscriptionType
             * @memberof protos.args.PulsarReadArgs
             * @instance
             */
            PulsarReadArgs.prototype.subscriptionType = 0;

            /**
             * Creates a new PulsarReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {protos.args.IPulsarReadArgs=} [properties] Properties to set
             * @returns {protos.args.PulsarReadArgs} PulsarReadArgs instance
             */
            PulsarReadArgs.create = function create(properties) {
                return new PulsarReadArgs(properties);
            };

            /**
             * Encodes the specified PulsarReadArgs message. Does not implicitly {@link protos.args.PulsarReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {protos.args.IPulsarReadArgs} message PulsarReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.subscriptionName != null && Object.hasOwnProperty.call(message, "subscriptionName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.subscriptionName);
                if (message.subscriptionType != null && Object.hasOwnProperty.call(message, "subscriptionType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.subscriptionType);
                return writer;
            };

            /**
             * Encodes the specified PulsarReadArgs message, length delimited. Does not implicitly {@link protos.args.PulsarReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {protos.args.IPulsarReadArgs} message PulsarReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PulsarReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.PulsarReadArgs} PulsarReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.PulsarReadArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.subscriptionName = reader.string();
                        break;
                    case 3:
                        message.subscriptionType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PulsarReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.PulsarReadArgs} PulsarReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PulsarReadArgs message.
             * @function verify
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PulsarReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.subscriptionName != null && message.hasOwnProperty("subscriptionName"))
                    if (!$util.isString(message.subscriptionName))
                        return "subscriptionName: string expected";
                if (message.subscriptionType != null && message.hasOwnProperty("subscriptionType"))
                    switch (message.subscriptionType) {
                    default:
                        return "subscriptionType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            /**
             * Creates a PulsarReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.PulsarReadArgs} PulsarReadArgs
             */
            PulsarReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.PulsarReadArgs)
                    return object;
                let message = new $root.protos.args.PulsarReadArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.subscriptionName != null)
                    message.subscriptionName = String(object.subscriptionName);
                switch (object.subscriptionType) {
                case "SHARED":
                case 0:
                    message.subscriptionType = 0;
                    break;
                case "EXCLUSIVE":
                case 1:
                    message.subscriptionType = 1;
                    break;
                case "FAILOVER":
                case 2:
                    message.subscriptionType = 2;
                    break;
                case "KEYSHARED":
                case 3:
                    message.subscriptionType = 3;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a PulsarReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {protos.args.PulsarReadArgs} message PulsarReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PulsarReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.subscriptionName = "";
                    object.subscriptionType = options.enums === String ? "SHARED" : 0;
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.subscriptionName != null && message.hasOwnProperty("subscriptionName"))
                    object.subscriptionName = message.subscriptionName;
                if (message.subscriptionType != null && message.hasOwnProperty("subscriptionType"))
                    object.subscriptionType = options.enums === String ? $root.protos.args.SubscriptionType[message.subscriptionType] : message.subscriptionType;
                return object;
            };

            /**
             * Converts this PulsarReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.PulsarReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PulsarReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PulsarReadArgs;
        })();

        args.PulsarWriteArgs = (function() {

            /**
             * Properties of a PulsarWriteArgs.
             * @memberof protos.args
             * @interface IPulsarWriteArgs
             * @property {string|null} [topic] PulsarWriteArgs topic
             */

            /**
             * Constructs a new PulsarWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a PulsarWriteArgs.
             * @implements IPulsarWriteArgs
             * @constructor
             * @param {protos.args.IPulsarWriteArgs=} [properties] Properties to set
             */
            function PulsarWriteArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PulsarWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.PulsarWriteArgs
             * @instance
             */
            PulsarWriteArgs.prototype.topic = "";

            /**
             * Creates a new PulsarWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {protos.args.IPulsarWriteArgs=} [properties] Properties to set
             * @returns {protos.args.PulsarWriteArgs} PulsarWriteArgs instance
             */
            PulsarWriteArgs.create = function create(properties) {
                return new PulsarWriteArgs(properties);
            };

            /**
             * Encodes the specified PulsarWriteArgs message. Does not implicitly {@link protos.args.PulsarWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {protos.args.IPulsarWriteArgs} message PulsarWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                return writer;
            };

            /**
             * Encodes the specified PulsarWriteArgs message, length delimited. Does not implicitly {@link protos.args.PulsarWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {protos.args.IPulsarWriteArgs} message PulsarWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PulsarWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.PulsarWriteArgs} PulsarWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.PulsarWriteArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PulsarWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.PulsarWriteArgs} PulsarWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PulsarWriteArgs message.
             * @function verify
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PulsarWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                return null;
            };

            /**
             * Creates a PulsarWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.PulsarWriteArgs} PulsarWriteArgs
             */
            PulsarWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.PulsarWriteArgs)
                    return object;
                let message = new $root.protos.args.PulsarWriteArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                return message;
            };

            /**
             * Creates a plain object from a PulsarWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {protos.args.PulsarWriteArgs} message PulsarWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PulsarWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.topic = "";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                return object;
            };

            /**
             * Converts this PulsarWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.PulsarWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PulsarWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PulsarWriteArgs;
        })();

        args.RabbitConn = (function() {

            /**
             * Properties of a RabbitConn.
             * @memberof protos.args
             * @interface IRabbitConn
             * @property {string|null} [address] RabbitConn address
             * @property {boolean|null} [useTls] RabbitConn useTls
             * @property {boolean|null} [insecureTls] RabbitConn insecureTls
             */

            /**
             * Constructs a new RabbitConn.
             * @memberof protos.args
             * @classdesc Represents a RabbitConn.
             * @implements IRabbitConn
             * @constructor
             * @param {protos.args.IRabbitConn=} [properties] Properties to set
             */
            function RabbitConn(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitConn address.
             * @member {string} address
             * @memberof protos.args.RabbitConn
             * @instance
             */
            RabbitConn.prototype.address = "";

            /**
             * RabbitConn useTls.
             * @member {boolean} useTls
             * @memberof protos.args.RabbitConn
             * @instance
             */
            RabbitConn.prototype.useTls = false;

            /**
             * RabbitConn insecureTls.
             * @member {boolean} insecureTls
             * @memberof protos.args.RabbitConn
             * @instance
             */
            RabbitConn.prototype.insecureTls = false;

            /**
             * Creates a new RabbitConn instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitConn
             * @static
             * @param {protos.args.IRabbitConn=} [properties] Properties to set
             * @returns {protos.args.RabbitConn} RabbitConn instance
             */
            RabbitConn.create = function create(properties) {
                return new RabbitConn(properties);
            };

            /**
             * Encodes the specified RabbitConn message. Does not implicitly {@link protos.args.RabbitConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitConn
             * @static
             * @param {protos.args.IRabbitConn} message RabbitConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.useTls);
                if (message.insecureTls != null && Object.hasOwnProperty.call(message, "insecureTls"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.insecureTls);
                return writer;
            };

            /**
             * Encodes the specified RabbitConn message, length delimited. Does not implicitly {@link protos.args.RabbitConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitConn
             * @static
             * @param {protos.args.IRabbitConn} message RabbitConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitConn} RabbitConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitConn();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.useTls = reader.bool();
                        break;
                    case 3:
                        message.insecureTls = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitConn} RabbitConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitConn message.
             * @function verify
             * @memberof protos.args.RabbitConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    if (typeof message.insecureTls !== "boolean")
                        return "insecureTls: boolean expected";
                return null;
            };

            /**
             * Creates a RabbitConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitConn} RabbitConn
             */
            RabbitConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitConn)
                    return object;
                let message = new $root.protos.args.RabbitConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.insecureTls != null)
                    message.insecureTls = Boolean(object.insecureTls);
                return message;
            };

            /**
             * Creates a plain object from a RabbitConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitConn
             * @static
             * @param {protos.args.RabbitConn} message RabbitConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.address = "";
                    object.useTls = false;
                    object.insecureTls = false;
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    object.insecureTls = message.insecureTls;
                return object;
            };

            /**
             * Converts this RabbitConn to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitConn;
        })();

        args.RabbitReadArgs = (function() {

            /**
             * Properties of a RabbitReadArgs.
             * @memberof protos.args
             * @interface IRabbitReadArgs
             * @property {string|null} [exchangeName] RabbitReadArgs exchangeName
             * @property {string|null} [queueName] RabbitReadArgs queueName
             * @property {string|null} [bindingKey] RabbitReadArgs bindingKey
             * @property {boolean|null} [queueExclusive] RabbitReadArgs queueExclusive
             * @property {boolean|null} [queueDeclare] RabbitReadArgs queueDeclare
             * @property {boolean|null} [queueDurable] RabbitReadArgs queueDurable
             * @property {boolean|null} [autoAck] RabbitReadArgs autoAck
             * @property {string|null} [consumerTag] RabbitReadArgs consumerTag
             * @property {boolean|null} [queueDelete] RabbitReadArgs queueDelete
             */

            /**
             * Constructs a new RabbitReadArgs.
             * @memberof protos.args
             * @classdesc Represents a RabbitReadArgs.
             * @implements IRabbitReadArgs
             * @constructor
             * @param {protos.args.IRabbitReadArgs=} [properties] Properties to set
             */
            function RabbitReadArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitReadArgs exchangeName.
             * @member {string} exchangeName
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.exchangeName = "";

            /**
             * RabbitReadArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueName = "";

            /**
             * RabbitReadArgs bindingKey.
             * @member {string} bindingKey
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.bindingKey = "";

            /**
             * RabbitReadArgs queueExclusive.
             * @member {boolean} queueExclusive
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueExclusive = false;

            /**
             * RabbitReadArgs queueDeclare.
             * @member {boolean} queueDeclare
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueDeclare = false;

            /**
             * RabbitReadArgs queueDurable.
             * @member {boolean} queueDurable
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueDurable = false;

            /**
             * RabbitReadArgs autoAck.
             * @member {boolean} autoAck
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.autoAck = false;

            /**
             * RabbitReadArgs consumerTag.
             * @member {string} consumerTag
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.consumerTag = "";

            /**
             * RabbitReadArgs queueDelete.
             * @member {boolean} queueDelete
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueDelete = false;

            /**
             * Creates a new RabbitReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {protos.args.IRabbitReadArgs=} [properties] Properties to set
             * @returns {protos.args.RabbitReadArgs} RabbitReadArgs instance
             */
            RabbitReadArgs.create = function create(properties) {
                return new RabbitReadArgs(properties);
            };

            /**
             * Encodes the specified RabbitReadArgs message. Does not implicitly {@link protos.args.RabbitReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {protos.args.IRabbitReadArgs} message RabbitReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.exchangeName != null && Object.hasOwnProperty.call(message, "exchangeName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.exchangeName);
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.queueName);
                if (message.bindingKey != null && Object.hasOwnProperty.call(message, "bindingKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.bindingKey);
                if (message.queueExclusive != null && Object.hasOwnProperty.call(message, "queueExclusive"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.queueExclusive);
                if (message.queueDeclare != null && Object.hasOwnProperty.call(message, "queueDeclare"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.queueDeclare);
                if (message.queueDurable != null && Object.hasOwnProperty.call(message, "queueDurable"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.queueDurable);
                if (message.autoAck != null && Object.hasOwnProperty.call(message, "autoAck"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.autoAck);
                if (message.consumerTag != null && Object.hasOwnProperty.call(message, "consumerTag"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.consumerTag);
                if (message.queueDelete != null && Object.hasOwnProperty.call(message, "queueDelete"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.queueDelete);
                return writer;
            };

            /**
             * Encodes the specified RabbitReadArgs message, length delimited. Does not implicitly {@link protos.args.RabbitReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {protos.args.IRabbitReadArgs} message RabbitReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitReadArgs} RabbitReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitReadArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.exchangeName = reader.string();
                        break;
                    case 2:
                        message.queueName = reader.string();
                        break;
                    case 3:
                        message.bindingKey = reader.string();
                        break;
                    case 4:
                        message.queueExclusive = reader.bool();
                        break;
                    case 5:
                        message.queueDeclare = reader.bool();
                        break;
                    case 6:
                        message.queueDurable = reader.bool();
                        break;
                    case 7:
                        message.autoAck = reader.bool();
                        break;
                    case 8:
                        message.consumerTag = reader.string();
                        break;
                    case 9:
                        message.queueDelete = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitReadArgs} RabbitReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitReadArgs message.
             * @function verify
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.exchangeName != null && message.hasOwnProperty("exchangeName"))
                    if (!$util.isString(message.exchangeName))
                        return "exchangeName: string expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                if (message.bindingKey != null && message.hasOwnProperty("bindingKey"))
                    if (!$util.isString(message.bindingKey))
                        return "bindingKey: string expected";
                if (message.queueExclusive != null && message.hasOwnProperty("queueExclusive"))
                    if (typeof message.queueExclusive !== "boolean")
                        return "queueExclusive: boolean expected";
                if (message.queueDeclare != null && message.hasOwnProperty("queueDeclare"))
                    if (typeof message.queueDeclare !== "boolean")
                        return "queueDeclare: boolean expected";
                if (message.queueDurable != null && message.hasOwnProperty("queueDurable"))
                    if (typeof message.queueDurable !== "boolean")
                        return "queueDurable: boolean expected";
                if (message.autoAck != null && message.hasOwnProperty("autoAck"))
                    if (typeof message.autoAck !== "boolean")
                        return "autoAck: boolean expected";
                if (message.consumerTag != null && message.hasOwnProperty("consumerTag"))
                    if (!$util.isString(message.consumerTag))
                        return "consumerTag: string expected";
                if (message.queueDelete != null && message.hasOwnProperty("queueDelete"))
                    if (typeof message.queueDelete !== "boolean")
                        return "queueDelete: boolean expected";
                return null;
            };

            /**
             * Creates a RabbitReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitReadArgs} RabbitReadArgs
             */
            RabbitReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitReadArgs)
                    return object;
                let message = new $root.protos.args.RabbitReadArgs();
                if (object.exchangeName != null)
                    message.exchangeName = String(object.exchangeName);
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                if (object.bindingKey != null)
                    message.bindingKey = String(object.bindingKey);
                if (object.queueExclusive != null)
                    message.queueExclusive = Boolean(object.queueExclusive);
                if (object.queueDeclare != null)
                    message.queueDeclare = Boolean(object.queueDeclare);
                if (object.queueDurable != null)
                    message.queueDurable = Boolean(object.queueDurable);
                if (object.autoAck != null)
                    message.autoAck = Boolean(object.autoAck);
                if (object.consumerTag != null)
                    message.consumerTag = String(object.consumerTag);
                if (object.queueDelete != null)
                    message.queueDelete = Boolean(object.queueDelete);
                return message;
            };

            /**
             * Creates a plain object from a RabbitReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {protos.args.RabbitReadArgs} message RabbitReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.exchangeName = "";
                    object.queueName = "";
                    object.bindingKey = "";
                    object.queueExclusive = false;
                    object.queueDeclare = false;
                    object.queueDurable = false;
                    object.autoAck = false;
                    object.consumerTag = "";
                    object.queueDelete = false;
                }
                if (message.exchangeName != null && message.hasOwnProperty("exchangeName"))
                    object.exchangeName = message.exchangeName;
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                if (message.bindingKey != null && message.hasOwnProperty("bindingKey"))
                    object.bindingKey = message.bindingKey;
                if (message.queueExclusive != null && message.hasOwnProperty("queueExclusive"))
                    object.queueExclusive = message.queueExclusive;
                if (message.queueDeclare != null && message.hasOwnProperty("queueDeclare"))
                    object.queueDeclare = message.queueDeclare;
                if (message.queueDurable != null && message.hasOwnProperty("queueDurable"))
                    object.queueDurable = message.queueDurable;
                if (message.autoAck != null && message.hasOwnProperty("autoAck"))
                    object.autoAck = message.autoAck;
                if (message.consumerTag != null && message.hasOwnProperty("consumerTag"))
                    object.consumerTag = message.consumerTag;
                if (message.queueDelete != null && message.hasOwnProperty("queueDelete"))
                    object.queueDelete = message.queueDelete;
                return object;
            };

            /**
             * Converts this RabbitReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitReadArgs;
        })();

        args.RabbitWriteArgs = (function() {

            /**
             * Properties of a RabbitWriteArgs.
             * @memberof protos.args
             * @interface IRabbitWriteArgs
             * @property {string|null} [exchangeName] RabbitWriteArgs exchangeName
             * @property {string|null} [routingKey] RabbitWriteArgs routingKey
             * @property {string|null} [appId] RabbitWriteArgs appId
             * @property {string|null} [exchangeType] RabbitWriteArgs exchangeType
             * @property {boolean|null} [exchangeDeclare] RabbitWriteArgs exchangeDeclare
             * @property {boolean|null} [exchangeDurable] RabbitWriteArgs exchangeDurable
             * @property {boolean|null} [exchangeAutoDelete] RabbitWriteArgs exchangeAutoDelete
             */

            /**
             * Constructs a new RabbitWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a RabbitWriteArgs.
             * @implements IRabbitWriteArgs
             * @constructor
             * @param {protos.args.IRabbitWriteArgs=} [properties] Properties to set
             */
            function RabbitWriteArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitWriteArgs exchangeName.
             * @member {string} exchangeName
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.exchangeName = "";

            /**
             * RabbitWriteArgs routingKey.
             * @member {string} routingKey
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.routingKey = "";

            /**
             * RabbitWriteArgs appId.
             * @member {string} appId
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.appId = "";

            /**
             * RabbitWriteArgs exchangeType.
             * @member {string} exchangeType
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.exchangeType = "";

            /**
             * RabbitWriteArgs exchangeDeclare.
             * @member {boolean} exchangeDeclare
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.exchangeDeclare = false;

            /**
             * RabbitWriteArgs exchangeDurable.
             * @member {boolean} exchangeDurable
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.exchangeDurable = false;

            /**
             * RabbitWriteArgs exchangeAutoDelete.
             * @member {boolean} exchangeAutoDelete
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.exchangeAutoDelete = false;

            /**
             * Creates a new RabbitWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {protos.args.IRabbitWriteArgs=} [properties] Properties to set
             * @returns {protos.args.RabbitWriteArgs} RabbitWriteArgs instance
             */
            RabbitWriteArgs.create = function create(properties) {
                return new RabbitWriteArgs(properties);
            };

            /**
             * Encodes the specified RabbitWriteArgs message. Does not implicitly {@link protos.args.RabbitWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {protos.args.IRabbitWriteArgs} message RabbitWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.exchangeName != null && Object.hasOwnProperty.call(message, "exchangeName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.exchangeName);
                if (message.routingKey != null && Object.hasOwnProperty.call(message, "routingKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.routingKey);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.appId);
                if (message.exchangeType != null && Object.hasOwnProperty.call(message, "exchangeType"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.exchangeType);
                if (message.exchangeDeclare != null && Object.hasOwnProperty.call(message, "exchangeDeclare"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.exchangeDeclare);
                if (message.exchangeDurable != null && Object.hasOwnProperty.call(message, "exchangeDurable"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.exchangeDurable);
                if (message.exchangeAutoDelete != null && Object.hasOwnProperty.call(message, "exchangeAutoDelete"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.exchangeAutoDelete);
                return writer;
            };

            /**
             * Encodes the specified RabbitWriteArgs message, length delimited. Does not implicitly {@link protos.args.RabbitWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {protos.args.IRabbitWriteArgs} message RabbitWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitWriteArgs} RabbitWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitWriteArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.exchangeName = reader.string();
                        break;
                    case 2:
                        message.routingKey = reader.string();
                        break;
                    case 3:
                        message.appId = reader.string();
                        break;
                    case 4:
                        message.exchangeType = reader.string();
                        break;
                    case 5:
                        message.exchangeDeclare = reader.bool();
                        break;
                    case 6:
                        message.exchangeDurable = reader.bool();
                        break;
                    case 7:
                        message.exchangeAutoDelete = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitWriteArgs} RabbitWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitWriteArgs message.
             * @function verify
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.exchangeName != null && message.hasOwnProperty("exchangeName"))
                    if (!$util.isString(message.exchangeName))
                        return "exchangeName: string expected";
                if (message.routingKey != null && message.hasOwnProperty("routingKey"))
                    if (!$util.isString(message.routingKey))
                        return "routingKey: string expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!$util.isString(message.appId))
                        return "appId: string expected";
                if (message.exchangeType != null && message.hasOwnProperty("exchangeType"))
                    if (!$util.isString(message.exchangeType))
                        return "exchangeType: string expected";
                if (message.exchangeDeclare != null && message.hasOwnProperty("exchangeDeclare"))
                    if (typeof message.exchangeDeclare !== "boolean")
                        return "exchangeDeclare: boolean expected";
                if (message.exchangeDurable != null && message.hasOwnProperty("exchangeDurable"))
                    if (typeof message.exchangeDurable !== "boolean")
                        return "exchangeDurable: boolean expected";
                if (message.exchangeAutoDelete != null && message.hasOwnProperty("exchangeAutoDelete"))
                    if (typeof message.exchangeAutoDelete !== "boolean")
                        return "exchangeAutoDelete: boolean expected";
                return null;
            };

            /**
             * Creates a RabbitWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitWriteArgs} RabbitWriteArgs
             */
            RabbitWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitWriteArgs)
                    return object;
                let message = new $root.protos.args.RabbitWriteArgs();
                if (object.exchangeName != null)
                    message.exchangeName = String(object.exchangeName);
                if (object.routingKey != null)
                    message.routingKey = String(object.routingKey);
                if (object.appId != null)
                    message.appId = String(object.appId);
                if (object.exchangeType != null)
                    message.exchangeType = String(object.exchangeType);
                if (object.exchangeDeclare != null)
                    message.exchangeDeclare = Boolean(object.exchangeDeclare);
                if (object.exchangeDurable != null)
                    message.exchangeDurable = Boolean(object.exchangeDurable);
                if (object.exchangeAutoDelete != null)
                    message.exchangeAutoDelete = Boolean(object.exchangeAutoDelete);
                return message;
            };

            /**
             * Creates a plain object from a RabbitWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {protos.args.RabbitWriteArgs} message RabbitWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.exchangeName = "";
                    object.routingKey = "";
                    object.appId = "";
                    object.exchangeType = "";
                    object.exchangeDeclare = false;
                    object.exchangeDurable = false;
                    object.exchangeAutoDelete = false;
                }
                if (message.exchangeName != null && message.hasOwnProperty("exchangeName"))
                    object.exchangeName = message.exchangeName;
                if (message.routingKey != null && message.hasOwnProperty("routingKey"))
                    object.routingKey = message.routingKey;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = message.appId;
                if (message.exchangeType != null && message.hasOwnProperty("exchangeType"))
                    object.exchangeType = message.exchangeType;
                if (message.exchangeDeclare != null && message.hasOwnProperty("exchangeDeclare"))
                    object.exchangeDeclare = message.exchangeDeclare;
                if (message.exchangeDurable != null && message.hasOwnProperty("exchangeDurable"))
                    object.exchangeDurable = message.exchangeDurable;
                if (message.exchangeAutoDelete != null && message.hasOwnProperty("exchangeAutoDelete"))
                    object.exchangeAutoDelete = message.exchangeAutoDelete;
                return object;
            };

            /**
             * Converts this RabbitWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitWriteArgs;
        })();

        args.RabbitStreamsConn = (function() {

            /**
             * Properties of a RabbitStreamsConn.
             * @memberof protos.args
             * @interface IRabbitStreamsConn
             * @property {string|null} [dsn] RabbitStreamsConn dsn
             * @property {boolean|null} [useTls] RabbitStreamsConn useTls
             * @property {boolean|null} [insecureTls] RabbitStreamsConn insecureTls
             * @property {string|null} [username] RabbitStreamsConn username
             * @property {string|null} [password] RabbitStreamsConn password
             * @property {string|null} [clientName] RabbitStreamsConn clientName
             */

            /**
             * Constructs a new RabbitStreamsConn.
             * @memberof protos.args
             * @classdesc Represents a RabbitStreamsConn.
             * @implements IRabbitStreamsConn
             * @constructor
             * @param {protos.args.IRabbitStreamsConn=} [properties] Properties to set
             */
            function RabbitStreamsConn(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreamsConn dsn.
             * @member {string} dsn
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.dsn = "";

            /**
             * RabbitStreamsConn useTls.
             * @member {boolean} useTls
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.useTls = false;

            /**
             * RabbitStreamsConn insecureTls.
             * @member {boolean} insecureTls
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.insecureTls = false;

            /**
             * RabbitStreamsConn username.
             * @member {string} username
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.username = "";

            /**
             * RabbitStreamsConn password.
             * @member {string} password
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.password = "";

            /**
             * RabbitStreamsConn clientName.
             * @member {string} clientName
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.clientName = "";

            /**
             * Creates a new RabbitStreamsConn instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {protos.args.IRabbitStreamsConn=} [properties] Properties to set
             * @returns {protos.args.RabbitStreamsConn} RabbitStreamsConn instance
             */
            RabbitStreamsConn.create = function create(properties) {
                return new RabbitStreamsConn(properties);
            };

            /**
             * Encodes the specified RabbitStreamsConn message. Does not implicitly {@link protos.args.RabbitStreamsConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {protos.args.IRabbitStreamsConn} message RabbitStreamsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.useTls);
                if (message.insecureTls != null && Object.hasOwnProperty.call(message, "insecureTls"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.insecureTls);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.username);
                if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.password);
                if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.clientName);
                return writer;
            };

            /**
             * Encodes the specified RabbitStreamsConn message, length delimited. Does not implicitly {@link protos.args.RabbitStreamsConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {protos.args.IRabbitStreamsConn} message RabbitStreamsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreamsConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitStreamsConn} RabbitStreamsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitStreamsConn();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    case 2:
                        message.useTls = reader.bool();
                        break;
                    case 3:
                        message.insecureTls = reader.bool();
                        break;
                    case 4:
                        message.username = reader.string();
                        break;
                    case 5:
                        message.password = reader.string();
                        break;
                    case 6:
                        message.clientName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreamsConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitStreamsConn} RabbitStreamsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreamsConn message.
             * @function verify
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreamsConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    if (typeof message.insecureTls !== "boolean")
                        return "insecureTls: boolean expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!$util.isString(message.password))
                        return "password: string expected";
                if (message.clientName != null && message.hasOwnProperty("clientName"))
                    if (!$util.isString(message.clientName))
                        return "clientName: string expected";
                return null;
            };

            /**
             * Creates a RabbitStreamsConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitStreamsConn} RabbitStreamsConn
             */
            RabbitStreamsConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitStreamsConn)
                    return object;
                let message = new $root.protos.args.RabbitStreamsConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.insecureTls != null)
                    message.insecureTls = Boolean(object.insecureTls);
                if (object.username != null)
                    message.username = String(object.username);
                if (object.password != null)
                    message.password = String(object.password);
                if (object.clientName != null)
                    message.clientName = String(object.clientName);
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreamsConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {protos.args.RabbitStreamsConn} message RabbitStreamsConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreamsConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.dsn = "";
                    object.useTls = false;
                    object.insecureTls = false;
                    object.username = "";
                    object.password = "";
                    object.clientName = "";
                }
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                if (message.insecureTls != null && message.hasOwnProperty("insecureTls"))
                    object.insecureTls = message.insecureTls;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = message.password;
                if (message.clientName != null && message.hasOwnProperty("clientName"))
                    object.clientName = message.clientName;
                return object;
            };

            /**
             * Converts this RabbitStreamsConn to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreamsConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreamsConn;
        })();

        args.RabbitStreamsOffsetOptions = (function() {

            /**
             * Properties of a RabbitStreamsOffsetOptions.
             * @memberof protos.args
             * @interface IRabbitStreamsOffsetOptions
             * @property {number|Long|null} [specificOffset] RabbitStreamsOffsetOptions specificOffset
             * @property {number|Long|null} [lastOffset] RabbitStreamsOffsetOptions lastOffset
             * @property {boolean|null} [lastConsumed] RabbitStreamsOffsetOptions lastConsumed
             * @property {boolean|null} [firstOffset] RabbitStreamsOffsetOptions firstOffset
             * @property {boolean|null} [nextOffset] RabbitStreamsOffsetOptions nextOffset
             */

            /**
             * Constructs a new RabbitStreamsOffsetOptions.
             * @memberof protos.args
             * @classdesc Represents a RabbitStreamsOffsetOptions.
             * @implements IRabbitStreamsOffsetOptions
             * @constructor
             * @param {protos.args.IRabbitStreamsOffsetOptions=} [properties] Properties to set
             */
            function RabbitStreamsOffsetOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreamsOffsetOptions specificOffset.
             * @member {number|Long} specificOffset
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             */
            RabbitStreamsOffsetOptions.prototype.specificOffset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RabbitStreamsOffsetOptions lastOffset.
             * @member {number|Long} lastOffset
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             */
            RabbitStreamsOffsetOptions.prototype.lastOffset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RabbitStreamsOffsetOptions lastConsumed.
             * @member {boolean} lastConsumed
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             */
            RabbitStreamsOffsetOptions.prototype.lastConsumed = false;

            /**
             * RabbitStreamsOffsetOptions firstOffset.
             * @member {boolean} firstOffset
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             */
            RabbitStreamsOffsetOptions.prototype.firstOffset = false;

            /**
             * RabbitStreamsOffsetOptions nextOffset.
             * @member {boolean} nextOffset
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             */
            RabbitStreamsOffsetOptions.prototype.nextOffset = false;

            /**
             * Creates a new RabbitStreamsOffsetOptions instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {protos.args.IRabbitStreamsOffsetOptions=} [properties] Properties to set
             * @returns {protos.args.RabbitStreamsOffsetOptions} RabbitStreamsOffsetOptions instance
             */
            RabbitStreamsOffsetOptions.create = function create(properties) {
                return new RabbitStreamsOffsetOptions(properties);
            };

            /**
             * Encodes the specified RabbitStreamsOffsetOptions message. Does not implicitly {@link protos.args.RabbitStreamsOffsetOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {protos.args.IRabbitStreamsOffsetOptions} message RabbitStreamsOffsetOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsOffsetOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.specificOffset != null && Object.hasOwnProperty.call(message, "specificOffset"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.specificOffset);
                if (message.lastOffset != null && Object.hasOwnProperty.call(message, "lastOffset"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.lastOffset);
                if (message.lastConsumed != null && Object.hasOwnProperty.call(message, "lastConsumed"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.lastConsumed);
                if (message.firstOffset != null && Object.hasOwnProperty.call(message, "firstOffset"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.firstOffset);
                if (message.nextOffset != null && Object.hasOwnProperty.call(message, "nextOffset"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.nextOffset);
                return writer;
            };

            /**
             * Encodes the specified RabbitStreamsOffsetOptions message, length delimited. Does not implicitly {@link protos.args.RabbitStreamsOffsetOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {protos.args.IRabbitStreamsOffsetOptions} message RabbitStreamsOffsetOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsOffsetOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreamsOffsetOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitStreamsOffsetOptions} RabbitStreamsOffsetOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsOffsetOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitStreamsOffsetOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.specificOffset = reader.uint64();
                        break;
                    case 2:
                        message.lastOffset = reader.uint64();
                        break;
                    case 3:
                        message.lastConsumed = reader.bool();
                        break;
                    case 4:
                        message.firstOffset = reader.bool();
                        break;
                    case 5:
                        message.nextOffset = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreamsOffsetOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitStreamsOffsetOptions} RabbitStreamsOffsetOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsOffsetOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreamsOffsetOptions message.
             * @function verify
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreamsOffsetOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.specificOffset != null && message.hasOwnProperty("specificOffset"))
                    if (!$util.isInteger(message.specificOffset) && !(message.specificOffset && $util.isInteger(message.specificOffset.low) && $util.isInteger(message.specificOffset.high)))
                        return "specificOffset: integer|Long expected";
                if (message.lastOffset != null && message.hasOwnProperty("lastOffset"))
                    if (!$util.isInteger(message.lastOffset) && !(message.lastOffset && $util.isInteger(message.lastOffset.low) && $util.isInteger(message.lastOffset.high)))
                        return "lastOffset: integer|Long expected";
                if (message.lastConsumed != null && message.hasOwnProperty("lastConsumed"))
                    if (typeof message.lastConsumed !== "boolean")
                        return "lastConsumed: boolean expected";
                if (message.firstOffset != null && message.hasOwnProperty("firstOffset"))
                    if (typeof message.firstOffset !== "boolean")
                        return "firstOffset: boolean expected";
                if (message.nextOffset != null && message.hasOwnProperty("nextOffset"))
                    if (typeof message.nextOffset !== "boolean")
                        return "nextOffset: boolean expected";
                return null;
            };

            /**
             * Creates a RabbitStreamsOffsetOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitStreamsOffsetOptions} RabbitStreamsOffsetOptions
             */
            RabbitStreamsOffsetOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitStreamsOffsetOptions)
                    return object;
                let message = new $root.protos.args.RabbitStreamsOffsetOptions();
                if (object.specificOffset != null)
                    if ($util.Long)
                        (message.specificOffset = $util.Long.fromValue(object.specificOffset)).unsigned = true;
                    else if (typeof object.specificOffset === "string")
                        message.specificOffset = parseInt(object.specificOffset, 10);
                    else if (typeof object.specificOffset === "number")
                        message.specificOffset = object.specificOffset;
                    else if (typeof object.specificOffset === "object")
                        message.specificOffset = new $util.LongBits(object.specificOffset.low >>> 0, object.specificOffset.high >>> 0).toNumber(true);
                if (object.lastOffset != null)
                    if ($util.Long)
                        (message.lastOffset = $util.Long.fromValue(object.lastOffset)).unsigned = true;
                    else if (typeof object.lastOffset === "string")
                        message.lastOffset = parseInt(object.lastOffset, 10);
                    else if (typeof object.lastOffset === "number")
                        message.lastOffset = object.lastOffset;
                    else if (typeof object.lastOffset === "object")
                        message.lastOffset = new $util.LongBits(object.lastOffset.low >>> 0, object.lastOffset.high >>> 0).toNumber(true);
                if (object.lastConsumed != null)
                    message.lastConsumed = Boolean(object.lastConsumed);
                if (object.firstOffset != null)
                    message.firstOffset = Boolean(object.firstOffset);
                if (object.nextOffset != null)
                    message.nextOffset = Boolean(object.nextOffset);
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreamsOffsetOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {protos.args.RabbitStreamsOffsetOptions} message RabbitStreamsOffsetOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreamsOffsetOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.specificOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.specificOffset = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.lastOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lastOffset = options.longs === String ? "0" : 0;
                    object.lastConsumed = false;
                    object.firstOffset = false;
                    object.nextOffset = false;
                }
                if (message.specificOffset != null && message.hasOwnProperty("specificOffset"))
                    if (typeof message.specificOffset === "number")
                        object.specificOffset = options.longs === String ? String(message.specificOffset) : message.specificOffset;
                    else
                        object.specificOffset = options.longs === String ? $util.Long.prototype.toString.call(message.specificOffset) : options.longs === Number ? new $util.LongBits(message.specificOffset.low >>> 0, message.specificOffset.high >>> 0).toNumber(true) : message.specificOffset;
                if (message.lastOffset != null && message.hasOwnProperty("lastOffset"))
                    if (typeof message.lastOffset === "number")
                        object.lastOffset = options.longs === String ? String(message.lastOffset) : message.lastOffset;
                    else
                        object.lastOffset = options.longs === String ? $util.Long.prototype.toString.call(message.lastOffset) : options.longs === Number ? new $util.LongBits(message.lastOffset.low >>> 0, message.lastOffset.high >>> 0).toNumber(true) : message.lastOffset;
                if (message.lastConsumed != null && message.hasOwnProperty("lastConsumed"))
                    object.lastConsumed = message.lastConsumed;
                if (message.firstOffset != null && message.hasOwnProperty("firstOffset"))
                    object.firstOffset = message.firstOffset;
                if (message.nextOffset != null && message.hasOwnProperty("nextOffset"))
                    object.nextOffset = message.nextOffset;
                return object;
            };

            /**
             * Converts this RabbitStreamsOffsetOptions to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreamsOffsetOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreamsOffsetOptions;
        })();

        args.RabbitStreamsReadArgs = (function() {

            /**
             * Properties of a RabbitStreamsReadArgs.
             * @memberof protos.args
             * @interface IRabbitStreamsReadArgs
             * @property {string|null} [stream] RabbitStreamsReadArgs stream
             * @property {boolean|null} [declareStream] RabbitStreamsReadArgs declareStream
             * @property {string|null} [declareStreamSize] RabbitStreamsReadArgs declareStreamSize
             * @property {protos.args.IRabbitStreamsOffsetOptions|null} [offsetOptions] RabbitStreamsReadArgs offsetOptions
             */

            /**
             * Constructs a new RabbitStreamsReadArgs.
             * @memberof protos.args
             * @classdesc Represents a RabbitStreamsReadArgs.
             * @implements IRabbitStreamsReadArgs
             * @constructor
             * @param {protos.args.IRabbitStreamsReadArgs=} [properties] Properties to set
             */
            function RabbitStreamsReadArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreamsReadArgs stream.
             * @member {string} stream
             * @memberof protos.args.RabbitStreamsReadArgs
             * @instance
             */
            RabbitStreamsReadArgs.prototype.stream = "";

            /**
             * RabbitStreamsReadArgs declareStream.
             * @member {boolean} declareStream
             * @memberof protos.args.RabbitStreamsReadArgs
             * @instance
             */
            RabbitStreamsReadArgs.prototype.declareStream = false;

            /**
             * RabbitStreamsReadArgs declareStreamSize.
             * @member {string} declareStreamSize
             * @memberof protos.args.RabbitStreamsReadArgs
             * @instance
             */
            RabbitStreamsReadArgs.prototype.declareStreamSize = "";

            /**
             * RabbitStreamsReadArgs offsetOptions.
             * @member {protos.args.IRabbitStreamsOffsetOptions|null|undefined} offsetOptions
             * @memberof protos.args.RabbitStreamsReadArgs
             * @instance
             */
            RabbitStreamsReadArgs.prototype.offsetOptions = null;

            /**
             * Creates a new RabbitStreamsReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {protos.args.IRabbitStreamsReadArgs=} [properties] Properties to set
             * @returns {protos.args.RabbitStreamsReadArgs} RabbitStreamsReadArgs instance
             */
            RabbitStreamsReadArgs.create = function create(properties) {
                return new RabbitStreamsReadArgs(properties);
            };

            /**
             * Encodes the specified RabbitStreamsReadArgs message. Does not implicitly {@link protos.args.RabbitStreamsReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {protos.args.IRabbitStreamsReadArgs} message RabbitStreamsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stream);
                if (message.declareStream != null && Object.hasOwnProperty.call(message, "declareStream"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.declareStream);
                if (message.declareStreamSize != null && Object.hasOwnProperty.call(message, "declareStreamSize"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.declareStreamSize);
                if (message.offsetOptions != null && Object.hasOwnProperty.call(message, "offsetOptions"))
                    $root.protos.args.RabbitStreamsOffsetOptions.encode(message.offsetOptions, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RabbitStreamsReadArgs message, length delimited. Does not implicitly {@link protos.args.RabbitStreamsReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {protos.args.IRabbitStreamsReadArgs} message RabbitStreamsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreamsReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitStreamsReadArgs} RabbitStreamsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitStreamsReadArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stream = reader.string();
                        break;
                    case 2:
                        message.declareStream = reader.bool();
                        break;
                    case 3:
                        message.declareStreamSize = reader.string();
                        break;
                    case 4:
                        message.offsetOptions = $root.protos.args.RabbitStreamsOffsetOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreamsReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitStreamsReadArgs} RabbitStreamsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreamsReadArgs message.
             * @function verify
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreamsReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isString(message.stream))
                        return "stream: string expected";
                if (message.declareStream != null && message.hasOwnProperty("declareStream"))
                    if (typeof message.declareStream !== "boolean")
                        return "declareStream: boolean expected";
                if (message.declareStreamSize != null && message.hasOwnProperty("declareStreamSize"))
                    if (!$util.isString(message.declareStreamSize))
                        return "declareStreamSize: string expected";
                if (message.offsetOptions != null && message.hasOwnProperty("offsetOptions")) {
                    let error = $root.protos.args.RabbitStreamsOffsetOptions.verify(message.offsetOptions);
                    if (error)
                        return "offsetOptions." + error;
                }
                return null;
            };

            /**
             * Creates a RabbitStreamsReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitStreamsReadArgs} RabbitStreamsReadArgs
             */
            RabbitStreamsReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitStreamsReadArgs)
                    return object;
                let message = new $root.protos.args.RabbitStreamsReadArgs();
                if (object.stream != null)
                    message.stream = String(object.stream);
                if (object.declareStream != null)
                    message.declareStream = Boolean(object.declareStream);
                if (object.declareStreamSize != null)
                    message.declareStreamSize = String(object.declareStreamSize);
                if (object.offsetOptions != null) {
                    if (typeof object.offsetOptions !== "object")
                        throw TypeError(".protos.args.RabbitStreamsReadArgs.offsetOptions: object expected");
                    message.offsetOptions = $root.protos.args.RabbitStreamsOffsetOptions.fromObject(object.offsetOptions);
                }
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreamsReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {protos.args.RabbitStreamsReadArgs} message RabbitStreamsReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreamsReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.stream = "";
                    object.declareStream = false;
                    object.declareStreamSize = "";
                    object.offsetOptions = null;
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                if (message.declareStream != null && message.hasOwnProperty("declareStream"))
                    object.declareStream = message.declareStream;
                if (message.declareStreamSize != null && message.hasOwnProperty("declareStreamSize"))
                    object.declareStreamSize = message.declareStreamSize;
                if (message.offsetOptions != null && message.hasOwnProperty("offsetOptions"))
                    object.offsetOptions = $root.protos.args.RabbitStreamsOffsetOptions.toObject(message.offsetOptions, options);
                return object;
            };

            /**
             * Converts this RabbitStreamsReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitStreamsReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreamsReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreamsReadArgs;
        })();

        args.RabbitStreamsWriteArgs = (function() {

            /**
             * Properties of a RabbitStreamsWriteArgs.
             * @memberof protos.args
             * @interface IRabbitStreamsWriteArgs
             * @property {string|null} [stream] RabbitStreamsWriteArgs stream
             * @property {boolean|null} [declareStream] RabbitStreamsWriteArgs declareStream
             * @property {string|null} [declareStreamSize] RabbitStreamsWriteArgs declareStreamSize
             */

            /**
             * Constructs a new RabbitStreamsWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a RabbitStreamsWriteArgs.
             * @implements IRabbitStreamsWriteArgs
             * @constructor
             * @param {protos.args.IRabbitStreamsWriteArgs=} [properties] Properties to set
             */
            function RabbitStreamsWriteArgs(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreamsWriteArgs stream.
             * @member {string} stream
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @instance
             */
            RabbitStreamsWriteArgs.prototype.stream = "";

            /**
             * RabbitStreamsWriteArgs declareStream.
             * @member {boolean} declareStream
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @instance
             */
            RabbitStreamsWriteArgs.prototype.declareStream = false;

            /**
             * RabbitStreamsWriteArgs declareStreamSize.
             * @member {string} declareStreamSize
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @instance
             */
            RabbitStreamsWriteArgs.prototype.declareStreamSize = "";

            /**
             * Creates a new RabbitStreamsWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {protos.args.IRabbitStreamsWriteArgs=} [properties] Properties to set
             * @returns {protos.args.RabbitStreamsWriteArgs} RabbitStreamsWriteArgs instance
             */
            RabbitStreamsWriteArgs.create = function create(properties) {
                return new RabbitStreamsWriteArgs(properties);
            };

            /**
             * Encodes the specified RabbitStreamsWriteArgs message. Does not implicitly {@link protos.args.RabbitStreamsWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {protos.args.IRabbitStreamsWriteArgs} message RabbitStreamsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stream);
                if (message.declareStream != null && Object.hasOwnProperty.call(message, "declareStream"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.declareStream);
                if (message.declareStreamSize != null && Object.hasOwnProperty.call(message, "declareStreamSize"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.declareStreamSize);
                return writer;
            };

            /**
             * Encodes the specified RabbitStreamsWriteArgs message, length delimited. Does not implicitly {@link protos.args.RabbitStreamsWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {protos.args.IRabbitStreamsWriteArgs} message RabbitStreamsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreamsWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitStreamsWriteArgs} RabbitStreamsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitStreamsWriteArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stream = reader.string();
                        break;
                    case 2:
                        message.declareStream = reader.bool();
                        break;
                    case 3:
                        message.declareStreamSize = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreamsWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitStreamsWriteArgs} RabbitStreamsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreamsWriteArgs message.
             * @function verify
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreamsWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isString(message.stream))
                        return "stream: string expected";
                if (message.declareStream != null && message.hasOwnProperty("declareStream"))
                    if (typeof message.declareStream !== "boolean")
                        return "declareStream: boolean expected";
                if (message.declareStreamSize != null && message.hasOwnProperty("declareStreamSize"))
                    if (!$util.isString(message.declareStreamSize))
                        return "declareStreamSize: string expected";
                return null;
            };

            /**
             * Creates a RabbitStreamsWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitStreamsWriteArgs} RabbitStreamsWriteArgs
             */
            RabbitStreamsWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitStreamsWriteArgs)
                    return object;
                let message = new $root.protos.args.RabbitStreamsWriteArgs();
                if (object.stream != null)
                    message.stream = String(object.stream);
                if (object.declareStream != null)
                    message.declareStream = Boolean(object.declareStream);
                if (object.declareStreamSize != null)
                    message.declareStreamSize = String(object.declareStreamSize);
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreamsWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {protos.args.RabbitStreamsWriteArgs} message RabbitStreamsWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreamsWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.stream = "";
                    object.declareStream = false;
                    object.declareStreamSize = "";
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                if (message.declareStream != null && message.hasOwnProperty("declareStream"))
                    object.declareStream = message.declareStream;
                if (message.declareStreamSize != null && message.hasOwnProperty("declareStreamSize"))
                    object.declareStreamSize = message.declareStreamSize;
                return object;
            };

            /**
             * Converts this RabbitStreamsWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreamsWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreamsWriteArgs;
        })();

        args.RedisPubSubConn = (function() {

            /**
             * Properties of a RedisPubSubConn.
             * @memberof protos.args
             * @interface IRedisPubSubConn
             * @property {string|null} [address] RedisPubSubConn address
             * @property {string|null} [username] RedisPubSubConn username
             * @property {string|null} [password] RedisPubSubConn password
             */

            /**
             * Constructs a new RedisPubSubConn.
             * @memberof protos.args
             * @classdesc Represents a RedisPubSubConn.
             * @implements IRedisPubSubConn
             * @constructor
             * @param {protos.args.IRedisPubSubConn=} [properties] Properties to set
             */
            function RedisPubSubConn(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisPubSubConn address.
             * @member {string} address
             * @memberof protos.args.RedisPubSubConn
             * @instance
             */
            RedisPubSubConn.prototype.address = "";

            /**
             * RedisPubSubConn username.
             * @member {string} username
             * @memberof protos.args.RedisPubSubConn
             * @instance
             */
            RedisPubSubConn.prototype.username = "";

            /**
             * RedisPubSubConn password.
             * @member {string} password
             * @memberof protos.args.RedisPubSubConn
             * @instance
             */
            RedisPubSubConn.prototype.password = "";

            /**
             * Creates a new RedisPubSubConn instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {protos.args.IRedisPubSubConn=} [properties] Properties to set
             * @returns {protos.args.RedisPubSubConn} RedisPubSubConn instance
             */
            RedisPubSubConn.create = function create(properties) {
                return new RedisPubSubConn(properties);
            };

            /**
             * Encodes the specified RedisPubSubConn message. Does not implicitly {@link protos.args.RedisPubSubConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {protos.args.IRedisPubSubConn} message RedisPubSubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
                if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.password);
                return writer;
            };

            /**
             * Encodes the specified RedisPubSubConn message, length delimited. Does not implicitly {@link protos.args.RedisPubSubConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {protos.args.IRedisPubSubConn} message RedisPubSubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisPubSubConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisPubSubConn} RedisPubSubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisPubSubConn();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.username = reader.string();
                        break;
                    case 3:
                        message.password = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisPubSubConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisPubSubConn} RedisPubSubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisPubSubConn message.
             * @function verify
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisPubSubConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!$util.isString(message.password))
                        return "password: string expected";
                return null;
            };

            /**
             * Creates a RedisPubSubConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisPubSubConn} RedisPubSubConn
             */
            RedisPubSubConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisPubSubConn)
                    return object;
                let message = new $root.protos.args.RedisPubSubConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.username != null)
                    message.username = String(object.username);
                if (object.password != null)
                    message.password = String(object.password);
                return message;
            };

            /**
             * Creates a plain object from a RedisPubSubConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {protos.args.RedisPubSubConn} message RedisPubSubConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisPubSubConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.address = "";
                    object.username = "";
                    object.password = "";
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = message.password;
                return object;
            };

            /**
             * Converts this RedisPubSubConn to JSON.
             * @function toJSON
             * @memberof protos.args.RedisPubSubConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisPubSubConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisPubSubConn;
        })();

        args.RedisPubSubReadArgs = (function() {

            /**
             * Properties of a RedisPubSubReadArgs.
             * @memberof protos.args
             * @interface IRedisPubSubReadArgs
             * @property {number|null} [database] RedisPubSubReadArgs database
             * @property {Array.<string>|null} [channel] RedisPubSubReadArgs channel
             */

            /**
             * Constructs a new RedisPubSubReadArgs.
             * @memberof protos.args
             * @classdesc Represents a RedisPubSubReadArgs.
             * @implements IRedisPubSubReadArgs
             * @constructor
             * @param {protos.args.IRedisPubSubReadArgs=} [properties] Properties to set
             */
            function RedisPubSubReadArgs(properties) {
                this.channel = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisPubSubReadArgs database.
             * @member {number} database
             * @memberof protos.args.RedisPubSubReadArgs
             * @instance
             */
            RedisPubSubReadArgs.prototype.database = 0;

            /**
             * RedisPubSubReadArgs channel.
             * @member {Array.<string>} channel
             * @memberof protos.args.RedisPubSubReadArgs
             * @instance
             */
            RedisPubSubReadArgs.prototype.channel = $util.emptyArray;

            /**
             * Creates a new RedisPubSubReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {protos.args.IRedisPubSubReadArgs=} [properties] Properties to set
             * @returns {protos.args.RedisPubSubReadArgs} RedisPubSubReadArgs instance
             */
            RedisPubSubReadArgs.create = function create(properties) {
                return new RedisPubSubReadArgs(properties);
            };

            /**
             * Encodes the specified RedisPubSubReadArgs message. Does not implicitly {@link protos.args.RedisPubSubReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {protos.args.IRedisPubSubReadArgs} message RedisPubSubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.database);
                if (message.channel != null && message.channel.length)
                    for (let i = 0; i < message.channel.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.channel[i]);
                return writer;
            };

            /**
             * Encodes the specified RedisPubSubReadArgs message, length delimited. Does not implicitly {@link protos.args.RedisPubSubReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {protos.args.IRedisPubSubReadArgs} message RedisPubSubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisPubSubReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisPubSubReadArgs} RedisPubSubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisPubSubReadArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.database = reader.uint32();
                        break;
                    case 2:
                        if (!(message.channel && message.channel.length))
                            message.channel = [];
                        message.channel.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisPubSubReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisPubSubReadArgs} RedisPubSubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisPubSubReadArgs message.
             * @function verify
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisPubSubReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isInteger(message.database))
                        return "database: integer expected";
                if (message.channel != null && message.hasOwnProperty("channel")) {
                    if (!Array.isArray(message.channel))
                        return "channel: array expected";
                    for (let i = 0; i < message.channel.length; ++i)
                        if (!$util.isString(message.channel[i]))
                            return "channel: string[] expected";
                }
                return null;
            };

            /**
             * Creates a RedisPubSubReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisPubSubReadArgs} RedisPubSubReadArgs
             */
            RedisPubSubReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisPubSubReadArgs)
                    return object;
                let message = new $root.protos.args.RedisPubSubReadArgs();
                if (object.database != null)
                    message.database = object.database >>> 0;
                if (object.channel) {
                    if (!Array.isArray(object.channel))
                        throw TypeError(".protos.args.RedisPubSubReadArgs.channel: array expected");
                    message.channel = [];
                    for (let i = 0; i < object.channel.length; ++i)
                        message.channel[i] = String(object.channel[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a RedisPubSubReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {protos.args.RedisPubSubReadArgs} message RedisPubSubReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisPubSubReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.channel = [];
                if (options.defaults)
                    object.database = 0;
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                if (message.channel && message.channel.length) {
                    object.channel = [];
                    for (let j = 0; j < message.channel.length; ++j)
                        object.channel[j] = message.channel[j];
                }
                return object;
            };

            /**
             * Converts this RedisPubSubReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RedisPubSubReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisPubSubReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisPubSubReadArgs;
        })();

        args.RedisPubSubWriteArgs = (function() {

            /**
             * Properties of a RedisPubSubWriteArgs.
             * @memberof protos.args
             * @interface IRedisPubSubWriteArgs
             * @property {number|null} [database] RedisPubSubWriteArgs database
             * @property {Array.<string>|null} [channel] RedisPubSubWriteArgs channel
             */

            /**
             * Constructs a new RedisPubSubWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a RedisPubSubWriteArgs.
             * @implements IRedisPubSubWriteArgs
             * @constructor
             * @param {protos.args.IRedisPubSubWriteArgs=} [properties] Properties to set
             */
            function RedisPubSubWriteArgs(properties) {
                this.channel = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisPubSubWriteArgs database.
             * @member {number} database
             * @memberof protos.args.RedisPubSubWriteArgs
             * @instance
             */
            RedisPubSubWriteArgs.prototype.database = 0;

            /**
             * RedisPubSubWriteArgs channel.
             * @member {Array.<string>} channel
             * @memberof protos.args.RedisPubSubWriteArgs
             * @instance
             */
            RedisPubSubWriteArgs.prototype.channel = $util.emptyArray;

            /**
             * Creates a new RedisPubSubWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {protos.args.IRedisPubSubWriteArgs=} [properties] Properties to set
             * @returns {protos.args.RedisPubSubWriteArgs} RedisPubSubWriteArgs instance
             */
            RedisPubSubWriteArgs.create = function create(properties) {
                return new RedisPubSubWriteArgs(properties);
            };

            /**
             * Encodes the specified RedisPubSubWriteArgs message. Does not implicitly {@link protos.args.RedisPubSubWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {protos.args.IRedisPubSubWriteArgs} message RedisPubSubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.database);
                if (message.channel != null && message.channel.length)
                    for (let i = 0; i < message.channel.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.channel[i]);
                return writer;
            };

            /**
             * Encodes the specified RedisPubSubWriteArgs message, length delimited. Does not implicitly {@link protos.args.RedisPubSubWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {protos.args.IRedisPubSubWriteArgs} message RedisPubSubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisPubSubWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisPubSubWriteArgs} RedisPubSubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisPubSubWriteArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.database = reader.uint32();
                        break;
                    case 2:
                        if (!(message.channel && message.channel.length))
                            message.channel = [];
                        message.channel.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisPubSubWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisPubSubWriteArgs} RedisPubSubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisPubSubWriteArgs message.
             * @function verify
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisPubSubWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isInteger(message.database))
                        return "database: integer expected";
                if (message.channel != null && message.hasOwnProperty("channel")) {
                    if (!Array.isArray(message.channel))
                        return "channel: array expected";
                    for (let i = 0; i < message.channel.length; ++i)
                        if (!$util.isString(message.channel[i]))
                            return "channel: string[] expected";
                }
                return null;
            };

            /**
             * Creates a RedisPubSubWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisPubSubWriteArgs} RedisPubSubWriteArgs
             */
            RedisPubSubWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisPubSubWriteArgs)
                    return object;
                let message = new $root.protos.args.RedisPubSubWriteArgs();
                if (object.database != null)
                    message.database = object.database >>> 0;
                if (object.channel) {
                    if (!Array.isArray(object.channel))
                        throw TypeError(".protos.args.RedisPubSubWriteArgs.channel: array expected");
                    message.channel = [];
                    for (let i = 0; i < object.channel.length; ++i)
                        message.channel[i] = String(object.channel[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a RedisPubSubWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {protos.args.RedisPubSubWriteArgs} message RedisPubSubWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisPubSubWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.channel = [];
                if (options.defaults)
                    object.database = 0;
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                if (message.channel && message.channel.length) {
                    object.channel = [];
                    for (let j = 0; j < message.channel.length; ++j)
                        object.channel[j] = message.channel[j];
                }
                return object;
            };

            /**
             * Converts this RedisPubSubWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RedisPubSubWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisPubSubWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisPubSubWriteArgs;
        })();

        /**
         * OffsetStart enum.
         * @name protos.args.OffsetStart
         * @enum {number}
         * @property {number} Latest=0 Latest value
         * @property {number} Oldest=1 Oldest value
         */
        args.OffsetStart = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Latest"] = 0;
            values[valuesById[1] = "Oldest"] = 1;
            return values;
        })();

        args.RedisStreamsConn = (function() {

            /**
             * Properties of a RedisStreamsConn.
             * @memberof protos.args
             * @interface IRedisStreamsConn
             * @property {string|null} [address] RedisStreamsConn address
             * @property {string|null} [username] RedisStreamsConn username
             * @property {string|null} [password] RedisStreamsConn password
             */

            /**
             * Constructs a new RedisStreamsConn.
             * @memberof protos.args
             * @classdesc Represents a RedisStreamsConn.
             * @implements IRedisStreamsConn
             * @constructor
             * @param {protos.args.IRedisStreamsConn=} [properties] Properties to set
             */
            function RedisStreamsConn(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisStreamsConn address.
             * @member {string} address
             * @memberof protos.args.RedisStreamsConn
             * @instance
             */
            RedisStreamsConn.prototype.address = "";

            /**
             * RedisStreamsConn username.
             * @member {string} username
             * @memberof protos.args.RedisStreamsConn
             * @instance
             */
            RedisStreamsConn.prototype.username = "";

            /**
             * RedisStreamsConn password.
             * @member {string} password
             * @memberof protos.args.RedisStreamsConn
             * @instance
             */
            RedisStreamsConn.prototype.password = "";

            /**
             * Creates a new RedisStreamsConn instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {protos.args.IRedisStreamsConn=} [properties] Properties to set
             * @returns {protos.args.RedisStreamsConn} RedisStreamsConn instance
             */
            RedisStreamsConn.create = function create(properties) {
                return new RedisStreamsConn(properties);
            };

            /**
             * Encodes the specified RedisStreamsConn message. Does not implicitly {@link protos.args.RedisStreamsConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {protos.args.IRedisStreamsConn} message RedisStreamsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
                if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.password);
                return writer;
            };

            /**
             * Encodes the specified RedisStreamsConn message, length delimited. Does not implicitly {@link protos.args.RedisStreamsConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {protos.args.IRedisStreamsConn} message RedisStreamsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisStreamsConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisStreamsConn} RedisStreamsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisStreamsConn();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.username = reader.string();
                        break;
                    case 3:
                        message.password = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisStreamsConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisStreamsConn} RedisStreamsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisStreamsConn message.
             * @function verify
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisStreamsConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!$util.isString(message.password))
                        return "password: string expected";
                return null;
            };

            /**
             * Creates a RedisStreamsConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisStreamsConn} RedisStreamsConn
             */
            RedisStreamsConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisStreamsConn)
                    return object;
                let message = new $root.protos.args.RedisStreamsConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.username != null)
                    message.username = String(object.username);
                if (object.password != null)
                    message.password = String(object.password);
                return message;
            };

            /**
             * Creates a plain object from a RedisStreamsConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {protos.args.RedisStreamsConn} message RedisStreamsConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisStreamsConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.address = "";
                    object.username = "";
                    object.password = "";
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = message.password;
                return object;
            };

            /**
             * Converts this RedisStreamsConn to JSON.
             * @function toJSON
             * @memberof protos.args.RedisStreamsConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisStreamsConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisStreamsConn;
        })();

        args.CreateConsumerConfig = (function() {

            /**
             * Properties of a CreateConsumerConfig.
             * @memberof protos.args
             * @interface ICreateConsumerConfig
             * @property {boolean|null} [createStreams] CreateConsumerConfig createStreams
             * @property {boolean|null} [recreateConsumerGroup] CreateConsumerConfig recreateConsumerGroup
             * @property {protos.args.OffsetStart|null} [offsetStart] CreateConsumerConfig offsetStart
             */

            /**
             * Constructs a new CreateConsumerConfig.
             * @memberof protos.args
             * @classdesc Represents a CreateConsumerConfig.
             * @implements ICreateConsumerConfig
             * @constructor
             * @param {protos.args.ICreateConsumerConfig=} [properties] Properties to set
             */
            function CreateConsumerConfig(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateConsumerConfig createStreams.
             * @member {boolean} createStreams
             * @memberof protos.args.CreateConsumerConfig
             * @instance
             */
            CreateConsumerConfig.prototype.createStreams = false;

            /**
             * CreateConsumerConfig recreateConsumerGroup.
             * @member {boolean} recreateConsumerGroup
             * @memberof protos.args.CreateConsumerConfig
             * @instance
             */
            CreateConsumerConfig.prototype.recreateConsumerGroup = false;

            /**
             * CreateConsumerConfig offsetStart.
             * @member {protos.args.OffsetStart} offsetStart
             * @memberof protos.args.CreateConsumerConfig
             * @instance
             */
            CreateConsumerConfig.prototype.offsetStart = 0;

            /**
             * Creates a new CreateConsumerConfig instance using the specified properties.
             * @function create
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {protos.args.ICreateConsumerConfig=} [properties] Properties to set
             * @returns {protos.args.CreateConsumerConfig} CreateConsumerConfig instance
             */
            CreateConsumerConfig.create = function create(properties) {
                return new CreateConsumerConfig(properties);
            };

            /**
             * Encodes the specified CreateConsumerConfig message. Does not implicitly {@link protos.args.CreateConsumerConfig.verify|verify} messages.
             * @function encode
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {protos.args.ICreateConsumerConfig} message CreateConsumerConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateConsumerConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.createStreams != null && Object.hasOwnProperty.call(message, "createStreams"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.createStreams);
                if (message.recreateConsumerGroup != null && Object.hasOwnProperty.call(message, "recreateConsumerGroup"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.recreateConsumerGroup);
                if (message.offsetStart != null && Object.hasOwnProperty.call(message, "offsetStart"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.offsetStart);
                return writer;
            };

            /**
             * Encodes the specified CreateConsumerConfig message, length delimited. Does not implicitly {@link protos.args.CreateConsumerConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {protos.args.ICreateConsumerConfig} message CreateConsumerConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateConsumerConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateConsumerConfig message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.CreateConsumerConfig} CreateConsumerConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateConsumerConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.CreateConsumerConfig();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.createStreams = reader.bool();
                        break;
                    case 2:
                        message.recreateConsumerGroup = reader.bool();
                        break;
                    case 3:
                        message.offsetStart = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateConsumerConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.CreateConsumerConfig} CreateConsumerConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateConsumerConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateConsumerConfig message.
             * @function verify
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateConsumerConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.createStreams != null && message.hasOwnProperty("createStreams"))
                    if (typeof message.createStreams !== "boolean")
                        return "createStreams: boolean expected";
                if (message.recreateConsumerGroup != null && message.hasOwnProperty("recreateConsumerGroup"))
                    if (typeof message.recreateConsumerGroup !== "boolean")
                        return "recreateConsumerGroup: boolean expected";
                if (message.offsetStart != null && message.hasOwnProperty("offsetStart"))
                    switch (message.offsetStart) {
                    default:
                        return "offsetStart: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a CreateConsumerConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.CreateConsumerConfig} CreateConsumerConfig
             */
            CreateConsumerConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.CreateConsumerConfig)
                    return object;
                let message = new $root.protos.args.CreateConsumerConfig();
                if (object.createStreams != null)
                    message.createStreams = Boolean(object.createStreams);
                if (object.recreateConsumerGroup != null)
                    message.recreateConsumerGroup = Boolean(object.recreateConsumerGroup);
                switch (object.offsetStart) {
                case "Latest":
                case 0:
                    message.offsetStart = 0;
                    break;
                case "Oldest":
                case 1:
                    message.offsetStart = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateConsumerConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {protos.args.CreateConsumerConfig} message CreateConsumerConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateConsumerConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.createStreams = false;
                    object.recreateConsumerGroup = false;
                    object.offsetStart = options.enums === String ? "Latest" : 0;
                }
                if (message.createStreams != null && message.hasOwnProperty("createStreams"))
                    object.createStreams = message.createStreams;
                if (message.recreateConsumerGroup != null && message.hasOwnProperty("recreateConsumerGroup"))
                    object.recreateConsumerGroup = message.recreateConsumerGroup;
                if (message.offsetStart != null && message.hasOwnProperty("offsetStart"))
                    object.offsetStart = options.enums === String ? $root.protos.args.OffsetStart[message.offsetStart] : message.offsetStart;
                return object;
            };

            /**
             * Converts this CreateConsumerConfig to JSON.
             * @function toJSON
             * @memberof protos.args.CreateConsumerConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateConsumerConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateConsumerConfig;
        })();

        args.RedisStreamsReadArgs = (function() {

            /**
             * Properties of a RedisStreamsReadArgs.
             * @memberof protos.args
             * @interface IRedisStreamsReadArgs
             * @property {number|null} [database] RedisStreamsReadArgs database
             * @property {Array.<string>|null} [stream] RedisStreamsReadArgs stream
             * @property {string|null} [consumerGroup] RedisStreamsReadArgs consumerGroup
             * @property {string|null} [consumerName] RedisStreamsReadArgs consumerName
             * @property {number|null} [count] RedisStreamsReadArgs count
             * @property {protos.args.ICreateConsumerConfig|null} [createConsumerConfig] RedisStreamsReadArgs createConsumerConfig
             */

            /**
             * Constructs a new RedisStreamsReadArgs.
             * @memberof protos.args
             * @classdesc Represents a RedisStreamsReadArgs.
             * @implements IRedisStreamsReadArgs
             * @constructor
             * @param {protos.args.IRedisStreamsReadArgs=} [properties] Properties to set
             */
            function RedisStreamsReadArgs(properties) {
                this.stream = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisStreamsReadArgs database.
             * @member {number} database
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.database = 0;

            /**
             * RedisStreamsReadArgs stream.
             * @member {Array.<string>} stream
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.stream = $util.emptyArray;

            /**
             * RedisStreamsReadArgs consumerGroup.
             * @member {string} consumerGroup
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.consumerGroup = "";

            /**
             * RedisStreamsReadArgs consumerName.
             * @member {string} consumerName
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.consumerName = "";

            /**
             * RedisStreamsReadArgs count.
             * @member {number} count
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.count = 0;

            /**
             * RedisStreamsReadArgs createConsumerConfig.
             * @member {protos.args.ICreateConsumerConfig|null|undefined} createConsumerConfig
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.createConsumerConfig = null;

            /**
             * Creates a new RedisStreamsReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {protos.args.IRedisStreamsReadArgs=} [properties] Properties to set
             * @returns {protos.args.RedisStreamsReadArgs} RedisStreamsReadArgs instance
             */
            RedisStreamsReadArgs.create = function create(properties) {
                return new RedisStreamsReadArgs(properties);
            };

            /**
             * Encodes the specified RedisStreamsReadArgs message. Does not implicitly {@link protos.args.RedisStreamsReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {protos.args.IRedisStreamsReadArgs} message RedisStreamsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.database);
                if (message.stream != null && message.stream.length)
                    for (let i = 0; i < message.stream.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.stream[i]);
                if (message.consumerGroup != null && Object.hasOwnProperty.call(message, "consumerGroup"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.consumerGroup);
                if (message.consumerName != null && Object.hasOwnProperty.call(message, "consumerName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.consumerName);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.count);
                if (message.createConsumerConfig != null && Object.hasOwnProperty.call(message, "createConsumerConfig"))
                    $root.protos.args.CreateConsumerConfig.encode(message.createConsumerConfig, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RedisStreamsReadArgs message, length delimited. Does not implicitly {@link protos.args.RedisStreamsReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {protos.args.IRedisStreamsReadArgs} message RedisStreamsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisStreamsReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisStreamsReadArgs} RedisStreamsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisStreamsReadArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.database = reader.uint32();
                        break;
                    case 2:
                        if (!(message.stream && message.stream.length))
                            message.stream = [];
                        message.stream.push(reader.string());
                        break;
                    case 3:
                        message.consumerGroup = reader.string();
                        break;
                    case 4:
                        message.consumerName = reader.string();
                        break;
                    case 5:
                        message.count = reader.uint32();
                        break;
                    case 6:
                        message.createConsumerConfig = $root.protos.args.CreateConsumerConfig.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisStreamsReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisStreamsReadArgs} RedisStreamsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisStreamsReadArgs message.
             * @function verify
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisStreamsReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isInteger(message.database))
                        return "database: integer expected";
                if (message.stream != null && message.hasOwnProperty("stream")) {
                    if (!Array.isArray(message.stream))
                        return "stream: array expected";
                    for (let i = 0; i < message.stream.length; ++i)
                        if (!$util.isString(message.stream[i]))
                            return "stream: string[] expected";
                }
                if (message.consumerGroup != null && message.hasOwnProperty("consumerGroup"))
                    if (!$util.isString(message.consumerGroup))
                        return "consumerGroup: string expected";
                if (message.consumerName != null && message.hasOwnProperty("consumerName"))
                    if (!$util.isString(message.consumerName))
                        return "consumerName: string expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                if (message.createConsumerConfig != null && message.hasOwnProperty("createConsumerConfig")) {
                    let error = $root.protos.args.CreateConsumerConfig.verify(message.createConsumerConfig);
                    if (error)
                        return "createConsumerConfig." + error;
                }
                return null;
            };

            /**
             * Creates a RedisStreamsReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisStreamsReadArgs} RedisStreamsReadArgs
             */
            RedisStreamsReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisStreamsReadArgs)
                    return object;
                let message = new $root.protos.args.RedisStreamsReadArgs();
                if (object.database != null)
                    message.database = object.database >>> 0;
                if (object.stream) {
                    if (!Array.isArray(object.stream))
                        throw TypeError(".protos.args.RedisStreamsReadArgs.stream: array expected");
                    message.stream = [];
                    for (let i = 0; i < object.stream.length; ++i)
                        message.stream[i] = String(object.stream[i]);
                }
                if (object.consumerGroup != null)
                    message.consumerGroup = String(object.consumerGroup);
                if (object.consumerName != null)
                    message.consumerName = String(object.consumerName);
                if (object.count != null)
                    message.count = object.count >>> 0;
                if (object.createConsumerConfig != null) {
                    if (typeof object.createConsumerConfig !== "object")
                        throw TypeError(".protos.args.RedisStreamsReadArgs.createConsumerConfig: object expected");
                    message.createConsumerConfig = $root.protos.args.CreateConsumerConfig.fromObject(object.createConsumerConfig);
                }
                return message;
            };

            /**
             * Creates a plain object from a RedisStreamsReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {protos.args.RedisStreamsReadArgs} message RedisStreamsReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisStreamsReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.stream = [];
                if (options.defaults) {
                    object.database = 0;
                    object.consumerGroup = "";
                    object.consumerName = "";
                    object.count = 0;
                    object.createConsumerConfig = null;
                }
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                if (message.stream && message.stream.length) {
                    object.stream = [];
                    for (let j = 0; j < message.stream.length; ++j)
                        object.stream[j] = message.stream[j];
                }
                if (message.consumerGroup != null && message.hasOwnProperty("consumerGroup"))
                    object.consumerGroup = message.consumerGroup;
                if (message.consumerName != null && message.hasOwnProperty("consumerName"))
                    object.consumerName = message.consumerName;
                if (message.count != null && message.hasOwnProperty("count"))
                    object.count = message.count;
                if (message.createConsumerConfig != null && message.hasOwnProperty("createConsumerConfig"))
                    object.createConsumerConfig = $root.protos.args.CreateConsumerConfig.toObject(message.createConsumerConfig, options);
                return object;
            };

            /**
             * Converts this RedisStreamsReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisStreamsReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisStreamsReadArgs;
        })();

        args.RedisStreamsWriteArgs = (function() {

            /**
             * Properties of a RedisStreamsWriteArgs.
             * @memberof protos.args
             * @interface IRedisStreamsWriteArgs
             * @property {string|null} [writeId] RedisStreamsWriteArgs writeId
             * @property {Array.<string>|null} [streams] RedisStreamsWriteArgs streams
             * @property {string|null} [key] RedisStreamsWriteArgs key
             */

            /**
             * Constructs a new RedisStreamsWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a RedisStreamsWriteArgs.
             * @implements IRedisStreamsWriteArgs
             * @constructor
             * @param {protos.args.IRedisStreamsWriteArgs=} [properties] Properties to set
             */
            function RedisStreamsWriteArgs(properties) {
                this.streams = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisStreamsWriteArgs writeId.
             * @member {string} writeId
             * @memberof protos.args.RedisStreamsWriteArgs
             * @instance
             */
            RedisStreamsWriteArgs.prototype.writeId = "";

            /**
             * RedisStreamsWriteArgs streams.
             * @member {Array.<string>} streams
             * @memberof protos.args.RedisStreamsWriteArgs
             * @instance
             */
            RedisStreamsWriteArgs.prototype.streams = $util.emptyArray;

            /**
             * RedisStreamsWriteArgs key.
             * @member {string} key
             * @memberof protos.args.RedisStreamsWriteArgs
             * @instance
             */
            RedisStreamsWriteArgs.prototype.key = "";

            /**
             * Creates a new RedisStreamsWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {protos.args.IRedisStreamsWriteArgs=} [properties] Properties to set
             * @returns {protos.args.RedisStreamsWriteArgs} RedisStreamsWriteArgs instance
             */
            RedisStreamsWriteArgs.create = function create(properties) {
                return new RedisStreamsWriteArgs(properties);
            };

            /**
             * Encodes the specified RedisStreamsWriteArgs message. Does not implicitly {@link protos.args.RedisStreamsWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {protos.args.IRedisStreamsWriteArgs} message RedisStreamsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.writeId != null && Object.hasOwnProperty.call(message, "writeId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.writeId);
                if (message.streams != null && message.streams.length)
                    for (let i = 0; i < message.streams.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.streams[i]);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.key);
                return writer;
            };

            /**
             * Encodes the specified RedisStreamsWriteArgs message, length delimited. Does not implicitly {@link protos.args.RedisStreamsWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {protos.args.IRedisStreamsWriteArgs} message RedisStreamsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisStreamsWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisStreamsWriteArgs} RedisStreamsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisStreamsWriteArgs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.writeId = reader.string();
                        break;
                    case 2:
                        if (!(message.streams && message.streams.length))
                            message.streams = [];
                        message.streams.push(reader.string());
                        break;
                    case 3:
                        message.key = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisStreamsWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisStreamsWriteArgs} RedisStreamsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisStreamsWriteArgs message.
             * @function verify
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisStreamsWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.writeId != null && message.hasOwnProperty("writeId"))
                    if (!$util.isString(message.writeId))
                        return "writeId: string expected";
                if (message.streams != null && message.hasOwnProperty("streams")) {
                    if (!Array.isArray(message.streams))
                        return "streams: array expected";
                    for (let i = 0; i < message.streams.length; ++i)
                        if (!$util.isString(message.streams[i]))
                            return "streams: string[] expected";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                return null;
            };

            /**
             * Creates a RedisStreamsWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisStreamsWriteArgs} RedisStreamsWriteArgs
             */
            RedisStreamsWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisStreamsWriteArgs)
                    return object;
                let message = new $root.protos.args.RedisStreamsWriteArgs();
                if (object.writeId != null)
                    message.writeId = String(object.writeId);
                if (object.streams) {
                    if (!Array.isArray(object.streams))
                        throw TypeError(".protos.args.RedisStreamsWriteArgs.streams: array expected");
                    message.streams = [];
                    for (let i = 0; i < object.streams.length; ++i)
                        message.streams[i] = String(object.streams[i]);
                }
                if (object.key != null)
                    message.key = String(object.key);
                return message;
            };

            /**
             * Creates a plain object from a RedisStreamsWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {protos.args.RedisStreamsWriteArgs} message RedisStreamsWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisStreamsWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.streams = [];
                if (options.defaults) {
                    object.writeId = "";
                    object.key = "";
                }
                if (message.writeId != null && message.hasOwnProperty("writeId"))
                    object.writeId = message.writeId;
                if (message.streams && message.streams.length) {
                    object.streams = [];
                    for (let j = 0; j < message.streams.length; ++j)
                        object.streams[j] = message.streams[j];
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                return object;
            };

            /**
             * Converts this RedisStreamsWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RedisStreamsWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisStreamsWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisStreamsWriteArgs;
        })();

        return args;
    })();

    protos.common = (function() {

        /**
         * Namespace common.
         * @memberof protos
         * @namespace
         */
        const common = {};

        common.Auth = (function() {

            /**
             * Properties of an Auth.
             * @memberof protos.common
             * @interface IAuth
             * @property {string|null} [token] Auth token
             */

            /**
             * Constructs a new Auth.
             * @memberof protos.common
             * @classdesc Represents an Auth.
             * @implements IAuth
             * @constructor
             * @param {protos.common.IAuth=} [properties] Properties to set
             */
            function Auth(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Auth token.
             * @member {string} token
             * @memberof protos.common.Auth
             * @instance
             */
            Auth.prototype.token = "";

            /**
             * Creates a new Auth instance using the specified properties.
             * @function create
             * @memberof protos.common.Auth
             * @static
             * @param {protos.common.IAuth=} [properties] Properties to set
             * @returns {protos.common.Auth} Auth instance
             */
            Auth.create = function create(properties) {
                return new Auth(properties);
            };

            /**
             * Encodes the specified Auth message. Does not implicitly {@link protos.common.Auth.verify|verify} messages.
             * @function encode
             * @memberof protos.common.Auth
             * @static
             * @param {protos.common.IAuth} message Auth message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Auth.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
                return writer;
            };

            /**
             * Encodes the specified Auth message, length delimited. Does not implicitly {@link protos.common.Auth.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.common.Auth
             * @static
             * @param {protos.common.IAuth} message Auth message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Auth.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Auth message from the specified reader or buffer.
             * @function decode
             * @memberof protos.common.Auth
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.common.Auth} Auth
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Auth.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.common.Auth();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.token = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Auth message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.common.Auth
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.common.Auth} Auth
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Auth.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Auth message.
             * @function verify
             * @memberof protos.common.Auth
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Auth.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                return null;
            };

            /**
             * Creates an Auth message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.common.Auth
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.common.Auth} Auth
             */
            Auth.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.common.Auth)
                    return object;
                let message = new $root.protos.common.Auth();
                if (object.token != null)
                    message.token = String(object.token);
                return message;
            };

            /**
             * Creates a plain object from an Auth message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.common.Auth
             * @static
             * @param {protos.common.Auth} message Auth
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Auth.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.token = "";
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = message.token;
                return object;
            };

            /**
             * Converts this Auth to JSON.
             * @function toJSON
             * @memberof protos.common.Auth
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Auth.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Auth;
        })();

        /**
         * BackendType enum.
         * @name protos.common.BackendType
         * @enum {number}
         * @property {number} BACKEND_TYPE_UNSET=0 BACKEND_TYPE_UNSET value
         * @property {number} BACKEND_TYPE_KAFKA=1 BACKEND_TYPE_KAFKA value
         * @property {number} BACKEND_TYPE_RABBIT=2 BACKEND_TYPE_RABBIT value
         * @property {number} BACKEND_TYPE_RABBIT_STREAMS=3 BACKEND_TYPE_RABBIT_STREAMS value
         * @property {number} BACKEND_TYPE_NSQ=4 BACKEND_TYPE_NSQ value
         * @property {number} BACKEND_TYPE_NATS=5 BACKEND_TYPE_NATS value
         * @property {number} BACKEND_TYPE_NATS_STREAMING=6 BACKEND_TYPE_NATS_STREAMING value
         * @property {number} BACKEND_TYPE_GCP_PUBSUB=7 BACKEND_TYPE_GCP_PUBSUB value
         * @property {number} BACKEND_TYPE_AZURE_SERVICE_BUS=8 BACKEND_TYPE_AZURE_SERVICE_BUS value
         * @property {number} BACKEND_TYPE_AZURE_EVENT_HUB=9 BACKEND_TYPE_AZURE_EVENT_HUB value
         * @property {number} BACKEND_TYPE_AWS_SQS=10 BACKEND_TYPE_AWS_SQS value
         * @property {number} BACKEND_TYPE_AWS_SNS=11 BACKEND_TYPE_AWS_SNS value
         * @property {number} BACKEND_TYPE_REDIS_PUBSUB=12 BACKEND_TYPE_REDIS_PUBSUB value
         * @property {number} BACKEND_TYPE_REDIS_STREAMS=13 BACKEND_TYPE_REDIS_STREAMS value
         * @property {number} BACKEND_TYPE_ACTIVEMQ=14 BACKEND_TYPE_ACTIVEMQ value
         * @property {number} BACKEND_TYPE_PULSAR=15 BACKEND_TYPE_PULSAR value
         * @property {number} BACKEND_TYPE_MQTT=16 BACKEND_TYPE_MQTT value
         * @property {number} BACKEND_TYPE_POSTGRES_CDC=17 BACKEND_TYPE_POSTGRES_CDC value
         * @property {number} BACKEND_TYPE_MONGODB_CDC=18 BACKEND_TYPE_MONGODB_CDC value
         * @property {number} BACKEND_TYPE_KUBE_MQ=19 BACKEND_TYPE_KUBE_MQ value
         */
        common.BackendType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "BACKEND_TYPE_UNSET"] = 0;
            values[valuesById[1] = "BACKEND_TYPE_KAFKA"] = 1;
            values[valuesById[2] = "BACKEND_TYPE_RABBIT"] = 2;
            values[valuesById[3] = "BACKEND_TYPE_RABBIT_STREAMS"] = 3;
            values[valuesById[4] = "BACKEND_TYPE_NSQ"] = 4;
            values[valuesById[5] = "BACKEND_TYPE_NATS"] = 5;
            values[valuesById[6] = "BACKEND_TYPE_NATS_STREAMING"] = 6;
            values[valuesById[7] = "BACKEND_TYPE_GCP_PUBSUB"] = 7;
            values[valuesById[8] = "BACKEND_TYPE_AZURE_SERVICE_BUS"] = 8;
            values[valuesById[9] = "BACKEND_TYPE_AZURE_EVENT_HUB"] = 9;
            values[valuesById[10] = "BACKEND_TYPE_AWS_SQS"] = 10;
            values[valuesById[11] = "BACKEND_TYPE_AWS_SNS"] = 11;
            values[valuesById[12] = "BACKEND_TYPE_REDIS_PUBSUB"] = 12;
            values[valuesById[13] = "BACKEND_TYPE_REDIS_STREAMS"] = 13;
            values[valuesById[14] = "BACKEND_TYPE_ACTIVEMQ"] = 14;
            values[valuesById[15] = "BACKEND_TYPE_PULSAR"] = 15;
            values[valuesById[16] = "BACKEND_TYPE_MQTT"] = 16;
            values[valuesById[17] = "BACKEND_TYPE_POSTGRES_CDC"] = 17;
            values[valuesById[18] = "BACKEND_TYPE_MONGODB_CDC"] = 18;
            values[valuesById[19] = "BACKEND_TYPE_KUBE_MQ"] = 19;
            return values;
        })();

        /**
         * Code enum.
         * @name protos.common.Code
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} CANCELLED=1 CANCELLED value
         * @property {number} UNKNOWN=2 UNKNOWN value
         * @property {number} INVALID_ARGUMENT=3 INVALID_ARGUMENT value
         * @property {number} DEADLINE_EXCEEDED=4 DEADLINE_EXCEEDED value
         * @property {number} NOT_FOUND=5 NOT_FOUND value
         * @property {number} ALREADY_EXISTS=6 ALREADY_EXISTS value
         * @property {number} PERMISSION_DENIED=7 PERMISSION_DENIED value
         * @property {number} UNAUTHENTICATED=16 UNAUTHENTICATED value
         * @property {number} RESOURCE_EXHAUSTED=8 RESOURCE_EXHAUSTED value
         * @property {number} FAILED_PRECONDITION=9 FAILED_PRECONDITION value
         * @property {number} ABORTED=10 ABORTED value
         * @property {number} OUT_OF_RANGE=11 OUT_OF_RANGE value
         * @property {number} UNIMPLEMENTED=12 UNIMPLEMENTED value
         * @property {number} INTERNAL=13 INTERNAL value
         * @property {number} UNAVAILABLE=14 UNAVAILABLE value
         * @property {number} DATA_LOSS=15 DATA_LOSS value
         */
        common.Code = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "CANCELLED"] = 1;
            values[valuesById[2] = "UNKNOWN"] = 2;
            values[valuesById[3] = "INVALID_ARGUMENT"] = 3;
            values[valuesById[4] = "DEADLINE_EXCEEDED"] = 4;
            values[valuesById[5] = "NOT_FOUND"] = 5;
            values[valuesById[6] = "ALREADY_EXISTS"] = 6;
            values[valuesById[7] = "PERMISSION_DENIED"] = 7;
            values[valuesById[16] = "UNAUTHENTICATED"] = 16;
            values[valuesById[8] = "RESOURCE_EXHAUSTED"] = 8;
            values[valuesById[9] = "FAILED_PRECONDITION"] = 9;
            values[valuesById[10] = "ABORTED"] = 10;
            values[valuesById[11] = "OUT_OF_RANGE"] = 11;
            values[valuesById[12] = "UNIMPLEMENTED"] = 12;
            values[valuesById[13] = "INTERNAL"] = 13;
            values[valuesById[14] = "UNAVAILABLE"] = 14;
            values[valuesById[15] = "DATA_LOSS"] = 15;
            return values;
        })();

        common.Status = (function() {

            /**
             * Properties of a Status.
             * @memberof protos.common
             * @interface IStatus
             * @property {protos.common.Code|null} [code] Status code
             * @property {string|null} [message] Status message
             * @property {string|null} [requestId] Status requestId
             */

            /**
             * Constructs a new Status.
             * @memberof protos.common
             * @classdesc Represents a Status.
             * @implements IStatus
             * @constructor
             * @param {protos.common.IStatus=} [properties] Properties to set
             */
            function Status(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Status code.
             * @member {protos.common.Code} code
             * @memberof protos.common.Status
             * @instance
             */
            Status.prototype.code = 0;

            /**
             * Status message.
             * @member {string} message
             * @memberof protos.common.Status
             * @instance
             */
            Status.prototype.message = "";

            /**
             * Status requestId.
             * @member {string} requestId
             * @memberof protos.common.Status
             * @instance
             */
            Status.prototype.requestId = "";

            /**
             * Creates a new Status instance using the specified properties.
             * @function create
             * @memberof protos.common.Status
             * @static
             * @param {protos.common.IStatus=} [properties] Properties to set
             * @returns {protos.common.Status} Status instance
             */
            Status.create = function create(properties) {
                return new Status(properties);
            };

            /**
             * Encodes the specified Status message. Does not implicitly {@link protos.common.Status.verify|verify} messages.
             * @function encode
             * @memberof protos.common.Status
             * @static
             * @param {protos.common.IStatus} message Status message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Status.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.requestId);
                return writer;
            };

            /**
             * Encodes the specified Status message, length delimited. Does not implicitly {@link protos.common.Status.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.common.Status
             * @static
             * @param {protos.common.IStatus} message Status message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Status.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Status message from the specified reader or buffer.
             * @function decode
             * @memberof protos.common.Status
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.common.Status} Status
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Status.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.common.Status();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.message = reader.string();
                        break;
                    case 3:
                        message.requestId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Status message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.common.Status
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.common.Status} Status
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Status.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Status message.
             * @function verify
             * @memberof protos.common.Status
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Status.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    switch (message.code) {
                    default:
                        return "code: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 16:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                        break;
                    }
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.requestId != null && message.hasOwnProperty("requestId"))
                    if (!$util.isString(message.requestId))
                        return "requestId: string expected";
                return null;
            };

            /**
             * Creates a Status message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.common.Status
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.common.Status} Status
             */
            Status.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.common.Status)
                    return object;
                let message = new $root.protos.common.Status();
                switch (object.code) {
                case "OK":
                case 0:
                    message.code = 0;
                    break;
                case "CANCELLED":
                case 1:
                    message.code = 1;
                    break;
                case "UNKNOWN":
                case 2:
                    message.code = 2;
                    break;
                case "INVALID_ARGUMENT":
                case 3:
                    message.code = 3;
                    break;
                case "DEADLINE_EXCEEDED":
                case 4:
                    message.code = 4;
                    break;
                case "NOT_FOUND":
                case 5:
                    message.code = 5;
                    break;
                case "ALREADY_EXISTS":
                case 6:
                    message.code = 6;
                    break;
                case "PERMISSION_DENIED":
                case 7:
                    message.code = 7;
                    break;
                case "UNAUTHENTICATED":
                case 16:
                    message.code = 16;
                    break;
                case "RESOURCE_EXHAUSTED":
                case 8:
                    message.code = 8;
                    break;
                case "FAILED_PRECONDITION":
                case 9:
                    message.code = 9;
                    break;
                case "ABORTED":
                case 10:
                    message.code = 10;
                    break;
                case "OUT_OF_RANGE":
                case 11:
                    message.code = 11;
                    break;
                case "UNIMPLEMENTED":
                case 12:
                    message.code = 12;
                    break;
                case "INTERNAL":
                case 13:
                    message.code = 13;
                    break;
                case "UNAVAILABLE":
                case 14:
                    message.code = 14;
                    break;
                case "DATA_LOSS":
                case 15:
                    message.code = 15;
                    break;
                }
                if (object.message != null)
                    message.message = String(object.message);
                if (object.requestId != null)
                    message.requestId = String(object.requestId);
                return message;
            };

            /**
             * Creates a plain object from a Status message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.common.Status
             * @static
             * @param {protos.common.Status} message Status
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Status.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.code = options.enums === String ? "OK" : 0;
                    object.message = "";
                    object.requestId = "";
                }
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = options.enums === String ? $root.protos.common.Code[message.code] : message.code;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                if (message.requestId != null && message.hasOwnProperty("requestId"))
                    object.requestId = message.requestId;
                return object;
            };

            /**
             * Converts this Status to JSON.
             * @function toJSON
             * @memberof protos.common.Status
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Status.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Status;
        })();

        return common;
    })();

    protos.encoding = (function() {

        /**
         * Namespace encoding.
         * @memberof protos
         * @namespace
         */
        const encoding = {};

        /**
         * EncodeType enum.
         * @name protos.encoding.EncodeType
         * @enum {number}
         * @property {number} ENCODE_TYPE_UNSET=0 ENCODE_TYPE_UNSET value
         * @property {number} ENCODE_TYPE_JSONPB=1 ENCODE_TYPE_JSONPB value
         * @property {number} ENCODE_TYPE_AVRO=2 ENCODE_TYPE_AVRO value
         */
        encoding.EncodeType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ENCODE_TYPE_UNSET"] = 0;
            values[valuesById[1] = "ENCODE_TYPE_JSONPB"] = 1;
            values[valuesById[2] = "ENCODE_TYPE_AVRO"] = 2;
            return values;
        })();

        /**
         * DecodeType enum.
         * @name protos.encoding.DecodeType
         * @enum {number}
         * @property {number} DECODE_TYPE_UNSET=0 DECODE_TYPE_UNSET value
         * @property {number} DECODE_TYPE_PROTOBUF=1 DECODE_TYPE_PROTOBUF value
         * @property {number} DECODE_TYPE_AVRO=2 DECODE_TYPE_AVRO value
         * @property {number} DECODE_TYPE_THRIFT=3 DECODE_TYPE_THRIFT value
         * @property {number} DECODE_TYPE_FLATBUFFER=4 DECODE_TYPE_FLATBUFFER value
         */
        encoding.DecodeType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DECODE_TYPE_UNSET"] = 0;
            values[valuesById[1] = "DECODE_TYPE_PROTOBUF"] = 1;
            values[valuesById[2] = "DECODE_TYPE_AVRO"] = 2;
            values[valuesById[3] = "DECODE_TYPE_THRIFT"] = 3;
            values[valuesById[4] = "DECODE_TYPE_FLATBUFFER"] = 4;
            return values;
        })();

        encoding.ProtobufSettings = (function() {

            /**
             * Properties of a ProtobufSettings.
             * @memberof protos.encoding
             * @interface IProtobufSettings
             * @property {string|null} [protobufRootMessage] ProtobufSettings protobufRootMessage
             * @property {Array.<string>|null} [protobufDirs] ProtobufSettings protobufDirs
             * @property {string|null} [_protobufRootDir] ProtobufSettings _protobufRootDir
             * @property {Uint8Array|null} [archive] ProtobufSettings archive
             * @property {Uint8Array|null} [_messageDescriptor] ProtobufSettings _messageDescriptor
             */

            /**
             * Constructs a new ProtobufSettings.
             * @memberof protos.encoding
             * @classdesc Represents a ProtobufSettings.
             * @implements IProtobufSettings
             * @constructor
             * @param {protos.encoding.IProtobufSettings=} [properties] Properties to set
             */
            function ProtobufSettings(properties) {
                this.protobufDirs = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProtobufSettings protobufRootMessage.
             * @member {string} protobufRootMessage
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype.protobufRootMessage = "";

            /**
             * ProtobufSettings protobufDirs.
             * @member {Array.<string>} protobufDirs
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype.protobufDirs = $util.emptyArray;

            /**
             * ProtobufSettings _protobufRootDir.
             * @member {string} _protobufRootDir
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype._protobufRootDir = "";

            /**
             * ProtobufSettings archive.
             * @member {Uint8Array} archive
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype.archive = $util.newBuffer([]);

            /**
             * ProtobufSettings _messageDescriptor.
             * @member {Uint8Array} _messageDescriptor
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype._messageDescriptor = $util.newBuffer([]);

            /**
             * Creates a new ProtobufSettings instance using the specified properties.
             * @function create
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {protos.encoding.IProtobufSettings=} [properties] Properties to set
             * @returns {protos.encoding.ProtobufSettings} ProtobufSettings instance
             */
            ProtobufSettings.create = function create(properties) {
                return new ProtobufSettings(properties);
            };

            /**
             * Encodes the specified ProtobufSettings message. Does not implicitly {@link protos.encoding.ProtobufSettings.verify|verify} messages.
             * @function encode
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {protos.encoding.IProtobufSettings} message ProtobufSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtobufSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.protobufRootMessage != null && Object.hasOwnProperty.call(message, "protobufRootMessage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.protobufRootMessage);
                if (message.protobufDirs != null && message.protobufDirs.length)
                    for (let i = 0; i < message.protobufDirs.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.protobufDirs[i]);
                if (message._protobufRootDir != null && Object.hasOwnProperty.call(message, "_protobufRootDir"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message._protobufRootDir);
                if (message.archive != null && Object.hasOwnProperty.call(message, "archive"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.archive);
                if (message._messageDescriptor != null && Object.hasOwnProperty.call(message, "_messageDescriptor"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message._messageDescriptor);
                return writer;
            };

            /**
             * Encodes the specified ProtobufSettings message, length delimited. Does not implicitly {@link protos.encoding.ProtobufSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {protos.encoding.IProtobufSettings} message ProtobufSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtobufSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtobufSettings message from the specified reader or buffer.
             * @function decode
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.encoding.ProtobufSettings} ProtobufSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtobufSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.encoding.ProtobufSettings();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.protobufRootMessage = reader.string();
                        break;
                    case 2:
                        if (!(message.protobufDirs && message.protobufDirs.length))
                            message.protobufDirs = [];
                        message.protobufDirs.push(reader.string());
                        break;
                    case 3:
                        message._protobufRootDir = reader.string();
                        break;
                    case 4:
                        message.archive = reader.bytes();
                        break;
                    case 5:
                        message._messageDescriptor = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtobufSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.encoding.ProtobufSettings} ProtobufSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtobufSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtobufSettings message.
             * @function verify
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtobufSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.protobufRootMessage != null && message.hasOwnProperty("protobufRootMessage"))
                    if (!$util.isString(message.protobufRootMessage))
                        return "protobufRootMessage: string expected";
                if (message.protobufDirs != null && message.hasOwnProperty("protobufDirs")) {
                    if (!Array.isArray(message.protobufDirs))
                        return "protobufDirs: array expected";
                    for (let i = 0; i < message.protobufDirs.length; ++i)
                        if (!$util.isString(message.protobufDirs[i]))
                            return "protobufDirs: string[] expected";
                }
                if (message._protobufRootDir != null && message.hasOwnProperty("_protobufRootDir"))
                    if (!$util.isString(message._protobufRootDir))
                        return "_protobufRootDir: string expected";
                if (message.archive != null && message.hasOwnProperty("archive"))
                    if (!(message.archive && typeof message.archive.length === "number" || $util.isString(message.archive)))
                        return "archive: buffer expected";
                if (message._messageDescriptor != null && message.hasOwnProperty("_messageDescriptor"))
                    if (!(message._messageDescriptor && typeof message._messageDescriptor.length === "number" || $util.isString(message._messageDescriptor)))
                        return "_messageDescriptor: buffer expected";
                return null;
            };

            /**
             * Creates a ProtobufSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.encoding.ProtobufSettings} ProtobufSettings
             */
            ProtobufSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.encoding.ProtobufSettings)
                    return object;
                let message = new $root.protos.encoding.ProtobufSettings();
                if (object.protobufRootMessage != null)
                    message.protobufRootMessage = String(object.protobufRootMessage);
                if (object.protobufDirs) {
                    if (!Array.isArray(object.protobufDirs))
                        throw TypeError(".protos.encoding.ProtobufSettings.protobufDirs: array expected");
                    message.protobufDirs = [];
                    for (let i = 0; i < object.protobufDirs.length; ++i)
                        message.protobufDirs[i] = String(object.protobufDirs[i]);
                }
                if (object._protobufRootDir != null)
                    message._protobufRootDir = String(object._protobufRootDir);
                if (object.archive != null)
                    if (typeof object.archive === "string")
                        $util.base64.decode(object.archive, message.archive = $util.newBuffer($util.base64.length(object.archive)), 0);
                    else if (object.archive.length)
                        message.archive = object.archive;
                if (object._messageDescriptor != null)
                    if (typeof object._messageDescriptor === "string")
                        $util.base64.decode(object._messageDescriptor, message._messageDescriptor = $util.newBuffer($util.base64.length(object._messageDescriptor)), 0);
                    else if (object._messageDescriptor.length)
                        message._messageDescriptor = object._messageDescriptor;
                return message;
            };

            /**
             * Creates a plain object from a ProtobufSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {protos.encoding.ProtobufSettings} message ProtobufSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtobufSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.protobufDirs = [];
                if (options.defaults) {
                    object.protobufRootMessage = "";
                    object._protobufRootDir = "";
                    if (options.bytes === String)
                        object.archive = "";
                    else {
                        object.archive = [];
                        if (options.bytes !== Array)
                            object.archive = $util.newBuffer(object.archive);
                    }
                    if (options.bytes === String)
                        object._messageDescriptor = "";
                    else {
                        object._messageDescriptor = [];
                        if (options.bytes !== Array)
                            object._messageDescriptor = $util.newBuffer(object._messageDescriptor);
                    }
                }
                if (message.protobufRootMessage != null && message.hasOwnProperty("protobufRootMessage"))
                    object.protobufRootMessage = message.protobufRootMessage;
                if (message.protobufDirs && message.protobufDirs.length) {
                    object.protobufDirs = [];
                    for (let j = 0; j < message.protobufDirs.length; ++j)
                        object.protobufDirs[j] = message.protobufDirs[j];
                }
                if (message._protobufRootDir != null && message.hasOwnProperty("_protobufRootDir"))
                    object._protobufRootDir = message._protobufRootDir;
                if (message.archive != null && message.hasOwnProperty("archive"))
                    object.archive = options.bytes === String ? $util.base64.encode(message.archive, 0, message.archive.length) : options.bytes === Array ? Array.prototype.slice.call(message.archive) : message.archive;
                if (message._messageDescriptor != null && message.hasOwnProperty("_messageDescriptor"))
                    object._messageDescriptor = options.bytes === String ? $util.base64.encode(message._messageDescriptor, 0, message._messageDescriptor.length) : options.bytes === Array ? Array.prototype.slice.call(message._messageDescriptor) : message._messageDescriptor;
                return object;
            };

            /**
             * Converts this ProtobufSettings to JSON.
             * @function toJSON
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtobufSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ProtobufSettings;
        })();

        encoding.AvroSettings = (function() {

            /**
             * Properties of an AvroSettings.
             * @memberof protos.encoding
             * @interface IAvroSettings
             * @property {string|null} [avroSchemaFile] AvroSettings avroSchemaFile
             * @property {Uint8Array|null} [schema] AvroSettings schema
             */

            /**
             * Constructs a new AvroSettings.
             * @memberof protos.encoding
             * @classdesc Represents an AvroSettings.
             * @implements IAvroSettings
             * @constructor
             * @param {protos.encoding.IAvroSettings=} [properties] Properties to set
             */
            function AvroSettings(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AvroSettings avroSchemaFile.
             * @member {string} avroSchemaFile
             * @memberof protos.encoding.AvroSettings
             * @instance
             */
            AvroSettings.prototype.avroSchemaFile = "";

            /**
             * AvroSettings schema.
             * @member {Uint8Array} schema
             * @memberof protos.encoding.AvroSettings
             * @instance
             */
            AvroSettings.prototype.schema = $util.newBuffer([]);

            /**
             * Creates a new AvroSettings instance using the specified properties.
             * @function create
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {protos.encoding.IAvroSettings=} [properties] Properties to set
             * @returns {protos.encoding.AvroSettings} AvroSettings instance
             */
            AvroSettings.create = function create(properties) {
                return new AvroSettings(properties);
            };

            /**
             * Encodes the specified AvroSettings message. Does not implicitly {@link protos.encoding.AvroSettings.verify|verify} messages.
             * @function encode
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {protos.encoding.IAvroSettings} message AvroSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AvroSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.avroSchemaFile != null && Object.hasOwnProperty.call(message, "avroSchemaFile"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.avroSchemaFile);
                if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.schema);
                return writer;
            };

            /**
             * Encodes the specified AvroSettings message, length delimited. Does not implicitly {@link protos.encoding.AvroSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {protos.encoding.IAvroSettings} message AvroSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AvroSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AvroSettings message from the specified reader or buffer.
             * @function decode
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.encoding.AvroSettings} AvroSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AvroSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.encoding.AvroSettings();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.avroSchemaFile = reader.string();
                        break;
                    case 2:
                        message.schema = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AvroSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.encoding.AvroSettings} AvroSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AvroSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AvroSettings message.
             * @function verify
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AvroSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.avroSchemaFile != null && message.hasOwnProperty("avroSchemaFile"))
                    if (!$util.isString(message.avroSchemaFile))
                        return "avroSchemaFile: string expected";
                if (message.schema != null && message.hasOwnProperty("schema"))
                    if (!(message.schema && typeof message.schema.length === "number" || $util.isString(message.schema)))
                        return "schema: buffer expected";
                return null;
            };

            /**
             * Creates an AvroSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.encoding.AvroSettings} AvroSettings
             */
            AvroSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.encoding.AvroSettings)
                    return object;
                let message = new $root.protos.encoding.AvroSettings();
                if (object.avroSchemaFile != null)
                    message.avroSchemaFile = String(object.avroSchemaFile);
                if (object.schema != null)
                    if (typeof object.schema === "string")
                        $util.base64.decode(object.schema, message.schema = $util.newBuffer($util.base64.length(object.schema)), 0);
                    else if (object.schema.length)
                        message.schema = object.schema;
                return message;
            };

            /**
             * Creates a plain object from an AvroSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {protos.encoding.AvroSettings} message AvroSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AvroSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.avroSchemaFile = "";
                    if (options.bytes === String)
                        object.schema = "";
                    else {
                        object.schema = [];
                        if (options.bytes !== Array)
                            object.schema = $util.newBuffer(object.schema);
                    }
                }
                if (message.avroSchemaFile != null && message.hasOwnProperty("avroSchemaFile"))
                    object.avroSchemaFile = message.avroSchemaFile;
                if (message.schema != null && message.hasOwnProperty("schema"))
                    object.schema = options.bytes === String ? $util.base64.encode(message.schema, 0, message.schema.length) : options.bytes === Array ? Array.prototype.slice.call(message.schema) : message.schema;
                return object;
            };

            /**
             * Converts this AvroSettings to JSON.
             * @function toJSON
             * @memberof protos.encoding.AvroSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AvroSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AvroSettings;
        })();

        encoding.EncodeOptions = (function() {

            /**
             * Properties of an EncodeOptions.
             * @memberof protos.encoding
             * @interface IEncodeOptions
             * @property {string|null} [schemaId] EncodeOptions schemaId
             * @property {protos.encoding.EncodeType|null} [encodeType] EncodeOptions encodeType
             * @property {protos.encoding.IProtobufSettings|null} [protobufSettings] EncodeOptions protobufSettings
             * @property {protos.encoding.IAvroSettings|null} [avroSettings] EncodeOptions avroSettings
             */

            /**
             * Constructs a new EncodeOptions.
             * @memberof protos.encoding
             * @classdesc Represents an EncodeOptions.
             * @implements IEncodeOptions
             * @constructor
             * @param {protos.encoding.IEncodeOptions=} [properties] Properties to set
             */
            function EncodeOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EncodeOptions schemaId.
             * @member {string} schemaId
             * @memberof protos.encoding.EncodeOptions
             * @instance
             */
            EncodeOptions.prototype.schemaId = "";

            /**
             * EncodeOptions encodeType.
             * @member {protos.encoding.EncodeType} encodeType
             * @memberof protos.encoding.EncodeOptions
             * @instance
             */
            EncodeOptions.prototype.encodeType = 0;

            /**
             * EncodeOptions protobufSettings.
             * @member {protos.encoding.IProtobufSettings|null|undefined} protobufSettings
             * @memberof protos.encoding.EncodeOptions
             * @instance
             */
            EncodeOptions.prototype.protobufSettings = null;

            /**
             * EncodeOptions avroSettings.
             * @member {protos.encoding.IAvroSettings|null|undefined} avroSettings
             * @memberof protos.encoding.EncodeOptions
             * @instance
             */
            EncodeOptions.prototype.avroSettings = null;

            /**
             * Creates a new EncodeOptions instance using the specified properties.
             * @function create
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {protos.encoding.IEncodeOptions=} [properties] Properties to set
             * @returns {protos.encoding.EncodeOptions} EncodeOptions instance
             */
            EncodeOptions.create = function create(properties) {
                return new EncodeOptions(properties);
            };

            /**
             * Encodes the specified EncodeOptions message. Does not implicitly {@link protos.encoding.EncodeOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {protos.encoding.IEncodeOptions} message EncodeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EncodeOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.schemaId != null && Object.hasOwnProperty.call(message, "schemaId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.schemaId);
                if (message.encodeType != null && Object.hasOwnProperty.call(message, "encodeType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.encodeType);
                if (message.protobufSettings != null && Object.hasOwnProperty.call(message, "protobufSettings"))
                    $root.protos.encoding.ProtobufSettings.encode(message.protobufSettings, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.avroSettings != null && Object.hasOwnProperty.call(message, "avroSettings"))
                    $root.protos.encoding.AvroSettings.encode(message.avroSettings, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EncodeOptions message, length delimited. Does not implicitly {@link protos.encoding.EncodeOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {protos.encoding.IEncodeOptions} message EncodeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EncodeOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EncodeOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.encoding.EncodeOptions} EncodeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EncodeOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.encoding.EncodeOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.schemaId = reader.string();
                        break;
                    case 2:
                        message.encodeType = reader.int32();
                        break;
                    case 3:
                        message.protobufSettings = $root.protos.encoding.ProtobufSettings.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.avroSettings = $root.protos.encoding.AvroSettings.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EncodeOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.encoding.EncodeOptions} EncodeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EncodeOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EncodeOptions message.
             * @function verify
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EncodeOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    if (!$util.isString(message.schemaId))
                        return "schemaId: string expected";
                if (message.encodeType != null && message.hasOwnProperty("encodeType"))
                    switch (message.encodeType) {
                    default:
                        return "encodeType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings")) {
                    let error = $root.protos.encoding.ProtobufSettings.verify(message.protobufSettings);
                    if (error)
                        return "protobufSettings." + error;
                }
                if (message.avroSettings != null && message.hasOwnProperty("avroSettings")) {
                    let error = $root.protos.encoding.AvroSettings.verify(message.avroSettings);
                    if (error)
                        return "avroSettings." + error;
                }
                return null;
            };

            /**
             * Creates an EncodeOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.encoding.EncodeOptions} EncodeOptions
             */
            EncodeOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.encoding.EncodeOptions)
                    return object;
                let message = new $root.protos.encoding.EncodeOptions();
                if (object.schemaId != null)
                    message.schemaId = String(object.schemaId);
                switch (object.encodeType) {
                case "ENCODE_TYPE_UNSET":
                case 0:
                    message.encodeType = 0;
                    break;
                case "ENCODE_TYPE_JSONPB":
                case 1:
                    message.encodeType = 1;
                    break;
                case "ENCODE_TYPE_AVRO":
                case 2:
                    message.encodeType = 2;
                    break;
                }
                if (object.protobufSettings != null) {
                    if (typeof object.protobufSettings !== "object")
                        throw TypeError(".protos.encoding.EncodeOptions.protobufSettings: object expected");
                    message.protobufSettings = $root.protos.encoding.ProtobufSettings.fromObject(object.protobufSettings);
                }
                if (object.avroSettings != null) {
                    if (typeof object.avroSettings !== "object")
                        throw TypeError(".protos.encoding.EncodeOptions.avroSettings: object expected");
                    message.avroSettings = $root.protos.encoding.AvroSettings.fromObject(object.avroSettings);
                }
                return message;
            };

            /**
             * Creates a plain object from an EncodeOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {protos.encoding.EncodeOptions} message EncodeOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EncodeOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.schemaId = "";
                    object.encodeType = options.enums === String ? "ENCODE_TYPE_UNSET" : 0;
                    object.protobufSettings = null;
                    object.avroSettings = null;
                }
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    object.schemaId = message.schemaId;
                if (message.encodeType != null && message.hasOwnProperty("encodeType"))
                    object.encodeType = options.enums === String ? $root.protos.encoding.EncodeType[message.encodeType] : message.encodeType;
                if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings"))
                    object.protobufSettings = $root.protos.encoding.ProtobufSettings.toObject(message.protobufSettings, options);
                if (message.avroSettings != null && message.hasOwnProperty("avroSettings"))
                    object.avroSettings = $root.protos.encoding.AvroSettings.toObject(message.avroSettings, options);
                return object;
            };

            /**
             * Converts this EncodeOptions to JSON.
             * @function toJSON
             * @memberof protos.encoding.EncodeOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EncodeOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EncodeOptions;
        })();

        encoding.DecodeOptions = (function() {

            /**
             * Properties of a DecodeOptions.
             * @memberof protos.encoding
             * @interface IDecodeOptions
             * @property {string|null} [schemaId] DecodeOptions schemaId
             * @property {protos.encoding.DecodeType|null} [decodeType] DecodeOptions decodeType
             * @property {protos.encoding.IProtobufSettings|null} [protobufSettings] DecodeOptions protobufSettings
             * @property {protos.encoding.IAvroSettings|null} [avroSettings] DecodeOptions avroSettings
             */

            /**
             * Constructs a new DecodeOptions.
             * @memberof protos.encoding
             * @classdesc Represents a DecodeOptions.
             * @implements IDecodeOptions
             * @constructor
             * @param {protos.encoding.IDecodeOptions=} [properties] Properties to set
             */
            function DecodeOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DecodeOptions schemaId.
             * @member {string} schemaId
             * @memberof protos.encoding.DecodeOptions
             * @instance
             */
            DecodeOptions.prototype.schemaId = "";

            /**
             * DecodeOptions decodeType.
             * @member {protos.encoding.DecodeType} decodeType
             * @memberof protos.encoding.DecodeOptions
             * @instance
             */
            DecodeOptions.prototype.decodeType = 0;

            /**
             * DecodeOptions protobufSettings.
             * @member {protos.encoding.IProtobufSettings|null|undefined} protobufSettings
             * @memberof protos.encoding.DecodeOptions
             * @instance
             */
            DecodeOptions.prototype.protobufSettings = null;

            /**
             * DecodeOptions avroSettings.
             * @member {protos.encoding.IAvroSettings|null|undefined} avroSettings
             * @memberof protos.encoding.DecodeOptions
             * @instance
             */
            DecodeOptions.prototype.avroSettings = null;

            /**
             * Creates a new DecodeOptions instance using the specified properties.
             * @function create
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {protos.encoding.IDecodeOptions=} [properties] Properties to set
             * @returns {protos.encoding.DecodeOptions} DecodeOptions instance
             */
            DecodeOptions.create = function create(properties) {
                return new DecodeOptions(properties);
            };

            /**
             * Encodes the specified DecodeOptions message. Does not implicitly {@link protos.encoding.DecodeOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {protos.encoding.IDecodeOptions} message DecodeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DecodeOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.schemaId != null && Object.hasOwnProperty.call(message, "schemaId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.schemaId);
                if (message.decodeType != null && Object.hasOwnProperty.call(message, "decodeType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.decodeType);
                if (message.protobufSettings != null && Object.hasOwnProperty.call(message, "protobufSettings"))
                    $root.protos.encoding.ProtobufSettings.encode(message.protobufSettings, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.avroSettings != null && Object.hasOwnProperty.call(message, "avroSettings"))
                    $root.protos.encoding.AvroSettings.encode(message.avroSettings, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DecodeOptions message, length delimited. Does not implicitly {@link protos.encoding.DecodeOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {protos.encoding.IDecodeOptions} message DecodeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DecodeOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DecodeOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.encoding.DecodeOptions} DecodeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DecodeOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.encoding.DecodeOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.schemaId = reader.string();
                        break;
                    case 2:
                        message.decodeType = reader.int32();
                        break;
                    case 3:
                        message.protobufSettings = $root.protos.encoding.ProtobufSettings.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.avroSettings = $root.protos.encoding.AvroSettings.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DecodeOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.encoding.DecodeOptions} DecodeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DecodeOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DecodeOptions message.
             * @function verify
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DecodeOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    if (!$util.isString(message.schemaId))
                        return "schemaId: string expected";
                if (message.decodeType != null && message.hasOwnProperty("decodeType"))
                    switch (message.decodeType) {
                    default:
                        return "decodeType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings")) {
                    let error = $root.protos.encoding.ProtobufSettings.verify(message.protobufSettings);
                    if (error)
                        return "protobufSettings." + error;
                }
                if (message.avroSettings != null && message.hasOwnProperty("avroSettings")) {
                    let error = $root.protos.encoding.AvroSettings.verify(message.avroSettings);
                    if (error)
                        return "avroSettings." + error;
                }
                return null;
            };

            /**
             * Creates a DecodeOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.encoding.DecodeOptions} DecodeOptions
             */
            DecodeOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.encoding.DecodeOptions)
                    return object;
                let message = new $root.protos.encoding.DecodeOptions();
                if (object.schemaId != null)
                    message.schemaId = String(object.schemaId);
                switch (object.decodeType) {
                case "DECODE_TYPE_UNSET":
                case 0:
                    message.decodeType = 0;
                    break;
                case "DECODE_TYPE_PROTOBUF":
                case 1:
                    message.decodeType = 1;
                    break;
                case "DECODE_TYPE_AVRO":
                case 2:
                    message.decodeType = 2;
                    break;
                case "DECODE_TYPE_THRIFT":
                case 3:
                    message.decodeType = 3;
                    break;
                case "DECODE_TYPE_FLATBUFFER":
                case 4:
                    message.decodeType = 4;
                    break;
                }
                if (object.protobufSettings != null) {
                    if (typeof object.protobufSettings !== "object")
                        throw TypeError(".protos.encoding.DecodeOptions.protobufSettings: object expected");
                    message.protobufSettings = $root.protos.encoding.ProtobufSettings.fromObject(object.protobufSettings);
                }
                if (object.avroSettings != null) {
                    if (typeof object.avroSettings !== "object")
                        throw TypeError(".protos.encoding.DecodeOptions.avroSettings: object expected");
                    message.avroSettings = $root.protos.encoding.AvroSettings.fromObject(object.avroSettings);
                }
                return message;
            };

            /**
             * Creates a plain object from a DecodeOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {protos.encoding.DecodeOptions} message DecodeOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DecodeOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.schemaId = "";
                    object.decodeType = options.enums === String ? "DECODE_TYPE_UNSET" : 0;
                    object.protobufSettings = null;
                    object.avroSettings = null;
                }
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    object.schemaId = message.schemaId;
                if (message.decodeType != null && message.hasOwnProperty("decodeType"))
                    object.decodeType = options.enums === String ? $root.protos.encoding.DecodeType[message.decodeType] : message.decodeType;
                if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings"))
                    object.protobufSettings = $root.protos.encoding.ProtobufSettings.toObject(message.protobufSettings, options);
                if (message.avroSettings != null && message.hasOwnProperty("avroSettings"))
                    object.avroSettings = $root.protos.encoding.AvroSettings.toObject(message.avroSettings, options);
                return object;
            };

            /**
             * Converts this DecodeOptions to JSON.
             * @function toJSON
             * @memberof protos.encoding.DecodeOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DecodeOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DecodeOptions;
        })();

        return encoding;
    })();

    protos.opts = (function() {

        /**
         * Namespace opts.
         * @memberof protos
         * @namespace
         */
        const opts = {};

        /**
         * BatchOutputType enum.
         * @name protos.opts.BatchOutputType
         * @enum {number}
         * @property {number} TABLE=0 TABLE value
         * @property {number} JSON=1 JSON value
         */
        opts.BatchOutputType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "TABLE"] = 0;
            values[valuesById[1] = "JSON"] = 1;
            return values;
        })();

        /**
         * BatchReplayType enum.
         * @name protos.opts.BatchReplayType
         * @enum {number}
         * @property {number} SINGLE=0 SINGLE value
         * @property {number} CONTINUOUS=1 CONTINUOUS value
         */
        opts.BatchReplayType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SINGLE"] = 0;
            values[valuesById[1] = "CONTINUOUS"] = 1;
            return values;
        })();

        opts.BatchOptions = (function() {

            /**
             * Properties of a BatchOptions.
             * @memberof protos.opts
             * @interface IBatchOptions
             * @property {protos.opts.BatchOutputType|null} [outputType] BatchOptions outputType
             * @property {string|null} [apiUrl] BatchOptions apiUrl
             * @property {protos.opts.IBatchLoginOptions|null} [login] BatchOptions login
             * @property {protos.opts.IBatchLogoutOptions|null} [logout] BatchOptions logout
             * @property {protos.opts.IBatchListOptions|null} [list] BatchOptions list
             * @property {protos.opts.IBatchCreateOptions|null} [create] BatchOptions create
             * @property {protos.opts.IBatchSearchOptions|null} [search] BatchOptions search
             * @property {protos.opts.IBatchArchiveOptions|null} [archive] BatchOptions archive
             */

            /**
             * Constructs a new BatchOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchOptions.
             * @implements IBatchOptions
             * @constructor
             * @param {protos.opts.IBatchOptions=} [properties] Properties to set
             */
            function BatchOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchOptions outputType.
             * @member {protos.opts.BatchOutputType} outputType
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.outputType = 0;

            /**
             * BatchOptions apiUrl.
             * @member {string} apiUrl
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.apiUrl = "";

            /**
             * BatchOptions login.
             * @member {protos.opts.IBatchLoginOptions|null|undefined} login
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.login = null;

            /**
             * BatchOptions logout.
             * @member {protos.opts.IBatchLogoutOptions|null|undefined} logout
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.logout = null;

            /**
             * BatchOptions list.
             * @member {protos.opts.IBatchListOptions|null|undefined} list
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.list = null;

            /**
             * BatchOptions create.
             * @member {protos.opts.IBatchCreateOptions|null|undefined} create
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.create = null;

            /**
             * BatchOptions search.
             * @member {protos.opts.IBatchSearchOptions|null|undefined} search
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.search = null;

            /**
             * BatchOptions archive.
             * @member {protos.opts.IBatchArchiveOptions|null|undefined} archive
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.archive = null;

            /**
             * Creates a new BatchOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {protos.opts.IBatchOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchOptions} BatchOptions instance
             */
            BatchOptions.create = function create(properties) {
                return new BatchOptions(properties);
            };

            /**
             * Encodes the specified BatchOptions message. Does not implicitly {@link protos.opts.BatchOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {protos.opts.IBatchOptions} message BatchOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.outputType != null && Object.hasOwnProperty.call(message, "outputType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.outputType);
                if (message.apiUrl != null && Object.hasOwnProperty.call(message, "apiUrl"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.apiUrl);
                if (message.login != null && Object.hasOwnProperty.call(message, "login"))
                    $root.protos.opts.BatchLoginOptions.encode(message.login, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.logout != null && Object.hasOwnProperty.call(message, "logout"))
                    $root.protos.opts.BatchLogoutOptions.encode(message.logout, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.list != null && Object.hasOwnProperty.call(message, "list"))
                    $root.protos.opts.BatchListOptions.encode(message.list, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.create != null && Object.hasOwnProperty.call(message, "create"))
                    $root.protos.opts.BatchCreateOptions.encode(message.create, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.search != null && Object.hasOwnProperty.call(message, "search"))
                    $root.protos.opts.BatchSearchOptions.encode(message.search, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.archive != null && Object.hasOwnProperty.call(message, "archive"))
                    $root.protos.opts.BatchArchiveOptions.encode(message.archive, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BatchOptions message, length delimited. Does not implicitly {@link protos.opts.BatchOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {protos.opts.IBatchOptions} message BatchOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchOptions} BatchOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.outputType = reader.int32();
                        break;
                    case 2:
                        message.apiUrl = reader.string();
                        break;
                    case 3:
                        message.login = $root.protos.opts.BatchLoginOptions.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.logout = $root.protos.opts.BatchLogoutOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.list = $root.protos.opts.BatchListOptions.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.create = $root.protos.opts.BatchCreateOptions.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.search = $root.protos.opts.BatchSearchOptions.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.archive = $root.protos.opts.BatchArchiveOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchOptions} BatchOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchOptions message.
             * @function verify
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    switch (message.outputType) {
                    default:
                        return "outputType: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.apiUrl != null && message.hasOwnProperty("apiUrl"))
                    if (!$util.isString(message.apiUrl))
                        return "apiUrl: string expected";
                if (message.login != null && message.hasOwnProperty("login")) {
                    let error = $root.protos.opts.BatchLoginOptions.verify(message.login);
                    if (error)
                        return "login." + error;
                }
                if (message.logout != null && message.hasOwnProperty("logout")) {
                    let error = $root.protos.opts.BatchLogoutOptions.verify(message.logout);
                    if (error)
                        return "logout." + error;
                }
                if (message.list != null && message.hasOwnProperty("list")) {
                    let error = $root.protos.opts.BatchListOptions.verify(message.list);
                    if (error)
                        return "list." + error;
                }
                if (message.create != null && message.hasOwnProperty("create")) {
                    let error = $root.protos.opts.BatchCreateOptions.verify(message.create);
                    if (error)
                        return "create." + error;
                }
                if (message.search != null && message.hasOwnProperty("search")) {
                    let error = $root.protos.opts.BatchSearchOptions.verify(message.search);
                    if (error)
                        return "search." + error;
                }
                if (message.archive != null && message.hasOwnProperty("archive")) {
                    let error = $root.protos.opts.BatchArchiveOptions.verify(message.archive);
                    if (error)
                        return "archive." + error;
                }
                return null;
            };

            /**
             * Creates a BatchOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchOptions} BatchOptions
             */
            BatchOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchOptions)
                    return object;
                let message = new $root.protos.opts.BatchOptions();
                switch (object.outputType) {
                case "TABLE":
                case 0:
                    message.outputType = 0;
                    break;
                case "JSON":
                case 1:
                    message.outputType = 1;
                    break;
                }
                if (object.apiUrl != null)
                    message.apiUrl = String(object.apiUrl);
                if (object.login != null) {
                    if (typeof object.login !== "object")
                        throw TypeError(".protos.opts.BatchOptions.login: object expected");
                    message.login = $root.protos.opts.BatchLoginOptions.fromObject(object.login);
                }
                if (object.logout != null) {
                    if (typeof object.logout !== "object")
                        throw TypeError(".protos.opts.BatchOptions.logout: object expected");
                    message.logout = $root.protos.opts.BatchLogoutOptions.fromObject(object.logout);
                }
                if (object.list != null) {
                    if (typeof object.list !== "object")
                        throw TypeError(".protos.opts.BatchOptions.list: object expected");
                    message.list = $root.protos.opts.BatchListOptions.fromObject(object.list);
                }
                if (object.create != null) {
                    if (typeof object.create !== "object")
                        throw TypeError(".protos.opts.BatchOptions.create: object expected");
                    message.create = $root.protos.opts.BatchCreateOptions.fromObject(object.create);
                }
                if (object.search != null) {
                    if (typeof object.search !== "object")
                        throw TypeError(".protos.opts.BatchOptions.search: object expected");
                    message.search = $root.protos.opts.BatchSearchOptions.fromObject(object.search);
                }
                if (object.archive != null) {
                    if (typeof object.archive !== "object")
                        throw TypeError(".protos.opts.BatchOptions.archive: object expected");
                    message.archive = $root.protos.opts.BatchArchiveOptions.fromObject(object.archive);
                }
                return message;
            };

            /**
             * Creates a plain object from a BatchOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {protos.opts.BatchOptions} message BatchOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.outputType = options.enums === String ? "TABLE" : 0;
                    object.apiUrl = "";
                    object.login = null;
                    object.logout = null;
                    object.list = null;
                    object.create = null;
                    object.search = null;
                    object.archive = null;
                }
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    object.outputType = options.enums === String ? $root.protos.opts.BatchOutputType[message.outputType] : message.outputType;
                if (message.apiUrl != null && message.hasOwnProperty("apiUrl"))
                    object.apiUrl = message.apiUrl;
                if (message.login != null && message.hasOwnProperty("login"))
                    object.login = $root.protos.opts.BatchLoginOptions.toObject(message.login, options);
                if (message.logout != null && message.hasOwnProperty("logout"))
                    object.logout = $root.protos.opts.BatchLogoutOptions.toObject(message.logout, options);
                if (message.list != null && message.hasOwnProperty("list"))
                    object.list = $root.protos.opts.BatchListOptions.toObject(message.list, options);
                if (message.create != null && message.hasOwnProperty("create"))
                    object.create = $root.protos.opts.BatchCreateOptions.toObject(message.create, options);
                if (message.search != null && message.hasOwnProperty("search"))
                    object.search = $root.protos.opts.BatchSearchOptions.toObject(message.search, options);
                if (message.archive != null && message.hasOwnProperty("archive"))
                    object.archive = $root.protos.opts.BatchArchiveOptions.toObject(message.archive, options);
                return object;
            };

            /**
             * Converts this BatchOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchOptions;
        })();

        opts.BatchLoginOptions = (function() {

            /**
             * Properties of a BatchLoginOptions.
             * @memberof protos.opts
             * @interface IBatchLoginOptions
             */

            /**
             * Constructs a new BatchLoginOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchLoginOptions.
             * @implements IBatchLoginOptions
             * @constructor
             * @param {protos.opts.IBatchLoginOptions=} [properties] Properties to set
             */
            function BatchLoginOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new BatchLoginOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {protos.opts.IBatchLoginOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchLoginOptions} BatchLoginOptions instance
             */
            BatchLoginOptions.create = function create(properties) {
                return new BatchLoginOptions(properties);
            };

            /**
             * Encodes the specified BatchLoginOptions message. Does not implicitly {@link protos.opts.BatchLoginOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {protos.opts.IBatchLoginOptions} message BatchLoginOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchLoginOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified BatchLoginOptions message, length delimited. Does not implicitly {@link protos.opts.BatchLoginOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {protos.opts.IBatchLoginOptions} message BatchLoginOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchLoginOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchLoginOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchLoginOptions} BatchLoginOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchLoginOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchLoginOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchLoginOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchLoginOptions} BatchLoginOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchLoginOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchLoginOptions message.
             * @function verify
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchLoginOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a BatchLoginOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchLoginOptions} BatchLoginOptions
             */
            BatchLoginOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchLoginOptions)
                    return object;
                return new $root.protos.opts.BatchLoginOptions();
            };

            /**
             * Creates a plain object from a BatchLoginOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {protos.opts.BatchLoginOptions} message BatchLoginOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchLoginOptions.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this BatchLoginOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchLoginOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchLoginOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchLoginOptions;
        })();

        opts.BatchLogoutOptions = (function() {

            /**
             * Properties of a BatchLogoutOptions.
             * @memberof protos.opts
             * @interface IBatchLogoutOptions
             */

            /**
             * Constructs a new BatchLogoutOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchLogoutOptions.
             * @implements IBatchLogoutOptions
             * @constructor
             * @param {protos.opts.IBatchLogoutOptions=} [properties] Properties to set
             */
            function BatchLogoutOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new BatchLogoutOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {protos.opts.IBatchLogoutOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchLogoutOptions} BatchLogoutOptions instance
             */
            BatchLogoutOptions.create = function create(properties) {
                return new BatchLogoutOptions(properties);
            };

            /**
             * Encodes the specified BatchLogoutOptions message. Does not implicitly {@link protos.opts.BatchLogoutOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {protos.opts.IBatchLogoutOptions} message BatchLogoutOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchLogoutOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified BatchLogoutOptions message, length delimited. Does not implicitly {@link protos.opts.BatchLogoutOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {protos.opts.IBatchLogoutOptions} message BatchLogoutOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchLogoutOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchLogoutOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchLogoutOptions} BatchLogoutOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchLogoutOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchLogoutOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchLogoutOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchLogoutOptions} BatchLogoutOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchLogoutOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchLogoutOptions message.
             * @function verify
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchLogoutOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a BatchLogoutOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchLogoutOptions} BatchLogoutOptions
             */
            BatchLogoutOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchLogoutOptions)
                    return object;
                return new $root.protos.opts.BatchLogoutOptions();
            };

            /**
             * Creates a plain object from a BatchLogoutOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {protos.opts.BatchLogoutOptions} message BatchLogoutOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchLogoutOptions.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this BatchLogoutOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchLogoutOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchLogoutOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchLogoutOptions;
        })();

        opts.BatchArchiveOptions = (function() {

            /**
             * Properties of a BatchArchiveOptions.
             * @memberof protos.opts
             * @interface IBatchArchiveOptions
             * @property {protos.opts.IBatchArchiveReplayOptions|null} [replay] BatchArchiveOptions replay
             */

            /**
             * Constructs a new BatchArchiveOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchArchiveOptions.
             * @implements IBatchArchiveOptions
             * @constructor
             * @param {protos.opts.IBatchArchiveOptions=} [properties] Properties to set
             */
            function BatchArchiveOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchArchiveOptions replay.
             * @member {protos.opts.IBatchArchiveReplayOptions|null|undefined} replay
             * @memberof protos.opts.BatchArchiveOptions
             * @instance
             */
            BatchArchiveOptions.prototype.replay = null;

            /**
             * Creates a new BatchArchiveOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {protos.opts.IBatchArchiveOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchArchiveOptions} BatchArchiveOptions instance
             */
            BatchArchiveOptions.create = function create(properties) {
                return new BatchArchiveOptions(properties);
            };

            /**
             * Encodes the specified BatchArchiveOptions message. Does not implicitly {@link protos.opts.BatchArchiveOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {protos.opts.IBatchArchiveOptions} message BatchArchiveOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchArchiveOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.replay != null && Object.hasOwnProperty.call(message, "replay"))
                    $root.protos.opts.BatchArchiveReplayOptions.encode(message.replay, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BatchArchiveOptions message, length delimited. Does not implicitly {@link protos.opts.BatchArchiveOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {protos.opts.IBatchArchiveOptions} message BatchArchiveOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchArchiveOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchArchiveOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchArchiveOptions} BatchArchiveOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchArchiveOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchArchiveOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.replay = $root.protos.opts.BatchArchiveReplayOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchArchiveOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchArchiveOptions} BatchArchiveOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchArchiveOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchArchiveOptions message.
             * @function verify
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchArchiveOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.replay != null && message.hasOwnProperty("replay")) {
                    let error = $root.protos.opts.BatchArchiveReplayOptions.verify(message.replay);
                    if (error)
                        return "replay." + error;
                }
                return null;
            };

            /**
             * Creates a BatchArchiveOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchArchiveOptions} BatchArchiveOptions
             */
            BatchArchiveOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchArchiveOptions)
                    return object;
                let message = new $root.protos.opts.BatchArchiveOptions();
                if (object.replay != null) {
                    if (typeof object.replay !== "object")
                        throw TypeError(".protos.opts.BatchArchiveOptions.replay: object expected");
                    message.replay = $root.protos.opts.BatchArchiveReplayOptions.fromObject(object.replay);
                }
                return message;
            };

            /**
             * Creates a plain object from a BatchArchiveOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {protos.opts.BatchArchiveOptions} message BatchArchiveOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchArchiveOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.replay = null;
                if (message.replay != null && message.hasOwnProperty("replay"))
                    object.replay = $root.protos.opts.BatchArchiveReplayOptions.toObject(message.replay, options);
                return object;
            };

            /**
             * Converts this BatchArchiveOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchArchiveOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchArchiveOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchArchiveOptions;
        })();

        opts.BatchArchiveReplayOptions = (function() {

            /**
             * Properties of a BatchArchiveReplayOptions.
             * @memberof protos.opts
             * @interface IBatchArchiveReplayOptions
             * @property {string|null} [replayId] BatchArchiveReplayOptions replayId
             */

            /**
             * Constructs a new BatchArchiveReplayOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchArchiveReplayOptions.
             * @implements IBatchArchiveReplayOptions
             * @constructor
             * @param {protos.opts.IBatchArchiveReplayOptions=} [properties] Properties to set
             */
            function BatchArchiveReplayOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchArchiveReplayOptions replayId.
             * @member {string} replayId
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @instance
             */
            BatchArchiveReplayOptions.prototype.replayId = "";

            /**
             * Creates a new BatchArchiveReplayOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {protos.opts.IBatchArchiveReplayOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchArchiveReplayOptions} BatchArchiveReplayOptions instance
             */
            BatchArchiveReplayOptions.create = function create(properties) {
                return new BatchArchiveReplayOptions(properties);
            };

            /**
             * Encodes the specified BatchArchiveReplayOptions message. Does not implicitly {@link protos.opts.BatchArchiveReplayOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {protos.opts.IBatchArchiveReplayOptions} message BatchArchiveReplayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchArchiveReplayOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.replayId != null && Object.hasOwnProperty.call(message, "replayId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.replayId);
                return writer;
            };

            /**
             * Encodes the specified BatchArchiveReplayOptions message, length delimited. Does not implicitly {@link protos.opts.BatchArchiveReplayOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {protos.opts.IBatchArchiveReplayOptions} message BatchArchiveReplayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchArchiveReplayOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchArchiveReplayOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchArchiveReplayOptions} BatchArchiveReplayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchArchiveReplayOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchArchiveReplayOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.replayId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchArchiveReplayOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchArchiveReplayOptions} BatchArchiveReplayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchArchiveReplayOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchArchiveReplayOptions message.
             * @function verify
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchArchiveReplayOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.replayId != null && message.hasOwnProperty("replayId"))
                    if (!$util.isString(message.replayId))
                        return "replayId: string expected";
                return null;
            };

            /**
             * Creates a BatchArchiveReplayOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchArchiveReplayOptions} BatchArchiveReplayOptions
             */
            BatchArchiveReplayOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchArchiveReplayOptions)
                    return object;
                let message = new $root.protos.opts.BatchArchiveReplayOptions();
                if (object.replayId != null)
                    message.replayId = String(object.replayId);
                return message;
            };

            /**
             * Creates a plain object from a BatchArchiveReplayOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {protos.opts.BatchArchiveReplayOptions} message BatchArchiveReplayOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchArchiveReplayOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.replayId = "";
                if (message.replayId != null && message.hasOwnProperty("replayId"))
                    object.replayId = message.replayId;
                return object;
            };

            /**
             * Converts this BatchArchiveReplayOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchArchiveReplayOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchArchiveReplayOptions;
        })();

        opts.BatchListOptions = (function() {

            /**
             * Properties of a BatchListOptions.
             * @memberof protos.opts
             * @interface IBatchListOptions
             * @property {boolean|null} [collection] BatchListOptions collection
             * @property {boolean|null} [destination] BatchListOptions destination
             * @property {boolean|null} [replay] BatchListOptions replay
             * @property {boolean|null} [schema] BatchListOptions schema
             */

            /**
             * Constructs a new BatchListOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchListOptions.
             * @implements IBatchListOptions
             * @constructor
             * @param {protos.opts.IBatchListOptions=} [properties] Properties to set
             */
            function BatchListOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchListOptions collection.
             * @member {boolean} collection
             * @memberof protos.opts.BatchListOptions
             * @instance
             */
            BatchListOptions.prototype.collection = false;

            /**
             * BatchListOptions destination.
             * @member {boolean} destination
             * @memberof protos.opts.BatchListOptions
             * @instance
             */
            BatchListOptions.prototype.destination = false;

            /**
             * BatchListOptions replay.
             * @member {boolean} replay
             * @memberof protos.opts.BatchListOptions
             * @instance
             */
            BatchListOptions.prototype.replay = false;

            /**
             * BatchListOptions schema.
             * @member {boolean} schema
             * @memberof protos.opts.BatchListOptions
             * @instance
             */
            BatchListOptions.prototype.schema = false;

            /**
             * Creates a new BatchListOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {protos.opts.IBatchListOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchListOptions} BatchListOptions instance
             */
            BatchListOptions.create = function create(properties) {
                return new BatchListOptions(properties);
            };

            /**
             * Encodes the specified BatchListOptions message. Does not implicitly {@link protos.opts.BatchListOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {protos.opts.IBatchListOptions} message BatchListOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchListOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.collection);
                if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.destination);
                if (message.replay != null && Object.hasOwnProperty.call(message, "replay"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.replay);
                if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.schema);
                return writer;
            };

            /**
             * Encodes the specified BatchListOptions message, length delimited. Does not implicitly {@link protos.opts.BatchListOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {protos.opts.IBatchListOptions} message BatchListOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchListOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchListOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchListOptions} BatchListOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchListOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchListOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collection = reader.bool();
                        break;
                    case 2:
                        message.destination = reader.bool();
                        break;
                    case 3:
                        message.replay = reader.bool();
                        break;
                    case 4:
                        message.schema = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchListOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchListOptions} BatchListOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchListOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchListOptions message.
             * @function verify
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchListOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (typeof message.collection !== "boolean")
                        return "collection: boolean expected";
                if (message.destination != null && message.hasOwnProperty("destination"))
                    if (typeof message.destination !== "boolean")
                        return "destination: boolean expected";
                if (message.replay != null && message.hasOwnProperty("replay"))
                    if (typeof message.replay !== "boolean")
                        return "replay: boolean expected";
                if (message.schema != null && message.hasOwnProperty("schema"))
                    if (typeof message.schema !== "boolean")
                        return "schema: boolean expected";
                return null;
            };

            /**
             * Creates a BatchListOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchListOptions} BatchListOptions
             */
            BatchListOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchListOptions)
                    return object;
                let message = new $root.protos.opts.BatchListOptions();
                if (object.collection != null)
                    message.collection = Boolean(object.collection);
                if (object.destination != null)
                    message.destination = Boolean(object.destination);
                if (object.replay != null)
                    message.replay = Boolean(object.replay);
                if (object.schema != null)
                    message.schema = Boolean(object.schema);
                return message;
            };

            /**
             * Creates a plain object from a BatchListOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {protos.opts.BatchListOptions} message BatchListOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchListOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.collection = false;
                    object.destination = false;
                    object.replay = false;
                    object.schema = false;
                }
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                if (message.destination != null && message.hasOwnProperty("destination"))
                    object.destination = message.destination;
                if (message.replay != null && message.hasOwnProperty("replay"))
                    object.replay = message.replay;
                if (message.schema != null && message.hasOwnProperty("schema"))
                    object.schema = message.schema;
                return object;
            };

            /**
             * Converts this BatchListOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchListOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchListOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchListOptions;
        })();

        opts.BatchCreateOptions = (function() {

            /**
             * Properties of a BatchCreateOptions.
             * @memberof protos.opts
             * @interface IBatchCreateOptions
             * @property {protos.opts.IBatchCreateCollectionOptions|null} [collection] BatchCreateOptions collection
             * @property {protos.opts.IBatchCreateReplayOptions|null} [replay] BatchCreateOptions replay
             * @property {protos.opts.IBatchCreateDestinationOptions|null} [destination] BatchCreateOptions destination
             */

            /**
             * Constructs a new BatchCreateOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchCreateOptions.
             * @implements IBatchCreateOptions
             * @constructor
             * @param {protos.opts.IBatchCreateOptions=} [properties] Properties to set
             */
            function BatchCreateOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchCreateOptions collection.
             * @member {protos.opts.IBatchCreateCollectionOptions|null|undefined} collection
             * @memberof protos.opts.BatchCreateOptions
             * @instance
             */
            BatchCreateOptions.prototype.collection = null;

            /**
             * BatchCreateOptions replay.
             * @member {protos.opts.IBatchCreateReplayOptions|null|undefined} replay
             * @memberof protos.opts.BatchCreateOptions
             * @instance
             */
            BatchCreateOptions.prototype.replay = null;

            /**
             * BatchCreateOptions destination.
             * @member {protos.opts.IBatchCreateDestinationOptions|null|undefined} destination
             * @memberof protos.opts.BatchCreateOptions
             * @instance
             */
            BatchCreateOptions.prototype.destination = null;

            /**
             * Creates a new BatchCreateOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {protos.opts.IBatchCreateOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchCreateOptions} BatchCreateOptions instance
             */
            BatchCreateOptions.create = function create(properties) {
                return new BatchCreateOptions(properties);
            };

            /**
             * Encodes the specified BatchCreateOptions message. Does not implicitly {@link protos.opts.BatchCreateOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {protos.opts.IBatchCreateOptions} message BatchCreateOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    $root.protos.opts.BatchCreateCollectionOptions.encode(message.collection, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.replay != null && Object.hasOwnProperty.call(message, "replay"))
                    $root.protos.opts.BatchCreateReplayOptions.encode(message.replay, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                    $root.protos.opts.BatchCreateDestinationOptions.encode(message.destination, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BatchCreateOptions message, length delimited. Does not implicitly {@link protos.opts.BatchCreateOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {protos.opts.IBatchCreateOptions} message BatchCreateOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchCreateOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchCreateOptions} BatchCreateOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchCreateOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collection = $root.protos.opts.BatchCreateCollectionOptions.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.replay = $root.protos.opts.BatchCreateReplayOptions.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.destination = $root.protos.opts.BatchCreateDestinationOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchCreateOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchCreateOptions} BatchCreateOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchCreateOptions message.
             * @function verify
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchCreateOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collection != null && message.hasOwnProperty("collection")) {
                    let error = $root.protos.opts.BatchCreateCollectionOptions.verify(message.collection);
                    if (error)
                        return "collection." + error;
                }
                if (message.replay != null && message.hasOwnProperty("replay")) {
                    let error = $root.protos.opts.BatchCreateReplayOptions.verify(message.replay);
                    if (error)
                        return "replay." + error;
                }
                if (message.destination != null && message.hasOwnProperty("destination")) {
                    let error = $root.protos.opts.BatchCreateDestinationOptions.verify(message.destination);
                    if (error)
                        return "destination." + error;
                }
                return null;
            };

            /**
             * Creates a BatchCreateOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchCreateOptions} BatchCreateOptions
             */
            BatchCreateOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchCreateOptions)
                    return object;
                let message = new $root.protos.opts.BatchCreateOptions();
                if (object.collection != null) {
                    if (typeof object.collection !== "object")
                        throw TypeError(".protos.opts.BatchCreateOptions.collection: object expected");
                    message.collection = $root.protos.opts.BatchCreateCollectionOptions.fromObject(object.collection);
                }
                if (object.replay != null) {
                    if (typeof object.replay !== "object")
                        throw TypeError(".protos.opts.BatchCreateOptions.replay: object expected");
                    message.replay = $root.protos.opts.BatchCreateReplayOptions.fromObject(object.replay);
                }
                if (object.destination != null) {
                    if (typeof object.destination !== "object")
                        throw TypeError(".protos.opts.BatchCreateOptions.destination: object expected");
                    message.destination = $root.protos.opts.BatchCreateDestinationOptions.fromObject(object.destination);
                }
                return message;
            };

            /**
             * Creates a plain object from a BatchCreateOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {protos.opts.BatchCreateOptions} message BatchCreateOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchCreateOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.collection = null;
                    object.replay = null;
                    object.destination = null;
                }
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = $root.protos.opts.BatchCreateCollectionOptions.toObject(message.collection, options);
                if (message.replay != null && message.hasOwnProperty("replay"))
                    object.replay = $root.protos.opts.BatchCreateReplayOptions.toObject(message.replay, options);
                if (message.destination != null && message.hasOwnProperty("destination"))
                    object.destination = $root.protos.opts.BatchCreateDestinationOptions.toObject(message.destination, options);
                return object;
            };

            /**
             * Converts this BatchCreateOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchCreateOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchCreateOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchCreateOptions;
        })();

        opts.BatchSearchOptions = (function() {

            /**
             * Properties of a BatchSearchOptions.
             * @memberof protos.opts
             * @interface IBatchSearchOptions
             * @property {string|null} [query] BatchSearchOptions query
             * @property {string|null} [collectionId] BatchSearchOptions collectionId
             * @property {number|null} [page] BatchSearchOptions page
             */

            /**
             * Constructs a new BatchSearchOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchSearchOptions.
             * @implements IBatchSearchOptions
             * @constructor
             * @param {protos.opts.IBatchSearchOptions=} [properties] Properties to set
             */
            function BatchSearchOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchSearchOptions query.
             * @member {string} query
             * @memberof protos.opts.BatchSearchOptions
             * @instance
             */
            BatchSearchOptions.prototype.query = "";

            /**
             * BatchSearchOptions collectionId.
             * @member {string} collectionId
             * @memberof protos.opts.BatchSearchOptions
             * @instance
             */
            BatchSearchOptions.prototype.collectionId = "";

            /**
             * BatchSearchOptions page.
             * @member {number} page
             * @memberof protos.opts.BatchSearchOptions
             * @instance
             */
            BatchSearchOptions.prototype.page = 0;

            /**
             * Creates a new BatchSearchOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {protos.opts.IBatchSearchOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchSearchOptions} BatchSearchOptions instance
             */
            BatchSearchOptions.create = function create(properties) {
                return new BatchSearchOptions(properties);
            };

            /**
             * Encodes the specified BatchSearchOptions message. Does not implicitly {@link protos.opts.BatchSearchOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {protos.opts.IBatchSearchOptions} message BatchSearchOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchSearchOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.query);
                if (message.collectionId != null && Object.hasOwnProperty.call(message, "collectionId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.collectionId);
                if (message.page != null && Object.hasOwnProperty.call(message, "page"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.page);
                return writer;
            };

            /**
             * Encodes the specified BatchSearchOptions message, length delimited. Does not implicitly {@link protos.opts.BatchSearchOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {protos.opts.IBatchSearchOptions} message BatchSearchOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchSearchOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchSearchOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchSearchOptions} BatchSearchOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchSearchOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchSearchOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.query = reader.string();
                        break;
                    case 2:
                        message.collectionId = reader.string();
                        break;
                    case 3:
                        message.page = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchSearchOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchSearchOptions} BatchSearchOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchSearchOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchSearchOptions message.
             * @function verify
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchSearchOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.query != null && message.hasOwnProperty("query"))
                    if (!$util.isString(message.query))
                        return "query: string expected";
                if (message.collectionId != null && message.hasOwnProperty("collectionId"))
                    if (!$util.isString(message.collectionId))
                        return "collectionId: string expected";
                if (message.page != null && message.hasOwnProperty("page"))
                    if (!$util.isInteger(message.page))
                        return "page: integer expected";
                return null;
            };

            /**
             * Creates a BatchSearchOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchSearchOptions} BatchSearchOptions
             */
            BatchSearchOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchSearchOptions)
                    return object;
                let message = new $root.protos.opts.BatchSearchOptions();
                if (object.query != null)
                    message.query = String(object.query);
                if (object.collectionId != null)
                    message.collectionId = String(object.collectionId);
                if (object.page != null)
                    message.page = object.page | 0;
                return message;
            };

            /**
             * Creates a plain object from a BatchSearchOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {protos.opts.BatchSearchOptions} message BatchSearchOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchSearchOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.query = "";
                    object.collectionId = "";
                    object.page = 0;
                }
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = message.query;
                if (message.collectionId != null && message.hasOwnProperty("collectionId"))
                    object.collectionId = message.collectionId;
                if (message.page != null && message.hasOwnProperty("page"))
                    object.page = message.page;
                return object;
            };

            /**
             * Converts this BatchSearchOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchSearchOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchSearchOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchSearchOptions;
        })();

        opts.BatchCreateCollectionOptions = (function() {

            /**
             * Properties of a BatchCreateCollectionOptions.
             * @memberof protos.opts
             * @interface IBatchCreateCollectionOptions
             * @property {string|null} [name] BatchCreateCollectionOptions name
             * @property {string|null} [schemaId] BatchCreateCollectionOptions schemaId
             * @property {string|null} [notes] BatchCreateCollectionOptions notes
             */

            /**
             * Constructs a new BatchCreateCollectionOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchCreateCollectionOptions.
             * @implements IBatchCreateCollectionOptions
             * @constructor
             * @param {protos.opts.IBatchCreateCollectionOptions=} [properties] Properties to set
             */
            function BatchCreateCollectionOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchCreateCollectionOptions name.
             * @member {string} name
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @instance
             */
            BatchCreateCollectionOptions.prototype.name = "";

            /**
             * BatchCreateCollectionOptions schemaId.
             * @member {string} schemaId
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @instance
             */
            BatchCreateCollectionOptions.prototype.schemaId = "";

            /**
             * BatchCreateCollectionOptions notes.
             * @member {string} notes
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @instance
             */
            BatchCreateCollectionOptions.prototype.notes = "";

            /**
             * Creates a new BatchCreateCollectionOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {protos.opts.IBatchCreateCollectionOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchCreateCollectionOptions} BatchCreateCollectionOptions instance
             */
            BatchCreateCollectionOptions.create = function create(properties) {
                return new BatchCreateCollectionOptions(properties);
            };

            /**
             * Encodes the specified BatchCreateCollectionOptions message. Does not implicitly {@link protos.opts.BatchCreateCollectionOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {protos.opts.IBatchCreateCollectionOptions} message BatchCreateCollectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateCollectionOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.schemaId != null && Object.hasOwnProperty.call(message, "schemaId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.schemaId);
                if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.notes);
                return writer;
            };

            /**
             * Encodes the specified BatchCreateCollectionOptions message, length delimited. Does not implicitly {@link protos.opts.BatchCreateCollectionOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {protos.opts.IBatchCreateCollectionOptions} message BatchCreateCollectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateCollectionOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchCreateCollectionOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchCreateCollectionOptions} BatchCreateCollectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateCollectionOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchCreateCollectionOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.schemaId = reader.string();
                        break;
                    case 3:
                        message.notes = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchCreateCollectionOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchCreateCollectionOptions} BatchCreateCollectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateCollectionOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchCreateCollectionOptions message.
             * @function verify
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchCreateCollectionOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    if (!$util.isString(message.schemaId))
                        return "schemaId: string expected";
                if (message.notes != null && message.hasOwnProperty("notes"))
                    if (!$util.isString(message.notes))
                        return "notes: string expected";
                return null;
            };

            /**
             * Creates a BatchCreateCollectionOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchCreateCollectionOptions} BatchCreateCollectionOptions
             */
            BatchCreateCollectionOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchCreateCollectionOptions)
                    return object;
                let message = new $root.protos.opts.BatchCreateCollectionOptions();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.schemaId != null)
                    message.schemaId = String(object.schemaId);
                if (object.notes != null)
                    message.notes = String(object.notes);
                return message;
            };

            /**
             * Creates a plain object from a BatchCreateCollectionOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {protos.opts.BatchCreateCollectionOptions} message BatchCreateCollectionOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchCreateCollectionOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.schemaId = "";
                    object.notes = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    object.schemaId = message.schemaId;
                if (message.notes != null && message.hasOwnProperty("notes"))
                    object.notes = message.notes;
                return object;
            };

            /**
             * Converts this BatchCreateCollectionOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchCreateCollectionOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchCreateCollectionOptions;
        })();

        opts.BatchCreateReplayOptions = (function() {

            /**
             * Properties of a BatchCreateReplayOptions.
             * @memberof protos.opts
             * @interface IBatchCreateReplayOptions
             * @property {string|null} [name] BatchCreateReplayOptions name
             * @property {protos.opts.BatchReplayType|null} [type] BatchCreateReplayOptions type
             * @property {string|null} [notes] BatchCreateReplayOptions notes
             * @property {string|null} [collectionId] BatchCreateReplayOptions collectionId
             * @property {string|null} [destinationId] BatchCreateReplayOptions destinationId
             * @property {string|null} [query] BatchCreateReplayOptions query
             * @property {string|null} [fromTimestamp] BatchCreateReplayOptions fromTimestamp
             * @property {string|null} [toTimestamp] BatchCreateReplayOptions toTimestamp
             */

            /**
             * Constructs a new BatchCreateReplayOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchCreateReplayOptions.
             * @implements IBatchCreateReplayOptions
             * @constructor
             * @param {protos.opts.IBatchCreateReplayOptions=} [properties] Properties to set
             */
            function BatchCreateReplayOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchCreateReplayOptions name.
             * @member {string} name
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.name = "";

            /**
             * BatchCreateReplayOptions type.
             * @member {protos.opts.BatchReplayType} type
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.type = 0;

            /**
             * BatchCreateReplayOptions notes.
             * @member {string} notes
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.notes = "";

            /**
             * BatchCreateReplayOptions collectionId.
             * @member {string} collectionId
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.collectionId = "";

            /**
             * BatchCreateReplayOptions destinationId.
             * @member {string} destinationId
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.destinationId = "";

            /**
             * BatchCreateReplayOptions query.
             * @member {string} query
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.query = "";

            /**
             * BatchCreateReplayOptions fromTimestamp.
             * @member {string} fromTimestamp
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.fromTimestamp = "";

            /**
             * BatchCreateReplayOptions toTimestamp.
             * @member {string} toTimestamp
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.toTimestamp = "";

            /**
             * Creates a new BatchCreateReplayOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {protos.opts.IBatchCreateReplayOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchCreateReplayOptions} BatchCreateReplayOptions instance
             */
            BatchCreateReplayOptions.create = function create(properties) {
                return new BatchCreateReplayOptions(properties);
            };

            /**
             * Encodes the specified BatchCreateReplayOptions message. Does not implicitly {@link protos.opts.BatchCreateReplayOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {protos.opts.IBatchCreateReplayOptions} message BatchCreateReplayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateReplayOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.notes);
                if (message.collectionId != null && Object.hasOwnProperty.call(message, "collectionId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.collectionId);
                if (message.destinationId != null && Object.hasOwnProperty.call(message, "destinationId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.destinationId);
                if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.query);
                if (message.fromTimestamp != null && Object.hasOwnProperty.call(message, "fromTimestamp"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.fromTimestamp);
                if (message.toTimestamp != null && Object.hasOwnProperty.call(message, "toTimestamp"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.toTimestamp);
                return writer;
            };

            /**
             * Encodes the specified BatchCreateReplayOptions message, length delimited. Does not implicitly {@link protos.opts.BatchCreateReplayOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {protos.opts.IBatchCreateReplayOptions} message BatchCreateReplayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateReplayOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchCreateReplayOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchCreateReplayOptions} BatchCreateReplayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateReplayOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchCreateReplayOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.notes = reader.string();
                        break;
                    case 4:
                        message.collectionId = reader.string();
                        break;
                    case 5:
                        message.destinationId = reader.string();
                        break;
                    case 6:
                        message.query = reader.string();
                        break;
                    case 7:
                        message.fromTimestamp = reader.string();
                        break;
                    case 8:
                        message.toTimestamp = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchCreateReplayOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchCreateReplayOptions} BatchCreateReplayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateReplayOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchCreateReplayOptions message.
             * @function verify
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchCreateReplayOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.notes != null && message.hasOwnProperty("notes"))
                    if (!$util.isString(message.notes))
                        return "notes: string expected";
                if (message.collectionId != null && message.hasOwnProperty("collectionId"))
                    if (!$util.isString(message.collectionId))
                        return "collectionId: string expected";
                if (message.destinationId != null && message.hasOwnProperty("destinationId"))
                    if (!$util.isString(message.destinationId))
                        return "destinationId: string expected";
                if (message.query != null && message.hasOwnProperty("query"))
                    if (!$util.isString(message.query))
                        return "query: string expected";
                if (message.fromTimestamp != null && message.hasOwnProperty("fromTimestamp"))
                    if (!$util.isString(message.fromTimestamp))
                        return "fromTimestamp: string expected";
                if (message.toTimestamp != null && message.hasOwnProperty("toTimestamp"))
                    if (!$util.isString(message.toTimestamp))
                        return "toTimestamp: string expected";
                return null;
            };

            /**
             * Creates a BatchCreateReplayOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchCreateReplayOptions} BatchCreateReplayOptions
             */
            BatchCreateReplayOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchCreateReplayOptions)
                    return object;
                let message = new $root.protos.opts.BatchCreateReplayOptions();
                if (object.name != null)
                    message.name = String(object.name);
                switch (object.type) {
                case "SINGLE":
                case 0:
                    message.type = 0;
                    break;
                case "CONTINUOUS":
                case 1:
                    message.type = 1;
                    break;
                }
                if (object.notes != null)
                    message.notes = String(object.notes);
                if (object.collectionId != null)
                    message.collectionId = String(object.collectionId);
                if (object.destinationId != null)
                    message.destinationId = String(object.destinationId);
                if (object.query != null)
                    message.query = String(object.query);
                if (object.fromTimestamp != null)
                    message.fromTimestamp = String(object.fromTimestamp);
                if (object.toTimestamp != null)
                    message.toTimestamp = String(object.toTimestamp);
                return message;
            };

            /**
             * Creates a plain object from a BatchCreateReplayOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {protos.opts.BatchCreateReplayOptions} message BatchCreateReplayOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchCreateReplayOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.type = options.enums === String ? "SINGLE" : 0;
                    object.notes = "";
                    object.collectionId = "";
                    object.destinationId = "";
                    object.query = "";
                    object.fromTimestamp = "";
                    object.toTimestamp = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.protos.opts.BatchReplayType[message.type] : message.type;
                if (message.notes != null && message.hasOwnProperty("notes"))
                    object.notes = message.notes;
                if (message.collectionId != null && message.hasOwnProperty("collectionId"))
                    object.collectionId = message.collectionId;
                if (message.destinationId != null && message.hasOwnProperty("destinationId"))
                    object.destinationId = message.destinationId;
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = message.query;
                if (message.fromTimestamp != null && message.hasOwnProperty("fromTimestamp"))
                    object.fromTimestamp = message.fromTimestamp;
                if (message.toTimestamp != null && message.hasOwnProperty("toTimestamp"))
                    object.toTimestamp = message.toTimestamp;
                return object;
            };

            /**
             * Converts this BatchCreateReplayOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchCreateReplayOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchCreateReplayOptions;
        })();

        opts.BatchCreateDestinationOptions = (function() {

            /**
             * Properties of a BatchCreateDestinationOptions.
             * @memberof protos.opts
             * @interface IBatchCreateDestinationOptions
             * @property {string|null} [name] BatchCreateDestinationOptions name
             * @property {string|null} [notes] BatchCreateDestinationOptions notes
             * @property {string|null} [_apiDestinationType] BatchCreateDestinationOptions _apiDestinationType
             * @property {protos.opts.IWriteGroupKafkaOptions|null} [kafka] BatchCreateDestinationOptions kafka
             * @property {protos.opts.IWriteGroupRabbitOptions|null} [rabbit] BatchCreateDestinationOptions rabbit
             * @property {protos.opts.IWriteGroupKubeMQQueueOptions|null} [kubemqQueue] BatchCreateDestinationOptions kubemqQueue
             * @property {protos.opts.IWriteGroupAWSSQSOptions|null} [awssqs] BatchCreateDestinationOptions awssqs
             * @property {protos.opts.IHTTPDestination|null} [http] BatchCreateDestinationOptions http
             */

            /**
             * Constructs a new BatchCreateDestinationOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchCreateDestinationOptions.
             * @implements IBatchCreateDestinationOptions
             * @constructor
             * @param {protos.opts.IBatchCreateDestinationOptions=} [properties] Properties to set
             */
            function BatchCreateDestinationOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchCreateDestinationOptions name.
             * @member {string} name
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype.name = "";

            /**
             * BatchCreateDestinationOptions notes.
             * @member {string} notes
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype.notes = "";

            /**
             * BatchCreateDestinationOptions _apiDestinationType.
             * @member {string} _apiDestinationType
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype._apiDestinationType = "";

            /**
             * BatchCreateDestinationOptions kafka.
             * @member {protos.opts.IWriteGroupKafkaOptions|null|undefined} kafka
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype.kafka = null;

            /**
             * BatchCreateDestinationOptions rabbit.
             * @member {protos.opts.IWriteGroupRabbitOptions|null|undefined} rabbit
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype.rabbit = null;

            /**
             * BatchCreateDestinationOptions kubemqQueue.
             * @member {protos.opts.IWriteGroupKubeMQQueueOptions|null|undefined} kubemqQueue
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype.kubemqQueue = null;

            /**
             * BatchCreateDestinationOptions awssqs.
             * @member {protos.opts.IWriteGroupAWSSQSOptions|null|undefined} awssqs
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype.awssqs = null;

            /**
             * BatchCreateDestinationOptions http.
             * @member {protos.opts.IHTTPDestination|null|undefined} http
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype.http = null;

            /**
             * Creates a new BatchCreateDestinationOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {protos.opts.IBatchCreateDestinationOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchCreateDestinationOptions} BatchCreateDestinationOptions instance
             */
            BatchCreateDestinationOptions.create = function create(properties) {
                return new BatchCreateDestinationOptions(properties);
            };

            /**
             * Encodes the specified BatchCreateDestinationOptions message. Does not implicitly {@link protos.opts.BatchCreateDestinationOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {protos.opts.IBatchCreateDestinationOptions} message BatchCreateDestinationOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateDestinationOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.notes);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.opts.WriteGroupKafkaOptions.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.opts.WriteGroupRabbitOptions.encode(message.rabbit, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.opts.WriteGroupKubeMQQueueOptions.encode(message.kubemqQueue, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.awssqs != null && Object.hasOwnProperty.call(message, "awssqs"))
                    $root.protos.opts.WriteGroupAWSSQSOptions.encode(message.awssqs, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.http != null && Object.hasOwnProperty.call(message, "http"))
                    $root.protos.opts.HTTPDestination.encode(message.http, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message._apiDestinationType != null && Object.hasOwnProperty.call(message, "_apiDestinationType"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._apiDestinationType);
                return writer;
            };

            /**
             * Encodes the specified BatchCreateDestinationOptions message, length delimited. Does not implicitly {@link protos.opts.BatchCreateDestinationOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {protos.opts.IBatchCreateDestinationOptions} message BatchCreateDestinationOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateDestinationOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchCreateDestinationOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchCreateDestinationOptions} BatchCreateDestinationOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateDestinationOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchCreateDestinationOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.notes = reader.string();
                        break;
                    case 1000:
                        message._apiDestinationType = reader.string();
                        break;
                    case 100:
                        message.kafka = $root.protos.opts.WriteGroupKafkaOptions.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.rabbit = $root.protos.opts.WriteGroupRabbitOptions.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.awssqs = $root.protos.opts.WriteGroupAWSSQSOptions.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.http = $root.protos.opts.HTTPDestination.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchCreateDestinationOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchCreateDestinationOptions} BatchCreateDestinationOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateDestinationOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchCreateDestinationOptions message.
             * @function verify
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchCreateDestinationOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.notes != null && message.hasOwnProperty("notes"))
                    if (!$util.isString(message.notes))
                        return "notes: string expected";
                if (message._apiDestinationType != null && message.hasOwnProperty("_apiDestinationType"))
                    if (!$util.isString(message._apiDestinationType))
                        return "_apiDestinationType: string expected";
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    let error = $root.protos.opts.WriteGroupKafkaOptions.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    let error = $root.protos.opts.WriteGroupRabbitOptions.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    let error = $root.protos.opts.WriteGroupKubeMQQueueOptions.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.awssqs != null && message.hasOwnProperty("awssqs")) {
                    let error = $root.protos.opts.WriteGroupAWSSQSOptions.verify(message.awssqs);
                    if (error)
                        return "awssqs." + error;
                }
                if (message.http != null && message.hasOwnProperty("http")) {
                    let error = $root.protos.opts.HTTPDestination.verify(message.http);
                    if (error)
                        return "http." + error;
                }
                return null;
            };

            /**
             * Creates a BatchCreateDestinationOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchCreateDestinationOptions} BatchCreateDestinationOptions
             */
            BatchCreateDestinationOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchCreateDestinationOptions)
                    return object;
                let message = new $root.protos.opts.BatchCreateDestinationOptions();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.notes != null)
                    message.notes = String(object.notes);
                if (object._apiDestinationType != null)
                    message._apiDestinationType = String(object._apiDestinationType);
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.BatchCreateDestinationOptions.kafka: object expected");
                    message.kafka = $root.protos.opts.WriteGroupKafkaOptions.fromObject(object.kafka);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.BatchCreateDestinationOptions.rabbit: object expected");
                    message.rabbit = $root.protos.opts.WriteGroupRabbitOptions.fromObject(object.rabbit);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.BatchCreateDestinationOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.fromObject(object.kubemqQueue);
                }
                if (object.awssqs != null) {
                    if (typeof object.awssqs !== "object")
                        throw TypeError(".protos.opts.BatchCreateDestinationOptions.awssqs: object expected");
                    message.awssqs = $root.protos.opts.WriteGroupAWSSQSOptions.fromObject(object.awssqs);
                }
                if (object.http != null) {
                    if (typeof object.http !== "object")
                        throw TypeError(".protos.opts.BatchCreateDestinationOptions.http: object expected");
                    message.http = $root.protos.opts.HTTPDestination.fromObject(object.http);
                }
                return message;
            };

            /**
             * Creates a plain object from a BatchCreateDestinationOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {protos.opts.BatchCreateDestinationOptions} message BatchCreateDestinationOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchCreateDestinationOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.notes = "";
                    object.kafka = null;
                    object.rabbit = null;
                    object.kubemqQueue = null;
                    object.awssqs = null;
                    object.http = null;
                    object._apiDestinationType = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.notes != null && message.hasOwnProperty("notes"))
                    object.notes = message.notes;
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.opts.WriteGroupKafkaOptions.toObject(message.kafka, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.opts.WriteGroupRabbitOptions.toObject(message.rabbit, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.toObject(message.kubemqQueue, options);
                if (message.awssqs != null && message.hasOwnProperty("awssqs"))
                    object.awssqs = $root.protos.opts.WriteGroupAWSSQSOptions.toObject(message.awssqs, options);
                if (message.http != null && message.hasOwnProperty("http"))
                    object.http = $root.protos.opts.HTTPDestination.toObject(message.http, options);
                if (message._apiDestinationType != null && message.hasOwnProperty("_apiDestinationType"))
                    object._apiDestinationType = message._apiDestinationType;
                return object;
            };

            /**
             * Converts this BatchCreateDestinationOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchCreateDestinationOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchCreateDestinationOptions;
        })();

        opts.HTTPDestination = (function() {

            /**
             * Properties of a HTTPDestination.
             * @memberof protos.opts
             * @interface IHTTPDestination
             * @property {string|null} [url] HTTPDestination url
             * @property {Object.<string,string>|null} [headers] HTTPDestination headers
             */

            /**
             * Constructs a new HTTPDestination.
             * @memberof protos.opts
             * @classdesc Represents a HTTPDestination.
             * @implements IHTTPDestination
             * @constructor
             * @param {protos.opts.IHTTPDestination=} [properties] Properties to set
             */
            function HTTPDestination(properties) {
                this.headers = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HTTPDestination url.
             * @member {string} url
             * @memberof protos.opts.HTTPDestination
             * @instance
             */
            HTTPDestination.prototype.url = "";

            /**
             * HTTPDestination headers.
             * @member {Object.<string,string>} headers
             * @memberof protos.opts.HTTPDestination
             * @instance
             */
            HTTPDestination.prototype.headers = $util.emptyObject;

            /**
             * Creates a new HTTPDestination instance using the specified properties.
             * @function create
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {protos.opts.IHTTPDestination=} [properties] Properties to set
             * @returns {protos.opts.HTTPDestination} HTTPDestination instance
             */
            HTTPDestination.create = function create(properties) {
                return new HTTPDestination(properties);
            };

            /**
             * Encodes the specified HTTPDestination message. Does not implicitly {@link protos.opts.HTTPDestination.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {protos.opts.IHTTPDestination} message HTTPDestination message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HTTPDestination.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.headers != null && Object.hasOwnProperty.call(message, "headers"))
                    for (let keys = Object.keys(message.headers), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.headers[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified HTTPDestination message, length delimited. Does not implicitly {@link protos.opts.HTTPDestination.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {protos.opts.IHTTPDestination} message HTTPDestination message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HTTPDestination.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HTTPDestination message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.HTTPDestination} HTTPDestination
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HTTPDestination.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.HTTPDestination(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.url = reader.string();
                        break;
                    case 2:
                        if (message.headers === $util.emptyObject)
                            message.headers = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.headers[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HTTPDestination message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.HTTPDestination} HTTPDestination
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HTTPDestination.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HTTPDestination message.
             * @function verify
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HTTPDestination.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    if (!$util.isObject(message.headers))
                        return "headers: object expected";
                    let key = Object.keys(message.headers);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isString(message.headers[key[i]]))
                            return "headers: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a HTTPDestination message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.HTTPDestination} HTTPDestination
             */
            HTTPDestination.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.HTTPDestination)
                    return object;
                let message = new $root.protos.opts.HTTPDestination();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.headers) {
                    if (typeof object.headers !== "object")
                        throw TypeError(".protos.opts.HTTPDestination.headers: object expected");
                    message.headers = {};
                    for (let keys = Object.keys(object.headers), i = 0; i < keys.length; ++i)
                        message.headers[keys[i]] = String(object.headers[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a HTTPDestination message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {protos.opts.HTTPDestination} message HTTPDestination
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HTTPDestination.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults)
                    object.headers = {};
                if (options.defaults)
                    object.url = "";
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                let keys2;
                if (message.headers && (keys2 = Object.keys(message.headers)).length) {
                    object.headers = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.headers[keys2[j]] = message.headers[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this HTTPDestination to JSON.
             * @function toJSON
             * @memberof protos.opts.HTTPDestination
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HTTPDestination.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HTTPDestination;
        })();

        opts.WriteCLIOptions = (function() {

            /**
             * Properties of a WriteCLIOptions.
             * @memberof protos.opts
             * @interface IWriteCLIOptions
             * @property {string|null} [inputFile] WriteCLIOptions inputFile
             * @property {boolean|null} [inputAsJsonArray] WriteCLIOptions inputAsJsonArray
             * @property {Array.<string>|null} [inputStdin] WriteCLIOptions inputStdin
             */

            /**
             * Constructs a new WriteCLIOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteCLIOptions.
             * @implements IWriteCLIOptions
             * @constructor
             * @param {protos.opts.IWriteCLIOptions=} [properties] Properties to set
             */
            function WriteCLIOptions(properties) {
                this.inputStdin = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteCLIOptions inputFile.
             * @member {string} inputFile
             * @memberof protos.opts.WriteCLIOptions
             * @instance
             */
            WriteCLIOptions.prototype.inputFile = "";

            /**
             * WriteCLIOptions inputAsJsonArray.
             * @member {boolean} inputAsJsonArray
             * @memberof protos.opts.WriteCLIOptions
             * @instance
             */
            WriteCLIOptions.prototype.inputAsJsonArray = false;

            /**
             * WriteCLIOptions inputStdin.
             * @member {Array.<string>} inputStdin
             * @memberof protos.opts.WriteCLIOptions
             * @instance
             */
            WriteCLIOptions.prototype.inputStdin = $util.emptyArray;

            /**
             * Creates a new WriteCLIOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {protos.opts.IWriteCLIOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteCLIOptions} WriteCLIOptions instance
             */
            WriteCLIOptions.create = function create(properties) {
                return new WriteCLIOptions(properties);
            };

            /**
             * Encodes the specified WriteCLIOptions message. Does not implicitly {@link protos.opts.WriteCLIOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {protos.opts.IWriteCLIOptions} message WriteCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteCLIOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.inputFile != null && Object.hasOwnProperty.call(message, "inputFile"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.inputFile);
                if (message.inputAsJsonArray != null && Object.hasOwnProperty.call(message, "inputAsJsonArray"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.inputAsJsonArray);
                if (message.inputStdin != null && message.inputStdin.length)
                    for (let i = 0; i < message.inputStdin.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.inputStdin[i]);
                return writer;
            };

            /**
             * Encodes the specified WriteCLIOptions message, length delimited. Does not implicitly {@link protos.opts.WriteCLIOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {protos.opts.IWriteCLIOptions} message WriteCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteCLIOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteCLIOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteCLIOptions} WriteCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteCLIOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteCLIOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.inputFile = reader.string();
                        break;
                    case 2:
                        message.inputAsJsonArray = reader.bool();
                        break;
                    case 3:
                        if (!(message.inputStdin && message.inputStdin.length))
                            message.inputStdin = [];
                        message.inputStdin.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteCLIOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteCLIOptions} WriteCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteCLIOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteCLIOptions message.
             * @function verify
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteCLIOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.inputFile != null && message.hasOwnProperty("inputFile"))
                    if (!$util.isString(message.inputFile))
                        return "inputFile: string expected";
                if (message.inputAsJsonArray != null && message.hasOwnProperty("inputAsJsonArray"))
                    if (typeof message.inputAsJsonArray !== "boolean")
                        return "inputAsJsonArray: boolean expected";
                if (message.inputStdin != null && message.hasOwnProperty("inputStdin")) {
                    if (!Array.isArray(message.inputStdin))
                        return "inputStdin: array expected";
                    for (let i = 0; i < message.inputStdin.length; ++i)
                        if (!$util.isString(message.inputStdin[i]))
                            return "inputStdin: string[] expected";
                }
                return null;
            };

            /**
             * Creates a WriteCLIOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteCLIOptions} WriteCLIOptions
             */
            WriteCLIOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteCLIOptions)
                    return object;
                let message = new $root.protos.opts.WriteCLIOptions();
                if (object.inputFile != null)
                    message.inputFile = String(object.inputFile);
                if (object.inputAsJsonArray != null)
                    message.inputAsJsonArray = Boolean(object.inputAsJsonArray);
                if (object.inputStdin) {
                    if (!Array.isArray(object.inputStdin))
                        throw TypeError(".protos.opts.WriteCLIOptions.inputStdin: array expected");
                    message.inputStdin = [];
                    for (let i = 0; i < object.inputStdin.length; ++i)
                        message.inputStdin[i] = String(object.inputStdin[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteCLIOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {protos.opts.WriteCLIOptions} message WriteCLIOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteCLIOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.inputStdin = [];
                if (options.defaults) {
                    object.inputFile = "";
                    object.inputAsJsonArray = false;
                }
                if (message.inputFile != null && message.hasOwnProperty("inputFile"))
                    object.inputFile = message.inputFile;
                if (message.inputAsJsonArray != null && message.hasOwnProperty("inputAsJsonArray"))
                    object.inputAsJsonArray = message.inputAsJsonArray;
                if (message.inputStdin && message.inputStdin.length) {
                    object.inputStdin = [];
                    for (let j = 0; j < message.inputStdin.length; ++j)
                        object.inputStdin[j] = message.inputStdin[j];
                }
                return object;
            };

            /**
             * Converts this WriteCLIOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteCLIOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteCLIOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteCLIOptions;
        })();

        opts.WriteOptions = (function() {

            /**
             * Properties of a WriteOptions.
             * @memberof protos.opts
             * @interface IWriteOptions
             * @property {string|null} [connectionId] WriteOptions connectionId
             * @property {protos.records.IWriteRecord|null} [record] WriteOptions record
             * @property {protos.encoding.IEncodeOptions|null} [encodeOptions] WriteOptions encodeOptions
             * @property {protos.opts.IWriteCLIOptions|null} [_cliOptions] WriteOptions _cliOptions
             * @property {protos.opts.IWriteGroupKafkaOptions|null} [kafka] WriteOptions kafka
             * @property {protos.opts.IWriteGroupActiveMQOptions|null} [activemq] WriteOptions activemq
             * @property {protos.opts.IWriteGroupAWSSQSOptions|null} [awssqs] WriteOptions awssqs
             * @property {protos.opts.IWriteGroupAWSSNSOptions|null} [awssns] WriteOptions awssns
             * @property {protos.opts.IWriteGroupNatsOptions|null} [nats] WriteOptions nats
             * @property {protos.opts.IWriteGroupNatsStreamingOptions|null} [natsStreaming] WriteOptions natsStreaming
             * @property {protos.opts.IWriteGroupNSQOptions|null} [nsq] WriteOptions nsq
             * @property {protos.opts.IWriteGroupPulsarOptions|null} [pulsar] WriteOptions pulsar
             * @property {protos.opts.IWriteGroupRabbitOptions|null} [rabbit] WriteOptions rabbit
             * @property {protos.opts.IWriteGroupRabbitStreamsOptions|null} [rabbitStreams] WriteOptions rabbitStreams
             * @property {protos.opts.IWriteGroupMQTTOptions|null} [mqtt] WriteOptions mqtt
             * @property {protos.opts.IWriteGroupAzureServiceBusOptions|null} [azureServiceBus] WriteOptions azureServiceBus
             * @property {protos.opts.IWriteGroupAzureEventHubOptions|null} [azureEventHub] WriteOptions azureEventHub
             * @property {protos.opts.IWriteGroupGCPPubSubOptions|null} [gcpPubsub] WriteOptions gcpPubsub
             * @property {protos.opts.IWriteGroupKubeMQQueueOptions|null} [kubemqQueue] WriteOptions kubemqQueue
             * @property {protos.opts.IWriteGroupRedisPubSubOptions|null} [redisPubsub] WriteOptions redisPubsub
             * @property {protos.opts.IWriteGroupRedisStreamsOptions|null} [redisStreams] WriteOptions redisStreams
             */

            /**
             * Constructs a new WriteOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteOptions.
             * @implements IWriteOptions
             * @constructor
             * @param {protos.opts.IWriteOptions=} [properties] Properties to set
             */
            function WriteOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteOptions connectionId.
             * @member {string} connectionId
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.connectionId = "";

            /**
             * WriteOptions record.
             * @member {protos.records.IWriteRecord|null|undefined} record
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.record = null;

            /**
             * WriteOptions encodeOptions.
             * @member {protos.encoding.IEncodeOptions|null|undefined} encodeOptions
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.encodeOptions = null;

            /**
             * WriteOptions _cliOptions.
             * @member {protos.opts.IWriteCLIOptions|null|undefined} _cliOptions
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype._cliOptions = null;

            /**
             * WriteOptions kafka.
             * @member {protos.opts.IWriteGroupKafkaOptions|null|undefined} kafka
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.kafka = null;

            /**
             * WriteOptions activemq.
             * @member {protos.opts.IWriteGroupActiveMQOptions|null|undefined} activemq
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.activemq = null;

            /**
             * WriteOptions awssqs.
             * @member {protos.opts.IWriteGroupAWSSQSOptions|null|undefined} awssqs
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.awssqs = null;

            /**
             * WriteOptions awssns.
             * @member {protos.opts.IWriteGroupAWSSNSOptions|null|undefined} awssns
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.awssns = null;

            /**
             * WriteOptions nats.
             * @member {protos.opts.IWriteGroupNatsOptions|null|undefined} nats
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.nats = null;

            /**
             * WriteOptions natsStreaming.
             * @member {protos.opts.IWriteGroupNatsStreamingOptions|null|undefined} natsStreaming
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.natsStreaming = null;

            /**
             * WriteOptions nsq.
             * @member {protos.opts.IWriteGroupNSQOptions|null|undefined} nsq
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.nsq = null;

            /**
             * WriteOptions pulsar.
             * @member {protos.opts.IWriteGroupPulsarOptions|null|undefined} pulsar
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.pulsar = null;

            /**
             * WriteOptions rabbit.
             * @member {protos.opts.IWriteGroupRabbitOptions|null|undefined} rabbit
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.rabbit = null;

            /**
             * WriteOptions rabbitStreams.
             * @member {protos.opts.IWriteGroupRabbitStreamsOptions|null|undefined} rabbitStreams
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.rabbitStreams = null;

            /**
             * WriteOptions mqtt.
             * @member {protos.opts.IWriteGroupMQTTOptions|null|undefined} mqtt
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.mqtt = null;

            /**
             * WriteOptions azureServiceBus.
             * @member {protos.opts.IWriteGroupAzureServiceBusOptions|null|undefined} azureServiceBus
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.azureServiceBus = null;

            /**
             * WriteOptions azureEventHub.
             * @member {protos.opts.IWriteGroupAzureEventHubOptions|null|undefined} azureEventHub
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.azureEventHub = null;

            /**
             * WriteOptions gcpPubsub.
             * @member {protos.opts.IWriteGroupGCPPubSubOptions|null|undefined} gcpPubsub
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.gcpPubsub = null;

            /**
             * WriteOptions kubemqQueue.
             * @member {protos.opts.IWriteGroupKubeMQQueueOptions|null|undefined} kubemqQueue
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.kubemqQueue = null;

            /**
             * WriteOptions redisPubsub.
             * @member {protos.opts.IWriteGroupRedisPubSubOptions|null|undefined} redisPubsub
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.redisPubsub = null;

            /**
             * WriteOptions redisStreams.
             * @member {protos.opts.IWriteGroupRedisStreamsOptions|null|undefined} redisStreams
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.redisStreams = null;

            /**
             * Creates a new WriteOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {protos.opts.IWriteOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteOptions} WriteOptions instance
             */
            WriteOptions.create = function create(properties) {
                return new WriteOptions(properties);
            };

            /**
             * Encodes the specified WriteOptions message. Does not implicitly {@link protos.opts.WriteOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {protos.opts.IWriteOptions} message WriteOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
                if (message.record != null && Object.hasOwnProperty.call(message, "record"))
                    $root.protos.records.WriteRecord.encode(message.record, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.encodeOptions != null && Object.hasOwnProperty.call(message, "encodeOptions"))
                    $root.protos.encoding.EncodeOptions.encode(message.encodeOptions, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.opts.WriteGroupKafkaOptions.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.activemq != null && Object.hasOwnProperty.call(message, "activemq"))
                    $root.protos.opts.WriteGroupActiveMQOptions.encode(message.activemq, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.awssqs != null && Object.hasOwnProperty.call(message, "awssqs"))
                    $root.protos.opts.WriteGroupAWSSQSOptions.encode(message.awssqs, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.awssns != null && Object.hasOwnProperty.call(message, "awssns"))
                    $root.protos.opts.WriteGroupAWSSNSOptions.encode(message.awssns, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.opts.WriteGroupNatsOptions.encode(message.nats, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.opts.WriteGroupNatsStreamingOptions.encode(message.natsStreaming, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.opts.WriteGroupNSQOptions.encode(message.nsq, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.pulsar != null && Object.hasOwnProperty.call(message, "pulsar"))
                    $root.protos.opts.WriteGroupPulsarOptions.encode(message.pulsar, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.opts.WriteGroupRabbitOptions.encode(message.rabbit, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.rabbitStreams != null && Object.hasOwnProperty.call(message, "rabbitStreams"))
                    $root.protos.opts.WriteGroupRabbitStreamsOptions.encode(message.rabbitStreams, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.opts.WriteGroupMQTTOptions.encode(message.mqtt, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.opts.WriteGroupAzureServiceBusOptions.encode(message.azureServiceBus, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.azureEventHub != null && Object.hasOwnProperty.call(message, "azureEventHub"))
                    $root.protos.opts.WriteGroupAzureEventHubOptions.encode(message.azureEventHub, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.opts.WriteGroupGCPPubSubOptions.encode(message.gcpPubsub, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.opts.WriteGroupKubeMQQueueOptions.encode(message.kubemqQueue, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.opts.WriteGroupRedisPubSubOptions.encode(message.redisPubsub, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.opts.WriteGroupRedisStreamsOptions.encode(message.redisStreams, writer.uint32(/* id 116, wireType 2 =*/930).fork()).ldelim();
                if (message._cliOptions != null && Object.hasOwnProperty.call(message, "_cliOptions"))
                    $root.protos.opts.WriteCLIOptions.encode(message._cliOptions, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteOptions message, length delimited. Does not implicitly {@link protos.opts.WriteOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {protos.opts.IWriteOptions} message WriteOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteOptions} WriteOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.connectionId = reader.string();
                        break;
                    case 2:
                        message.record = $root.protos.records.WriteRecord.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.encodeOptions = $root.protos.encoding.EncodeOptions.decode(reader, reader.uint32());
                        break;
                    case 1000:
                        message._cliOptions = $root.protos.opts.WriteCLIOptions.decode(reader, reader.uint32());
                        break;
                    case 100:
                        message.kafka = $root.protos.opts.WriteGroupKafkaOptions.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.activemq = $root.protos.opts.WriteGroupActiveMQOptions.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.awssqs = $root.protos.opts.WriteGroupAWSSQSOptions.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.awssns = $root.protos.opts.WriteGroupAWSSNSOptions.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.nats = $root.protos.opts.WriteGroupNatsOptions.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.natsStreaming = $root.protos.opts.WriteGroupNatsStreamingOptions.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.nsq = $root.protos.opts.WriteGroupNSQOptions.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.pulsar = $root.protos.opts.WriteGroupPulsarOptions.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.rabbit = $root.protos.opts.WriteGroupRabbitOptions.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.rabbitStreams = $root.protos.opts.WriteGroupRabbitStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 110:
                        message.mqtt = $root.protos.opts.WriteGroupMQTTOptions.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.azureServiceBus = $root.protos.opts.WriteGroupAzureServiceBusOptions.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.azureEventHub = $root.protos.opts.WriteGroupAzureEventHubOptions.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.gcpPubsub = $root.protos.opts.WriteGroupGCPPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.redisPubsub = $root.protos.opts.WriteGroupRedisPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 116:
                        message.redisStreams = $root.protos.opts.WriteGroupRedisStreamsOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteOptions} WriteOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteOptions message.
             * @function verify
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    if (!$util.isString(message.connectionId))
                        return "connectionId: string expected";
                if (message.record != null && message.hasOwnProperty("record")) {
                    let error = $root.protos.records.WriteRecord.verify(message.record);
                    if (error)
                        return "record." + error;
                }
                if (message.encodeOptions != null && message.hasOwnProperty("encodeOptions")) {
                    let error = $root.protos.encoding.EncodeOptions.verify(message.encodeOptions);
                    if (error)
                        return "encodeOptions." + error;
                }
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions")) {
                    let error = $root.protos.opts.WriteCLIOptions.verify(message._cliOptions);
                    if (error)
                        return "_cliOptions." + error;
                }
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    let error = $root.protos.opts.WriteGroupKafkaOptions.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.activemq != null && message.hasOwnProperty("activemq")) {
                    let error = $root.protos.opts.WriteGroupActiveMQOptions.verify(message.activemq);
                    if (error)
                        return "activemq." + error;
                }
                if (message.awssqs != null && message.hasOwnProperty("awssqs")) {
                    let error = $root.protos.opts.WriteGroupAWSSQSOptions.verify(message.awssqs);
                    if (error)
                        return "awssqs." + error;
                }
                if (message.awssns != null && message.hasOwnProperty("awssns")) {
                    let error = $root.protos.opts.WriteGroupAWSSNSOptions.verify(message.awssns);
                    if (error)
                        return "awssns." + error;
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    let error = $root.protos.opts.WriteGroupNatsOptions.verify(message.nats);
                    if (error)
                        return "nats." + error;
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    let error = $root.protos.opts.WriteGroupNatsStreamingOptions.verify(message.natsStreaming);
                    if (error)
                        return "natsStreaming." + error;
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    let error = $root.protos.opts.WriteGroupNSQOptions.verify(message.nsq);
                    if (error)
                        return "nsq." + error;
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    let error = $root.protos.opts.WriteGroupPulsarOptions.verify(message.pulsar);
                    if (error)
                        return "pulsar." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    let error = $root.protos.opts.WriteGroupRabbitOptions.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    let error = $root.protos.opts.WriteGroupRabbitStreamsOptions.verify(message.rabbitStreams);
                    if (error)
                        return "rabbitStreams." + error;
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    let error = $root.protos.opts.WriteGroupMQTTOptions.verify(message.mqtt);
                    if (error)
                        return "mqtt." + error;
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    let error = $root.protos.opts.WriteGroupAzureServiceBusOptions.verify(message.azureServiceBus);
                    if (error)
                        return "azureServiceBus." + error;
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    let error = $root.protos.opts.WriteGroupAzureEventHubOptions.verify(message.azureEventHub);
                    if (error)
                        return "azureEventHub." + error;
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    let error = $root.protos.opts.WriteGroupGCPPubSubOptions.verify(message.gcpPubsub);
                    if (error)
                        return "gcpPubsub." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    let error = $root.protos.opts.WriteGroupKubeMQQueueOptions.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    let error = $root.protos.opts.WriteGroupRedisPubSubOptions.verify(message.redisPubsub);
                    if (error)
                        return "redisPubsub." + error;
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    let error = $root.protos.opts.WriteGroupRedisStreamsOptions.verify(message.redisStreams);
                    if (error)
                        return "redisStreams." + error;
                }
                return null;
            };

            /**
             * Creates a WriteOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteOptions} WriteOptions
             */
            WriteOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteOptions)
                    return object;
                let message = new $root.protos.opts.WriteOptions();
                if (object.connectionId != null)
                    message.connectionId = String(object.connectionId);
                if (object.record != null) {
                    if (typeof object.record !== "object")
                        throw TypeError(".protos.opts.WriteOptions.record: object expected");
                    message.record = $root.protos.records.WriteRecord.fromObject(object.record);
                }
                if (object.encodeOptions != null) {
                    if (typeof object.encodeOptions !== "object")
                        throw TypeError(".protos.opts.WriteOptions.encodeOptions: object expected");
                    message.encodeOptions = $root.protos.encoding.EncodeOptions.fromObject(object.encodeOptions);
                }
                if (object._cliOptions != null) {
                    if (typeof object._cliOptions !== "object")
                        throw TypeError(".protos.opts.WriteOptions._cliOptions: object expected");
                    message._cliOptions = $root.protos.opts.WriteCLIOptions.fromObject(object._cliOptions);
                }
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.WriteOptions.kafka: object expected");
                    message.kafka = $root.protos.opts.WriteGroupKafkaOptions.fromObject(object.kafka);
                }
                if (object.activemq != null) {
                    if (typeof object.activemq !== "object")
                        throw TypeError(".protos.opts.WriteOptions.activemq: object expected");
                    message.activemq = $root.protos.opts.WriteGroupActiveMQOptions.fromObject(object.activemq);
                }
                if (object.awssqs != null) {
                    if (typeof object.awssqs !== "object")
                        throw TypeError(".protos.opts.WriteOptions.awssqs: object expected");
                    message.awssqs = $root.protos.opts.WriteGroupAWSSQSOptions.fromObject(object.awssqs);
                }
                if (object.awssns != null) {
                    if (typeof object.awssns !== "object")
                        throw TypeError(".protos.opts.WriteOptions.awssns: object expected");
                    message.awssns = $root.protos.opts.WriteGroupAWSSNSOptions.fromObject(object.awssns);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.opts.WriteOptions.nats: object expected");
                    message.nats = $root.protos.opts.WriteGroupNatsOptions.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.opts.WriteOptions.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.opts.WriteGroupNatsStreamingOptions.fromObject(object.natsStreaming);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.WriteOptions.nsq: object expected");
                    message.nsq = $root.protos.opts.WriteGroupNSQOptions.fromObject(object.nsq);
                }
                if (object.pulsar != null) {
                    if (typeof object.pulsar !== "object")
                        throw TypeError(".protos.opts.WriteOptions.pulsar: object expected");
                    message.pulsar = $root.protos.opts.WriteGroupPulsarOptions.fromObject(object.pulsar);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.WriteOptions.rabbit: object expected");
                    message.rabbit = $root.protos.opts.WriteGroupRabbitOptions.fromObject(object.rabbit);
                }
                if (object.rabbitStreams != null) {
                    if (typeof object.rabbitStreams !== "object")
                        throw TypeError(".protos.opts.WriteOptions.rabbitStreams: object expected");
                    message.rabbitStreams = $root.protos.opts.WriteGroupRabbitStreamsOptions.fromObject(object.rabbitStreams);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.WriteOptions.mqtt: object expected");
                    message.mqtt = $root.protos.opts.WriteGroupMQTTOptions.fromObject(object.mqtt);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.WriteOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.opts.WriteGroupAzureServiceBusOptions.fromObject(object.azureServiceBus);
                }
                if (object.azureEventHub != null) {
                    if (typeof object.azureEventHub !== "object")
                        throw TypeError(".protos.opts.WriteOptions.azureEventHub: object expected");
                    message.azureEventHub = $root.protos.opts.WriteGroupAzureEventHubOptions.fromObject(object.azureEventHub);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.WriteOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.opts.WriteGroupGCPPubSubOptions.fromObject(object.gcpPubsub);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.WriteOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.fromObject(object.kubemqQueue);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.WriteOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.opts.WriteGroupRedisPubSubOptions.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.WriteOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.opts.WriteGroupRedisStreamsOptions.fromObject(object.redisStreams);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {protos.opts.WriteOptions} message WriteOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.connectionId = "";
                    object.record = null;
                    object.encodeOptions = null;
                    object.kafka = null;
                    object.activemq = null;
                    object.awssqs = null;
                    object.awssns = null;
                    object.nats = null;
                    object.natsStreaming = null;
                    object.nsq = null;
                    object.pulsar = null;
                    object.rabbit = null;
                    object.rabbitStreams = null;
                    object.mqtt = null;
                    object.azureServiceBus = null;
                    object.azureEventHub = null;
                    object.gcpPubsub = null;
                    object.kubemqQueue = null;
                    object.redisPubsub = null;
                    object.redisStreams = null;
                    object._cliOptions = null;
                }
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    object.connectionId = message.connectionId;
                if (message.record != null && message.hasOwnProperty("record"))
                    object.record = $root.protos.records.WriteRecord.toObject(message.record, options);
                if (message.encodeOptions != null && message.hasOwnProperty("encodeOptions"))
                    object.encodeOptions = $root.protos.encoding.EncodeOptions.toObject(message.encodeOptions, options);
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.opts.WriteGroupKafkaOptions.toObject(message.kafka, options);
                if (message.activemq != null && message.hasOwnProperty("activemq"))
                    object.activemq = $root.protos.opts.WriteGroupActiveMQOptions.toObject(message.activemq, options);
                if (message.awssqs != null && message.hasOwnProperty("awssqs"))
                    object.awssqs = $root.protos.opts.WriteGroupAWSSQSOptions.toObject(message.awssqs, options);
                if (message.awssns != null && message.hasOwnProperty("awssns"))
                    object.awssns = $root.protos.opts.WriteGroupAWSSNSOptions.toObject(message.awssns, options);
                if (message.nats != null && message.hasOwnProperty("nats"))
                    object.nats = $root.protos.opts.WriteGroupNatsOptions.toObject(message.nats, options);
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming"))
                    object.natsStreaming = $root.protos.opts.WriteGroupNatsStreamingOptions.toObject(message.natsStreaming, options);
                if (message.nsq != null && message.hasOwnProperty("nsq"))
                    object.nsq = $root.protos.opts.WriteGroupNSQOptions.toObject(message.nsq, options);
                if (message.pulsar != null && message.hasOwnProperty("pulsar"))
                    object.pulsar = $root.protos.opts.WriteGroupPulsarOptions.toObject(message.pulsar, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.opts.WriteGroupRabbitOptions.toObject(message.rabbit, options);
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams"))
                    object.rabbitStreams = $root.protos.opts.WriteGroupRabbitStreamsOptions.toObject(message.rabbitStreams, options);
                if (message.mqtt != null && message.hasOwnProperty("mqtt"))
                    object.mqtt = $root.protos.opts.WriteGroupMQTTOptions.toObject(message.mqtt, options);
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus"))
                    object.azureServiceBus = $root.protos.opts.WriteGroupAzureServiceBusOptions.toObject(message.azureServiceBus, options);
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub"))
                    object.azureEventHub = $root.protos.opts.WriteGroupAzureEventHubOptions.toObject(message.azureEventHub, options);
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub"))
                    object.gcpPubsub = $root.protos.opts.WriteGroupGCPPubSubOptions.toObject(message.gcpPubsub, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.toObject(message.kubemqQueue, options);
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub"))
                    object.redisPubsub = $root.protos.opts.WriteGroupRedisPubSubOptions.toObject(message.redisPubsub, options);
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams"))
                    object.redisStreams = $root.protos.opts.WriteGroupRedisStreamsOptions.toObject(message.redisStreams, options);
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions"))
                    object._cliOptions = $root.protos.opts.WriteCLIOptions.toObject(message._cliOptions, options);
                return object;
            };

            /**
             * Converts this WriteOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteOptions;
        })();

        opts.WriteGroupKafkaOptions = (function() {

            /**
             * Properties of a WriteGroupKafkaOptions.
             * @memberof protos.opts
             * @interface IWriteGroupKafkaOptions
             * @property {protos.args.IKafkaConn|null} [_conn] WriteGroupKafkaOptions _conn
             * @property {protos.args.IKafkaWriteArgs|null} [args] WriteGroupKafkaOptions args
             */

            /**
             * Constructs a new WriteGroupKafkaOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupKafkaOptions.
             * @implements IWriteGroupKafkaOptions
             * @constructor
             * @param {protos.opts.IWriteGroupKafkaOptions=} [properties] Properties to set
             */
            function WriteGroupKafkaOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupKafkaOptions _conn.
             * @member {protos.args.IKafkaConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @instance
             */
            WriteGroupKafkaOptions.prototype._conn = null;

            /**
             * WriteGroupKafkaOptions args.
             * @member {protos.args.IKafkaWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @instance
             */
            WriteGroupKafkaOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupKafkaOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {protos.opts.IWriteGroupKafkaOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupKafkaOptions} WriteGroupKafkaOptions instance
             */
            WriteGroupKafkaOptions.create = function create(properties) {
                return new WriteGroupKafkaOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupKafkaOptions message. Does not implicitly {@link protos.opts.WriteGroupKafkaOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {protos.opts.IWriteGroupKafkaOptions} message WriteGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupKafkaOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KafkaConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KafkaWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupKafkaOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupKafkaOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {protos.opts.IWriteGroupKafkaOptions} message WriteGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupKafkaOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupKafkaOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupKafkaOptions} WriteGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupKafkaOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupKafkaOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KafkaConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KafkaWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupKafkaOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupKafkaOptions} WriteGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupKafkaOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupKafkaOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupKafkaOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.KafkaConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.KafkaWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupKafkaOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupKafkaOptions} WriteGroupKafkaOptions
             */
            WriteGroupKafkaOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupKafkaOptions)
                    return object;
                let message = new $root.protos.opts.WriteGroupKafkaOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupKafkaOptions._conn: object expected");
                    message._conn = $root.protos.args.KafkaConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupKafkaOptions.args: object expected");
                    message.args = $root.protos.args.KafkaWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupKafkaOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {protos.opts.WriteGroupKafkaOptions} message WriteGroupKafkaOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupKafkaOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KafkaConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KafkaWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupKafkaOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupKafkaOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupKafkaOptions;
        })();

        opts.WriteGroupActiveMQOptions = (function() {

            /**
             * Properties of a WriteGroupActiveMQOptions.
             * @memberof protos.opts
             * @interface IWriteGroupActiveMQOptions
             * @property {protos.args.IActiveMQConn|null} [_conn] WriteGroupActiveMQOptions _conn
             * @property {protos.args.IActiveMQWriteArgs|null} [args] WriteGroupActiveMQOptions args
             */

            /**
             * Constructs a new WriteGroupActiveMQOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupActiveMQOptions.
             * @implements IWriteGroupActiveMQOptions
             * @constructor
             * @param {protos.opts.IWriteGroupActiveMQOptions=} [properties] Properties to set
             */
            function WriteGroupActiveMQOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupActiveMQOptions _conn.
             * @member {protos.args.IActiveMQConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @instance
             */
            WriteGroupActiveMQOptions.prototype._conn = null;

            /**
             * WriteGroupActiveMQOptions args.
             * @member {protos.args.IActiveMQWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @instance
             */
            WriteGroupActiveMQOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupActiveMQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {protos.opts.IWriteGroupActiveMQOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupActiveMQOptions} WriteGroupActiveMQOptions instance
             */
            WriteGroupActiveMQOptions.create = function create(properties) {
                return new WriteGroupActiveMQOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupActiveMQOptions message. Does not implicitly {@link protos.opts.WriteGroupActiveMQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {protos.opts.IWriteGroupActiveMQOptions} message WriteGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupActiveMQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.ActiveMQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.ActiveMQWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupActiveMQOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupActiveMQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {protos.opts.IWriteGroupActiveMQOptions} message WriteGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupActiveMQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupActiveMQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupActiveMQOptions} WriteGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupActiveMQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupActiveMQOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.ActiveMQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.ActiveMQWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupActiveMQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupActiveMQOptions} WriteGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupActiveMQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupActiveMQOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupActiveMQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.ActiveMQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.ActiveMQWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupActiveMQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupActiveMQOptions} WriteGroupActiveMQOptions
             */
            WriteGroupActiveMQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupActiveMQOptions)
                    return object;
                let message = new $root.protos.opts.WriteGroupActiveMQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupActiveMQOptions._conn: object expected");
                    message._conn = $root.protos.args.ActiveMQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupActiveMQOptions.args: object expected");
                    message.args = $root.protos.args.ActiveMQWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupActiveMQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {protos.opts.WriteGroupActiveMQOptions} message WriteGroupActiveMQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupActiveMQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.ActiveMQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.ActiveMQWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupActiveMQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupActiveMQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupActiveMQOptions;
        })();

        opts.WriteGroupAWSSQSOptions = (function() {

            /**
             * Properties of a WriteGroupAWSSQSOptions.
             * @memberof protos.opts
             * @interface IWriteGroupAWSSQSOptions
             * @property {protos.args.IAWSSQSConn|null} [_conn] WriteGroupAWSSQSOptions _conn
             * @property {protos.args.IAWSSQSWriteArgs|null} [args] WriteGroupAWSSQSOptions args
             */

            /**
             * Constructs a new WriteGroupAWSSQSOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupAWSSQSOptions.
             * @implements IWriteGroupAWSSQSOptions
             * @constructor
             * @param {protos.opts.IWriteGroupAWSSQSOptions=} [properties] Properties to set
             */
            function WriteGroupAWSSQSOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupAWSSQSOptions _conn.
             * @member {protos.args.IAWSSQSConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @instance
             */
            WriteGroupAWSSQSOptions.prototype._conn = null;

            /**
             * WriteGroupAWSSQSOptions args.
             * @member {protos.args.IAWSSQSWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @instance
             */
            WriteGroupAWSSQSOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupAWSSQSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSQSOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupAWSSQSOptions} WriteGroupAWSSQSOptions instance
             */
            WriteGroupAWSSQSOptions.create = function create(properties) {
                return new WriteGroupAWSSQSOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupAWSSQSOptions message. Does not implicitly {@link protos.opts.WriteGroupAWSSQSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSQSOptions} message WriteGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAWSSQSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSQSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSQSWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupAWSSQSOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupAWSSQSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSQSOptions} message WriteGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAWSSQSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupAWSSQSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupAWSSQSOptions} WriteGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAWSSQSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupAWSSQSOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSQSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSQSWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupAWSSQSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupAWSSQSOptions} WriteGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAWSSQSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupAWSSQSOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupAWSSQSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.AWSSQSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.AWSSQSWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupAWSSQSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupAWSSQSOptions} WriteGroupAWSSQSOptions
             */
            WriteGroupAWSSQSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupAWSSQSOptions)
                    return object;
                let message = new $root.protos.opts.WriteGroupAWSSQSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupAWSSQSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSQSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupAWSSQSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSQSWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupAWSSQSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {protos.opts.WriteGroupAWSSQSOptions} message WriteGroupAWSSQSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupAWSSQSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSQSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSQSWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupAWSSQSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupAWSSQSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupAWSSQSOptions;
        })();

        opts.WriteGroupAWSSNSOptions = (function() {

            /**
             * Properties of a WriteGroupAWSSNSOptions.
             * @memberof protos.opts
             * @interface IWriteGroupAWSSNSOptions
             * @property {protos.args.IAWSSNSConn|null} [_conn] WriteGroupAWSSNSOptions _conn
             * @property {protos.args.IAWSSNSWriteArgs|null} [args] WriteGroupAWSSNSOptions args
             */

            /**
             * Constructs a new WriteGroupAWSSNSOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupAWSSNSOptions.
             * @implements IWriteGroupAWSSNSOptions
             * @constructor
             * @param {protos.opts.IWriteGroupAWSSNSOptions=} [properties] Properties to set
             */
            function WriteGroupAWSSNSOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupAWSSNSOptions _conn.
             * @member {protos.args.IAWSSNSConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @instance
             */
            WriteGroupAWSSNSOptions.prototype._conn = null;

            /**
             * WriteGroupAWSSNSOptions args.
             * @member {protos.args.IAWSSNSWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @instance
             */
            WriteGroupAWSSNSOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupAWSSNSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSNSOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupAWSSNSOptions} WriteGroupAWSSNSOptions instance
             */
            WriteGroupAWSSNSOptions.create = function create(properties) {
                return new WriteGroupAWSSNSOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupAWSSNSOptions message. Does not implicitly {@link protos.opts.WriteGroupAWSSNSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSNSOptions} message WriteGroupAWSSNSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAWSSNSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSNSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSNSWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupAWSSNSOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupAWSSNSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSNSOptions} message WriteGroupAWSSNSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAWSSNSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupAWSSNSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupAWSSNSOptions} WriteGroupAWSSNSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAWSSNSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupAWSSNSOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSNSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSNSWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupAWSSNSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupAWSSNSOptions} WriteGroupAWSSNSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAWSSNSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupAWSSNSOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupAWSSNSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.AWSSNSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.AWSSNSWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupAWSSNSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupAWSSNSOptions} WriteGroupAWSSNSOptions
             */
            WriteGroupAWSSNSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupAWSSNSOptions)
                    return object;
                let message = new $root.protos.opts.WriteGroupAWSSNSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupAWSSNSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSNSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupAWSSNSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSNSWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupAWSSNSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {protos.opts.WriteGroupAWSSNSOptions} message WriteGroupAWSSNSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupAWSSNSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSNSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSNSWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupAWSSNSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupAWSSNSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupAWSSNSOptions;
        })();

        opts.WriteGroupNatsOptions = (function() {

            /**
             * Properties of a WriteGroupNatsOptions.
             * @memberof protos.opts
             * @interface IWriteGroupNatsOptions
             * @property {protos.args.INatsConn|null} [_conn] WriteGroupNatsOptions _conn
             * @property {protos.args.INatsWriteArgs|null} [args] WriteGroupNatsOptions args
             */

            /**
             * Constructs a new WriteGroupNatsOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupNatsOptions.
             * @implements IWriteGroupNatsOptions
             * @constructor
             * @param {protos.opts.IWriteGroupNatsOptions=} [properties] Properties to set
             */
            function WriteGroupNatsOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupNatsOptions _conn.
             * @member {protos.args.INatsConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupNatsOptions
             * @instance
             */
            WriteGroupNatsOptions.prototype._conn = null;

            /**
             * WriteGroupNatsOptions args.
             * @member {protos.args.INatsWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupNatsOptions
             * @instance
             */
            WriteGroupNatsOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupNatsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupNatsOptions} WriteGroupNatsOptions instance
             */
            WriteGroupNatsOptions.create = function create(properties) {
                return new WriteGroupNatsOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupNatsOptions message. Does not implicitly {@link protos.opts.WriteGroupNatsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsOptions} message WriteGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNatsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupNatsOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupNatsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsOptions} message WriteGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNatsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupNatsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupNatsOptions} WriteGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNatsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupNatsOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupNatsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupNatsOptions} WriteGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNatsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupNatsOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupNatsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.NatsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.NatsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupNatsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupNatsOptions} WriteGroupNatsOptions
             */
            WriteGroupNatsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupNatsOptions)
                    return object;
                let message = new $root.protos.opts.WriteGroupNatsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupNatsOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupNatsOptions.args: object expected");
                    message.args = $root.protos.args.NatsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupNatsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {protos.opts.WriteGroupNatsOptions} message WriteGroupNatsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupNatsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupNatsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupNatsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupNatsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupNatsOptions;
        })();

        opts.WriteGroupNatsStreamingOptions = (function() {

            /**
             * Properties of a WriteGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @interface IWriteGroupNatsStreamingOptions
             * @property {protos.args.INatsStreamingConn|null} [_conn] WriteGroupNatsStreamingOptions _conn
             * @property {protos.args.INatsStreamingWriteArgs|null} [args] WriteGroupNatsStreamingOptions args
             */

            /**
             * Constructs a new WriteGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupNatsStreamingOptions.
             * @implements IWriteGroupNatsStreamingOptions
             * @constructor
             * @param {protos.opts.IWriteGroupNatsStreamingOptions=} [properties] Properties to set
             */
            function WriteGroupNatsStreamingOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupNatsStreamingOptions _conn.
             * @member {protos.args.INatsStreamingConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @instance
             */
            WriteGroupNatsStreamingOptions.prototype._conn = null;

            /**
             * WriteGroupNatsStreamingOptions args.
             * @member {protos.args.INatsStreamingWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @instance
             */
            WriteGroupNatsStreamingOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupNatsStreamingOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsStreamingOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupNatsStreamingOptions} WriteGroupNatsStreamingOptions instance
             */
            WriteGroupNatsStreamingOptions.create = function create(properties) {
                return new WriteGroupNatsStreamingOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupNatsStreamingOptions message. Does not implicitly {@link protos.opts.WriteGroupNatsStreamingOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsStreamingOptions} message WriteGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNatsStreamingOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsStreamingConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsStreamingWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupNatsStreamingOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupNatsStreamingOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsStreamingOptions} message WriteGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNatsStreamingOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupNatsStreamingOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupNatsStreamingOptions} WriteGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNatsStreamingOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupNatsStreamingOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsStreamingConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsStreamingWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupNatsStreamingOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupNatsStreamingOptions} WriteGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNatsStreamingOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupNatsStreamingOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupNatsStreamingOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.NatsStreamingConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.NatsStreamingWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupNatsStreamingOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupNatsStreamingOptions} WriteGroupNatsStreamingOptions
             */
            WriteGroupNatsStreamingOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupNatsStreamingOptions)
                    return object;
                let message = new $root.protos.opts.WriteGroupNatsStreamingOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupNatsStreamingOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsStreamingConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupNatsStreamingOptions.args: object expected");
                    message.args = $root.protos.args.NatsStreamingWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupNatsStreamingOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.WriteGroupNatsStreamingOptions} message WriteGroupNatsStreamingOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupNatsStreamingOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsStreamingConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsStreamingWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupNatsStreamingOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupNatsStreamingOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupNatsStreamingOptions;
        })();

        opts.WriteGroupNSQOptions = (function() {

            /**
             * Properties of a WriteGroupNSQOptions.
             * @memberof protos.opts
             * @interface IWriteGroupNSQOptions
             * @property {protos.args.INSQConn|null} [_conn] WriteGroupNSQOptions _conn
             * @property {protos.args.INSQWriteArgs|null} [args] WriteGroupNSQOptions args
             */

            /**
             * Constructs a new WriteGroupNSQOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupNSQOptions.
             * @implements IWriteGroupNSQOptions
             * @constructor
             * @param {protos.opts.IWriteGroupNSQOptions=} [properties] Properties to set
             */
            function WriteGroupNSQOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupNSQOptions _conn.
             * @member {protos.args.INSQConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupNSQOptions
             * @instance
             */
            WriteGroupNSQOptions.prototype._conn = null;

            /**
             * WriteGroupNSQOptions args.
             * @member {protos.args.INSQWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupNSQOptions
             * @instance
             */
            WriteGroupNSQOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupNSQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {protos.opts.IWriteGroupNSQOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupNSQOptions} WriteGroupNSQOptions instance
             */
            WriteGroupNSQOptions.create = function create(properties) {
                return new WriteGroupNSQOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupNSQOptions message. Does not implicitly {@link protos.opts.WriteGroupNSQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {protos.opts.IWriteGroupNSQOptions} message WriteGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNSQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NSQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NSQWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupNSQOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupNSQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {protos.opts.IWriteGroupNSQOptions} message WriteGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNSQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupNSQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupNSQOptions} WriteGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNSQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupNSQOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NSQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NSQWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupNSQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupNSQOptions} WriteGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNSQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupNSQOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupNSQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.NSQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.NSQWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupNSQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupNSQOptions} WriteGroupNSQOptions
             */
            WriteGroupNSQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupNSQOptions)
                    return object;
                let message = new $root.protos.opts.WriteGroupNSQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupNSQOptions._conn: object expected");
                    message._conn = $root.protos.args.NSQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupNSQOptions.args: object expected");
                    message.args = $root.protos.args.NSQWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupNSQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {protos.opts.WriteGroupNSQOptions} message WriteGroupNSQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupNSQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NSQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NSQWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupNSQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupNSQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupNSQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupNSQOptions;
        })();

        opts.WriteGroupPulsarOptions = (function() {

            /**
             * Properties of a WriteGroupPulsarOptions.
             * @memberof protos.opts
             * @interface IWriteGroupPulsarOptions
             * @property {protos.args.IPulsarConn|null} [_conn] WriteGroupPulsarOptions _conn
             * @property {protos.args.IPulsarWriteArgs|null} [args] WriteGroupPulsarOptions args
             */

            /**
             * Constructs a new WriteGroupPulsarOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupPulsarOptions.
             * @implements IWriteGroupPulsarOptions
             * @constructor
             * @param {protos.opts.IWriteGroupPulsarOptions=} [properties] Properties to set
             */
            function WriteGroupPulsarOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupPulsarOptions _conn.
             * @member {protos.args.IPulsarConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @instance
             */
            WriteGroupPulsarOptions.prototype._conn = null;

            /**
             * WriteGroupPulsarOptions args.
             * @member {protos.args.IPulsarWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @instance
             */
            WriteGroupPulsarOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupPulsarOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {protos.opts.IWriteGroupPulsarOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupPulsarOptions} WriteGroupPulsarOptions instance
             */
            WriteGroupPulsarOptions.create = function create(properties) {
                return new WriteGroupPulsarOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupPulsarOptions message. Does not implicitly {@link protos.opts.WriteGroupPulsarOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {protos.opts.IWriteGroupPulsarOptions} message WriteGroupPulsarOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupPulsarOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.PulsarConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.PulsarWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupPulsarOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupPulsarOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {protos.opts.IWriteGroupPulsarOptions} message WriteGroupPulsarOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupPulsarOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupPulsarOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupPulsarOptions} WriteGroupPulsarOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupPulsarOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupPulsarOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.PulsarConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.PulsarWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupPulsarOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupPulsarOptions} WriteGroupPulsarOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupPulsarOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupPulsarOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupPulsarOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.PulsarConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.PulsarWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupPulsarOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupPulsarOptions} WriteGroupPulsarOptions
             */
            WriteGroupPulsarOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupPulsarOptions)
                    return object;
                let message = new $root.protos.opts.WriteGroupPulsarOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupPulsarOptions._conn: object expected");
                    message._conn = $root.protos.args.PulsarConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupPulsarOptions.args: object expected");
                    message.args = $root.protos.args.PulsarWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupPulsarOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {protos.opts.WriteGroupPulsarOptions} message WriteGroupPulsarOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupPulsarOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.PulsarConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.PulsarWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupPulsarOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupPulsarOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupPulsarOptions;
        })();

        opts.WriteGroupRabbitOptions = (function() {

            /**
             * Properties of a WriteGroupRabbitOptions.
             * @memberof protos.opts
             * @interface IWriteGroupRabbitOptions
             * @property {protos.args.IRabbitConn|null} [_conn] WriteGroupRabbitOptions _conn
             * @property {protos.args.IRabbitWriteArgs|null} [args] WriteGroupRabbitOptions args
             */

            /**
             * Constructs a new WriteGroupRabbitOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupRabbitOptions.
             * @implements IWriteGroupRabbitOptions
             * @constructor
             * @param {protos.opts.IWriteGroupRabbitOptions=} [properties] Properties to set
             */
            function WriteGroupRabbitOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupRabbitOptions _conn.
             * @member {protos.args.IRabbitConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @instance
             */
            WriteGroupRabbitOptions.prototype._conn = null;

            /**
             * WriteGroupRabbitOptions args.
             * @member {protos.args.IRabbitWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @instance
             */
            WriteGroupRabbitOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupRabbitOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupRabbitOptions} WriteGroupRabbitOptions instance
             */
            WriteGroupRabbitOptions.create = function create(properties) {
                return new WriteGroupRabbitOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupRabbitOptions message. Does not implicitly {@link protos.opts.WriteGroupRabbitOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitOptions} message WriteGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRabbitOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupRabbitOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupRabbitOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitOptions} message WriteGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRabbitOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupRabbitOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupRabbitOptions} WriteGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRabbitOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupRabbitOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupRabbitOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupRabbitOptions} WriteGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRabbitOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupRabbitOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupRabbitOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.RabbitConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.RabbitWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupRabbitOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupRabbitOptions} WriteGroupRabbitOptions
             */
            WriteGroupRabbitOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupRabbitOptions)
                    return object;
                let message = new $root.protos.opts.WriteGroupRabbitOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupRabbitOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupRabbitOptions.args: object expected");
                    message.args = $root.protos.args.RabbitWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupRabbitOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {protos.opts.WriteGroupRabbitOptions} message WriteGroupRabbitOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupRabbitOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupRabbitOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupRabbitOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupRabbitOptions;
        })();

        opts.WriteGroupRabbitStreamsOptions = (function() {

            /**
             * Properties of a WriteGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @interface IWriteGroupRabbitStreamsOptions
             * @property {protos.args.IRabbitStreamsConn|null} [_conn] WriteGroupRabbitStreamsOptions _conn
             * @property {protos.args.IRabbitStreamsWriteArgs|null} [args] WriteGroupRabbitStreamsOptions args
             */

            /**
             * Constructs a new WriteGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupRabbitStreamsOptions.
             * @implements IWriteGroupRabbitStreamsOptions
             * @constructor
             * @param {protos.opts.IWriteGroupRabbitStreamsOptions=} [properties] Properties to set
             */
            function WriteGroupRabbitStreamsOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupRabbitStreamsOptions _conn.
             * @member {protos.args.IRabbitStreamsConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @instance
             */
            WriteGroupRabbitStreamsOptions.prototype._conn = null;

            /**
             * WriteGroupRabbitStreamsOptions args.
             * @member {protos.args.IRabbitStreamsWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @instance
             */
            WriteGroupRabbitStreamsOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupRabbitStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupRabbitStreamsOptions} WriteGroupRabbitStreamsOptions instance
             */
            WriteGroupRabbitStreamsOptions.create = function create(properties) {
                return new WriteGroupRabbitStreamsOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupRabbitStreamsOptions message. Does not implicitly {@link protos.opts.WriteGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitStreamsOptions} message WriteGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRabbitStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitStreamsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupRabbitStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitStreamsOptions} message WriteGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRabbitStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupRabbitStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupRabbitStreamsOptions} WriteGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRabbitStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupRabbitStreamsOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitStreamsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupRabbitStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupRabbitStreamsOptions} WriteGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRabbitStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupRabbitStreamsOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupRabbitStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.RabbitStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.RabbitStreamsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupRabbitStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupRabbitStreamsOptions} WriteGroupRabbitStreamsOptions
             */
            WriteGroupRabbitStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupRabbitStreamsOptions)
                    return object;
                let message = new $root.protos.opts.WriteGroupRabbitStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupRabbitStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupRabbitStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RabbitStreamsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupRabbitStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.WriteGroupRabbitStreamsOptions} message WriteGroupRabbitStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupRabbitStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitStreamsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupRabbitStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupRabbitStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupRabbitStreamsOptions;
        })();

        opts.WriteGroupRedisPubSubOptions = (function() {

            /**
             * Properties of a WriteGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @interface IWriteGroupRedisPubSubOptions
             * @property {protos.args.IRedisPubSubConn|null} [_conn] WriteGroupRedisPubSubOptions _conn
             * @property {protos.args.IRedisPubSubWriteArgs|null} [args] WriteGroupRedisPubSubOptions args
             */

            /**
             * Constructs a new WriteGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupRedisPubSubOptions.
             * @implements IWriteGroupRedisPubSubOptions
             * @constructor
             * @param {protos.opts.IWriteGroupRedisPubSubOptions=} [properties] Properties to set
             */
            function WriteGroupRedisPubSubOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupRedisPubSubOptions _conn.
             * @member {protos.args.IRedisPubSubConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @instance
             */
            WriteGroupRedisPubSubOptions.prototype._conn = null;

            /**
             * WriteGroupRedisPubSubOptions args.
             * @member {protos.args.IRedisPubSubWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @instance
             */
            WriteGroupRedisPubSubOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupRedisPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupRedisPubSubOptions} WriteGroupRedisPubSubOptions instance
             */
            WriteGroupRedisPubSubOptions.create = function create(properties) {
                return new WriteGroupRedisPubSubOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupRedisPubSubOptions message. Does not implicitly {@link protos.opts.WriteGroupRedisPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisPubSubOptions} message WriteGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRedisPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisPubSubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupRedisPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupRedisPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisPubSubOptions} message WriteGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRedisPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupRedisPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupRedisPubSubOptions} WriteGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRedisPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupRedisPubSubOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisPubSubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupRedisPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupRedisPubSubOptions} WriteGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRedisPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupRedisPubSubOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupRedisPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.RedisPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.RedisPubSubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupRedisPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupRedisPubSubOptions} WriteGroupRedisPubSubOptions
             */
            WriteGroupRedisPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupRedisPubSubOptions)
                    return object;
                let message = new $root.protos.opts.WriteGroupRedisPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupRedisPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupRedisPubSubOptions.args: object expected");
                    message.args = $root.protos.args.RedisPubSubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupRedisPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.WriteGroupRedisPubSubOptions} message WriteGroupRedisPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupRedisPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisPubSubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupRedisPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupRedisPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupRedisPubSubOptions;
        })();

        opts.WriteGroupRedisStreamsOptions = (function() {

            /**
             * Properties of a WriteGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @interface IWriteGroupRedisStreamsOptions
             * @property {protos.args.IRedisStreamsConn|null} [_conn] WriteGroupRedisStreamsOptions _conn
             * @property {protos.args.IRedisStreamsWriteArgs|null} [args] WriteGroupRedisStreamsOptions args
             */

            /**
             * Constructs a new WriteGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupRedisStreamsOptions.
             * @implements IWriteGroupRedisStreamsOptions
             * @constructor
             * @param {protos.opts.IWriteGroupRedisStreamsOptions=} [properties] Properties to set
             */
            function WriteGroupRedisStreamsOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupRedisStreamsOptions _conn.
             * @member {protos.args.IRedisStreamsConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @instance
             */
            WriteGroupRedisStreamsOptions.prototype._conn = null;

            /**
             * WriteGroupRedisStreamsOptions args.
             * @member {protos.args.IRedisStreamsWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @instance
             */
            WriteGroupRedisStreamsOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupRedisStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupRedisStreamsOptions} WriteGroupRedisStreamsOptions instance
             */
            WriteGroupRedisStreamsOptions.create = function create(properties) {
                return new WriteGroupRedisStreamsOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupRedisStreamsOptions message. Does not implicitly {@link protos.opts.WriteGroupRedisStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisStreamsOptions} message WriteGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRedisStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisStreamsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupRedisStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupRedisStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisStreamsOptions} message WriteGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRedisStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupRedisStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupRedisStreamsOptions} WriteGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRedisStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupRedisStreamsOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisStreamsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupRedisStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupRedisStreamsOptions} WriteGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRedisStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupRedisStreamsOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupRedisStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.RedisStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.RedisStreamsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupRedisStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupRedisStreamsOptions} WriteGroupRedisStreamsOptions
             */
            WriteGroupRedisStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupRedisStreamsOptions)
                    return object;
                let message = new $root.protos.opts.WriteGroupRedisStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupRedisStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupRedisStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RedisStreamsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupRedisStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.WriteGroupRedisStreamsOptions} message WriteGroupRedisStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupRedisStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisStreamsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupRedisStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupRedisStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupRedisStreamsOptions;
        })();

        opts.WriteGroupAzureEventHubOptions = (function() {

            /**
             * Properties of a WriteGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @interface IWriteGroupAzureEventHubOptions
             * @property {protos.args.IAzureEventHubConn|null} [_conn] WriteGroupAzureEventHubOptions _conn
             * @property {protos.args.IAzureEventHubWriteArgs|null} [args] WriteGroupAzureEventHubOptions args
             */

            /**
             * Constructs a new WriteGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupAzureEventHubOptions.
             * @implements IWriteGroupAzureEventHubOptions
             * @constructor
             * @param {protos.opts.IWriteGroupAzureEventHubOptions=} [properties] Properties to set
             */
            function WriteGroupAzureEventHubOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupAzureEventHubOptions _conn.
             * @member {protos.args.IAzureEventHubConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @instance
             */
            WriteGroupAzureEventHubOptions.prototype._conn = null;

            /**
             * WriteGroupAzureEventHubOptions args.
             * @member {protos.args.IAzureEventHubWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @instance
             */
            WriteGroupAzureEventHubOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupAzureEventHubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureEventHubOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupAzureEventHubOptions} WriteGroupAzureEventHubOptions instance
             */
            WriteGroupAzureEventHubOptions.create = function create(properties) {
                return new WriteGroupAzureEventHubOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupAzureEventHubOptions message. Does not implicitly {@link protos.opts.WriteGroupAzureEventHubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureEventHubOptions} message WriteGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAzureEventHubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureEventHubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureEventHubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupAzureEventHubOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupAzureEventHubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureEventHubOptions} message WriteGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAzureEventHubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupAzureEventHubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupAzureEventHubOptions} WriteGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAzureEventHubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupAzureEventHubOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureEventHubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureEventHubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupAzureEventHubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupAzureEventHubOptions} WriteGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAzureEventHubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupAzureEventHubOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupAzureEventHubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.AzureEventHubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.AzureEventHubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupAzureEventHubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupAzureEventHubOptions} WriteGroupAzureEventHubOptions
             */
            WriteGroupAzureEventHubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupAzureEventHubOptions)
                    return object;
                let message = new $root.protos.opts.WriteGroupAzureEventHubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupAzureEventHubOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureEventHubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupAzureEventHubOptions.args: object expected");
                    message.args = $root.protos.args.AzureEventHubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupAzureEventHubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.WriteGroupAzureEventHubOptions} message WriteGroupAzureEventHubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupAzureEventHubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureEventHubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureEventHubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupAzureEventHubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupAzureEventHubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupAzureEventHubOptions;
        })();

        opts.WriteGroupAzureServiceBusOptions = (function() {

            /**
             * Properties of a WriteGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @interface IWriteGroupAzureServiceBusOptions
             * @property {protos.args.IAzureServiceBusConn|null} [_conn] WriteGroupAzureServiceBusOptions _conn
             * @property {protos.args.IAzureServiceBusWriteArgs|null} [args] WriteGroupAzureServiceBusOptions args
             */

            /**
             * Constructs a new WriteGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupAzureServiceBusOptions.
             * @implements IWriteGroupAzureServiceBusOptions
             * @constructor
             * @param {protos.opts.IWriteGroupAzureServiceBusOptions=} [properties] Properties to set
             */
            function WriteGroupAzureServiceBusOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupAzureServiceBusOptions _conn.
             * @member {protos.args.IAzureServiceBusConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @instance
             */
            WriteGroupAzureServiceBusOptions.prototype._conn = null;

            /**
             * WriteGroupAzureServiceBusOptions args.
             * @member {protos.args.IAzureServiceBusWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @instance
             */
            WriteGroupAzureServiceBusOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupAzureServiceBusOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureServiceBusOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupAzureServiceBusOptions} WriteGroupAzureServiceBusOptions instance
             */
            WriteGroupAzureServiceBusOptions.create = function create(properties) {
                return new WriteGroupAzureServiceBusOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupAzureServiceBusOptions message. Does not implicitly {@link protos.opts.WriteGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureServiceBusOptions} message WriteGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAzureServiceBusOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureServiceBusConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureServiceBusWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupAzureServiceBusOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureServiceBusOptions} message WriteGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAzureServiceBusOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupAzureServiceBusOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupAzureServiceBusOptions} WriteGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAzureServiceBusOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupAzureServiceBusOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureServiceBusConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureServiceBusWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupAzureServiceBusOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupAzureServiceBusOptions} WriteGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAzureServiceBusOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupAzureServiceBusOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupAzureServiceBusOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.AzureServiceBusConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.AzureServiceBusWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupAzureServiceBusOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupAzureServiceBusOptions} WriteGroupAzureServiceBusOptions
             */
            WriteGroupAzureServiceBusOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupAzureServiceBusOptions)
                    return object;
                let message = new $root.protos.opts.WriteGroupAzureServiceBusOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupAzureServiceBusOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureServiceBusConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupAzureServiceBusOptions.args: object expected");
                    message.args = $root.protos.args.AzureServiceBusWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupAzureServiceBusOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.WriteGroupAzureServiceBusOptions} message WriteGroupAzureServiceBusOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupAzureServiceBusOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureServiceBusConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureServiceBusWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupAzureServiceBusOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupAzureServiceBusOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupAzureServiceBusOptions;
        })();

        opts.WriteGroupMQTTOptions = (function() {

            /**
             * Properties of a WriteGroupMQTTOptions.
             * @memberof protos.opts
             * @interface IWriteGroupMQTTOptions
             * @property {protos.args.IMQTTConn|null} [_conn] WriteGroupMQTTOptions _conn
             * @property {protos.args.IMQTTWriteArgs|null} [args] WriteGroupMQTTOptions args
             */

            /**
             * Constructs a new WriteGroupMQTTOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupMQTTOptions.
             * @implements IWriteGroupMQTTOptions
             * @constructor
             * @param {protos.opts.IWriteGroupMQTTOptions=} [properties] Properties to set
             */
            function WriteGroupMQTTOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupMQTTOptions _conn.
             * @member {protos.args.IMQTTConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @instance
             */
            WriteGroupMQTTOptions.prototype._conn = null;

            /**
             * WriteGroupMQTTOptions args.
             * @member {protos.args.IMQTTWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @instance
             */
            WriteGroupMQTTOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupMQTTOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {protos.opts.IWriteGroupMQTTOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupMQTTOptions} WriteGroupMQTTOptions instance
             */
            WriteGroupMQTTOptions.create = function create(properties) {
                return new WriteGroupMQTTOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupMQTTOptions message. Does not implicitly {@link protos.opts.WriteGroupMQTTOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {protos.opts.IWriteGroupMQTTOptions} message WriteGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupMQTTOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MQTTConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MQTTWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupMQTTOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupMQTTOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {protos.opts.IWriteGroupMQTTOptions} message WriteGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupMQTTOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupMQTTOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupMQTTOptions} WriteGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupMQTTOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupMQTTOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MQTTConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MQTTWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupMQTTOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupMQTTOptions} WriteGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupMQTTOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupMQTTOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupMQTTOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.MQTTConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.MQTTWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupMQTTOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupMQTTOptions} WriteGroupMQTTOptions
             */
            WriteGroupMQTTOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupMQTTOptions)
                    return object;
                let message = new $root.protos.opts.WriteGroupMQTTOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupMQTTOptions._conn: object expected");
                    message._conn = $root.protos.args.MQTTConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupMQTTOptions.args: object expected");
                    message.args = $root.protos.args.MQTTWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupMQTTOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {protos.opts.WriteGroupMQTTOptions} message WriteGroupMQTTOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupMQTTOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MQTTConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MQTTWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupMQTTOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupMQTTOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupMQTTOptions;
        })();

        opts.WriteGroupGCPPubSubOptions = (function() {

            /**
             * Properties of a WriteGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @interface IWriteGroupGCPPubSubOptions
             * @property {protos.args.IGCPPubSubConn|null} [_conn] WriteGroupGCPPubSubOptions _conn
             * @property {protos.args.IGCPPubSubWriteArgs|null} [args] WriteGroupGCPPubSubOptions args
             */

            /**
             * Constructs a new WriteGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupGCPPubSubOptions.
             * @implements IWriteGroupGCPPubSubOptions
             * @constructor
             * @param {protos.opts.IWriteGroupGCPPubSubOptions=} [properties] Properties to set
             */
            function WriteGroupGCPPubSubOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupGCPPubSubOptions _conn.
             * @member {protos.args.IGCPPubSubConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @instance
             */
            WriteGroupGCPPubSubOptions.prototype._conn = null;

            /**
             * WriteGroupGCPPubSubOptions args.
             * @member {protos.args.IGCPPubSubWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @instance
             */
            WriteGroupGCPPubSubOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupGCPPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupGCPPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupGCPPubSubOptions} WriteGroupGCPPubSubOptions instance
             */
            WriteGroupGCPPubSubOptions.create = function create(properties) {
                return new WriteGroupGCPPubSubOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupGCPPubSubOptions message. Does not implicitly {@link protos.opts.WriteGroupGCPPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupGCPPubSubOptions} message WriteGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupGCPPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.GCPPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.GCPPubSubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupGCPPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupGCPPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupGCPPubSubOptions} message WriteGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupGCPPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupGCPPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupGCPPubSubOptions} WriteGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupGCPPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupGCPPubSubOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.GCPPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.GCPPubSubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupGCPPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupGCPPubSubOptions} WriteGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupGCPPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupGCPPubSubOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupGCPPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.GCPPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.GCPPubSubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupGCPPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupGCPPubSubOptions} WriteGroupGCPPubSubOptions
             */
            WriteGroupGCPPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupGCPPubSubOptions)
                    return object;
                let message = new $root.protos.opts.WriteGroupGCPPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupGCPPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.GCPPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupGCPPubSubOptions.args: object expected");
                    message.args = $root.protos.args.GCPPubSubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupGCPPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.WriteGroupGCPPubSubOptions} message WriteGroupGCPPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupGCPPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.GCPPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.GCPPubSubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupGCPPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupGCPPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupGCPPubSubOptions;
        })();

        opts.WriteGroupKubeMQQueueOptions = (function() {

            /**
             * Properties of a WriteGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @interface IWriteGroupKubeMQQueueOptions
             * @property {protos.args.IKubeMQQueueConn|null} [_conn] WriteGroupKubeMQQueueOptions _conn
             * @property {protos.args.IKubeMQQueueWriteArgs|null} [args] WriteGroupKubeMQQueueOptions args
             */

            /**
             * Constructs a new WriteGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupKubeMQQueueOptions.
             * @implements IWriteGroupKubeMQQueueOptions
             * @constructor
             * @param {protos.opts.IWriteGroupKubeMQQueueOptions=} [properties] Properties to set
             */
            function WriteGroupKubeMQQueueOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupKubeMQQueueOptions _conn.
             * @member {protos.args.IKubeMQQueueConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @instance
             */
            WriteGroupKubeMQQueueOptions.prototype._conn = null;

            /**
             * WriteGroupKubeMQQueueOptions args.
             * @member {protos.args.IKubeMQQueueWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @instance
             */
            WriteGroupKubeMQQueueOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupKubeMQQueueOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IWriteGroupKubeMQQueueOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupKubeMQQueueOptions} WriteGroupKubeMQQueueOptions instance
             */
            WriteGroupKubeMQQueueOptions.create = function create(properties) {
                return new WriteGroupKubeMQQueueOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupKubeMQQueueOptions message. Does not implicitly {@link protos.opts.WriteGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IWriteGroupKubeMQQueueOptions} message WriteGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupKubeMQQueueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KubeMQQueueConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KubeMQQueueWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupKubeMQQueueOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IWriteGroupKubeMQQueueOptions} message WriteGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupKubeMQQueueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupKubeMQQueueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupKubeMQQueueOptions} WriteGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupKubeMQQueueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupKubeMQQueueOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KubeMQQueueConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KubeMQQueueWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupKubeMQQueueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupKubeMQQueueOptions} WriteGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupKubeMQQueueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupKubeMQQueueOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupKubeMQQueueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.KubeMQQueueConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.KubeMQQueueWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupKubeMQQueueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupKubeMQQueueOptions} WriteGroupKubeMQQueueOptions
             */
            WriteGroupKubeMQQueueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupKubeMQQueueOptions)
                    return object;
                let message = new $root.protos.opts.WriteGroupKubeMQQueueOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupKubeMQQueueOptions._conn: object expected");
                    message._conn = $root.protos.args.KubeMQQueueConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupKubeMQQueueOptions.args: object expected");
                    message.args = $root.protos.args.KubeMQQueueWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupKubeMQQueueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.WriteGroupKubeMQQueueOptions} message WriteGroupKubeMQQueueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupKubeMQQueueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KubeMQQueueConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KubeMQQueueWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupKubeMQQueueOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupKubeMQQueueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupKubeMQQueueOptions;
        })();

        opts.GlobalCLIOptions = (function() {

            /**
             * Properties of a GlobalCLIOptions.
             * @memberof protos.opts
             * @interface IGlobalCLIOptions
             * @property {boolean|null} [debug] GlobalCLIOptions debug
             * @property {boolean|null} [quiet] GlobalCLIOptions quiet
             * @property {boolean|null} [version] GlobalCLIOptions version
             * @property {string|null} [_fullCommand] GlobalCLIOptions _fullCommand
             * @property {string|null} [_action] GlobalCLIOptions _action
             * @property {string|null} [_backend] GlobalCLIOptions _backend
             */

            /**
             * Constructs a new GlobalCLIOptions.
             * @memberof protos.opts
             * @classdesc Represents a GlobalCLIOptions.
             * @implements IGlobalCLIOptions
             * @constructor
             * @param {protos.opts.IGlobalCLIOptions=} [properties] Properties to set
             */
            function GlobalCLIOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GlobalCLIOptions debug.
             * @member {boolean} debug
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype.debug = false;

            /**
             * GlobalCLIOptions quiet.
             * @member {boolean} quiet
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype.quiet = false;

            /**
             * GlobalCLIOptions version.
             * @member {boolean} version
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype.version = false;

            /**
             * GlobalCLIOptions _fullCommand.
             * @member {string} _fullCommand
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype._fullCommand = "";

            /**
             * GlobalCLIOptions _action.
             * @member {string} _action
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype._action = "";

            /**
             * GlobalCLIOptions _backend.
             * @member {string} _backend
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype._backend = "";

            /**
             * Creates a new GlobalCLIOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {protos.opts.IGlobalCLIOptions=} [properties] Properties to set
             * @returns {protos.opts.GlobalCLIOptions} GlobalCLIOptions instance
             */
            GlobalCLIOptions.create = function create(properties) {
                return new GlobalCLIOptions(properties);
            };

            /**
             * Encodes the specified GlobalCLIOptions message. Does not implicitly {@link protos.opts.GlobalCLIOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {protos.opts.IGlobalCLIOptions} message GlobalCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlobalCLIOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.debug != null && Object.hasOwnProperty.call(message, "debug"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.debug);
                if (message.quiet != null && Object.hasOwnProperty.call(message, "quiet"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.quiet);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.version);
                if (message._fullCommand != null && Object.hasOwnProperty.call(message, "_fullCommand"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._fullCommand);
                if (message._action != null && Object.hasOwnProperty.call(message, "_action"))
                    writer.uint32(/* id 1001, wireType 2 =*/8010).string(message._action);
                if (message._backend != null && Object.hasOwnProperty.call(message, "_backend"))
                    writer.uint32(/* id 1002, wireType 2 =*/8018).string(message._backend);
                return writer;
            };

            /**
             * Encodes the specified GlobalCLIOptions message, length delimited. Does not implicitly {@link protos.opts.GlobalCLIOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {protos.opts.IGlobalCLIOptions} message GlobalCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlobalCLIOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GlobalCLIOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.GlobalCLIOptions} GlobalCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlobalCLIOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.GlobalCLIOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.debug = reader.bool();
                        break;
                    case 2:
                        message.quiet = reader.bool();
                        break;
                    case 3:
                        message.version = reader.bool();
                        break;
                    case 1000:
                        message._fullCommand = reader.string();
                        break;
                    case 1001:
                        message._action = reader.string();
                        break;
                    case 1002:
                        message._backend = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GlobalCLIOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.GlobalCLIOptions} GlobalCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlobalCLIOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GlobalCLIOptions message.
             * @function verify
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GlobalCLIOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.debug != null && message.hasOwnProperty("debug"))
                    if (typeof message.debug !== "boolean")
                        return "debug: boolean expected";
                if (message.quiet != null && message.hasOwnProperty("quiet"))
                    if (typeof message.quiet !== "boolean")
                        return "quiet: boolean expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (typeof message.version !== "boolean")
                        return "version: boolean expected";
                if (message._fullCommand != null && message.hasOwnProperty("_fullCommand"))
                    if (!$util.isString(message._fullCommand))
                        return "_fullCommand: string expected";
                if (message._action != null && message.hasOwnProperty("_action"))
                    if (!$util.isString(message._action))
                        return "_action: string expected";
                if (message._backend != null && message.hasOwnProperty("_backend"))
                    if (!$util.isString(message._backend))
                        return "_backend: string expected";
                return null;
            };

            /**
             * Creates a GlobalCLIOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.GlobalCLIOptions} GlobalCLIOptions
             */
            GlobalCLIOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.GlobalCLIOptions)
                    return object;
                let message = new $root.protos.opts.GlobalCLIOptions();
                if (object.debug != null)
                    message.debug = Boolean(object.debug);
                if (object.quiet != null)
                    message.quiet = Boolean(object.quiet);
                if (object.version != null)
                    message.version = Boolean(object.version);
                if (object._fullCommand != null)
                    message._fullCommand = String(object._fullCommand);
                if (object._action != null)
                    message._action = String(object._action);
                if (object._backend != null)
                    message._backend = String(object._backend);
                return message;
            };

            /**
             * Creates a plain object from a GlobalCLIOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {protos.opts.GlobalCLIOptions} message GlobalCLIOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GlobalCLIOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.debug = false;
                    object.quiet = false;
                    object.version = false;
                    object._fullCommand = "";
                    object._action = "";
                    object._backend = "";
                }
                if (message.debug != null && message.hasOwnProperty("debug"))
                    object.debug = message.debug;
                if (message.quiet != null && message.hasOwnProperty("quiet"))
                    object.quiet = message.quiet;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message._fullCommand != null && message.hasOwnProperty("_fullCommand"))
                    object._fullCommand = message._fullCommand;
                if (message._action != null && message.hasOwnProperty("_action"))
                    object._action = message._action;
                if (message._backend != null && message.hasOwnProperty("_backend"))
                    object._backend = message._backend;
                return object;
            };

            /**
             * Converts this GlobalCLIOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GlobalCLIOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GlobalCLIOptions;
        })();

        opts.CLIOptions = (function() {

            /**
             * Properties of a CLIOptions.
             * @memberof protos.opts
             * @interface ICLIOptions
             * @property {protos.opts.IGlobalCLIOptions|null} [global] CLIOptions global
             * @property {protos.opts.IReadOptions|null} [read] CLIOptions read
             * @property {protos.opts.IWriteOptions|null} [write] CLIOptions write
             * @property {protos.opts.IRelayOptions|null} [relay] CLIOptions relay
             * @property {protos.opts.IDynamicOptions|null} [dynamic] CLIOptions dynamic
             * @property {protos.opts.IBatchOptions|null} [batch] CLIOptions batch
             * @property {protos.opts.IServerOptions|null} [server] CLIOptions server
             */

            /**
             * Constructs a new CLIOptions.
             * @memberof protos.opts
             * @classdesc Represents a CLIOptions.
             * @implements ICLIOptions
             * @constructor
             * @param {protos.opts.ICLIOptions=} [properties] Properties to set
             */
            function CLIOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CLIOptions global.
             * @member {protos.opts.IGlobalCLIOptions|null|undefined} global
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.global = null;

            /**
             * CLIOptions read.
             * @member {protos.opts.IReadOptions|null|undefined} read
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.read = null;

            /**
             * CLIOptions write.
             * @member {protos.opts.IWriteOptions|null|undefined} write
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.write = null;

            /**
             * CLIOptions relay.
             * @member {protos.opts.IRelayOptions|null|undefined} relay
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.relay = null;

            /**
             * CLIOptions dynamic.
             * @member {protos.opts.IDynamicOptions|null|undefined} dynamic
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.dynamic = null;

            /**
             * CLIOptions batch.
             * @member {protos.opts.IBatchOptions|null|undefined} batch
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.batch = null;

            /**
             * CLIOptions server.
             * @member {protos.opts.IServerOptions|null|undefined} server
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.server = null;

            /**
             * Creates a new CLIOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {protos.opts.ICLIOptions=} [properties] Properties to set
             * @returns {protos.opts.CLIOptions} CLIOptions instance
             */
            CLIOptions.create = function create(properties) {
                return new CLIOptions(properties);
            };

            /**
             * Encodes the specified CLIOptions message. Does not implicitly {@link protos.opts.CLIOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {protos.opts.ICLIOptions} message CLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CLIOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.global != null && Object.hasOwnProperty.call(message, "global"))
                    $root.protos.opts.GlobalCLIOptions.encode(message.global, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.read != null && Object.hasOwnProperty.call(message, "read"))
                    $root.protos.opts.ReadOptions.encode(message.read, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.write != null && Object.hasOwnProperty.call(message, "write"))
                    $root.protos.opts.WriteOptions.encode(message.write, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.relay != null && Object.hasOwnProperty.call(message, "relay"))
                    $root.protos.opts.RelayOptions.encode(message.relay, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.dynamic != null && Object.hasOwnProperty.call(message, "dynamic"))
                    $root.protos.opts.DynamicOptions.encode(message.dynamic, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.batch != null && Object.hasOwnProperty.call(message, "batch"))
                    $root.protos.opts.BatchOptions.encode(message.batch, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.server != null && Object.hasOwnProperty.call(message, "server"))
                    $root.protos.opts.ServerOptions.encode(message.server, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CLIOptions message, length delimited. Does not implicitly {@link protos.opts.CLIOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {protos.opts.ICLIOptions} message CLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CLIOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CLIOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.CLIOptions} CLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CLIOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.CLIOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.global = $root.protos.opts.GlobalCLIOptions.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.read = $root.protos.opts.ReadOptions.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.write = $root.protos.opts.WriteOptions.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.relay = $root.protos.opts.RelayOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.dynamic = $root.protos.opts.DynamicOptions.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.batch = $root.protos.opts.BatchOptions.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.server = $root.protos.opts.ServerOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CLIOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.CLIOptions} CLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CLIOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CLIOptions message.
             * @function verify
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CLIOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.global != null && message.hasOwnProperty("global")) {
                    let error = $root.protos.opts.GlobalCLIOptions.verify(message.global);
                    if (error)
                        return "global." + error;
                }
                if (message.read != null && message.hasOwnProperty("read")) {
                    let error = $root.protos.opts.ReadOptions.verify(message.read);
                    if (error)
                        return "read." + error;
                }
                if (message.write != null && message.hasOwnProperty("write")) {
                    let error = $root.protos.opts.WriteOptions.verify(message.write);
                    if (error)
                        return "write." + error;
                }
                if (message.relay != null && message.hasOwnProperty("relay")) {
                    let error = $root.protos.opts.RelayOptions.verify(message.relay);
                    if (error)
                        return "relay." + error;
                }
                if (message.dynamic != null && message.hasOwnProperty("dynamic")) {
                    let error = $root.protos.opts.DynamicOptions.verify(message.dynamic);
                    if (error)
                        return "dynamic." + error;
                }
                if (message.batch != null && message.hasOwnProperty("batch")) {
                    let error = $root.protos.opts.BatchOptions.verify(message.batch);
                    if (error)
                        return "batch." + error;
                }
                if (message.server != null && message.hasOwnProperty("server")) {
                    let error = $root.protos.opts.ServerOptions.verify(message.server);
                    if (error)
                        return "server." + error;
                }
                return null;
            };

            /**
             * Creates a CLIOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.CLIOptions} CLIOptions
             */
            CLIOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.CLIOptions)
                    return object;
                let message = new $root.protos.opts.CLIOptions();
                if (object.global != null) {
                    if (typeof object.global !== "object")
                        throw TypeError(".protos.opts.CLIOptions.global: object expected");
                    message.global = $root.protos.opts.GlobalCLIOptions.fromObject(object.global);
                }
                if (object.read != null) {
                    if (typeof object.read !== "object")
                        throw TypeError(".protos.opts.CLIOptions.read: object expected");
                    message.read = $root.protos.opts.ReadOptions.fromObject(object.read);
                }
                if (object.write != null) {
                    if (typeof object.write !== "object")
                        throw TypeError(".protos.opts.CLIOptions.write: object expected");
                    message.write = $root.protos.opts.WriteOptions.fromObject(object.write);
                }
                if (object.relay != null) {
                    if (typeof object.relay !== "object")
                        throw TypeError(".protos.opts.CLIOptions.relay: object expected");
                    message.relay = $root.protos.opts.RelayOptions.fromObject(object.relay);
                }
                if (object.dynamic != null) {
                    if (typeof object.dynamic !== "object")
                        throw TypeError(".protos.opts.CLIOptions.dynamic: object expected");
                    message.dynamic = $root.protos.opts.DynamicOptions.fromObject(object.dynamic);
                }
                if (object.batch != null) {
                    if (typeof object.batch !== "object")
                        throw TypeError(".protos.opts.CLIOptions.batch: object expected");
                    message.batch = $root.protos.opts.BatchOptions.fromObject(object.batch);
                }
                if (object.server != null) {
                    if (typeof object.server !== "object")
                        throw TypeError(".protos.opts.CLIOptions.server: object expected");
                    message.server = $root.protos.opts.ServerOptions.fromObject(object.server);
                }
                return message;
            };

            /**
             * Creates a plain object from a CLIOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {protos.opts.CLIOptions} message CLIOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CLIOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.global = null;
                    object.read = null;
                    object.write = null;
                    object.relay = null;
                    object.dynamic = null;
                    object.batch = null;
                    object.server = null;
                }
                if (message.global != null && message.hasOwnProperty("global"))
                    object.global = $root.protos.opts.GlobalCLIOptions.toObject(message.global, options);
                if (message.read != null && message.hasOwnProperty("read"))
                    object.read = $root.protos.opts.ReadOptions.toObject(message.read, options);
                if (message.write != null && message.hasOwnProperty("write"))
                    object.write = $root.protos.opts.WriteOptions.toObject(message.write, options);
                if (message.relay != null && message.hasOwnProperty("relay"))
                    object.relay = $root.protos.opts.RelayOptions.toObject(message.relay, options);
                if (message.dynamic != null && message.hasOwnProperty("dynamic"))
                    object.dynamic = $root.protos.opts.DynamicOptions.toObject(message.dynamic, options);
                if (message.batch != null && message.hasOwnProperty("batch"))
                    object.batch = $root.protos.opts.BatchOptions.toObject(message.batch, options);
                if (message.server != null && message.hasOwnProperty("server"))
                    object.server = $root.protos.opts.ServerOptions.toObject(message.server, options);
                return object;
            };

            /**
             * Converts this CLIOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.CLIOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CLIOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CLIOptions;
        })();

        /**
         * ConvertOption enum.
         * @name protos.opts.ConvertOption
         * @enum {number}
         * @property {number} CONVERT_OPTION_UNSET=0 CONVERT_OPTION_UNSET value
         * @property {number} CONVERT_OPTION_BASE64=1 CONVERT_OPTION_BASE64 value
         * @property {number} CONVERT_OPTION_GZIP=2 CONVERT_OPTION_GZIP value
         */
        opts.ConvertOption = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CONVERT_OPTION_UNSET"] = 0;
            values[valuesById[1] = "CONVERT_OPTION_BASE64"] = 1;
            values[valuesById[2] = "CONVERT_OPTION_GZIP"] = 2;
            return values;
        })();

        opts.ReadCLIOptions = (function() {

            /**
             * Properties of a ReadCLIOptions.
             * @memberof protos.opts
             * @interface IReadCLIOptions
             * @property {boolean|null} [verboseOutput] ReadCLIOptions verboseOutput
             * @property {boolean|null} [statsEnable] ReadCLIOptions statsEnable
             * @property {number|null} [statsReportIntervalSec] ReadCLIOptions statsReportIntervalSec
             * @property {boolean|null} [pretty] ReadCLIOptions pretty
             */

            /**
             * Constructs a new ReadCLIOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadCLIOptions.
             * @implements IReadCLIOptions
             * @constructor
             * @param {protos.opts.IReadCLIOptions=} [properties] Properties to set
             */
            function ReadCLIOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadCLIOptions verboseOutput.
             * @member {boolean} verboseOutput
             * @memberof protos.opts.ReadCLIOptions
             * @instance
             */
            ReadCLIOptions.prototype.verboseOutput = false;

            /**
             * ReadCLIOptions statsEnable.
             * @member {boolean} statsEnable
             * @memberof protos.opts.ReadCLIOptions
             * @instance
             */
            ReadCLIOptions.prototype.statsEnable = false;

            /**
             * ReadCLIOptions statsReportIntervalSec.
             * @member {number} statsReportIntervalSec
             * @memberof protos.opts.ReadCLIOptions
             * @instance
             */
            ReadCLIOptions.prototype.statsReportIntervalSec = 0;

            /**
             * ReadCLIOptions pretty.
             * @member {boolean} pretty
             * @memberof protos.opts.ReadCLIOptions
             * @instance
             */
            ReadCLIOptions.prototype.pretty = false;

            /**
             * Creates a new ReadCLIOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {protos.opts.IReadCLIOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadCLIOptions} ReadCLIOptions instance
             */
            ReadCLIOptions.create = function create(properties) {
                return new ReadCLIOptions(properties);
            };

            /**
             * Encodes the specified ReadCLIOptions message. Does not implicitly {@link protos.opts.ReadCLIOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {protos.opts.IReadCLIOptions} message ReadCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadCLIOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.verboseOutput != null && Object.hasOwnProperty.call(message, "verboseOutput"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.verboseOutput);
                if (message.statsEnable != null && Object.hasOwnProperty.call(message, "statsEnable"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.statsEnable);
                if (message.statsReportIntervalSec != null && Object.hasOwnProperty.call(message, "statsReportIntervalSec"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.statsReportIntervalSec);
                if (message.pretty != null && Object.hasOwnProperty.call(message, "pretty"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.pretty);
                return writer;
            };

            /**
             * Encodes the specified ReadCLIOptions message, length delimited. Does not implicitly {@link protos.opts.ReadCLIOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {protos.opts.IReadCLIOptions} message ReadCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadCLIOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadCLIOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadCLIOptions} ReadCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadCLIOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadCLIOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.verboseOutput = reader.bool();
                        break;
                    case 2:
                        message.statsEnable = reader.bool();
                        break;
                    case 3:
                        message.statsReportIntervalSec = reader.int32();
                        break;
                    case 4:
                        message.pretty = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadCLIOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadCLIOptions} ReadCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadCLIOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadCLIOptions message.
             * @function verify
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadCLIOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.verboseOutput != null && message.hasOwnProperty("verboseOutput"))
                    if (typeof message.verboseOutput !== "boolean")
                        return "verboseOutput: boolean expected";
                if (message.statsEnable != null && message.hasOwnProperty("statsEnable"))
                    if (typeof message.statsEnable !== "boolean")
                        return "statsEnable: boolean expected";
                if (message.statsReportIntervalSec != null && message.hasOwnProperty("statsReportIntervalSec"))
                    if (!$util.isInteger(message.statsReportIntervalSec))
                        return "statsReportIntervalSec: integer expected";
                if (message.pretty != null && message.hasOwnProperty("pretty"))
                    if (typeof message.pretty !== "boolean")
                        return "pretty: boolean expected";
                return null;
            };

            /**
             * Creates a ReadCLIOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadCLIOptions} ReadCLIOptions
             */
            ReadCLIOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadCLIOptions)
                    return object;
                let message = new $root.protos.opts.ReadCLIOptions();
                if (object.verboseOutput != null)
                    message.verboseOutput = Boolean(object.verboseOutput);
                if (object.statsEnable != null)
                    message.statsEnable = Boolean(object.statsEnable);
                if (object.statsReportIntervalSec != null)
                    message.statsReportIntervalSec = object.statsReportIntervalSec | 0;
                if (object.pretty != null)
                    message.pretty = Boolean(object.pretty);
                return message;
            };

            /**
             * Creates a plain object from a ReadCLIOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {protos.opts.ReadCLIOptions} message ReadCLIOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadCLIOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.verboseOutput = false;
                    object.statsEnable = false;
                    object.statsReportIntervalSec = 0;
                    object.pretty = false;
                }
                if (message.verboseOutput != null && message.hasOwnProperty("verboseOutput"))
                    object.verboseOutput = message.verboseOutput;
                if (message.statsEnable != null && message.hasOwnProperty("statsEnable"))
                    object.statsEnable = message.statsEnable;
                if (message.statsReportIntervalSec != null && message.hasOwnProperty("statsReportIntervalSec"))
                    object.statsReportIntervalSec = message.statsReportIntervalSec;
                if (message.pretty != null && message.hasOwnProperty("pretty"))
                    object.pretty = message.pretty;
                return object;
            };

            /**
             * Converts this ReadCLIOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadCLIOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadCLIOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadCLIOptions;
        })();

        opts.ReadSampleOptions = (function() {

            /**
             * Properties of a ReadSampleOptions.
             * @memberof protos.opts
             * @interface IReadSampleOptions
             * @property {number|null} [sampleRate] ReadSampleOptions sampleRate
             * @property {number|null} [sampleIntervalSeconds] ReadSampleOptions sampleIntervalSeconds
             */

            /**
             * Constructs a new ReadSampleOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadSampleOptions.
             * @implements IReadSampleOptions
             * @constructor
             * @param {protos.opts.IReadSampleOptions=} [properties] Properties to set
             */
            function ReadSampleOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadSampleOptions sampleRate.
             * @member {number} sampleRate
             * @memberof protos.opts.ReadSampleOptions
             * @instance
             */
            ReadSampleOptions.prototype.sampleRate = 0;

            /**
             * ReadSampleOptions sampleIntervalSeconds.
             * @member {number} sampleIntervalSeconds
             * @memberof protos.opts.ReadSampleOptions
             * @instance
             */
            ReadSampleOptions.prototype.sampleIntervalSeconds = 0;

            /**
             * Creates a new ReadSampleOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {protos.opts.IReadSampleOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadSampleOptions} ReadSampleOptions instance
             */
            ReadSampleOptions.create = function create(properties) {
                return new ReadSampleOptions(properties);
            };

            /**
             * Encodes the specified ReadSampleOptions message. Does not implicitly {@link protos.opts.ReadSampleOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {protos.opts.IReadSampleOptions} message ReadSampleOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadSampleOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sampleRate != null && Object.hasOwnProperty.call(message, "sampleRate"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.sampleRate);
                if (message.sampleIntervalSeconds != null && Object.hasOwnProperty.call(message, "sampleIntervalSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.sampleIntervalSeconds);
                return writer;
            };

            /**
             * Encodes the specified ReadSampleOptions message, length delimited. Does not implicitly {@link protos.opts.ReadSampleOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {protos.opts.IReadSampleOptions} message ReadSampleOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadSampleOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadSampleOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadSampleOptions} ReadSampleOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadSampleOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadSampleOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sampleRate = reader.uint32();
                        break;
                    case 2:
                        message.sampleIntervalSeconds = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadSampleOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadSampleOptions} ReadSampleOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadSampleOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadSampleOptions message.
             * @function verify
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadSampleOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sampleRate != null && message.hasOwnProperty("sampleRate"))
                    if (!$util.isInteger(message.sampleRate))
                        return "sampleRate: integer expected";
                if (message.sampleIntervalSeconds != null && message.hasOwnProperty("sampleIntervalSeconds"))
                    if (!$util.isInteger(message.sampleIntervalSeconds))
                        return "sampleIntervalSeconds: integer expected";
                return null;
            };

            /**
             * Creates a ReadSampleOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadSampleOptions} ReadSampleOptions
             */
            ReadSampleOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadSampleOptions)
                    return object;
                let message = new $root.protos.opts.ReadSampleOptions();
                if (object.sampleRate != null)
                    message.sampleRate = object.sampleRate >>> 0;
                if (object.sampleIntervalSeconds != null)
                    message.sampleIntervalSeconds = object.sampleIntervalSeconds >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a ReadSampleOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {protos.opts.ReadSampleOptions} message ReadSampleOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadSampleOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.sampleRate = 0;
                    object.sampleIntervalSeconds = 0;
                }
                if (message.sampleRate != null && message.hasOwnProperty("sampleRate"))
                    object.sampleRate = message.sampleRate;
                if (message.sampleIntervalSeconds != null && message.hasOwnProperty("sampleIntervalSeconds"))
                    object.sampleIntervalSeconds = message.sampleIntervalSeconds;
                return object;
            };

            /**
             * Converts this ReadSampleOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadSampleOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadSampleOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadSampleOptions;
        })();

        opts.ReadOptions = (function() {

            /**
             * Properties of a ReadOptions.
             * @memberof protos.opts
             * @interface IReadOptions
             * @property {string|null} [name] ReadOptions name
             * @property {string|null} [connectionId] ReadOptions connectionId
             * @property {boolean|null} [continuous] ReadOptions continuous
             * @property {protos.opts.IReadSampleOptions|null} [sampleOptions] ReadOptions sampleOptions
             * @property {protos.encoding.IDecodeOptions|null} [decodeOptions] ReadOptions decodeOptions
             * @property {protos.opts.ConvertOption|null} [convertOutput] ReadOptions convertOutput
             * @property {string|null} [_id] ReadOptions _id
             * @property {boolean|null} [_active] ReadOptions _active
             * @property {protos.opts.IReadCLIOptions|null} [_cliOptions] ReadOptions _cliOptions
             * @property {protos.opts.IReadGroupKafkaOptions|null} [kafka] ReadOptions kafka
             * @property {protos.opts.IReadGroupActiveMQOptions|null} [activemq] ReadOptions activemq
             * @property {protos.opts.IReadGroupAWSSQSOptions|null} [awssqs] ReadOptions awssqs
             * @property {protos.opts.IReadGroupMongoOptions|null} [mongo] ReadOptions mongo
             * @property {protos.opts.IReadGroupNatsOptions|null} [nats] ReadOptions nats
             * @property {protos.opts.IReadGroupNatsStreamingOptions|null} [natsStreaming] ReadOptions natsStreaming
             * @property {protos.opts.IReadGroupNSQOptions|null} [nsq] ReadOptions nsq
             * @property {protos.opts.IReadGroupPulsarOptions|null} [pulsar] ReadOptions pulsar
             * @property {protos.opts.IReadGroupRabbitOptions|null} [rabbit] ReadOptions rabbit
             * @property {protos.opts.IReadGroupRabbitStreamsOptions|null} [rabbitStreams] ReadOptions rabbitStreams
             * @property {protos.opts.IReadGroupMQTTOptions|null} [mqtt] ReadOptions mqtt
             * @property {protos.opts.IReadGroupAzureServiceBusOptions|null} [azureServiceBus] ReadOptions azureServiceBus
             * @property {protos.opts.IReadGroupAzureEventHubOptions|null} [azureEventHub] ReadOptions azureEventHub
             * @property {protos.opts.IReadGroupGCPPubSubOptions|null} [gcpPubsub] ReadOptions gcpPubsub
             * @property {protos.opts.IReadGroupKubeMQQueueOptions|null} [kubemqQueue] ReadOptions kubemqQueue
             * @property {protos.opts.IReadGroupRedisPubSubOptions|null} [redisPubsub] ReadOptions redisPubsub
             * @property {protos.opts.IReadGroupRedisStreamsOptions|null} [redisStreams] ReadOptions redisStreams
             * @property {protos.opts.IReadGroupPostgresOptions|null} [postgres] ReadOptions postgres
             */

            /**
             * Constructs a new ReadOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadOptions.
             * @implements IReadOptions
             * @constructor
             * @param {protos.opts.IReadOptions=} [properties] Properties to set
             */
            function ReadOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadOptions name.
             * @member {string} name
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.name = "";

            /**
             * ReadOptions connectionId.
             * @member {string} connectionId
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.connectionId = "";

            /**
             * ReadOptions continuous.
             * @member {boolean} continuous
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.continuous = false;

            /**
             * ReadOptions sampleOptions.
             * @member {protos.opts.IReadSampleOptions|null|undefined} sampleOptions
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.sampleOptions = null;

            /**
             * ReadOptions decodeOptions.
             * @member {protos.encoding.IDecodeOptions|null|undefined} decodeOptions
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.decodeOptions = null;

            /**
             * ReadOptions convertOutput.
             * @member {protos.opts.ConvertOption} convertOutput
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.convertOutput = 0;

            /**
             * ReadOptions _id.
             * @member {string} _id
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype._id = "";

            /**
             * ReadOptions _active.
             * @member {boolean} _active
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype._active = false;

            /**
             * ReadOptions _cliOptions.
             * @member {protos.opts.IReadCLIOptions|null|undefined} _cliOptions
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype._cliOptions = null;

            /**
             * ReadOptions kafka.
             * @member {protos.opts.IReadGroupKafkaOptions|null|undefined} kafka
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.kafka = null;

            /**
             * ReadOptions activemq.
             * @member {protos.opts.IReadGroupActiveMQOptions|null|undefined} activemq
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.activemq = null;

            /**
             * ReadOptions awssqs.
             * @member {protos.opts.IReadGroupAWSSQSOptions|null|undefined} awssqs
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.awssqs = null;

            /**
             * ReadOptions mongo.
             * @member {protos.opts.IReadGroupMongoOptions|null|undefined} mongo
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.mongo = null;

            /**
             * ReadOptions nats.
             * @member {protos.opts.IReadGroupNatsOptions|null|undefined} nats
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.nats = null;

            /**
             * ReadOptions natsStreaming.
             * @member {protos.opts.IReadGroupNatsStreamingOptions|null|undefined} natsStreaming
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.natsStreaming = null;

            /**
             * ReadOptions nsq.
             * @member {protos.opts.IReadGroupNSQOptions|null|undefined} nsq
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.nsq = null;

            /**
             * ReadOptions pulsar.
             * @member {protos.opts.IReadGroupPulsarOptions|null|undefined} pulsar
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.pulsar = null;

            /**
             * ReadOptions rabbit.
             * @member {protos.opts.IReadGroupRabbitOptions|null|undefined} rabbit
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.rabbit = null;

            /**
             * ReadOptions rabbitStreams.
             * @member {protos.opts.IReadGroupRabbitStreamsOptions|null|undefined} rabbitStreams
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.rabbitStreams = null;

            /**
             * ReadOptions mqtt.
             * @member {protos.opts.IReadGroupMQTTOptions|null|undefined} mqtt
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.mqtt = null;

            /**
             * ReadOptions azureServiceBus.
             * @member {protos.opts.IReadGroupAzureServiceBusOptions|null|undefined} azureServiceBus
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.azureServiceBus = null;

            /**
             * ReadOptions azureEventHub.
             * @member {protos.opts.IReadGroupAzureEventHubOptions|null|undefined} azureEventHub
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.azureEventHub = null;

            /**
             * ReadOptions gcpPubsub.
             * @member {protos.opts.IReadGroupGCPPubSubOptions|null|undefined} gcpPubsub
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.gcpPubsub = null;

            /**
             * ReadOptions kubemqQueue.
             * @member {protos.opts.IReadGroupKubeMQQueueOptions|null|undefined} kubemqQueue
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.kubemqQueue = null;

            /**
             * ReadOptions redisPubsub.
             * @member {protos.opts.IReadGroupRedisPubSubOptions|null|undefined} redisPubsub
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.redisPubsub = null;

            /**
             * ReadOptions redisStreams.
             * @member {protos.opts.IReadGroupRedisStreamsOptions|null|undefined} redisStreams
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.redisStreams = null;

            /**
             * ReadOptions postgres.
             * @member {protos.opts.IReadGroupPostgresOptions|null|undefined} postgres
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.postgres = null;

            /**
             * Creates a new ReadOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {protos.opts.IReadOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadOptions} ReadOptions instance
             */
            ReadOptions.create = function create(properties) {
                return new ReadOptions(properties);
            };

            /**
             * Encodes the specified ReadOptions message. Does not implicitly {@link protos.opts.ReadOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {protos.opts.IReadOptions} message ReadOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.connectionId);
                if (message.continuous != null && Object.hasOwnProperty.call(message, "continuous"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.continuous);
                if (message.sampleOptions != null && Object.hasOwnProperty.call(message, "sampleOptions"))
                    $root.protos.opts.ReadSampleOptions.encode(message.sampleOptions, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.decodeOptions != null && Object.hasOwnProperty.call(message, "decodeOptions"))
                    $root.protos.encoding.DecodeOptions.encode(message.decodeOptions, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.convertOutput != null && Object.hasOwnProperty.call(message, "convertOutput"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.convertOutput);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.opts.ReadGroupKafkaOptions.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.activemq != null && Object.hasOwnProperty.call(message, "activemq"))
                    $root.protos.opts.ReadGroupActiveMQOptions.encode(message.activemq, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.awssqs != null && Object.hasOwnProperty.call(message, "awssqs"))
                    $root.protos.opts.ReadGroupAWSSQSOptions.encode(message.awssqs, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.mongo != null && Object.hasOwnProperty.call(message, "mongo"))
                    $root.protos.opts.ReadGroupMongoOptions.encode(message.mongo, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.opts.ReadGroupNatsOptions.encode(message.nats, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.opts.ReadGroupNatsStreamingOptions.encode(message.natsStreaming, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.opts.ReadGroupNSQOptions.encode(message.nsq, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.pulsar != null && Object.hasOwnProperty.call(message, "pulsar"))
                    $root.protos.opts.ReadGroupPulsarOptions.encode(message.pulsar, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.opts.ReadGroupRabbitOptions.encode(message.rabbit, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.rabbitStreams != null && Object.hasOwnProperty.call(message, "rabbitStreams"))
                    $root.protos.opts.ReadGroupRabbitStreamsOptions.encode(message.rabbitStreams, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.opts.ReadGroupMQTTOptions.encode(message.mqtt, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.opts.ReadGroupAzureServiceBusOptions.encode(message.azureServiceBus, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.azureEventHub != null && Object.hasOwnProperty.call(message, "azureEventHub"))
                    $root.protos.opts.ReadGroupAzureEventHubOptions.encode(message.azureEventHub, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.opts.ReadGroupGCPPubSubOptions.encode(message.gcpPubsub, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.opts.ReadGroupKubeMQQueueOptions.encode(message.kubemqQueue, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.opts.ReadGroupRedisPubSubOptions.encode(message.redisPubsub, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.opts.ReadGroupRedisStreamsOptions.encode(message.redisStreams, writer.uint32(/* id 116, wireType 2 =*/930).fork()).ldelim();
                if (message.postgres != null && Object.hasOwnProperty.call(message, "postgres"))
                    $root.protos.opts.ReadGroupPostgresOptions.encode(message.postgres, writer.uint32(/* id 117, wireType 2 =*/938).fork()).ldelim();
                if (message._id != null && Object.hasOwnProperty.call(message, "_id"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._id);
                if (message._active != null && Object.hasOwnProperty.call(message, "_active"))
                    writer.uint32(/* id 1001, wireType 0 =*/8008).bool(message._active);
                if (message._cliOptions != null && Object.hasOwnProperty.call(message, "_cliOptions"))
                    $root.protos.opts.ReadCLIOptions.encode(message._cliOptions, writer.uint32(/* id 1002, wireType 2 =*/8018).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadOptions message, length delimited. Does not implicitly {@link protos.opts.ReadOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {protos.opts.IReadOptions} message ReadOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadOptions} ReadOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.connectionId = reader.string();
                        break;
                    case 3:
                        message.continuous = reader.bool();
                        break;
                    case 4:
                        message.sampleOptions = $root.protos.opts.ReadSampleOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.decodeOptions = $root.protos.encoding.DecodeOptions.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.convertOutput = reader.int32();
                        break;
                    case 1000:
                        message._id = reader.string();
                        break;
                    case 1001:
                        message._active = reader.bool();
                        break;
                    case 1002:
                        message._cliOptions = $root.protos.opts.ReadCLIOptions.decode(reader, reader.uint32());
                        break;
                    case 100:
                        message.kafka = $root.protos.opts.ReadGroupKafkaOptions.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.activemq = $root.protos.opts.ReadGroupActiveMQOptions.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.awssqs = $root.protos.opts.ReadGroupAWSSQSOptions.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.mongo = $root.protos.opts.ReadGroupMongoOptions.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.nats = $root.protos.opts.ReadGroupNatsOptions.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.natsStreaming = $root.protos.opts.ReadGroupNatsStreamingOptions.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.nsq = $root.protos.opts.ReadGroupNSQOptions.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.pulsar = $root.protos.opts.ReadGroupPulsarOptions.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.rabbit = $root.protos.opts.ReadGroupRabbitOptions.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.rabbitStreams = $root.protos.opts.ReadGroupRabbitStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 110:
                        message.mqtt = $root.protos.opts.ReadGroupMQTTOptions.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.azureServiceBus = $root.protos.opts.ReadGroupAzureServiceBusOptions.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.azureEventHub = $root.protos.opts.ReadGroupAzureEventHubOptions.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.gcpPubsub = $root.protos.opts.ReadGroupGCPPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.kubemqQueue = $root.protos.opts.ReadGroupKubeMQQueueOptions.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.redisPubsub = $root.protos.opts.ReadGroupRedisPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 116:
                        message.redisStreams = $root.protos.opts.ReadGroupRedisStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 117:
                        message.postgres = $root.protos.opts.ReadGroupPostgresOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadOptions} ReadOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadOptions message.
             * @function verify
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    if (!$util.isString(message.connectionId))
                        return "connectionId: string expected";
                if (message.continuous != null && message.hasOwnProperty("continuous"))
                    if (typeof message.continuous !== "boolean")
                        return "continuous: boolean expected";
                if (message.sampleOptions != null && message.hasOwnProperty("sampleOptions")) {
                    let error = $root.protos.opts.ReadSampleOptions.verify(message.sampleOptions);
                    if (error)
                        return "sampleOptions." + error;
                }
                if (message.decodeOptions != null && message.hasOwnProperty("decodeOptions")) {
                    let error = $root.protos.encoding.DecodeOptions.verify(message.decodeOptions);
                    if (error)
                        return "decodeOptions." + error;
                }
                if (message.convertOutput != null && message.hasOwnProperty("convertOutput"))
                    switch (message.convertOutput) {
                    default:
                        return "convertOutput: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message._id != null && message.hasOwnProperty("_id"))
                    if (!$util.isString(message._id))
                        return "_id: string expected";
                if (message._active != null && message.hasOwnProperty("_active"))
                    if (typeof message._active !== "boolean")
                        return "_active: boolean expected";
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions")) {
                    let error = $root.protos.opts.ReadCLIOptions.verify(message._cliOptions);
                    if (error)
                        return "_cliOptions." + error;
                }
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    let error = $root.protos.opts.ReadGroupKafkaOptions.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.activemq != null && message.hasOwnProperty("activemq")) {
                    let error = $root.protos.opts.ReadGroupActiveMQOptions.verify(message.activemq);
                    if (error)
                        return "activemq." + error;
                }
                if (message.awssqs != null && message.hasOwnProperty("awssqs")) {
                    let error = $root.protos.opts.ReadGroupAWSSQSOptions.verify(message.awssqs);
                    if (error)
                        return "awssqs." + error;
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    let error = $root.protos.opts.ReadGroupMongoOptions.verify(message.mongo);
                    if (error)
                        return "mongo." + error;
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    let error = $root.protos.opts.ReadGroupNatsOptions.verify(message.nats);
                    if (error)
                        return "nats." + error;
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    let error = $root.protos.opts.ReadGroupNatsStreamingOptions.verify(message.natsStreaming);
                    if (error)
                        return "natsStreaming." + error;
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    let error = $root.protos.opts.ReadGroupNSQOptions.verify(message.nsq);
                    if (error)
                        return "nsq." + error;
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    let error = $root.protos.opts.ReadGroupPulsarOptions.verify(message.pulsar);
                    if (error)
                        return "pulsar." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    let error = $root.protos.opts.ReadGroupRabbitOptions.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    let error = $root.protos.opts.ReadGroupRabbitStreamsOptions.verify(message.rabbitStreams);
                    if (error)
                        return "rabbitStreams." + error;
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    let error = $root.protos.opts.ReadGroupMQTTOptions.verify(message.mqtt);
                    if (error)
                        return "mqtt." + error;
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    let error = $root.protos.opts.ReadGroupAzureServiceBusOptions.verify(message.azureServiceBus);
                    if (error)
                        return "azureServiceBus." + error;
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    let error = $root.protos.opts.ReadGroupAzureEventHubOptions.verify(message.azureEventHub);
                    if (error)
                        return "azureEventHub." + error;
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    let error = $root.protos.opts.ReadGroupGCPPubSubOptions.verify(message.gcpPubsub);
                    if (error)
                        return "gcpPubsub." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    let error = $root.protos.opts.ReadGroupKubeMQQueueOptions.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    let error = $root.protos.opts.ReadGroupRedisPubSubOptions.verify(message.redisPubsub);
                    if (error)
                        return "redisPubsub." + error;
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    let error = $root.protos.opts.ReadGroupRedisStreamsOptions.verify(message.redisStreams);
                    if (error)
                        return "redisStreams." + error;
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    let error = $root.protos.opts.ReadGroupPostgresOptions.verify(message.postgres);
                    if (error)
                        return "postgres." + error;
                }
                return null;
            };

            /**
             * Creates a ReadOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadOptions} ReadOptions
             */
            ReadOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadOptions)
                    return object;
                let message = new $root.protos.opts.ReadOptions();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.connectionId != null)
                    message.connectionId = String(object.connectionId);
                if (object.continuous != null)
                    message.continuous = Boolean(object.continuous);
                if (object.sampleOptions != null) {
                    if (typeof object.sampleOptions !== "object")
                        throw TypeError(".protos.opts.ReadOptions.sampleOptions: object expected");
                    message.sampleOptions = $root.protos.opts.ReadSampleOptions.fromObject(object.sampleOptions);
                }
                if (object.decodeOptions != null) {
                    if (typeof object.decodeOptions !== "object")
                        throw TypeError(".protos.opts.ReadOptions.decodeOptions: object expected");
                    message.decodeOptions = $root.protos.encoding.DecodeOptions.fromObject(object.decodeOptions);
                }
                switch (object.convertOutput) {
                case "CONVERT_OPTION_UNSET":
                case 0:
                    message.convertOutput = 0;
                    break;
                case "CONVERT_OPTION_BASE64":
                case 1:
                    message.convertOutput = 1;
                    break;
                case "CONVERT_OPTION_GZIP":
                case 2:
                    message.convertOutput = 2;
                    break;
                }
                if (object._id != null)
                    message._id = String(object._id);
                if (object._active != null)
                    message._active = Boolean(object._active);
                if (object._cliOptions != null) {
                    if (typeof object._cliOptions !== "object")
                        throw TypeError(".protos.opts.ReadOptions._cliOptions: object expected");
                    message._cliOptions = $root.protos.opts.ReadCLIOptions.fromObject(object._cliOptions);
                }
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.ReadOptions.kafka: object expected");
                    message.kafka = $root.protos.opts.ReadGroupKafkaOptions.fromObject(object.kafka);
                }
                if (object.activemq != null) {
                    if (typeof object.activemq !== "object")
                        throw TypeError(".protos.opts.ReadOptions.activemq: object expected");
                    message.activemq = $root.protos.opts.ReadGroupActiveMQOptions.fromObject(object.activemq);
                }
                if (object.awssqs != null) {
                    if (typeof object.awssqs !== "object")
                        throw TypeError(".protos.opts.ReadOptions.awssqs: object expected");
                    message.awssqs = $root.protos.opts.ReadGroupAWSSQSOptions.fromObject(object.awssqs);
                }
                if (object.mongo != null) {
                    if (typeof object.mongo !== "object")
                        throw TypeError(".protos.opts.ReadOptions.mongo: object expected");
                    message.mongo = $root.protos.opts.ReadGroupMongoOptions.fromObject(object.mongo);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.opts.ReadOptions.nats: object expected");
                    message.nats = $root.protos.opts.ReadGroupNatsOptions.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.opts.ReadOptions.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.opts.ReadGroupNatsStreamingOptions.fromObject(object.natsStreaming);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.ReadOptions.nsq: object expected");
                    message.nsq = $root.protos.opts.ReadGroupNSQOptions.fromObject(object.nsq);
                }
                if (object.pulsar != null) {
                    if (typeof object.pulsar !== "object")
                        throw TypeError(".protos.opts.ReadOptions.pulsar: object expected");
                    message.pulsar = $root.protos.opts.ReadGroupPulsarOptions.fromObject(object.pulsar);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.ReadOptions.rabbit: object expected");
                    message.rabbit = $root.protos.opts.ReadGroupRabbitOptions.fromObject(object.rabbit);
                }
                if (object.rabbitStreams != null) {
                    if (typeof object.rabbitStreams !== "object")
                        throw TypeError(".protos.opts.ReadOptions.rabbitStreams: object expected");
                    message.rabbitStreams = $root.protos.opts.ReadGroupRabbitStreamsOptions.fromObject(object.rabbitStreams);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.ReadOptions.mqtt: object expected");
                    message.mqtt = $root.protos.opts.ReadGroupMQTTOptions.fromObject(object.mqtt);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.ReadOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.opts.ReadGroupAzureServiceBusOptions.fromObject(object.azureServiceBus);
                }
                if (object.azureEventHub != null) {
                    if (typeof object.azureEventHub !== "object")
                        throw TypeError(".protos.opts.ReadOptions.azureEventHub: object expected");
                    message.azureEventHub = $root.protos.opts.ReadGroupAzureEventHubOptions.fromObject(object.azureEventHub);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.ReadOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.opts.ReadGroupGCPPubSubOptions.fromObject(object.gcpPubsub);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.ReadOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.opts.ReadGroupKubeMQQueueOptions.fromObject(object.kubemqQueue);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.ReadOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.opts.ReadGroupRedisPubSubOptions.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.ReadOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.opts.ReadGroupRedisStreamsOptions.fromObject(object.redisStreams);
                }
                if (object.postgres != null) {
                    if (typeof object.postgres !== "object")
                        throw TypeError(".protos.opts.ReadOptions.postgres: object expected");
                    message.postgres = $root.protos.opts.ReadGroupPostgresOptions.fromObject(object.postgres);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {protos.opts.ReadOptions} message ReadOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.connectionId = "";
                    object.continuous = false;
                    object.sampleOptions = null;
                    object.decodeOptions = null;
                    object.convertOutput = options.enums === String ? "CONVERT_OPTION_UNSET" : 0;
                    object.kafka = null;
                    object.activemq = null;
                    object.awssqs = null;
                    object.mongo = null;
                    object.nats = null;
                    object.natsStreaming = null;
                    object.nsq = null;
                    object.pulsar = null;
                    object.rabbit = null;
                    object.rabbitStreams = null;
                    object.mqtt = null;
                    object.azureServiceBus = null;
                    object.azureEventHub = null;
                    object.gcpPubsub = null;
                    object.kubemqQueue = null;
                    object.redisPubsub = null;
                    object.redisStreams = null;
                    object.postgres = null;
                    object._id = "";
                    object._active = false;
                    object._cliOptions = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    object.connectionId = message.connectionId;
                if (message.continuous != null && message.hasOwnProperty("continuous"))
                    object.continuous = message.continuous;
                if (message.sampleOptions != null && message.hasOwnProperty("sampleOptions"))
                    object.sampleOptions = $root.protos.opts.ReadSampleOptions.toObject(message.sampleOptions, options);
                if (message.decodeOptions != null && message.hasOwnProperty("decodeOptions"))
                    object.decodeOptions = $root.protos.encoding.DecodeOptions.toObject(message.decodeOptions, options);
                if (message.convertOutput != null && message.hasOwnProperty("convertOutput"))
                    object.convertOutput = options.enums === String ? $root.protos.opts.ConvertOption[message.convertOutput] : message.convertOutput;
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.opts.ReadGroupKafkaOptions.toObject(message.kafka, options);
                if (message.activemq != null && message.hasOwnProperty("activemq"))
                    object.activemq = $root.protos.opts.ReadGroupActiveMQOptions.toObject(message.activemq, options);
                if (message.awssqs != null && message.hasOwnProperty("awssqs"))
                    object.awssqs = $root.protos.opts.ReadGroupAWSSQSOptions.toObject(message.awssqs, options);
                if (message.mongo != null && message.hasOwnProperty("mongo"))
                    object.mongo = $root.protos.opts.ReadGroupMongoOptions.toObject(message.mongo, options);
                if (message.nats != null && message.hasOwnProperty("nats"))
                    object.nats = $root.protos.opts.ReadGroupNatsOptions.toObject(message.nats, options);
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming"))
                    object.natsStreaming = $root.protos.opts.ReadGroupNatsStreamingOptions.toObject(message.natsStreaming, options);
                if (message.nsq != null && message.hasOwnProperty("nsq"))
                    object.nsq = $root.protos.opts.ReadGroupNSQOptions.toObject(message.nsq, options);
                if (message.pulsar != null && message.hasOwnProperty("pulsar"))
                    object.pulsar = $root.protos.opts.ReadGroupPulsarOptions.toObject(message.pulsar, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.opts.ReadGroupRabbitOptions.toObject(message.rabbit, options);
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams"))
                    object.rabbitStreams = $root.protos.opts.ReadGroupRabbitStreamsOptions.toObject(message.rabbitStreams, options);
                if (message.mqtt != null && message.hasOwnProperty("mqtt"))
                    object.mqtt = $root.protos.opts.ReadGroupMQTTOptions.toObject(message.mqtt, options);
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus"))
                    object.azureServiceBus = $root.protos.opts.ReadGroupAzureServiceBusOptions.toObject(message.azureServiceBus, options);
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub"))
                    object.azureEventHub = $root.protos.opts.ReadGroupAzureEventHubOptions.toObject(message.azureEventHub, options);
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub"))
                    object.gcpPubsub = $root.protos.opts.ReadGroupGCPPubSubOptions.toObject(message.gcpPubsub, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.opts.ReadGroupKubeMQQueueOptions.toObject(message.kubemqQueue, options);
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub"))
                    object.redisPubsub = $root.protos.opts.ReadGroupRedisPubSubOptions.toObject(message.redisPubsub, options);
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams"))
                    object.redisStreams = $root.protos.opts.ReadGroupRedisStreamsOptions.toObject(message.redisStreams, options);
                if (message.postgres != null && message.hasOwnProperty("postgres"))
                    object.postgres = $root.protos.opts.ReadGroupPostgresOptions.toObject(message.postgres, options);
                if (message._id != null && message.hasOwnProperty("_id"))
                    object._id = message._id;
                if (message._active != null && message.hasOwnProperty("_active"))
                    object._active = message._active;
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions"))
                    object._cliOptions = $root.protos.opts.ReadCLIOptions.toObject(message._cliOptions, options);
                return object;
            };

            /**
             * Converts this ReadOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadOptions;
        })();

        opts.ReadGroupKafkaOptions = (function() {

            /**
             * Properties of a ReadGroupKafkaOptions.
             * @memberof protos.opts
             * @interface IReadGroupKafkaOptions
             * @property {protos.args.IKafkaConn|null} [_conn] ReadGroupKafkaOptions _conn
             * @property {protos.args.IKafkaReadArgs|null} [args] ReadGroupKafkaOptions args
             */

            /**
             * Constructs a new ReadGroupKafkaOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupKafkaOptions.
             * @implements IReadGroupKafkaOptions
             * @constructor
             * @param {protos.opts.IReadGroupKafkaOptions=} [properties] Properties to set
             */
            function ReadGroupKafkaOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupKafkaOptions _conn.
             * @member {protos.args.IKafkaConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @instance
             */
            ReadGroupKafkaOptions.prototype._conn = null;

            /**
             * ReadGroupKafkaOptions args.
             * @member {protos.args.IKafkaReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @instance
             */
            ReadGroupKafkaOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupKafkaOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {protos.opts.IReadGroupKafkaOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupKafkaOptions} ReadGroupKafkaOptions instance
             */
            ReadGroupKafkaOptions.create = function create(properties) {
                return new ReadGroupKafkaOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupKafkaOptions message. Does not implicitly {@link protos.opts.ReadGroupKafkaOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {protos.opts.IReadGroupKafkaOptions} message ReadGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupKafkaOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KafkaConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KafkaReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupKafkaOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupKafkaOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {protos.opts.IReadGroupKafkaOptions} message ReadGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupKafkaOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupKafkaOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupKafkaOptions} ReadGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupKafkaOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupKafkaOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KafkaConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KafkaReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupKafkaOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupKafkaOptions} ReadGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupKafkaOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupKafkaOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupKafkaOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.KafkaConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.KafkaReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupKafkaOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupKafkaOptions} ReadGroupKafkaOptions
             */
            ReadGroupKafkaOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupKafkaOptions)
                    return object;
                let message = new $root.protos.opts.ReadGroupKafkaOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupKafkaOptions._conn: object expected");
                    message._conn = $root.protos.args.KafkaConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupKafkaOptions.args: object expected");
                    message.args = $root.protos.args.KafkaReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupKafkaOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {protos.opts.ReadGroupKafkaOptions} message ReadGroupKafkaOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupKafkaOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KafkaConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KafkaReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupKafkaOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupKafkaOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupKafkaOptions;
        })();

        opts.ReadGroupActiveMQOptions = (function() {

            /**
             * Properties of a ReadGroupActiveMQOptions.
             * @memberof protos.opts
             * @interface IReadGroupActiveMQOptions
             * @property {protos.args.IActiveMQConn|null} [_conn] ReadGroupActiveMQOptions _conn
             * @property {protos.args.IActiveMQReadArgs|null} [args] ReadGroupActiveMQOptions args
             */

            /**
             * Constructs a new ReadGroupActiveMQOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupActiveMQOptions.
             * @implements IReadGroupActiveMQOptions
             * @constructor
             * @param {protos.opts.IReadGroupActiveMQOptions=} [properties] Properties to set
             */
            function ReadGroupActiveMQOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupActiveMQOptions _conn.
             * @member {protos.args.IActiveMQConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @instance
             */
            ReadGroupActiveMQOptions.prototype._conn = null;

            /**
             * ReadGroupActiveMQOptions args.
             * @member {protos.args.IActiveMQReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @instance
             */
            ReadGroupActiveMQOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupActiveMQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {protos.opts.IReadGroupActiveMQOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupActiveMQOptions} ReadGroupActiveMQOptions instance
             */
            ReadGroupActiveMQOptions.create = function create(properties) {
                return new ReadGroupActiveMQOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupActiveMQOptions message. Does not implicitly {@link protos.opts.ReadGroupActiveMQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {protos.opts.IReadGroupActiveMQOptions} message ReadGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupActiveMQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.ActiveMQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.ActiveMQReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupActiveMQOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupActiveMQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {protos.opts.IReadGroupActiveMQOptions} message ReadGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupActiveMQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupActiveMQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupActiveMQOptions} ReadGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupActiveMQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupActiveMQOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.ActiveMQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.ActiveMQReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupActiveMQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupActiveMQOptions} ReadGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupActiveMQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupActiveMQOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupActiveMQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.ActiveMQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.ActiveMQReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupActiveMQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupActiveMQOptions} ReadGroupActiveMQOptions
             */
            ReadGroupActiveMQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupActiveMQOptions)
                    return object;
                let message = new $root.protos.opts.ReadGroupActiveMQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupActiveMQOptions._conn: object expected");
                    message._conn = $root.protos.args.ActiveMQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupActiveMQOptions.args: object expected");
                    message.args = $root.protos.args.ActiveMQReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupActiveMQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {protos.opts.ReadGroupActiveMQOptions} message ReadGroupActiveMQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupActiveMQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.ActiveMQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.ActiveMQReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupActiveMQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupActiveMQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupActiveMQOptions;
        })();

        opts.ReadGroupAWSSQSOptions = (function() {

            /**
             * Properties of a ReadGroupAWSSQSOptions.
             * @memberof protos.opts
             * @interface IReadGroupAWSSQSOptions
             * @property {protos.args.IAWSSQSConn|null} [_conn] ReadGroupAWSSQSOptions _conn
             * @property {protos.args.IAWSSQSReadArgs|null} [args] ReadGroupAWSSQSOptions args
             */

            /**
             * Constructs a new ReadGroupAWSSQSOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupAWSSQSOptions.
             * @implements IReadGroupAWSSQSOptions
             * @constructor
             * @param {protos.opts.IReadGroupAWSSQSOptions=} [properties] Properties to set
             */
            function ReadGroupAWSSQSOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupAWSSQSOptions _conn.
             * @member {protos.args.IAWSSQSConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @instance
             */
            ReadGroupAWSSQSOptions.prototype._conn = null;

            /**
             * ReadGroupAWSSQSOptions args.
             * @member {protos.args.IAWSSQSReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @instance
             */
            ReadGroupAWSSQSOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupAWSSQSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IReadGroupAWSSQSOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupAWSSQSOptions} ReadGroupAWSSQSOptions instance
             */
            ReadGroupAWSSQSOptions.create = function create(properties) {
                return new ReadGroupAWSSQSOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupAWSSQSOptions message. Does not implicitly {@link protos.opts.ReadGroupAWSSQSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IReadGroupAWSSQSOptions} message ReadGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAWSSQSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSQSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSQSReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupAWSSQSOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupAWSSQSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IReadGroupAWSSQSOptions} message ReadGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAWSSQSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupAWSSQSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupAWSSQSOptions} ReadGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAWSSQSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupAWSSQSOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSQSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSQSReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupAWSSQSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupAWSSQSOptions} ReadGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAWSSQSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupAWSSQSOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupAWSSQSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.AWSSQSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.AWSSQSReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupAWSSQSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupAWSSQSOptions} ReadGroupAWSSQSOptions
             */
            ReadGroupAWSSQSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupAWSSQSOptions)
                    return object;
                let message = new $root.protos.opts.ReadGroupAWSSQSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupAWSSQSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSQSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupAWSSQSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSQSReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupAWSSQSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {protos.opts.ReadGroupAWSSQSOptions} message ReadGroupAWSSQSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupAWSSQSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSQSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSQSReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupAWSSQSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupAWSSQSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupAWSSQSOptions;
        })();

        opts.ReadGroupMongoOptions = (function() {

            /**
             * Properties of a ReadGroupMongoOptions.
             * @memberof protos.opts
             * @interface IReadGroupMongoOptions
             * @property {protos.args.IMongoConn|null} [_conn] ReadGroupMongoOptions _conn
             * @property {protos.args.IMongoReadArgs|null} [args] ReadGroupMongoOptions args
             */

            /**
             * Constructs a new ReadGroupMongoOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupMongoOptions.
             * @implements IReadGroupMongoOptions
             * @constructor
             * @param {protos.opts.IReadGroupMongoOptions=} [properties] Properties to set
             */
            function ReadGroupMongoOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupMongoOptions _conn.
             * @member {protos.args.IMongoConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupMongoOptions
             * @instance
             */
            ReadGroupMongoOptions.prototype._conn = null;

            /**
             * ReadGroupMongoOptions args.
             * @member {protos.args.IMongoReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupMongoOptions
             * @instance
             */
            ReadGroupMongoOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupMongoOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {protos.opts.IReadGroupMongoOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupMongoOptions} ReadGroupMongoOptions instance
             */
            ReadGroupMongoOptions.create = function create(properties) {
                return new ReadGroupMongoOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupMongoOptions message. Does not implicitly {@link protos.opts.ReadGroupMongoOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {protos.opts.IReadGroupMongoOptions} message ReadGroupMongoOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupMongoOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MongoConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MongoReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupMongoOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupMongoOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {protos.opts.IReadGroupMongoOptions} message ReadGroupMongoOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupMongoOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupMongoOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupMongoOptions} ReadGroupMongoOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupMongoOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupMongoOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MongoConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MongoReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupMongoOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupMongoOptions} ReadGroupMongoOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupMongoOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupMongoOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupMongoOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.MongoConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.MongoReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupMongoOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupMongoOptions} ReadGroupMongoOptions
             */
            ReadGroupMongoOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupMongoOptions)
                    return object;
                let message = new $root.protos.opts.ReadGroupMongoOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupMongoOptions._conn: object expected");
                    message._conn = $root.protos.args.MongoConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupMongoOptions.args: object expected");
                    message.args = $root.protos.args.MongoReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupMongoOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {protos.opts.ReadGroupMongoOptions} message ReadGroupMongoOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupMongoOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MongoConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MongoReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupMongoOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupMongoOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupMongoOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupMongoOptions;
        })();

        opts.ReadGroupNatsOptions = (function() {

            /**
             * Properties of a ReadGroupNatsOptions.
             * @memberof protos.opts
             * @interface IReadGroupNatsOptions
             * @property {protos.args.INatsConn|null} [_conn] ReadGroupNatsOptions _conn
             * @property {protos.args.INatsReadArgs|null} [args] ReadGroupNatsOptions args
             */

            /**
             * Constructs a new ReadGroupNatsOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupNatsOptions.
             * @implements IReadGroupNatsOptions
             * @constructor
             * @param {protos.opts.IReadGroupNatsOptions=} [properties] Properties to set
             */
            function ReadGroupNatsOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupNatsOptions _conn.
             * @member {protos.args.INatsConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupNatsOptions
             * @instance
             */
            ReadGroupNatsOptions.prototype._conn = null;

            /**
             * ReadGroupNatsOptions args.
             * @member {protos.args.INatsReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupNatsOptions
             * @instance
             */
            ReadGroupNatsOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupNatsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {protos.opts.IReadGroupNatsOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupNatsOptions} ReadGroupNatsOptions instance
             */
            ReadGroupNatsOptions.create = function create(properties) {
                return new ReadGroupNatsOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupNatsOptions message. Does not implicitly {@link protos.opts.ReadGroupNatsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {protos.opts.IReadGroupNatsOptions} message ReadGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNatsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupNatsOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupNatsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {protos.opts.IReadGroupNatsOptions} message ReadGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNatsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupNatsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupNatsOptions} ReadGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNatsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupNatsOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupNatsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupNatsOptions} ReadGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNatsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupNatsOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupNatsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.NatsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.NatsReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupNatsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupNatsOptions} ReadGroupNatsOptions
             */
            ReadGroupNatsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupNatsOptions)
                    return object;
                let message = new $root.protos.opts.ReadGroupNatsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupNatsOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupNatsOptions.args: object expected");
                    message.args = $root.protos.args.NatsReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupNatsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {protos.opts.ReadGroupNatsOptions} message ReadGroupNatsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupNatsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupNatsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupNatsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupNatsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupNatsOptions;
        })();

        opts.ReadGroupNatsStreamingOptions = (function() {

            /**
             * Properties of a ReadGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @interface IReadGroupNatsStreamingOptions
             * @property {protos.args.INatsStreamingConn|null} [_conn] ReadGroupNatsStreamingOptions _conn
             * @property {protos.args.INatsStreamingReadArgs|null} [args] ReadGroupNatsStreamingOptions args
             */

            /**
             * Constructs a new ReadGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupNatsStreamingOptions.
             * @implements IReadGroupNatsStreamingOptions
             * @constructor
             * @param {protos.opts.IReadGroupNatsStreamingOptions=} [properties] Properties to set
             */
            function ReadGroupNatsStreamingOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupNatsStreamingOptions _conn.
             * @member {protos.args.INatsStreamingConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @instance
             */
            ReadGroupNatsStreamingOptions.prototype._conn = null;

            /**
             * ReadGroupNatsStreamingOptions args.
             * @member {protos.args.INatsStreamingReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @instance
             */
            ReadGroupNatsStreamingOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupNatsStreamingOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IReadGroupNatsStreamingOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupNatsStreamingOptions} ReadGroupNatsStreamingOptions instance
             */
            ReadGroupNatsStreamingOptions.create = function create(properties) {
                return new ReadGroupNatsStreamingOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupNatsStreamingOptions message. Does not implicitly {@link protos.opts.ReadGroupNatsStreamingOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IReadGroupNatsStreamingOptions} message ReadGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNatsStreamingOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsStreamingConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsStreamingReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupNatsStreamingOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupNatsStreamingOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IReadGroupNatsStreamingOptions} message ReadGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNatsStreamingOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupNatsStreamingOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupNatsStreamingOptions} ReadGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNatsStreamingOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupNatsStreamingOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsStreamingConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsStreamingReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupNatsStreamingOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupNatsStreamingOptions} ReadGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNatsStreamingOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupNatsStreamingOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupNatsStreamingOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.NatsStreamingConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.NatsStreamingReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupNatsStreamingOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupNatsStreamingOptions} ReadGroupNatsStreamingOptions
             */
            ReadGroupNatsStreamingOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupNatsStreamingOptions)
                    return object;
                let message = new $root.protos.opts.ReadGroupNatsStreamingOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupNatsStreamingOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsStreamingConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupNatsStreamingOptions.args: object expected");
                    message.args = $root.protos.args.NatsStreamingReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupNatsStreamingOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.ReadGroupNatsStreamingOptions} message ReadGroupNatsStreamingOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupNatsStreamingOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsStreamingConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsStreamingReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupNatsStreamingOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupNatsStreamingOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupNatsStreamingOptions;
        })();

        opts.ReadGroupNSQOptions = (function() {

            /**
             * Properties of a ReadGroupNSQOptions.
             * @memberof protos.opts
             * @interface IReadGroupNSQOptions
             * @property {protos.args.INSQConn|null} [_conn] ReadGroupNSQOptions _conn
             * @property {protos.args.INSQReadArgs|null} [args] ReadGroupNSQOptions args
             */

            /**
             * Constructs a new ReadGroupNSQOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupNSQOptions.
             * @implements IReadGroupNSQOptions
             * @constructor
             * @param {protos.opts.IReadGroupNSQOptions=} [properties] Properties to set
             */
            function ReadGroupNSQOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupNSQOptions _conn.
             * @member {protos.args.INSQConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupNSQOptions
             * @instance
             */
            ReadGroupNSQOptions.prototype._conn = null;

            /**
             * ReadGroupNSQOptions args.
             * @member {protos.args.INSQReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupNSQOptions
             * @instance
             */
            ReadGroupNSQOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupNSQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {protos.opts.IReadGroupNSQOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupNSQOptions} ReadGroupNSQOptions instance
             */
            ReadGroupNSQOptions.create = function create(properties) {
                return new ReadGroupNSQOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupNSQOptions message. Does not implicitly {@link protos.opts.ReadGroupNSQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {protos.opts.IReadGroupNSQOptions} message ReadGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNSQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NSQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NSQReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupNSQOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupNSQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {protos.opts.IReadGroupNSQOptions} message ReadGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNSQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupNSQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupNSQOptions} ReadGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNSQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupNSQOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NSQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NSQReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupNSQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupNSQOptions} ReadGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNSQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupNSQOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupNSQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.NSQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.NSQReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupNSQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupNSQOptions} ReadGroupNSQOptions
             */
            ReadGroupNSQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupNSQOptions)
                    return object;
                let message = new $root.protos.opts.ReadGroupNSQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupNSQOptions._conn: object expected");
                    message._conn = $root.protos.args.NSQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupNSQOptions.args: object expected");
                    message.args = $root.protos.args.NSQReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupNSQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {protos.opts.ReadGroupNSQOptions} message ReadGroupNSQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupNSQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NSQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NSQReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupNSQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupNSQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupNSQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupNSQOptions;
        })();

        opts.ReadGroupPostgresOptions = (function() {

            /**
             * Properties of a ReadGroupPostgresOptions.
             * @memberof protos.opts
             * @interface IReadGroupPostgresOptions
             * @property {protos.args.IPostgresConn|null} [_conn] ReadGroupPostgresOptions _conn
             * @property {protos.args.IPostgresReadArgs|null} [args] ReadGroupPostgresOptions args
             */

            /**
             * Constructs a new ReadGroupPostgresOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupPostgresOptions.
             * @implements IReadGroupPostgresOptions
             * @constructor
             * @param {protos.opts.IReadGroupPostgresOptions=} [properties] Properties to set
             */
            function ReadGroupPostgresOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupPostgresOptions _conn.
             * @member {protos.args.IPostgresConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @instance
             */
            ReadGroupPostgresOptions.prototype._conn = null;

            /**
             * ReadGroupPostgresOptions args.
             * @member {protos.args.IPostgresReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @instance
             */
            ReadGroupPostgresOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupPostgresOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {protos.opts.IReadGroupPostgresOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupPostgresOptions} ReadGroupPostgresOptions instance
             */
            ReadGroupPostgresOptions.create = function create(properties) {
                return new ReadGroupPostgresOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupPostgresOptions message. Does not implicitly {@link protos.opts.ReadGroupPostgresOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {protos.opts.IReadGroupPostgresOptions} message ReadGroupPostgresOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupPostgresOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.PostgresConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.PostgresReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupPostgresOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupPostgresOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {protos.opts.IReadGroupPostgresOptions} message ReadGroupPostgresOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupPostgresOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupPostgresOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupPostgresOptions} ReadGroupPostgresOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupPostgresOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupPostgresOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.PostgresConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.PostgresReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupPostgresOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupPostgresOptions} ReadGroupPostgresOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupPostgresOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupPostgresOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupPostgresOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.PostgresConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.PostgresReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupPostgresOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupPostgresOptions} ReadGroupPostgresOptions
             */
            ReadGroupPostgresOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupPostgresOptions)
                    return object;
                let message = new $root.protos.opts.ReadGroupPostgresOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupPostgresOptions._conn: object expected");
                    message._conn = $root.protos.args.PostgresConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupPostgresOptions.args: object expected");
                    message.args = $root.protos.args.PostgresReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupPostgresOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {protos.opts.ReadGroupPostgresOptions} message ReadGroupPostgresOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupPostgresOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.PostgresConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.PostgresReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupPostgresOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupPostgresOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupPostgresOptions;
        })();

        opts.ReadGroupPulsarOptions = (function() {

            /**
             * Properties of a ReadGroupPulsarOptions.
             * @memberof protos.opts
             * @interface IReadGroupPulsarOptions
             * @property {protos.args.IPulsarConn|null} [_conn] ReadGroupPulsarOptions _conn
             * @property {protos.args.IPulsarReadArgs|null} [args] ReadGroupPulsarOptions args
             */

            /**
             * Constructs a new ReadGroupPulsarOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupPulsarOptions.
             * @implements IReadGroupPulsarOptions
             * @constructor
             * @param {protos.opts.IReadGroupPulsarOptions=} [properties] Properties to set
             */
            function ReadGroupPulsarOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupPulsarOptions _conn.
             * @member {protos.args.IPulsarConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @instance
             */
            ReadGroupPulsarOptions.prototype._conn = null;

            /**
             * ReadGroupPulsarOptions args.
             * @member {protos.args.IPulsarReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @instance
             */
            ReadGroupPulsarOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupPulsarOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {protos.opts.IReadGroupPulsarOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupPulsarOptions} ReadGroupPulsarOptions instance
             */
            ReadGroupPulsarOptions.create = function create(properties) {
                return new ReadGroupPulsarOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupPulsarOptions message. Does not implicitly {@link protos.opts.ReadGroupPulsarOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {protos.opts.IReadGroupPulsarOptions} message ReadGroupPulsarOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupPulsarOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.PulsarConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.PulsarReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupPulsarOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupPulsarOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {protos.opts.IReadGroupPulsarOptions} message ReadGroupPulsarOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupPulsarOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupPulsarOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupPulsarOptions} ReadGroupPulsarOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupPulsarOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupPulsarOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.PulsarConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.PulsarReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupPulsarOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupPulsarOptions} ReadGroupPulsarOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupPulsarOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupPulsarOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupPulsarOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.PulsarConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.PulsarReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupPulsarOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupPulsarOptions} ReadGroupPulsarOptions
             */
            ReadGroupPulsarOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupPulsarOptions)
                    return object;
                let message = new $root.protos.opts.ReadGroupPulsarOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupPulsarOptions._conn: object expected");
                    message._conn = $root.protos.args.PulsarConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupPulsarOptions.args: object expected");
                    message.args = $root.protos.args.PulsarReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupPulsarOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {protos.opts.ReadGroupPulsarOptions} message ReadGroupPulsarOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupPulsarOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.PulsarConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.PulsarReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupPulsarOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupPulsarOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupPulsarOptions;
        })();

        opts.ReadGroupRabbitOptions = (function() {

            /**
             * Properties of a ReadGroupRabbitOptions.
             * @memberof protos.opts
             * @interface IReadGroupRabbitOptions
             * @property {protos.args.IRabbitConn|null} [_conn] ReadGroupRabbitOptions _conn
             * @property {protos.args.IRabbitReadArgs|null} [args] ReadGroupRabbitOptions args
             */

            /**
             * Constructs a new ReadGroupRabbitOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupRabbitOptions.
             * @implements IReadGroupRabbitOptions
             * @constructor
             * @param {protos.opts.IReadGroupRabbitOptions=} [properties] Properties to set
             */
            function ReadGroupRabbitOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupRabbitOptions _conn.
             * @member {protos.args.IRabbitConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @instance
             */
            ReadGroupRabbitOptions.prototype._conn = null;

            /**
             * ReadGroupRabbitOptions args.
             * @member {protos.args.IRabbitReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @instance
             */
            ReadGroupRabbitOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupRabbitOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupRabbitOptions} ReadGroupRabbitOptions instance
             */
            ReadGroupRabbitOptions.create = function create(properties) {
                return new ReadGroupRabbitOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupRabbitOptions message. Does not implicitly {@link protos.opts.ReadGroupRabbitOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitOptions} message ReadGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRabbitOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupRabbitOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupRabbitOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitOptions} message ReadGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRabbitOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupRabbitOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupRabbitOptions} ReadGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRabbitOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupRabbitOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupRabbitOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupRabbitOptions} ReadGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRabbitOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupRabbitOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupRabbitOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.RabbitConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.RabbitReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupRabbitOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupRabbitOptions} ReadGroupRabbitOptions
             */
            ReadGroupRabbitOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupRabbitOptions)
                    return object;
                let message = new $root.protos.opts.ReadGroupRabbitOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupRabbitOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupRabbitOptions.args: object expected");
                    message.args = $root.protos.args.RabbitReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupRabbitOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {protos.opts.ReadGroupRabbitOptions} message ReadGroupRabbitOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupRabbitOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupRabbitOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupRabbitOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupRabbitOptions;
        })();

        opts.ReadGroupRabbitStreamsOptions = (function() {

            /**
             * Properties of a ReadGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @interface IReadGroupRabbitStreamsOptions
             * @property {protos.args.IRabbitStreamsConn|null} [_conn] ReadGroupRabbitStreamsOptions _conn
             * @property {protos.args.IRabbitStreamsReadArgs|null} [args] ReadGroupRabbitStreamsOptions args
             */

            /**
             * Constructs a new ReadGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupRabbitStreamsOptions.
             * @implements IReadGroupRabbitStreamsOptions
             * @constructor
             * @param {protos.opts.IReadGroupRabbitStreamsOptions=} [properties] Properties to set
             */
            function ReadGroupRabbitStreamsOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupRabbitStreamsOptions _conn.
             * @member {protos.args.IRabbitStreamsConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @instance
             */
            ReadGroupRabbitStreamsOptions.prototype._conn = null;

            /**
             * ReadGroupRabbitStreamsOptions args.
             * @member {protos.args.IRabbitStreamsReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @instance
             */
            ReadGroupRabbitStreamsOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupRabbitStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupRabbitStreamsOptions} ReadGroupRabbitStreamsOptions instance
             */
            ReadGroupRabbitStreamsOptions.create = function create(properties) {
                return new ReadGroupRabbitStreamsOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupRabbitStreamsOptions message. Does not implicitly {@link protos.opts.ReadGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitStreamsOptions} message ReadGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRabbitStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitStreamsReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupRabbitStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitStreamsOptions} message ReadGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRabbitStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupRabbitStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupRabbitStreamsOptions} ReadGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRabbitStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupRabbitStreamsOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitStreamsReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupRabbitStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupRabbitStreamsOptions} ReadGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRabbitStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupRabbitStreamsOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupRabbitStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.RabbitStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.RabbitStreamsReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupRabbitStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupRabbitStreamsOptions} ReadGroupRabbitStreamsOptions
             */
            ReadGroupRabbitStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupRabbitStreamsOptions)
                    return object;
                let message = new $root.protos.opts.ReadGroupRabbitStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupRabbitStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupRabbitStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RabbitStreamsReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupRabbitStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.ReadGroupRabbitStreamsOptions} message ReadGroupRabbitStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupRabbitStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitStreamsReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupRabbitStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupRabbitStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupRabbitStreamsOptions;
        })();

        opts.ReadGroupRedisPubSubOptions = (function() {

            /**
             * Properties of a ReadGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @interface IReadGroupRedisPubSubOptions
             * @property {protos.args.IRedisPubSubConn|null} [_conn] ReadGroupRedisPubSubOptions _conn
             * @property {protos.args.IRedisPubSubReadArgs|null} [args] ReadGroupRedisPubSubOptions args
             */

            /**
             * Constructs a new ReadGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupRedisPubSubOptions.
             * @implements IReadGroupRedisPubSubOptions
             * @constructor
             * @param {protos.opts.IReadGroupRedisPubSubOptions=} [properties] Properties to set
             */
            function ReadGroupRedisPubSubOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupRedisPubSubOptions _conn.
             * @member {protos.args.IRedisPubSubConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @instance
             */
            ReadGroupRedisPubSubOptions.prototype._conn = null;

            /**
             * ReadGroupRedisPubSubOptions args.
             * @member {protos.args.IRedisPubSubReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @instance
             */
            ReadGroupRedisPubSubOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupRedisPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupRedisPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupRedisPubSubOptions} ReadGroupRedisPubSubOptions instance
             */
            ReadGroupRedisPubSubOptions.create = function create(properties) {
                return new ReadGroupRedisPubSubOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupRedisPubSubOptions message. Does not implicitly {@link protos.opts.ReadGroupRedisPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupRedisPubSubOptions} message ReadGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRedisPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisPubSubReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupRedisPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupRedisPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupRedisPubSubOptions} message ReadGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRedisPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupRedisPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupRedisPubSubOptions} ReadGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRedisPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupRedisPubSubOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisPubSubReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupRedisPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupRedisPubSubOptions} ReadGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRedisPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupRedisPubSubOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupRedisPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.RedisPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.RedisPubSubReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupRedisPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupRedisPubSubOptions} ReadGroupRedisPubSubOptions
             */
            ReadGroupRedisPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupRedisPubSubOptions)
                    return object;
                let message = new $root.protos.opts.ReadGroupRedisPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupRedisPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupRedisPubSubOptions.args: object expected");
                    message.args = $root.protos.args.RedisPubSubReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupRedisPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.ReadGroupRedisPubSubOptions} message ReadGroupRedisPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupRedisPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisPubSubReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupRedisPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupRedisPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupRedisPubSubOptions;
        })();

        opts.ReadGroupRedisStreamsOptions = (function() {

            /**
             * Properties of a ReadGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @interface IReadGroupRedisStreamsOptions
             * @property {protos.args.IRedisStreamsConn|null} [_conn] ReadGroupRedisStreamsOptions _conn
             * @property {protos.args.IRedisStreamsReadArgs|null} [args] ReadGroupRedisStreamsOptions args
             */

            /**
             * Constructs a new ReadGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupRedisStreamsOptions.
             * @implements IReadGroupRedisStreamsOptions
             * @constructor
             * @param {protos.opts.IReadGroupRedisStreamsOptions=} [properties] Properties to set
             */
            function ReadGroupRedisStreamsOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupRedisStreamsOptions _conn.
             * @member {protos.args.IRedisStreamsConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @instance
             */
            ReadGroupRedisStreamsOptions.prototype._conn = null;

            /**
             * ReadGroupRedisStreamsOptions args.
             * @member {protos.args.IRedisStreamsReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @instance
             */
            ReadGroupRedisStreamsOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupRedisStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRedisStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupRedisStreamsOptions} ReadGroupRedisStreamsOptions instance
             */
            ReadGroupRedisStreamsOptions.create = function create(properties) {
                return new ReadGroupRedisStreamsOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupRedisStreamsOptions message. Does not implicitly {@link protos.opts.ReadGroupRedisStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRedisStreamsOptions} message ReadGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRedisStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisStreamsReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupRedisStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupRedisStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRedisStreamsOptions} message ReadGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRedisStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupRedisStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupRedisStreamsOptions} ReadGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRedisStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupRedisStreamsOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisStreamsReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupRedisStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupRedisStreamsOptions} ReadGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRedisStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupRedisStreamsOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupRedisStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.RedisStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.RedisStreamsReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupRedisStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupRedisStreamsOptions} ReadGroupRedisStreamsOptions
             */
            ReadGroupRedisStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupRedisStreamsOptions)
                    return object;
                let message = new $root.protos.opts.ReadGroupRedisStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupRedisStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupRedisStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RedisStreamsReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupRedisStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.ReadGroupRedisStreamsOptions} message ReadGroupRedisStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupRedisStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisStreamsReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupRedisStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupRedisStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupRedisStreamsOptions;
        })();

        opts.ReadGroupAzureEventHubOptions = (function() {

            /**
             * Properties of a ReadGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @interface IReadGroupAzureEventHubOptions
             * @property {protos.args.IAzureEventHubConn|null} [_conn] ReadGroupAzureEventHubOptions _conn
             * @property {protos.args.IAzureEventHubReadArgs|null} [args] ReadGroupAzureEventHubOptions args
             */

            /**
             * Constructs a new ReadGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupAzureEventHubOptions.
             * @implements IReadGroupAzureEventHubOptions
             * @constructor
             * @param {protos.opts.IReadGroupAzureEventHubOptions=} [properties] Properties to set
             */
            function ReadGroupAzureEventHubOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupAzureEventHubOptions _conn.
             * @member {protos.args.IAzureEventHubConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @instance
             */
            ReadGroupAzureEventHubOptions.prototype._conn = null;

            /**
             * ReadGroupAzureEventHubOptions args.
             * @member {protos.args.IAzureEventHubReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @instance
             */
            ReadGroupAzureEventHubOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupAzureEventHubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IReadGroupAzureEventHubOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupAzureEventHubOptions} ReadGroupAzureEventHubOptions instance
             */
            ReadGroupAzureEventHubOptions.create = function create(properties) {
                return new ReadGroupAzureEventHubOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupAzureEventHubOptions message. Does not implicitly {@link protos.opts.ReadGroupAzureEventHubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IReadGroupAzureEventHubOptions} message ReadGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAzureEventHubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureEventHubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureEventHubReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupAzureEventHubOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupAzureEventHubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IReadGroupAzureEventHubOptions} message ReadGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAzureEventHubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupAzureEventHubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupAzureEventHubOptions} ReadGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAzureEventHubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupAzureEventHubOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureEventHubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureEventHubReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupAzureEventHubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupAzureEventHubOptions} ReadGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAzureEventHubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupAzureEventHubOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupAzureEventHubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.AzureEventHubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.AzureEventHubReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupAzureEventHubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupAzureEventHubOptions} ReadGroupAzureEventHubOptions
             */
            ReadGroupAzureEventHubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupAzureEventHubOptions)
                    return object;
                let message = new $root.protos.opts.ReadGroupAzureEventHubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupAzureEventHubOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureEventHubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupAzureEventHubOptions.args: object expected");
                    message.args = $root.protos.args.AzureEventHubReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupAzureEventHubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.ReadGroupAzureEventHubOptions} message ReadGroupAzureEventHubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupAzureEventHubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureEventHubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureEventHubReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupAzureEventHubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupAzureEventHubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupAzureEventHubOptions;
        })();

        opts.ReadGroupAzureServiceBusOptions = (function() {

            /**
             * Properties of a ReadGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @interface IReadGroupAzureServiceBusOptions
             * @property {protos.args.IAzureServiceBusConn|null} [_conn] ReadGroupAzureServiceBusOptions _conn
             * @property {protos.args.IAzureServiceBusReadArgs|null} [args] ReadGroupAzureServiceBusOptions args
             */

            /**
             * Constructs a new ReadGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupAzureServiceBusOptions.
             * @implements IReadGroupAzureServiceBusOptions
             * @constructor
             * @param {protos.opts.IReadGroupAzureServiceBusOptions=} [properties] Properties to set
             */
            function ReadGroupAzureServiceBusOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupAzureServiceBusOptions _conn.
             * @member {protos.args.IAzureServiceBusConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @instance
             */
            ReadGroupAzureServiceBusOptions.prototype._conn = null;

            /**
             * ReadGroupAzureServiceBusOptions args.
             * @member {protos.args.IAzureServiceBusReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @instance
             */
            ReadGroupAzureServiceBusOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupAzureServiceBusOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IReadGroupAzureServiceBusOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupAzureServiceBusOptions} ReadGroupAzureServiceBusOptions instance
             */
            ReadGroupAzureServiceBusOptions.create = function create(properties) {
                return new ReadGroupAzureServiceBusOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupAzureServiceBusOptions message. Does not implicitly {@link protos.opts.ReadGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IReadGroupAzureServiceBusOptions} message ReadGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAzureServiceBusOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureServiceBusConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureServiceBusReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupAzureServiceBusOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IReadGroupAzureServiceBusOptions} message ReadGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAzureServiceBusOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupAzureServiceBusOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupAzureServiceBusOptions} ReadGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAzureServiceBusOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupAzureServiceBusOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureServiceBusConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureServiceBusReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupAzureServiceBusOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupAzureServiceBusOptions} ReadGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAzureServiceBusOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupAzureServiceBusOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupAzureServiceBusOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.AzureServiceBusConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.AzureServiceBusReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupAzureServiceBusOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupAzureServiceBusOptions} ReadGroupAzureServiceBusOptions
             */
            ReadGroupAzureServiceBusOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupAzureServiceBusOptions)
                    return object;
                let message = new $root.protos.opts.ReadGroupAzureServiceBusOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupAzureServiceBusOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureServiceBusConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupAzureServiceBusOptions.args: object expected");
                    message.args = $root.protos.args.AzureServiceBusReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupAzureServiceBusOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.ReadGroupAzureServiceBusOptions} message ReadGroupAzureServiceBusOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupAzureServiceBusOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureServiceBusConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureServiceBusReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupAzureServiceBusOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupAzureServiceBusOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupAzureServiceBusOptions;
        })();

        opts.ReadGroupMQTTOptions = (function() {

            /**
             * Properties of a ReadGroupMQTTOptions.
             * @memberof protos.opts
             * @interface IReadGroupMQTTOptions
             * @property {protos.args.IMQTTConn|null} [_conn] ReadGroupMQTTOptions _conn
             * @property {protos.args.IMQTTReadArgs|null} [args] ReadGroupMQTTOptions args
             */

            /**
             * Constructs a new ReadGroupMQTTOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupMQTTOptions.
             * @implements IReadGroupMQTTOptions
             * @constructor
             * @param {protos.opts.IReadGroupMQTTOptions=} [properties] Properties to set
             */
            function ReadGroupMQTTOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupMQTTOptions _conn.
             * @member {protos.args.IMQTTConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @instance
             */
            ReadGroupMQTTOptions.prototype._conn = null;

            /**
             * ReadGroupMQTTOptions args.
             * @member {protos.args.IMQTTReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @instance
             */
            ReadGroupMQTTOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupMQTTOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {protos.opts.IReadGroupMQTTOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupMQTTOptions} ReadGroupMQTTOptions instance
             */
            ReadGroupMQTTOptions.create = function create(properties) {
                return new ReadGroupMQTTOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupMQTTOptions message. Does not implicitly {@link protos.opts.ReadGroupMQTTOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {protos.opts.IReadGroupMQTTOptions} message ReadGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupMQTTOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MQTTConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MQTTReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupMQTTOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupMQTTOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {protos.opts.IReadGroupMQTTOptions} message ReadGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupMQTTOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupMQTTOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupMQTTOptions} ReadGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupMQTTOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupMQTTOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MQTTConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MQTTReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupMQTTOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupMQTTOptions} ReadGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupMQTTOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupMQTTOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupMQTTOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.MQTTConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.MQTTReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupMQTTOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupMQTTOptions} ReadGroupMQTTOptions
             */
            ReadGroupMQTTOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupMQTTOptions)
                    return object;
                let message = new $root.protos.opts.ReadGroupMQTTOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupMQTTOptions._conn: object expected");
                    message._conn = $root.protos.args.MQTTConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupMQTTOptions.args: object expected");
                    message.args = $root.protos.args.MQTTReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupMQTTOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {protos.opts.ReadGroupMQTTOptions} message ReadGroupMQTTOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupMQTTOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MQTTConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MQTTReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupMQTTOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupMQTTOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupMQTTOptions;
        })();

        opts.ReadGroupGCPPubSubOptions = (function() {

            /**
             * Properties of a ReadGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @interface IReadGroupGCPPubSubOptions
             * @property {protos.args.IGCPPubSubConn|null} [_conn] ReadGroupGCPPubSubOptions _conn
             * @property {protos.args.IGCPPubSubReadArgs|null} [args] ReadGroupGCPPubSubOptions args
             */

            /**
             * Constructs a new ReadGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupGCPPubSubOptions.
             * @implements IReadGroupGCPPubSubOptions
             * @constructor
             * @param {protos.opts.IReadGroupGCPPubSubOptions=} [properties] Properties to set
             */
            function ReadGroupGCPPubSubOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupGCPPubSubOptions _conn.
             * @member {protos.args.IGCPPubSubConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @instance
             */
            ReadGroupGCPPubSubOptions.prototype._conn = null;

            /**
             * ReadGroupGCPPubSubOptions args.
             * @member {protos.args.IGCPPubSubReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @instance
             */
            ReadGroupGCPPubSubOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupGCPPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupGCPPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupGCPPubSubOptions} ReadGroupGCPPubSubOptions instance
             */
            ReadGroupGCPPubSubOptions.create = function create(properties) {
                return new ReadGroupGCPPubSubOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupGCPPubSubOptions message. Does not implicitly {@link protos.opts.ReadGroupGCPPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupGCPPubSubOptions} message ReadGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupGCPPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.GCPPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.GCPPubSubReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupGCPPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupGCPPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupGCPPubSubOptions} message ReadGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupGCPPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupGCPPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupGCPPubSubOptions} ReadGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupGCPPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupGCPPubSubOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.GCPPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.GCPPubSubReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupGCPPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupGCPPubSubOptions} ReadGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupGCPPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupGCPPubSubOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupGCPPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.GCPPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.GCPPubSubReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupGCPPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupGCPPubSubOptions} ReadGroupGCPPubSubOptions
             */
            ReadGroupGCPPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupGCPPubSubOptions)
                    return object;
                let message = new $root.protos.opts.ReadGroupGCPPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupGCPPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.GCPPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupGCPPubSubOptions.args: object expected");
                    message.args = $root.protos.args.GCPPubSubReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupGCPPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.ReadGroupGCPPubSubOptions} message ReadGroupGCPPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupGCPPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.GCPPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.GCPPubSubReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupGCPPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupGCPPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupGCPPubSubOptions;
        })();

        opts.ReadGroupKubeMQQueueOptions = (function() {

            /**
             * Properties of a ReadGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @interface IReadGroupKubeMQQueueOptions
             * @property {protos.args.IKubeMQQueueConn|null} [_conn] ReadGroupKubeMQQueueOptions _conn
             * @property {protos.args.IKubeMQQueueReadArgs|null} [args] ReadGroupKubeMQQueueOptions args
             */

            /**
             * Constructs a new ReadGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupKubeMQQueueOptions.
             * @implements IReadGroupKubeMQQueueOptions
             * @constructor
             * @param {protos.opts.IReadGroupKubeMQQueueOptions=} [properties] Properties to set
             */
            function ReadGroupKubeMQQueueOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupKubeMQQueueOptions _conn.
             * @member {protos.args.IKubeMQQueueConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @instance
             */
            ReadGroupKubeMQQueueOptions.prototype._conn = null;

            /**
             * ReadGroupKubeMQQueueOptions args.
             * @member {protos.args.IKubeMQQueueReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @instance
             */
            ReadGroupKubeMQQueueOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupKubeMQQueueOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IReadGroupKubeMQQueueOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupKubeMQQueueOptions} ReadGroupKubeMQQueueOptions instance
             */
            ReadGroupKubeMQQueueOptions.create = function create(properties) {
                return new ReadGroupKubeMQQueueOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupKubeMQQueueOptions message. Does not implicitly {@link protos.opts.ReadGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IReadGroupKubeMQQueueOptions} message ReadGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupKubeMQQueueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KubeMQQueueConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KubeMQQueueReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupKubeMQQueueOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IReadGroupKubeMQQueueOptions} message ReadGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupKubeMQQueueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupKubeMQQueueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupKubeMQQueueOptions} ReadGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupKubeMQQueueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupKubeMQQueueOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KubeMQQueueConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KubeMQQueueReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupKubeMQQueueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupKubeMQQueueOptions} ReadGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupKubeMQQueueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupKubeMQQueueOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupKubeMQQueueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.KubeMQQueueConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.KubeMQQueueReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupKubeMQQueueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupKubeMQQueueOptions} ReadGroupKubeMQQueueOptions
             */
            ReadGroupKubeMQQueueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupKubeMQQueueOptions)
                    return object;
                let message = new $root.protos.opts.ReadGroupKubeMQQueueOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupKubeMQQueueOptions._conn: object expected");
                    message._conn = $root.protos.args.KubeMQQueueConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupKubeMQQueueOptions.args: object expected");
                    message.args = $root.protos.args.KubeMQQueueReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupKubeMQQueueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.ReadGroupKubeMQQueueOptions} message ReadGroupKubeMQQueueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupKubeMQQueueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KubeMQQueueConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KubeMQQueueReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupKubeMQQueueOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupKubeMQQueueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupKubeMQQueueOptions;
        })();

        opts.RelayCLIOptions = (function() {

            /**
             * Properties of a RelayCLIOptions.
             * @memberof protos.opts
             * @interface IRelayCLIOptions
             * @property {string|null} [httpListenAddress] RelayCLIOptions httpListenAddress
             */

            /**
             * Constructs a new RelayCLIOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayCLIOptions.
             * @implements IRelayCLIOptions
             * @constructor
             * @param {protos.opts.IRelayCLIOptions=} [properties] Properties to set
             */
            function RelayCLIOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayCLIOptions httpListenAddress.
             * @member {string} httpListenAddress
             * @memberof protos.opts.RelayCLIOptions
             * @instance
             */
            RelayCLIOptions.prototype.httpListenAddress = "";

            /**
             * Creates a new RelayCLIOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {protos.opts.IRelayCLIOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayCLIOptions} RelayCLIOptions instance
             */
            RelayCLIOptions.create = function create(properties) {
                return new RelayCLIOptions(properties);
            };

            /**
             * Encodes the specified RelayCLIOptions message. Does not implicitly {@link protos.opts.RelayCLIOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {protos.opts.IRelayCLIOptions} message RelayCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayCLIOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.httpListenAddress != null && Object.hasOwnProperty.call(message, "httpListenAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.httpListenAddress);
                return writer;
            };

            /**
             * Encodes the specified RelayCLIOptions message, length delimited. Does not implicitly {@link protos.opts.RelayCLIOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {protos.opts.IRelayCLIOptions} message RelayCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayCLIOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayCLIOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayCLIOptions} RelayCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayCLIOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayCLIOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.httpListenAddress = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayCLIOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayCLIOptions} RelayCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayCLIOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayCLIOptions message.
             * @function verify
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayCLIOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.httpListenAddress != null && message.hasOwnProperty("httpListenAddress"))
                    if (!$util.isString(message.httpListenAddress))
                        return "httpListenAddress: string expected";
                return null;
            };

            /**
             * Creates a RelayCLIOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayCLIOptions} RelayCLIOptions
             */
            RelayCLIOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayCLIOptions)
                    return object;
                let message = new $root.protos.opts.RelayCLIOptions();
                if (object.httpListenAddress != null)
                    message.httpListenAddress = String(object.httpListenAddress);
                return message;
            };

            /**
             * Creates a plain object from a RelayCLIOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {protos.opts.RelayCLIOptions} message RelayCLIOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayCLIOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.httpListenAddress = "";
                if (message.httpListenAddress != null && message.hasOwnProperty("httpListenAddress"))
                    object.httpListenAddress = message.httpListenAddress;
                return object;
            };

            /**
             * Converts this RelayCLIOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayCLIOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayCLIOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayCLIOptions;
        })();

        opts.RelayOptions = (function() {

            /**
             * Properties of a RelayOptions.
             * @memberof protos.opts
             * @interface IRelayOptions
             * @property {string|null} [collectionToken] RelayOptions collectionToken
             * @property {number|null} [batchSize] RelayOptions batchSize
             * @property {number|null} [batchMaxRetry] RelayOptions batchMaxRetry
             * @property {string|null} [connectionId] RelayOptions connectionId
             * @property {number|null} [numWorkers] RelayOptions numWorkers
             * @property {string|null} [_batchshGrpcAddress] RelayOptions _batchshGrpcAddress
             * @property {boolean|null} [_batchshGrpcDisableTls] RelayOptions _batchshGrpcDisableTls
             * @property {number|null} [_batchshGrpcTimeoutSeconds] RelayOptions _batchshGrpcTimeoutSeconds
             * @property {string|null} [_relayId] RelayOptions _relayId
             * @property {protos.opts.IRelayCLIOptions|null} [_cliOptions] RelayOptions _cliOptions
             * @property {protos.opts.IRelayGroupKafkaOptions|null} [kafka] RelayOptions kafka
             * @property {protos.opts.IRelayGroupAWSSQSOptions|null} [awssqs] RelayOptions awssqs
             * @property {protos.opts.IRelayGroupMongoOptions|null} [mongo] RelayOptions mongo
             * @property {protos.opts.IRelayGroupNSQOptions|null} [nsq] RelayOptions nsq
             * @property {protos.opts.IRelayGroupRabbitOptions|null} [rabbit] RelayOptions rabbit
             * @property {protos.opts.IRelayGroupMQTTOptions|null} [mqtt] RelayOptions mqtt
             * @property {protos.opts.IRelayGroupAzureServiceBusOptions|null} [azureServiceBus] RelayOptions azureServiceBus
             * @property {protos.opts.IRelayGroupGCPPubSubOptions|null} [gcpPubsub] RelayOptions gcpPubsub
             * @property {protos.opts.IRelayGroupKubeMQQueueOptions|null} [kubemqQueue] RelayOptions kubemqQueue
             * @property {protos.opts.IRelayGroupRedisPubSubOptions|null} [redisPubsub] RelayOptions redisPubsub
             * @property {protos.opts.IRelayGroupRedisStreamsOptions|null} [redisStreams] RelayOptions redisStreams
             * @property {protos.opts.IRelayGroupPostgresOptions|null} [postgres] RelayOptions postgres
             */

            /**
             * Constructs a new RelayOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayOptions.
             * @implements IRelayOptions
             * @constructor
             * @param {protos.opts.IRelayOptions=} [properties] Properties to set
             */
            function RelayOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayOptions collectionToken.
             * @member {string} collectionToken
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.collectionToken = "";

            /**
             * RelayOptions batchSize.
             * @member {number} batchSize
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.batchSize = 0;

            /**
             * RelayOptions batchMaxRetry.
             * @member {number} batchMaxRetry
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.batchMaxRetry = 0;

            /**
             * RelayOptions connectionId.
             * @member {string} connectionId
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.connectionId = "";

            /**
             * RelayOptions numWorkers.
             * @member {number} numWorkers
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.numWorkers = 0;

            /**
             * RelayOptions _batchshGrpcAddress.
             * @member {string} _batchshGrpcAddress
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._batchshGrpcAddress = "";

            /**
             * RelayOptions _batchshGrpcDisableTls.
             * @member {boolean} _batchshGrpcDisableTls
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._batchshGrpcDisableTls = false;

            /**
             * RelayOptions _batchshGrpcTimeoutSeconds.
             * @member {number} _batchshGrpcTimeoutSeconds
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._batchshGrpcTimeoutSeconds = 0;

            /**
             * RelayOptions _relayId.
             * @member {string} _relayId
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._relayId = "";

            /**
             * RelayOptions _cliOptions.
             * @member {protos.opts.IRelayCLIOptions|null|undefined} _cliOptions
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._cliOptions = null;

            /**
             * RelayOptions kafka.
             * @member {protos.opts.IRelayGroupKafkaOptions|null|undefined} kafka
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.kafka = null;

            /**
             * RelayOptions awssqs.
             * @member {protos.opts.IRelayGroupAWSSQSOptions|null|undefined} awssqs
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.awssqs = null;

            /**
             * RelayOptions mongo.
             * @member {protos.opts.IRelayGroupMongoOptions|null|undefined} mongo
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.mongo = null;

            /**
             * RelayOptions nsq.
             * @member {protos.opts.IRelayGroupNSQOptions|null|undefined} nsq
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.nsq = null;

            /**
             * RelayOptions rabbit.
             * @member {protos.opts.IRelayGroupRabbitOptions|null|undefined} rabbit
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.rabbit = null;

            /**
             * RelayOptions mqtt.
             * @member {protos.opts.IRelayGroupMQTTOptions|null|undefined} mqtt
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.mqtt = null;

            /**
             * RelayOptions azureServiceBus.
             * @member {protos.opts.IRelayGroupAzureServiceBusOptions|null|undefined} azureServiceBus
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.azureServiceBus = null;

            /**
             * RelayOptions gcpPubsub.
             * @member {protos.opts.IRelayGroupGCPPubSubOptions|null|undefined} gcpPubsub
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.gcpPubsub = null;

            /**
             * RelayOptions kubemqQueue.
             * @member {protos.opts.IRelayGroupKubeMQQueueOptions|null|undefined} kubemqQueue
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.kubemqQueue = null;

            /**
             * RelayOptions redisPubsub.
             * @member {protos.opts.IRelayGroupRedisPubSubOptions|null|undefined} redisPubsub
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.redisPubsub = null;

            /**
             * RelayOptions redisStreams.
             * @member {protos.opts.IRelayGroupRedisStreamsOptions|null|undefined} redisStreams
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.redisStreams = null;

            /**
             * RelayOptions postgres.
             * @member {protos.opts.IRelayGroupPostgresOptions|null|undefined} postgres
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.postgres = null;

            /**
             * Creates a new RelayOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {protos.opts.IRelayOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayOptions} RelayOptions instance
             */
            RelayOptions.create = function create(properties) {
                return new RelayOptions(properties);
            };

            /**
             * Encodes the specified RelayOptions message. Does not implicitly {@link protos.opts.RelayOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {protos.opts.IRelayOptions} message RelayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collectionToken != null && Object.hasOwnProperty.call(message, "collectionToken"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.collectionToken);
                if (message.batchSize != null && Object.hasOwnProperty.call(message, "batchSize"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.batchSize);
                if (message.batchMaxRetry != null && Object.hasOwnProperty.call(message, "batchMaxRetry"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.batchMaxRetry);
                if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.connectionId);
                if (message.numWorkers != null && Object.hasOwnProperty.call(message, "numWorkers"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.numWorkers);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.opts.RelayGroupKafkaOptions.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.awssqs != null && Object.hasOwnProperty.call(message, "awssqs"))
                    $root.protos.opts.RelayGroupAWSSQSOptions.encode(message.awssqs, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.mongo != null && Object.hasOwnProperty.call(message, "mongo"))
                    $root.protos.opts.RelayGroupMongoOptions.encode(message.mongo, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.opts.RelayGroupNSQOptions.encode(message.nsq, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.opts.RelayGroupRabbitOptions.encode(message.rabbit, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.opts.RelayGroupMQTTOptions.encode(message.mqtt, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.opts.RelayGroupAzureServiceBusOptions.encode(message.azureServiceBus, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.opts.RelayGroupGCPPubSubOptions.encode(message.gcpPubsub, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.opts.RelayGroupKubeMQQueueOptions.encode(message.kubemqQueue, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.opts.RelayGroupRedisPubSubOptions.encode(message.redisPubsub, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.opts.RelayGroupRedisStreamsOptions.encode(message.redisStreams, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.postgres != null && Object.hasOwnProperty.call(message, "postgres"))
                    $root.protos.opts.RelayGroupPostgresOptions.encode(message.postgres, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message._batchshGrpcAddress != null && Object.hasOwnProperty.call(message, "_batchshGrpcAddress"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._batchshGrpcAddress);
                if (message._batchshGrpcDisableTls != null && Object.hasOwnProperty.call(message, "_batchshGrpcDisableTls"))
                    writer.uint32(/* id 1001, wireType 0 =*/8008).bool(message._batchshGrpcDisableTls);
                if (message._batchshGrpcTimeoutSeconds != null && Object.hasOwnProperty.call(message, "_batchshGrpcTimeoutSeconds"))
                    writer.uint32(/* id 1002, wireType 0 =*/8016).int32(message._batchshGrpcTimeoutSeconds);
                if (message._relayId != null && Object.hasOwnProperty.call(message, "_relayId"))
                    writer.uint32(/* id 1003, wireType 2 =*/8026).string(message._relayId);
                if (message._cliOptions != null && Object.hasOwnProperty.call(message, "_cliOptions"))
                    $root.protos.opts.RelayCLIOptions.encode(message._cliOptions, writer.uint32(/* id 1004, wireType 2 =*/8034).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayOptions message, length delimited. Does not implicitly {@link protos.opts.RelayOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {protos.opts.IRelayOptions} message RelayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayOptions} RelayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collectionToken = reader.string();
                        break;
                    case 2:
                        message.batchSize = reader.int32();
                        break;
                    case 3:
                        message.batchMaxRetry = reader.int32();
                        break;
                    case 4:
                        message.connectionId = reader.string();
                        break;
                    case 5:
                        message.numWorkers = reader.int32();
                        break;
                    case 1000:
                        message._batchshGrpcAddress = reader.string();
                        break;
                    case 1001:
                        message._batchshGrpcDisableTls = reader.bool();
                        break;
                    case 1002:
                        message._batchshGrpcTimeoutSeconds = reader.int32();
                        break;
                    case 1003:
                        message._relayId = reader.string();
                        break;
                    case 1004:
                        message._cliOptions = $root.protos.opts.RelayCLIOptions.decode(reader, reader.uint32());
                        break;
                    case 100:
                        message.kafka = $root.protos.opts.RelayGroupKafkaOptions.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.awssqs = $root.protos.opts.RelayGroupAWSSQSOptions.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.mongo = $root.protos.opts.RelayGroupMongoOptions.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.nsq = $root.protos.opts.RelayGroupNSQOptions.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.rabbit = $root.protos.opts.RelayGroupRabbitOptions.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.mqtt = $root.protos.opts.RelayGroupMQTTOptions.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.azureServiceBus = $root.protos.opts.RelayGroupAzureServiceBusOptions.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.gcpPubsub = $root.protos.opts.RelayGroupGCPPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.kubemqQueue = $root.protos.opts.RelayGroupKubeMQQueueOptions.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.redisPubsub = $root.protos.opts.RelayGroupRedisPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.redisStreams = $root.protos.opts.RelayGroupRedisStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.postgres = $root.protos.opts.RelayGroupPostgresOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayOptions} RelayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayOptions message.
             * @function verify
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collectionToken != null && message.hasOwnProperty("collectionToken"))
                    if (!$util.isString(message.collectionToken))
                        return "collectionToken: string expected";
                if (message.batchSize != null && message.hasOwnProperty("batchSize"))
                    if (!$util.isInteger(message.batchSize))
                        return "batchSize: integer expected";
                if (message.batchMaxRetry != null && message.hasOwnProperty("batchMaxRetry"))
                    if (!$util.isInteger(message.batchMaxRetry))
                        return "batchMaxRetry: integer expected";
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    if (!$util.isString(message.connectionId))
                        return "connectionId: string expected";
                if (message.numWorkers != null && message.hasOwnProperty("numWorkers"))
                    if (!$util.isInteger(message.numWorkers))
                        return "numWorkers: integer expected";
                if (message._batchshGrpcAddress != null && message.hasOwnProperty("_batchshGrpcAddress"))
                    if (!$util.isString(message._batchshGrpcAddress))
                        return "_batchshGrpcAddress: string expected";
                if (message._batchshGrpcDisableTls != null && message.hasOwnProperty("_batchshGrpcDisableTls"))
                    if (typeof message._batchshGrpcDisableTls !== "boolean")
                        return "_batchshGrpcDisableTls: boolean expected";
                if (message._batchshGrpcTimeoutSeconds != null && message.hasOwnProperty("_batchshGrpcTimeoutSeconds"))
                    if (!$util.isInteger(message._batchshGrpcTimeoutSeconds))
                        return "_batchshGrpcTimeoutSeconds: integer expected";
                if (message._relayId != null && message.hasOwnProperty("_relayId"))
                    if (!$util.isString(message._relayId))
                        return "_relayId: string expected";
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions")) {
                    let error = $root.protos.opts.RelayCLIOptions.verify(message._cliOptions);
                    if (error)
                        return "_cliOptions." + error;
                }
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    let error = $root.protos.opts.RelayGroupKafkaOptions.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.awssqs != null && message.hasOwnProperty("awssqs")) {
                    let error = $root.protos.opts.RelayGroupAWSSQSOptions.verify(message.awssqs);
                    if (error)
                        return "awssqs." + error;
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    let error = $root.protos.opts.RelayGroupMongoOptions.verify(message.mongo);
                    if (error)
                        return "mongo." + error;
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    let error = $root.protos.opts.RelayGroupNSQOptions.verify(message.nsq);
                    if (error)
                        return "nsq." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    let error = $root.protos.opts.RelayGroupRabbitOptions.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    let error = $root.protos.opts.RelayGroupMQTTOptions.verify(message.mqtt);
                    if (error)
                        return "mqtt." + error;
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    let error = $root.protos.opts.RelayGroupAzureServiceBusOptions.verify(message.azureServiceBus);
                    if (error)
                        return "azureServiceBus." + error;
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    let error = $root.protos.opts.RelayGroupGCPPubSubOptions.verify(message.gcpPubsub);
                    if (error)
                        return "gcpPubsub." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    let error = $root.protos.opts.RelayGroupKubeMQQueueOptions.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    let error = $root.protos.opts.RelayGroupRedisPubSubOptions.verify(message.redisPubsub);
                    if (error)
                        return "redisPubsub." + error;
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    let error = $root.protos.opts.RelayGroupRedisStreamsOptions.verify(message.redisStreams);
                    if (error)
                        return "redisStreams." + error;
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    let error = $root.protos.opts.RelayGroupPostgresOptions.verify(message.postgres);
                    if (error)
                        return "postgres." + error;
                }
                return null;
            };

            /**
             * Creates a RelayOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayOptions} RelayOptions
             */
            RelayOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayOptions)
                    return object;
                let message = new $root.protos.opts.RelayOptions();
                if (object.collectionToken != null)
                    message.collectionToken = String(object.collectionToken);
                if (object.batchSize != null)
                    message.batchSize = object.batchSize | 0;
                if (object.batchMaxRetry != null)
                    message.batchMaxRetry = object.batchMaxRetry | 0;
                if (object.connectionId != null)
                    message.connectionId = String(object.connectionId);
                if (object.numWorkers != null)
                    message.numWorkers = object.numWorkers | 0;
                if (object._batchshGrpcAddress != null)
                    message._batchshGrpcAddress = String(object._batchshGrpcAddress);
                if (object._batchshGrpcDisableTls != null)
                    message._batchshGrpcDisableTls = Boolean(object._batchshGrpcDisableTls);
                if (object._batchshGrpcTimeoutSeconds != null)
                    message._batchshGrpcTimeoutSeconds = object._batchshGrpcTimeoutSeconds | 0;
                if (object._relayId != null)
                    message._relayId = String(object._relayId);
                if (object._cliOptions != null) {
                    if (typeof object._cliOptions !== "object")
                        throw TypeError(".protos.opts.RelayOptions._cliOptions: object expected");
                    message._cliOptions = $root.protos.opts.RelayCLIOptions.fromObject(object._cliOptions);
                }
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.RelayOptions.kafka: object expected");
                    message.kafka = $root.protos.opts.RelayGroupKafkaOptions.fromObject(object.kafka);
                }
                if (object.awssqs != null) {
                    if (typeof object.awssqs !== "object")
                        throw TypeError(".protos.opts.RelayOptions.awssqs: object expected");
                    message.awssqs = $root.protos.opts.RelayGroupAWSSQSOptions.fromObject(object.awssqs);
                }
                if (object.mongo != null) {
                    if (typeof object.mongo !== "object")
                        throw TypeError(".protos.opts.RelayOptions.mongo: object expected");
                    message.mongo = $root.protos.opts.RelayGroupMongoOptions.fromObject(object.mongo);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.RelayOptions.nsq: object expected");
                    message.nsq = $root.protos.opts.RelayGroupNSQOptions.fromObject(object.nsq);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.RelayOptions.rabbit: object expected");
                    message.rabbit = $root.protos.opts.RelayGroupRabbitOptions.fromObject(object.rabbit);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.RelayOptions.mqtt: object expected");
                    message.mqtt = $root.protos.opts.RelayGroupMQTTOptions.fromObject(object.mqtt);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.RelayOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.opts.RelayGroupAzureServiceBusOptions.fromObject(object.azureServiceBus);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.RelayOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.opts.RelayGroupGCPPubSubOptions.fromObject(object.gcpPubsub);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.RelayOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.opts.RelayGroupKubeMQQueueOptions.fromObject(object.kubemqQueue);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.RelayOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.opts.RelayGroupRedisPubSubOptions.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.RelayOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.opts.RelayGroupRedisStreamsOptions.fromObject(object.redisStreams);
                }
                if (object.postgres != null) {
                    if (typeof object.postgres !== "object")
                        throw TypeError(".protos.opts.RelayOptions.postgres: object expected");
                    message.postgres = $root.protos.opts.RelayGroupPostgresOptions.fromObject(object.postgres);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {protos.opts.RelayOptions} message RelayOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.collectionToken = "";
                    object.batchSize = 0;
                    object.batchMaxRetry = 0;
                    object.connectionId = "";
                    object.numWorkers = 0;
                    object.kafka = null;
                    object.awssqs = null;
                    object.mongo = null;
                    object.nsq = null;
                    object.rabbit = null;
                    object.mqtt = null;
                    object.azureServiceBus = null;
                    object.gcpPubsub = null;
                    object.kubemqQueue = null;
                    object.redisPubsub = null;
                    object.redisStreams = null;
                    object.postgres = null;
                    object._batchshGrpcAddress = "";
                    object._batchshGrpcDisableTls = false;
                    object._batchshGrpcTimeoutSeconds = 0;
                    object._relayId = "";
                    object._cliOptions = null;
                }
                if (message.collectionToken != null && message.hasOwnProperty("collectionToken"))
                    object.collectionToken = message.collectionToken;
                if (message.batchSize != null && message.hasOwnProperty("batchSize"))
                    object.batchSize = message.batchSize;
                if (message.batchMaxRetry != null && message.hasOwnProperty("batchMaxRetry"))
                    object.batchMaxRetry = message.batchMaxRetry;
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    object.connectionId = message.connectionId;
                if (message.numWorkers != null && message.hasOwnProperty("numWorkers"))
                    object.numWorkers = message.numWorkers;
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.opts.RelayGroupKafkaOptions.toObject(message.kafka, options);
                if (message.awssqs != null && message.hasOwnProperty("awssqs"))
                    object.awssqs = $root.protos.opts.RelayGroupAWSSQSOptions.toObject(message.awssqs, options);
                if (message.mongo != null && message.hasOwnProperty("mongo"))
                    object.mongo = $root.protos.opts.RelayGroupMongoOptions.toObject(message.mongo, options);
                if (message.nsq != null && message.hasOwnProperty("nsq"))
                    object.nsq = $root.protos.opts.RelayGroupNSQOptions.toObject(message.nsq, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.opts.RelayGroupRabbitOptions.toObject(message.rabbit, options);
                if (message.mqtt != null && message.hasOwnProperty("mqtt"))
                    object.mqtt = $root.protos.opts.RelayGroupMQTTOptions.toObject(message.mqtt, options);
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus"))
                    object.azureServiceBus = $root.protos.opts.RelayGroupAzureServiceBusOptions.toObject(message.azureServiceBus, options);
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub"))
                    object.gcpPubsub = $root.protos.opts.RelayGroupGCPPubSubOptions.toObject(message.gcpPubsub, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.opts.RelayGroupKubeMQQueueOptions.toObject(message.kubemqQueue, options);
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub"))
                    object.redisPubsub = $root.protos.opts.RelayGroupRedisPubSubOptions.toObject(message.redisPubsub, options);
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams"))
                    object.redisStreams = $root.protos.opts.RelayGroupRedisStreamsOptions.toObject(message.redisStreams, options);
                if (message.postgres != null && message.hasOwnProperty("postgres"))
                    object.postgres = $root.protos.opts.RelayGroupPostgresOptions.toObject(message.postgres, options);
                if (message._batchshGrpcAddress != null && message.hasOwnProperty("_batchshGrpcAddress"))
                    object._batchshGrpcAddress = message._batchshGrpcAddress;
                if (message._batchshGrpcDisableTls != null && message.hasOwnProperty("_batchshGrpcDisableTls"))
                    object._batchshGrpcDisableTls = message._batchshGrpcDisableTls;
                if (message._batchshGrpcTimeoutSeconds != null && message.hasOwnProperty("_batchshGrpcTimeoutSeconds"))
                    object._batchshGrpcTimeoutSeconds = message._batchshGrpcTimeoutSeconds;
                if (message._relayId != null && message.hasOwnProperty("_relayId"))
                    object._relayId = message._relayId;
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions"))
                    object._cliOptions = $root.protos.opts.RelayCLIOptions.toObject(message._cliOptions, options);
                return object;
            };

            /**
             * Converts this RelayOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayOptions;
        })();

        opts.RelayGroupKafkaOptions = (function() {

            /**
             * Properties of a RelayGroupKafkaOptions.
             * @memberof protos.opts
             * @interface IRelayGroupKafkaOptions
             * @property {protos.args.IKafkaConn|null} [_conn] RelayGroupKafkaOptions _conn
             * @property {protos.args.IKafkaRelayArgs|null} [args] RelayGroupKafkaOptions args
             */

            /**
             * Constructs a new RelayGroupKafkaOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupKafkaOptions.
             * @implements IRelayGroupKafkaOptions
             * @constructor
             * @param {protos.opts.IRelayGroupKafkaOptions=} [properties] Properties to set
             */
            function RelayGroupKafkaOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupKafkaOptions _conn.
             * @member {protos.args.IKafkaConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @instance
             */
            RelayGroupKafkaOptions.prototype._conn = null;

            /**
             * RelayGroupKafkaOptions args.
             * @member {protos.args.IKafkaRelayArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @instance
             */
            RelayGroupKafkaOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupKafkaOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {protos.opts.IRelayGroupKafkaOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupKafkaOptions} RelayGroupKafkaOptions instance
             */
            RelayGroupKafkaOptions.create = function create(properties) {
                return new RelayGroupKafkaOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupKafkaOptions message. Does not implicitly {@link protos.opts.RelayGroupKafkaOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {protos.opts.IRelayGroupKafkaOptions} message RelayGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupKafkaOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KafkaConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KafkaRelayArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupKafkaOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupKafkaOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {protos.opts.IRelayGroupKafkaOptions} message RelayGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupKafkaOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupKafkaOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupKafkaOptions} RelayGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupKafkaOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupKafkaOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KafkaConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KafkaRelayArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupKafkaOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupKafkaOptions} RelayGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupKafkaOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupKafkaOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupKafkaOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.KafkaConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.KafkaRelayArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupKafkaOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupKafkaOptions} RelayGroupKafkaOptions
             */
            RelayGroupKafkaOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupKafkaOptions)
                    return object;
                let message = new $root.protos.opts.RelayGroupKafkaOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupKafkaOptions._conn: object expected");
                    message._conn = $root.protos.args.KafkaConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupKafkaOptions.args: object expected");
                    message.args = $root.protos.args.KafkaRelayArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupKafkaOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {protos.opts.RelayGroupKafkaOptions} message RelayGroupKafkaOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupKafkaOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KafkaConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KafkaRelayArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupKafkaOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupKafkaOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupKafkaOptions;
        })();

        opts.RelayGroupAWSSQSOptions = (function() {

            /**
             * Properties of a RelayGroupAWSSQSOptions.
             * @memberof protos.opts
             * @interface IRelayGroupAWSSQSOptions
             * @property {protos.args.IAWSSQSConn|null} [_conn] RelayGroupAWSSQSOptions _conn
             * @property {protos.args.IAWSSQSRelayArgs|null} [args] RelayGroupAWSSQSOptions args
             */

            /**
             * Constructs a new RelayGroupAWSSQSOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupAWSSQSOptions.
             * @implements IRelayGroupAWSSQSOptions
             * @constructor
             * @param {protos.opts.IRelayGroupAWSSQSOptions=} [properties] Properties to set
             */
            function RelayGroupAWSSQSOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupAWSSQSOptions _conn.
             * @member {protos.args.IAWSSQSConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @instance
             */
            RelayGroupAWSSQSOptions.prototype._conn = null;

            /**
             * RelayGroupAWSSQSOptions args.
             * @member {protos.args.IAWSSQSRelayArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @instance
             */
            RelayGroupAWSSQSOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupAWSSQSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IRelayGroupAWSSQSOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupAWSSQSOptions} RelayGroupAWSSQSOptions instance
             */
            RelayGroupAWSSQSOptions.create = function create(properties) {
                return new RelayGroupAWSSQSOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupAWSSQSOptions message. Does not implicitly {@link protos.opts.RelayGroupAWSSQSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IRelayGroupAWSSQSOptions} message RelayGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupAWSSQSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSQSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSQSRelayArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupAWSSQSOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupAWSSQSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IRelayGroupAWSSQSOptions} message RelayGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupAWSSQSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupAWSSQSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupAWSSQSOptions} RelayGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupAWSSQSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupAWSSQSOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSQSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSQSRelayArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupAWSSQSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupAWSSQSOptions} RelayGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupAWSSQSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupAWSSQSOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupAWSSQSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.AWSSQSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.AWSSQSRelayArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupAWSSQSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupAWSSQSOptions} RelayGroupAWSSQSOptions
             */
            RelayGroupAWSSQSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupAWSSQSOptions)
                    return object;
                let message = new $root.protos.opts.RelayGroupAWSSQSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupAWSSQSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSQSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupAWSSQSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSQSRelayArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupAWSSQSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {protos.opts.RelayGroupAWSSQSOptions} message RelayGroupAWSSQSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupAWSSQSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSQSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSQSRelayArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupAWSSQSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupAWSSQSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupAWSSQSOptions;
        })();

        opts.RelayGroupMongoOptions = (function() {

            /**
             * Properties of a RelayGroupMongoOptions.
             * @memberof protos.opts
             * @interface IRelayGroupMongoOptions
             * @property {protos.args.IMongoConn|null} [_conn] RelayGroupMongoOptions _conn
             * @property {protos.args.IMongoReadArgs|null} [args] RelayGroupMongoOptions args
             */

            /**
             * Constructs a new RelayGroupMongoOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupMongoOptions.
             * @implements IRelayGroupMongoOptions
             * @constructor
             * @param {protos.opts.IRelayGroupMongoOptions=} [properties] Properties to set
             */
            function RelayGroupMongoOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupMongoOptions _conn.
             * @member {protos.args.IMongoConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupMongoOptions
             * @instance
             */
            RelayGroupMongoOptions.prototype._conn = null;

            /**
             * RelayGroupMongoOptions args.
             * @member {protos.args.IMongoReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupMongoOptions
             * @instance
             */
            RelayGroupMongoOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupMongoOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {protos.opts.IRelayGroupMongoOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupMongoOptions} RelayGroupMongoOptions instance
             */
            RelayGroupMongoOptions.create = function create(properties) {
                return new RelayGroupMongoOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupMongoOptions message. Does not implicitly {@link protos.opts.RelayGroupMongoOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {protos.opts.IRelayGroupMongoOptions} message RelayGroupMongoOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupMongoOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MongoConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MongoReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupMongoOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupMongoOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {protos.opts.IRelayGroupMongoOptions} message RelayGroupMongoOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupMongoOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupMongoOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupMongoOptions} RelayGroupMongoOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupMongoOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupMongoOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MongoConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MongoReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupMongoOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupMongoOptions} RelayGroupMongoOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupMongoOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupMongoOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupMongoOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.MongoConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.MongoReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupMongoOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupMongoOptions} RelayGroupMongoOptions
             */
            RelayGroupMongoOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupMongoOptions)
                    return object;
                let message = new $root.protos.opts.RelayGroupMongoOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupMongoOptions._conn: object expected");
                    message._conn = $root.protos.args.MongoConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupMongoOptions.args: object expected");
                    message.args = $root.protos.args.MongoReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupMongoOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {protos.opts.RelayGroupMongoOptions} message RelayGroupMongoOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupMongoOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MongoConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MongoReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupMongoOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupMongoOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupMongoOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupMongoOptions;
        })();

        opts.RelayGroupNSQOptions = (function() {

            /**
             * Properties of a RelayGroupNSQOptions.
             * @memberof protos.opts
             * @interface IRelayGroupNSQOptions
             * @property {protos.args.INSQConn|null} [_conn] RelayGroupNSQOptions _conn
             * @property {protos.args.INSQReadArgs|null} [args] RelayGroupNSQOptions args
             */

            /**
             * Constructs a new RelayGroupNSQOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupNSQOptions.
             * @implements IRelayGroupNSQOptions
             * @constructor
             * @param {protos.opts.IRelayGroupNSQOptions=} [properties] Properties to set
             */
            function RelayGroupNSQOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupNSQOptions _conn.
             * @member {protos.args.INSQConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupNSQOptions
             * @instance
             */
            RelayGroupNSQOptions.prototype._conn = null;

            /**
             * RelayGroupNSQOptions args.
             * @member {protos.args.INSQReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupNSQOptions
             * @instance
             */
            RelayGroupNSQOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupNSQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {protos.opts.IRelayGroupNSQOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupNSQOptions} RelayGroupNSQOptions instance
             */
            RelayGroupNSQOptions.create = function create(properties) {
                return new RelayGroupNSQOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupNSQOptions message. Does not implicitly {@link protos.opts.RelayGroupNSQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {protos.opts.IRelayGroupNSQOptions} message RelayGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupNSQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NSQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NSQReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupNSQOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupNSQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {protos.opts.IRelayGroupNSQOptions} message RelayGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupNSQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupNSQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupNSQOptions} RelayGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupNSQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupNSQOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NSQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NSQReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupNSQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupNSQOptions} RelayGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupNSQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupNSQOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupNSQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.NSQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.NSQReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupNSQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupNSQOptions} RelayGroupNSQOptions
             */
            RelayGroupNSQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupNSQOptions)
                    return object;
                let message = new $root.protos.opts.RelayGroupNSQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupNSQOptions._conn: object expected");
                    message._conn = $root.protos.args.NSQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupNSQOptions.args: object expected");
                    message.args = $root.protos.args.NSQReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupNSQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {protos.opts.RelayGroupNSQOptions} message RelayGroupNSQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupNSQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NSQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NSQReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupNSQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupNSQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupNSQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupNSQOptions;
        })();

        opts.RelayGroupPostgresOptions = (function() {

            /**
             * Properties of a RelayGroupPostgresOptions.
             * @memberof protos.opts
             * @interface IRelayGroupPostgresOptions
             * @property {protos.args.IPostgresConn|null} [_conn] RelayGroupPostgresOptions _conn
             * @property {protos.args.IPostgresReadArgs|null} [args] RelayGroupPostgresOptions args
             */

            /**
             * Constructs a new RelayGroupPostgresOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupPostgresOptions.
             * @implements IRelayGroupPostgresOptions
             * @constructor
             * @param {protos.opts.IRelayGroupPostgresOptions=} [properties] Properties to set
             */
            function RelayGroupPostgresOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupPostgresOptions _conn.
             * @member {protos.args.IPostgresConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @instance
             */
            RelayGroupPostgresOptions.prototype._conn = null;

            /**
             * RelayGroupPostgresOptions args.
             * @member {protos.args.IPostgresReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @instance
             */
            RelayGroupPostgresOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupPostgresOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {protos.opts.IRelayGroupPostgresOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupPostgresOptions} RelayGroupPostgresOptions instance
             */
            RelayGroupPostgresOptions.create = function create(properties) {
                return new RelayGroupPostgresOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupPostgresOptions message. Does not implicitly {@link protos.opts.RelayGroupPostgresOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {protos.opts.IRelayGroupPostgresOptions} message RelayGroupPostgresOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupPostgresOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.PostgresConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.PostgresReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupPostgresOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupPostgresOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {protos.opts.IRelayGroupPostgresOptions} message RelayGroupPostgresOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupPostgresOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupPostgresOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupPostgresOptions} RelayGroupPostgresOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupPostgresOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupPostgresOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.PostgresConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.PostgresReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupPostgresOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupPostgresOptions} RelayGroupPostgresOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupPostgresOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupPostgresOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupPostgresOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.PostgresConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.PostgresReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupPostgresOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupPostgresOptions} RelayGroupPostgresOptions
             */
            RelayGroupPostgresOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupPostgresOptions)
                    return object;
                let message = new $root.protos.opts.RelayGroupPostgresOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupPostgresOptions._conn: object expected");
                    message._conn = $root.protos.args.PostgresConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupPostgresOptions.args: object expected");
                    message.args = $root.protos.args.PostgresReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupPostgresOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {protos.opts.RelayGroupPostgresOptions} message RelayGroupPostgresOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupPostgresOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.PostgresConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.PostgresReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupPostgresOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupPostgresOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupPostgresOptions;
        })();

        opts.RelayGroupRabbitOptions = (function() {

            /**
             * Properties of a RelayGroupRabbitOptions.
             * @memberof protos.opts
             * @interface IRelayGroupRabbitOptions
             * @property {protos.args.IRabbitConn|null} [_conn] RelayGroupRabbitOptions _conn
             * @property {protos.args.IRabbitReadArgs|null} [args] RelayGroupRabbitOptions args
             */

            /**
             * Constructs a new RelayGroupRabbitOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupRabbitOptions.
             * @implements IRelayGroupRabbitOptions
             * @constructor
             * @param {protos.opts.IRelayGroupRabbitOptions=} [properties] Properties to set
             */
            function RelayGroupRabbitOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupRabbitOptions _conn.
             * @member {protos.args.IRabbitConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @instance
             */
            RelayGroupRabbitOptions.prototype._conn = null;

            /**
             * RelayGroupRabbitOptions args.
             * @member {protos.args.IRabbitReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @instance
             */
            RelayGroupRabbitOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupRabbitOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {protos.opts.IRelayGroupRabbitOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupRabbitOptions} RelayGroupRabbitOptions instance
             */
            RelayGroupRabbitOptions.create = function create(properties) {
                return new RelayGroupRabbitOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupRabbitOptions message. Does not implicitly {@link protos.opts.RelayGroupRabbitOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {protos.opts.IRelayGroupRabbitOptions} message RelayGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRabbitOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupRabbitOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupRabbitOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {protos.opts.IRelayGroupRabbitOptions} message RelayGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRabbitOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupRabbitOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupRabbitOptions} RelayGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRabbitOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupRabbitOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupRabbitOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupRabbitOptions} RelayGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRabbitOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupRabbitOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupRabbitOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.RabbitConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.RabbitReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupRabbitOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupRabbitOptions} RelayGroupRabbitOptions
             */
            RelayGroupRabbitOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupRabbitOptions)
                    return object;
                let message = new $root.protos.opts.RelayGroupRabbitOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupRabbitOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupRabbitOptions.args: object expected");
                    message.args = $root.protos.args.RabbitReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupRabbitOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {protos.opts.RelayGroupRabbitOptions} message RelayGroupRabbitOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupRabbitOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupRabbitOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupRabbitOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupRabbitOptions;
        })();

        opts.RelayGroupRedisPubSubOptions = (function() {

            /**
             * Properties of a RelayGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @interface IRelayGroupRedisPubSubOptions
             * @property {protos.args.IRedisPubSubConn|null} [_conn] RelayGroupRedisPubSubOptions _conn
             * @property {protos.args.IRedisPubSubReadArgs|null} [args] RelayGroupRedisPubSubOptions args
             */

            /**
             * Constructs a new RelayGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupRedisPubSubOptions.
             * @implements IRelayGroupRedisPubSubOptions
             * @constructor
             * @param {protos.opts.IRelayGroupRedisPubSubOptions=} [properties] Properties to set
             */
            function RelayGroupRedisPubSubOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupRedisPubSubOptions _conn.
             * @member {protos.args.IRedisPubSubConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @instance
             */
            RelayGroupRedisPubSubOptions.prototype._conn = null;

            /**
             * RelayGroupRedisPubSubOptions args.
             * @member {protos.args.IRedisPubSubReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @instance
             */
            RelayGroupRedisPubSubOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupRedisPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupRedisPubSubOptions} RelayGroupRedisPubSubOptions instance
             */
            RelayGroupRedisPubSubOptions.create = function create(properties) {
                return new RelayGroupRedisPubSubOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupRedisPubSubOptions message. Does not implicitly {@link protos.opts.RelayGroupRedisPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisPubSubOptions} message RelayGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRedisPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisPubSubReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupRedisPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupRedisPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisPubSubOptions} message RelayGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRedisPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupRedisPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupRedisPubSubOptions} RelayGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRedisPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupRedisPubSubOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisPubSubReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupRedisPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupRedisPubSubOptions} RelayGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRedisPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupRedisPubSubOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupRedisPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.RedisPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.RedisPubSubReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupRedisPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupRedisPubSubOptions} RelayGroupRedisPubSubOptions
             */
            RelayGroupRedisPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupRedisPubSubOptions)
                    return object;
                let message = new $root.protos.opts.RelayGroupRedisPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupRedisPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupRedisPubSubOptions.args: object expected");
                    message.args = $root.protos.args.RedisPubSubReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupRedisPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.RelayGroupRedisPubSubOptions} message RelayGroupRedisPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupRedisPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisPubSubReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupRedisPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupRedisPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupRedisPubSubOptions;
        })();

        opts.RelayGroupRedisStreamsOptions = (function() {

            /**
             * Properties of a RelayGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @interface IRelayGroupRedisStreamsOptions
             * @property {protos.args.IRedisStreamsConn|null} [_conn] RelayGroupRedisStreamsOptions _conn
             * @property {protos.args.IRedisStreamsReadArgs|null} [args] RelayGroupRedisStreamsOptions args
             */

            /**
             * Constructs a new RelayGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupRedisStreamsOptions.
             * @implements IRelayGroupRedisStreamsOptions
             * @constructor
             * @param {protos.opts.IRelayGroupRedisStreamsOptions=} [properties] Properties to set
             */
            function RelayGroupRedisStreamsOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupRedisStreamsOptions _conn.
             * @member {protos.args.IRedisStreamsConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @instance
             */
            RelayGroupRedisStreamsOptions.prototype._conn = null;

            /**
             * RelayGroupRedisStreamsOptions args.
             * @member {protos.args.IRedisStreamsReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @instance
             */
            RelayGroupRedisStreamsOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupRedisStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupRedisStreamsOptions} RelayGroupRedisStreamsOptions instance
             */
            RelayGroupRedisStreamsOptions.create = function create(properties) {
                return new RelayGroupRedisStreamsOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupRedisStreamsOptions message. Does not implicitly {@link protos.opts.RelayGroupRedisStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisStreamsOptions} message RelayGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRedisStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisStreamsReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupRedisStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupRedisStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisStreamsOptions} message RelayGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRedisStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupRedisStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupRedisStreamsOptions} RelayGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRedisStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupRedisStreamsOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisStreamsReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupRedisStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupRedisStreamsOptions} RelayGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRedisStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupRedisStreamsOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupRedisStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.RedisStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.RedisStreamsReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupRedisStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupRedisStreamsOptions} RelayGroupRedisStreamsOptions
             */
            RelayGroupRedisStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupRedisStreamsOptions)
                    return object;
                let message = new $root.protos.opts.RelayGroupRedisStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupRedisStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupRedisStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RedisStreamsReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupRedisStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.RelayGroupRedisStreamsOptions} message RelayGroupRedisStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupRedisStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisStreamsReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupRedisStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupRedisStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupRedisStreamsOptions;
        })();

        opts.RelayGroupAzureServiceBusOptions = (function() {

            /**
             * Properties of a RelayGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @interface IRelayGroupAzureServiceBusOptions
             * @property {protos.args.IAzureServiceBusConn|null} [_conn] RelayGroupAzureServiceBusOptions _conn
             * @property {protos.args.IAzureServiceBusReadArgs|null} [args] RelayGroupAzureServiceBusOptions args
             */

            /**
             * Constructs a new RelayGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupAzureServiceBusOptions.
             * @implements IRelayGroupAzureServiceBusOptions
             * @constructor
             * @param {protos.opts.IRelayGroupAzureServiceBusOptions=} [properties] Properties to set
             */
            function RelayGroupAzureServiceBusOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupAzureServiceBusOptions _conn.
             * @member {protos.args.IAzureServiceBusConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @instance
             */
            RelayGroupAzureServiceBusOptions.prototype._conn = null;

            /**
             * RelayGroupAzureServiceBusOptions args.
             * @member {protos.args.IAzureServiceBusReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @instance
             */
            RelayGroupAzureServiceBusOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupAzureServiceBusOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IRelayGroupAzureServiceBusOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupAzureServiceBusOptions} RelayGroupAzureServiceBusOptions instance
             */
            RelayGroupAzureServiceBusOptions.create = function create(properties) {
                return new RelayGroupAzureServiceBusOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupAzureServiceBusOptions message. Does not implicitly {@link protos.opts.RelayGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IRelayGroupAzureServiceBusOptions} message RelayGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupAzureServiceBusOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureServiceBusConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureServiceBusReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupAzureServiceBusOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IRelayGroupAzureServiceBusOptions} message RelayGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupAzureServiceBusOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupAzureServiceBusOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupAzureServiceBusOptions} RelayGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupAzureServiceBusOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupAzureServiceBusOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureServiceBusConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureServiceBusReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupAzureServiceBusOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupAzureServiceBusOptions} RelayGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupAzureServiceBusOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupAzureServiceBusOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupAzureServiceBusOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.AzureServiceBusConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.AzureServiceBusReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupAzureServiceBusOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupAzureServiceBusOptions} RelayGroupAzureServiceBusOptions
             */
            RelayGroupAzureServiceBusOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupAzureServiceBusOptions)
                    return object;
                let message = new $root.protos.opts.RelayGroupAzureServiceBusOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupAzureServiceBusOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureServiceBusConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupAzureServiceBusOptions.args: object expected");
                    message.args = $root.protos.args.AzureServiceBusReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupAzureServiceBusOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.RelayGroupAzureServiceBusOptions} message RelayGroupAzureServiceBusOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupAzureServiceBusOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureServiceBusConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureServiceBusReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupAzureServiceBusOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupAzureServiceBusOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupAzureServiceBusOptions;
        })();

        opts.RelayGroupMQTTOptions = (function() {

            /**
             * Properties of a RelayGroupMQTTOptions.
             * @memberof protos.opts
             * @interface IRelayGroupMQTTOptions
             * @property {protos.args.IMQTTConn|null} [_conn] RelayGroupMQTTOptions _conn
             * @property {protos.args.IMQTTReadArgs|null} [args] RelayGroupMQTTOptions args
             */

            /**
             * Constructs a new RelayGroupMQTTOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupMQTTOptions.
             * @implements IRelayGroupMQTTOptions
             * @constructor
             * @param {protos.opts.IRelayGroupMQTTOptions=} [properties] Properties to set
             */
            function RelayGroupMQTTOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupMQTTOptions _conn.
             * @member {protos.args.IMQTTConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @instance
             */
            RelayGroupMQTTOptions.prototype._conn = null;

            /**
             * RelayGroupMQTTOptions args.
             * @member {protos.args.IMQTTReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @instance
             */
            RelayGroupMQTTOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupMQTTOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {protos.opts.IRelayGroupMQTTOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupMQTTOptions} RelayGroupMQTTOptions instance
             */
            RelayGroupMQTTOptions.create = function create(properties) {
                return new RelayGroupMQTTOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupMQTTOptions message. Does not implicitly {@link protos.opts.RelayGroupMQTTOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {protos.opts.IRelayGroupMQTTOptions} message RelayGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupMQTTOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MQTTConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MQTTReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupMQTTOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupMQTTOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {protos.opts.IRelayGroupMQTTOptions} message RelayGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupMQTTOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupMQTTOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupMQTTOptions} RelayGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupMQTTOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupMQTTOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MQTTConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MQTTReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupMQTTOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupMQTTOptions} RelayGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupMQTTOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupMQTTOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupMQTTOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.MQTTConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.MQTTReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupMQTTOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupMQTTOptions} RelayGroupMQTTOptions
             */
            RelayGroupMQTTOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupMQTTOptions)
                    return object;
                let message = new $root.protos.opts.RelayGroupMQTTOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupMQTTOptions._conn: object expected");
                    message._conn = $root.protos.args.MQTTConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupMQTTOptions.args: object expected");
                    message.args = $root.protos.args.MQTTReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupMQTTOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {protos.opts.RelayGroupMQTTOptions} message RelayGroupMQTTOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupMQTTOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MQTTConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MQTTReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupMQTTOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupMQTTOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupMQTTOptions;
        })();

        opts.RelayGroupGCPPubSubOptions = (function() {

            /**
             * Properties of a RelayGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @interface IRelayGroupGCPPubSubOptions
             * @property {protos.args.IGCPPubSubConn|null} [_conn] RelayGroupGCPPubSubOptions _conn
             * @property {protos.args.IGCPPubSubReadArgs|null} [args] RelayGroupGCPPubSubOptions args
             */

            /**
             * Constructs a new RelayGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupGCPPubSubOptions.
             * @implements IRelayGroupGCPPubSubOptions
             * @constructor
             * @param {protos.opts.IRelayGroupGCPPubSubOptions=} [properties] Properties to set
             */
            function RelayGroupGCPPubSubOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupGCPPubSubOptions _conn.
             * @member {protos.args.IGCPPubSubConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @instance
             */
            RelayGroupGCPPubSubOptions.prototype._conn = null;

            /**
             * RelayGroupGCPPubSubOptions args.
             * @member {protos.args.IGCPPubSubReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @instance
             */
            RelayGroupGCPPubSubOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupGCPPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupGCPPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupGCPPubSubOptions} RelayGroupGCPPubSubOptions instance
             */
            RelayGroupGCPPubSubOptions.create = function create(properties) {
                return new RelayGroupGCPPubSubOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupGCPPubSubOptions message. Does not implicitly {@link protos.opts.RelayGroupGCPPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupGCPPubSubOptions} message RelayGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupGCPPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.GCPPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.GCPPubSubReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupGCPPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupGCPPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupGCPPubSubOptions} message RelayGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupGCPPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupGCPPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupGCPPubSubOptions} RelayGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupGCPPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupGCPPubSubOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.GCPPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.GCPPubSubReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupGCPPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupGCPPubSubOptions} RelayGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupGCPPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupGCPPubSubOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupGCPPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.GCPPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.GCPPubSubReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupGCPPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupGCPPubSubOptions} RelayGroupGCPPubSubOptions
             */
            RelayGroupGCPPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupGCPPubSubOptions)
                    return object;
                let message = new $root.protos.opts.RelayGroupGCPPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupGCPPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.GCPPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupGCPPubSubOptions.args: object expected");
                    message.args = $root.protos.args.GCPPubSubReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupGCPPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.RelayGroupGCPPubSubOptions} message RelayGroupGCPPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupGCPPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.GCPPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.GCPPubSubReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupGCPPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupGCPPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupGCPPubSubOptions;
        })();

        opts.RelayGroupKubeMQQueueOptions = (function() {

            /**
             * Properties of a RelayGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @interface IRelayGroupKubeMQQueueOptions
             * @property {protos.args.IKubeMQQueueConn|null} [_conn] RelayGroupKubeMQQueueOptions _conn
             * @property {protos.args.IKubeMQQueueReadArgs|null} [args] RelayGroupKubeMQQueueOptions args
             */

            /**
             * Constructs a new RelayGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupKubeMQQueueOptions.
             * @implements IRelayGroupKubeMQQueueOptions
             * @constructor
             * @param {protos.opts.IRelayGroupKubeMQQueueOptions=} [properties] Properties to set
             */
            function RelayGroupKubeMQQueueOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupKubeMQQueueOptions _conn.
             * @member {protos.args.IKubeMQQueueConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @instance
             */
            RelayGroupKubeMQQueueOptions.prototype._conn = null;

            /**
             * RelayGroupKubeMQQueueOptions args.
             * @member {protos.args.IKubeMQQueueReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @instance
             */
            RelayGroupKubeMQQueueOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupKubeMQQueueOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IRelayGroupKubeMQQueueOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupKubeMQQueueOptions} RelayGroupKubeMQQueueOptions instance
             */
            RelayGroupKubeMQQueueOptions.create = function create(properties) {
                return new RelayGroupKubeMQQueueOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupKubeMQQueueOptions message. Does not implicitly {@link protos.opts.RelayGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IRelayGroupKubeMQQueueOptions} message RelayGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupKubeMQQueueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KubeMQQueueConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KubeMQQueueReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupKubeMQQueueOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IRelayGroupKubeMQQueueOptions} message RelayGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupKubeMQQueueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupKubeMQQueueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupKubeMQQueueOptions} RelayGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupKubeMQQueueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupKubeMQQueueOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KubeMQQueueConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KubeMQQueueReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupKubeMQQueueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupKubeMQQueueOptions} RelayGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupKubeMQQueueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupKubeMQQueueOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupKubeMQQueueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.KubeMQQueueConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.KubeMQQueueReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupKubeMQQueueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupKubeMQQueueOptions} RelayGroupKubeMQQueueOptions
             */
            RelayGroupKubeMQQueueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupKubeMQQueueOptions)
                    return object;
                let message = new $root.protos.opts.RelayGroupKubeMQQueueOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupKubeMQQueueOptions._conn: object expected");
                    message._conn = $root.protos.args.KubeMQQueueConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupKubeMQQueueOptions.args: object expected");
                    message.args = $root.protos.args.KubeMQQueueReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupKubeMQQueueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.RelayGroupKubeMQQueueOptions} message RelayGroupKubeMQQueueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupKubeMQQueueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KubeMQQueueConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KubeMQQueueReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupKubeMQQueueOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupKubeMQQueueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupKubeMQQueueOptions;
        })();

        opts.ServerOptions = (function() {

            /**
             * Properties of a ServerOptions.
             * @memberof protos.opts
             * @interface IServerOptions
             * @property {string|null} [nodeId] ServerOptions nodeId
             * @property {string|null} [clusterId] ServerOptions clusterId
             * @property {string|null} [grpcListenAddress] ServerOptions grpcListenAddress
             * @property {string|null} [authToken] ServerOptions authToken
             * @property {string|null} [initialCluster] ServerOptions initialCluster
             * @property {string|null} [advertisePeerUrl] ServerOptions advertisePeerUrl
             * @property {string|null} [advertiseClientUrl] ServerOptions advertiseClientUrl
             * @property {string|null} [listenerPeerUrl] ServerOptions listenerPeerUrl
             * @property {string|null} [listenerClientUrl] ServerOptions listenerClientUrl
             * @property {string|null} [peerToken] ServerOptions peerToken
             * @property {string|null} [vcserviceGrpcAddress] ServerOptions vcserviceGrpcAddress
             * @property {number|null} [vcserviceGrpcTimeoutSeconds] ServerOptions vcserviceGrpcTimeoutSeconds
             * @property {boolean|null} [vcserviceGrpcInsecure] ServerOptions vcserviceGrpcInsecure
             */

            /**
             * Constructs a new ServerOptions.
             * @memberof protos.opts
             * @classdesc Represents a ServerOptions.
             * @implements IServerOptions
             * @constructor
             * @param {protos.opts.IServerOptions=} [properties] Properties to set
             */
            function ServerOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServerOptions nodeId.
             * @member {string} nodeId
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.nodeId = "";

            /**
             * ServerOptions clusterId.
             * @member {string} clusterId
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.clusterId = "";

            /**
             * ServerOptions grpcListenAddress.
             * @member {string} grpcListenAddress
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.grpcListenAddress = "";

            /**
             * ServerOptions authToken.
             * @member {string} authToken
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.authToken = "";

            /**
             * ServerOptions initialCluster.
             * @member {string} initialCluster
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.initialCluster = "";

            /**
             * ServerOptions advertisePeerUrl.
             * @member {string} advertisePeerUrl
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.advertisePeerUrl = "";

            /**
             * ServerOptions advertiseClientUrl.
             * @member {string} advertiseClientUrl
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.advertiseClientUrl = "";

            /**
             * ServerOptions listenerPeerUrl.
             * @member {string} listenerPeerUrl
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.listenerPeerUrl = "";

            /**
             * ServerOptions listenerClientUrl.
             * @member {string} listenerClientUrl
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.listenerClientUrl = "";

            /**
             * ServerOptions peerToken.
             * @member {string} peerToken
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.peerToken = "";

            /**
             * ServerOptions vcserviceGrpcAddress.
             * @member {string} vcserviceGrpcAddress
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.vcserviceGrpcAddress = "";

            /**
             * ServerOptions vcserviceGrpcTimeoutSeconds.
             * @member {number} vcserviceGrpcTimeoutSeconds
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.vcserviceGrpcTimeoutSeconds = 0;

            /**
             * ServerOptions vcserviceGrpcInsecure.
             * @member {boolean} vcserviceGrpcInsecure
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.vcserviceGrpcInsecure = false;

            /**
             * Creates a new ServerOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {protos.opts.IServerOptions=} [properties] Properties to set
             * @returns {protos.opts.ServerOptions} ServerOptions instance
             */
            ServerOptions.create = function create(properties) {
                return new ServerOptions(properties);
            };

            /**
             * Encodes the specified ServerOptions message. Does not implicitly {@link protos.opts.ServerOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {protos.opts.IServerOptions} message ServerOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServerOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nodeId);
                if (message.clusterId != null && Object.hasOwnProperty.call(message, "clusterId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.clusterId);
                if (message.grpcListenAddress != null && Object.hasOwnProperty.call(message, "grpcListenAddress"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.grpcListenAddress);
                if (message.authToken != null && Object.hasOwnProperty.call(message, "authToken"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.authToken);
                if (message.initialCluster != null && Object.hasOwnProperty.call(message, "initialCluster"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.initialCluster);
                if (message.advertisePeerUrl != null && Object.hasOwnProperty.call(message, "advertisePeerUrl"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.advertisePeerUrl);
                if (message.advertiseClientUrl != null && Object.hasOwnProperty.call(message, "advertiseClientUrl"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.advertiseClientUrl);
                if (message.listenerPeerUrl != null && Object.hasOwnProperty.call(message, "listenerPeerUrl"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.listenerPeerUrl);
                if (message.listenerClientUrl != null && Object.hasOwnProperty.call(message, "listenerClientUrl"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.listenerClientUrl);
                if (message.peerToken != null && Object.hasOwnProperty.call(message, "peerToken"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.peerToken);
                if (message.vcserviceGrpcAddress != null && Object.hasOwnProperty.call(message, "vcserviceGrpcAddress"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.vcserviceGrpcAddress);
                if (message.vcserviceGrpcTimeoutSeconds != null && Object.hasOwnProperty.call(message, "vcserviceGrpcTimeoutSeconds"))
                    writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.vcserviceGrpcTimeoutSeconds);
                if (message.vcserviceGrpcInsecure != null && Object.hasOwnProperty.call(message, "vcserviceGrpcInsecure"))
                    writer.uint32(/* id 13, wireType 0 =*/104).bool(message.vcserviceGrpcInsecure);
                return writer;
            };

            /**
             * Encodes the specified ServerOptions message, length delimited. Does not implicitly {@link protos.opts.ServerOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {protos.opts.IServerOptions} message ServerOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServerOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServerOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ServerOptions} ServerOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServerOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ServerOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nodeId = reader.string();
                        break;
                    case 2:
                        message.clusterId = reader.string();
                        break;
                    case 3:
                        message.grpcListenAddress = reader.string();
                        break;
                    case 4:
                        message.authToken = reader.string();
                        break;
                    case 5:
                        message.initialCluster = reader.string();
                        break;
                    case 6:
                        message.advertisePeerUrl = reader.string();
                        break;
                    case 7:
                        message.advertiseClientUrl = reader.string();
                        break;
                    case 8:
                        message.listenerPeerUrl = reader.string();
                        break;
                    case 9:
                        message.listenerClientUrl = reader.string();
                        break;
                    case 10:
                        message.peerToken = reader.string();
                        break;
                    case 11:
                        message.vcserviceGrpcAddress = reader.string();
                        break;
                    case 12:
                        message.vcserviceGrpcTimeoutSeconds = reader.uint32();
                        break;
                    case 13:
                        message.vcserviceGrpcInsecure = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServerOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ServerOptions} ServerOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServerOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServerOptions message.
             * @function verify
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServerOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    if (!$util.isString(message.nodeId))
                        return "nodeId: string expected";
                if (message.clusterId != null && message.hasOwnProperty("clusterId"))
                    if (!$util.isString(message.clusterId))
                        return "clusterId: string expected";
                if (message.grpcListenAddress != null && message.hasOwnProperty("grpcListenAddress"))
                    if (!$util.isString(message.grpcListenAddress))
                        return "grpcListenAddress: string expected";
                if (message.authToken != null && message.hasOwnProperty("authToken"))
                    if (!$util.isString(message.authToken))
                        return "authToken: string expected";
                if (message.initialCluster != null && message.hasOwnProperty("initialCluster"))
                    if (!$util.isString(message.initialCluster))
                        return "initialCluster: string expected";
                if (message.advertisePeerUrl != null && message.hasOwnProperty("advertisePeerUrl"))
                    if (!$util.isString(message.advertisePeerUrl))
                        return "advertisePeerUrl: string expected";
                if (message.advertiseClientUrl != null && message.hasOwnProperty("advertiseClientUrl"))
                    if (!$util.isString(message.advertiseClientUrl))
                        return "advertiseClientUrl: string expected";
                if (message.listenerPeerUrl != null && message.hasOwnProperty("listenerPeerUrl"))
                    if (!$util.isString(message.listenerPeerUrl))
                        return "listenerPeerUrl: string expected";
                if (message.listenerClientUrl != null && message.hasOwnProperty("listenerClientUrl"))
                    if (!$util.isString(message.listenerClientUrl))
                        return "listenerClientUrl: string expected";
                if (message.peerToken != null && message.hasOwnProperty("peerToken"))
                    if (!$util.isString(message.peerToken))
                        return "peerToken: string expected";
                if (message.vcserviceGrpcAddress != null && message.hasOwnProperty("vcserviceGrpcAddress"))
                    if (!$util.isString(message.vcserviceGrpcAddress))
                        return "vcserviceGrpcAddress: string expected";
                if (message.vcserviceGrpcTimeoutSeconds != null && message.hasOwnProperty("vcserviceGrpcTimeoutSeconds"))
                    if (!$util.isInteger(message.vcserviceGrpcTimeoutSeconds))
                        return "vcserviceGrpcTimeoutSeconds: integer expected";
                if (message.vcserviceGrpcInsecure != null && message.hasOwnProperty("vcserviceGrpcInsecure"))
                    if (typeof message.vcserviceGrpcInsecure !== "boolean")
                        return "vcserviceGrpcInsecure: boolean expected";
                return null;
            };

            /**
             * Creates a ServerOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ServerOptions} ServerOptions
             */
            ServerOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ServerOptions)
                    return object;
                let message = new $root.protos.opts.ServerOptions();
                if (object.nodeId != null)
                    message.nodeId = String(object.nodeId);
                if (object.clusterId != null)
                    message.clusterId = String(object.clusterId);
                if (object.grpcListenAddress != null)
                    message.grpcListenAddress = String(object.grpcListenAddress);
                if (object.authToken != null)
                    message.authToken = String(object.authToken);
                if (object.initialCluster != null)
                    message.initialCluster = String(object.initialCluster);
                if (object.advertisePeerUrl != null)
                    message.advertisePeerUrl = String(object.advertisePeerUrl);
                if (object.advertiseClientUrl != null)
                    message.advertiseClientUrl = String(object.advertiseClientUrl);
                if (object.listenerPeerUrl != null)
                    message.listenerPeerUrl = String(object.listenerPeerUrl);
                if (object.listenerClientUrl != null)
                    message.listenerClientUrl = String(object.listenerClientUrl);
                if (object.peerToken != null)
                    message.peerToken = String(object.peerToken);
                if (object.vcserviceGrpcAddress != null)
                    message.vcserviceGrpcAddress = String(object.vcserviceGrpcAddress);
                if (object.vcserviceGrpcTimeoutSeconds != null)
                    message.vcserviceGrpcTimeoutSeconds = object.vcserviceGrpcTimeoutSeconds >>> 0;
                if (object.vcserviceGrpcInsecure != null)
                    message.vcserviceGrpcInsecure = Boolean(object.vcserviceGrpcInsecure);
                return message;
            };

            /**
             * Creates a plain object from a ServerOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {protos.opts.ServerOptions} message ServerOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServerOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.nodeId = "";
                    object.clusterId = "";
                    object.grpcListenAddress = "";
                    object.authToken = "";
                    object.initialCluster = "";
                    object.advertisePeerUrl = "";
                    object.advertiseClientUrl = "";
                    object.listenerPeerUrl = "";
                    object.listenerClientUrl = "";
                    object.peerToken = "";
                    object.vcserviceGrpcAddress = "";
                    object.vcserviceGrpcTimeoutSeconds = 0;
                    object.vcserviceGrpcInsecure = false;
                }
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    object.nodeId = message.nodeId;
                if (message.clusterId != null && message.hasOwnProperty("clusterId"))
                    object.clusterId = message.clusterId;
                if (message.grpcListenAddress != null && message.hasOwnProperty("grpcListenAddress"))
                    object.grpcListenAddress = message.grpcListenAddress;
                if (message.authToken != null && message.hasOwnProperty("authToken"))
                    object.authToken = message.authToken;
                if (message.initialCluster != null && message.hasOwnProperty("initialCluster"))
                    object.initialCluster = message.initialCluster;
                if (message.advertisePeerUrl != null && message.hasOwnProperty("advertisePeerUrl"))
                    object.advertisePeerUrl = message.advertisePeerUrl;
                if (message.advertiseClientUrl != null && message.hasOwnProperty("advertiseClientUrl"))
                    object.advertiseClientUrl = message.advertiseClientUrl;
                if (message.listenerPeerUrl != null && message.hasOwnProperty("listenerPeerUrl"))
                    object.listenerPeerUrl = message.listenerPeerUrl;
                if (message.listenerClientUrl != null && message.hasOwnProperty("listenerClientUrl"))
                    object.listenerClientUrl = message.listenerClientUrl;
                if (message.peerToken != null && message.hasOwnProperty("peerToken"))
                    object.peerToken = message.peerToken;
                if (message.vcserviceGrpcAddress != null && message.hasOwnProperty("vcserviceGrpcAddress"))
                    object.vcserviceGrpcAddress = message.vcserviceGrpcAddress;
                if (message.vcserviceGrpcTimeoutSeconds != null && message.hasOwnProperty("vcserviceGrpcTimeoutSeconds"))
                    object.vcserviceGrpcTimeoutSeconds = message.vcserviceGrpcTimeoutSeconds;
                if (message.vcserviceGrpcInsecure != null && message.hasOwnProperty("vcserviceGrpcInsecure"))
                    object.vcserviceGrpcInsecure = message.vcserviceGrpcInsecure;
                return object;
            };

            /**
             * Converts this ServerOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ServerOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServerOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServerOptions;
        })();

        opts.DynamicOptions = (function() {

            /**
             * Properties of a DynamicOptions.
             * @memberof protos.opts
             * @interface IDynamicOptions
             * @property {string|null} [apiToken] DynamicOptions apiToken
             * @property {string|null} [_grpcAddress] DynamicOptions _grpcAddress
             * @property {number|null} [_grpcTimeoutSeconds] DynamicOptions _grpcTimeoutSeconds
             * @property {boolean|null} [_grpcInsecure] DynamicOptions _grpcInsecure
             * @property {protos.opts.IDynamicGroupKafkaOptions|null} [kafka] DynamicOptions kafka
             * @property {protos.opts.IDynamicGroupActiveMQOptions|null} [activemq] DynamicOptions activemq
             * @property {protos.opts.IDynamicGroupAWSSQSOptions|null} [awssqs] DynamicOptions awssqs
             * @property {protos.opts.IDynamicGroupAWSSNSOptions|null} [awssns] DynamicOptions awssns
             * @property {protos.opts.IDynamicGroupNatsOptions|null} [nats] DynamicOptions nats
             * @property {protos.opts.IDynamicGroupNatsStreamingOptions|null} [natsStreaming] DynamicOptions natsStreaming
             * @property {protos.opts.IDynamicGroupNSQOptions|null} [nsq] DynamicOptions nsq
             * @property {protos.opts.IDynamicGroupRabbitOptions|null} [rabbit] DynamicOptions rabbit
             * @property {protos.opts.IDynamicGroupMQTTOptions|null} [mqtt] DynamicOptions mqtt
             * @property {protos.opts.IDynamicGroupAzureServiceBusOptions|null} [azureServiceBus] DynamicOptions azureServiceBus
             * @property {protos.opts.IDynamicGroupAzureEventHubOptions|null} [azureEventHub] DynamicOptions azureEventHub
             * @property {protos.opts.IDynamicGroupGCPPubSubOptions|null} [gcpPubsub] DynamicOptions gcpPubsub
             * @property {protos.opts.IDynamicGroupKubeMQQueueOptions|null} [kubemqQueue] DynamicOptions kubemqQueue
             * @property {protos.opts.IDynamicGroupRedisPubSubOptions|null} [redisPubsub] DynamicOptions redisPubsub
             * @property {protos.opts.IDynamicGroupRedisStreamsOptions|null} [redisStreams] DynamicOptions redisStreams
             */

            /**
             * Constructs a new DynamicOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicOptions.
             * @implements IDynamicOptions
             * @constructor
             * @param {protos.opts.IDynamicOptions=} [properties] Properties to set
             */
            function DynamicOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicOptions apiToken.
             * @member {string} apiToken
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.apiToken = "";

            /**
             * DynamicOptions _grpcAddress.
             * @member {string} _grpcAddress
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype._grpcAddress = "";

            /**
             * DynamicOptions _grpcTimeoutSeconds.
             * @member {number} _grpcTimeoutSeconds
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype._grpcTimeoutSeconds = 0;

            /**
             * DynamicOptions _grpcInsecure.
             * @member {boolean} _grpcInsecure
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype._grpcInsecure = false;

            /**
             * DynamicOptions kafka.
             * @member {protos.opts.IDynamicGroupKafkaOptions|null|undefined} kafka
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.kafka = null;

            /**
             * DynamicOptions activemq.
             * @member {protos.opts.IDynamicGroupActiveMQOptions|null|undefined} activemq
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.activemq = null;

            /**
             * DynamicOptions awssqs.
             * @member {protos.opts.IDynamicGroupAWSSQSOptions|null|undefined} awssqs
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.awssqs = null;

            /**
             * DynamicOptions awssns.
             * @member {protos.opts.IDynamicGroupAWSSNSOptions|null|undefined} awssns
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.awssns = null;

            /**
             * DynamicOptions nats.
             * @member {protos.opts.IDynamicGroupNatsOptions|null|undefined} nats
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.nats = null;

            /**
             * DynamicOptions natsStreaming.
             * @member {protos.opts.IDynamicGroupNatsStreamingOptions|null|undefined} natsStreaming
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.natsStreaming = null;

            /**
             * DynamicOptions nsq.
             * @member {protos.opts.IDynamicGroupNSQOptions|null|undefined} nsq
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.nsq = null;

            /**
             * DynamicOptions rabbit.
             * @member {protos.opts.IDynamicGroupRabbitOptions|null|undefined} rabbit
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.rabbit = null;

            /**
             * DynamicOptions mqtt.
             * @member {protos.opts.IDynamicGroupMQTTOptions|null|undefined} mqtt
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.mqtt = null;

            /**
             * DynamicOptions azureServiceBus.
             * @member {protos.opts.IDynamicGroupAzureServiceBusOptions|null|undefined} azureServiceBus
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.azureServiceBus = null;

            /**
             * DynamicOptions azureEventHub.
             * @member {protos.opts.IDynamicGroupAzureEventHubOptions|null|undefined} azureEventHub
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.azureEventHub = null;

            /**
             * DynamicOptions gcpPubsub.
             * @member {protos.opts.IDynamicGroupGCPPubSubOptions|null|undefined} gcpPubsub
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.gcpPubsub = null;

            /**
             * DynamicOptions kubemqQueue.
             * @member {protos.opts.IDynamicGroupKubeMQQueueOptions|null|undefined} kubemqQueue
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.kubemqQueue = null;

            /**
             * DynamicOptions redisPubsub.
             * @member {protos.opts.IDynamicGroupRedisPubSubOptions|null|undefined} redisPubsub
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.redisPubsub = null;

            /**
             * DynamicOptions redisStreams.
             * @member {protos.opts.IDynamicGroupRedisStreamsOptions|null|undefined} redisStreams
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.redisStreams = null;

            /**
             * Creates a new DynamicOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {protos.opts.IDynamicOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicOptions} DynamicOptions instance
             */
            DynamicOptions.create = function create(properties) {
                return new DynamicOptions(properties);
            };

            /**
             * Encodes the specified DynamicOptions message. Does not implicitly {@link protos.opts.DynamicOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {protos.opts.IDynamicOptions} message DynamicOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.apiToken != null && Object.hasOwnProperty.call(message, "apiToken"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.apiToken);
                if (message._grpcAddress != null && Object.hasOwnProperty.call(message, "_grpcAddress"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message._grpcAddress);
                if (message._grpcTimeoutSeconds != null && Object.hasOwnProperty.call(message, "_grpcTimeoutSeconds"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message._grpcTimeoutSeconds);
                if (message._grpcInsecure != null && Object.hasOwnProperty.call(message, "_grpcInsecure"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message._grpcInsecure);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.opts.DynamicGroupKafkaOptions.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.activemq != null && Object.hasOwnProperty.call(message, "activemq"))
                    $root.protos.opts.DynamicGroupActiveMQOptions.encode(message.activemq, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.awssqs != null && Object.hasOwnProperty.call(message, "awssqs"))
                    $root.protos.opts.DynamicGroupAWSSQSOptions.encode(message.awssqs, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.awssns != null && Object.hasOwnProperty.call(message, "awssns"))
                    $root.protos.opts.DynamicGroupAWSSNSOptions.encode(message.awssns, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.opts.DynamicGroupNatsOptions.encode(message.nats, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.opts.DynamicGroupNatsStreamingOptions.encode(message.natsStreaming, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.opts.DynamicGroupNSQOptions.encode(message.nsq, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.opts.DynamicGroupRabbitOptions.encode(message.rabbit, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.opts.DynamicGroupMQTTOptions.encode(message.mqtt, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.opts.DynamicGroupAzureServiceBusOptions.encode(message.azureServiceBus, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.azureEventHub != null && Object.hasOwnProperty.call(message, "azureEventHub"))
                    $root.protos.opts.DynamicGroupAzureEventHubOptions.encode(message.azureEventHub, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.opts.DynamicGroupGCPPubSubOptions.encode(message.gcpPubsub, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.opts.DynamicGroupKubeMQQueueOptions.encode(message.kubemqQueue, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.opts.DynamicGroupRedisPubSubOptions.encode(message.redisPubsub, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.opts.DynamicGroupRedisStreamsOptions.encode(message.redisStreams, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {protos.opts.IDynamicOptions} message DynamicOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicOptions} DynamicOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.apiToken = reader.string();
                        break;
                    case 2:
                        message._grpcAddress = reader.string();
                        break;
                    case 3:
                        message._grpcTimeoutSeconds = reader.uint32();
                        break;
                    case 4:
                        message._grpcInsecure = reader.bool();
                        break;
                    case 100:
                        message.kafka = $root.protos.opts.DynamicGroupKafkaOptions.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.activemq = $root.protos.opts.DynamicGroupActiveMQOptions.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.awssqs = $root.protos.opts.DynamicGroupAWSSQSOptions.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.awssns = $root.protos.opts.DynamicGroupAWSSNSOptions.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.nats = $root.protos.opts.DynamicGroupNatsOptions.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.natsStreaming = $root.protos.opts.DynamicGroupNatsStreamingOptions.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.nsq = $root.protos.opts.DynamicGroupNSQOptions.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.rabbit = $root.protos.opts.DynamicGroupRabbitOptions.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.mqtt = $root.protos.opts.DynamicGroupMQTTOptions.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.azureServiceBus = $root.protos.opts.DynamicGroupAzureServiceBusOptions.decode(reader, reader.uint32());
                        break;
                    case 110:
                        message.azureEventHub = $root.protos.opts.DynamicGroupAzureEventHubOptions.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.gcpPubsub = $root.protos.opts.DynamicGroupGCPPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.kubemqQueue = $root.protos.opts.DynamicGroupKubeMQQueueOptions.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.redisPubsub = $root.protos.opts.DynamicGroupRedisPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.redisStreams = $root.protos.opts.DynamicGroupRedisStreamsOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicOptions} DynamicOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicOptions message.
             * @function verify
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.apiToken != null && message.hasOwnProperty("apiToken"))
                    if (!$util.isString(message.apiToken))
                        return "apiToken: string expected";
                if (message._grpcAddress != null && message.hasOwnProperty("_grpcAddress"))
                    if (!$util.isString(message._grpcAddress))
                        return "_grpcAddress: string expected";
                if (message._grpcTimeoutSeconds != null && message.hasOwnProperty("_grpcTimeoutSeconds"))
                    if (!$util.isInteger(message._grpcTimeoutSeconds))
                        return "_grpcTimeoutSeconds: integer expected";
                if (message._grpcInsecure != null && message.hasOwnProperty("_grpcInsecure"))
                    if (typeof message._grpcInsecure !== "boolean")
                        return "_grpcInsecure: boolean expected";
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    let error = $root.protos.opts.DynamicGroupKafkaOptions.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.activemq != null && message.hasOwnProperty("activemq")) {
                    let error = $root.protos.opts.DynamicGroupActiveMQOptions.verify(message.activemq);
                    if (error)
                        return "activemq." + error;
                }
                if (message.awssqs != null && message.hasOwnProperty("awssqs")) {
                    let error = $root.protos.opts.DynamicGroupAWSSQSOptions.verify(message.awssqs);
                    if (error)
                        return "awssqs." + error;
                }
                if (message.awssns != null && message.hasOwnProperty("awssns")) {
                    let error = $root.protos.opts.DynamicGroupAWSSNSOptions.verify(message.awssns);
                    if (error)
                        return "awssns." + error;
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    let error = $root.protos.opts.DynamicGroupNatsOptions.verify(message.nats);
                    if (error)
                        return "nats." + error;
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    let error = $root.protos.opts.DynamicGroupNatsStreamingOptions.verify(message.natsStreaming);
                    if (error)
                        return "natsStreaming." + error;
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    let error = $root.protos.opts.DynamicGroupNSQOptions.verify(message.nsq);
                    if (error)
                        return "nsq." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    let error = $root.protos.opts.DynamicGroupRabbitOptions.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    let error = $root.protos.opts.DynamicGroupMQTTOptions.verify(message.mqtt);
                    if (error)
                        return "mqtt." + error;
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    let error = $root.protos.opts.DynamicGroupAzureServiceBusOptions.verify(message.azureServiceBus);
                    if (error)
                        return "azureServiceBus." + error;
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    let error = $root.protos.opts.DynamicGroupAzureEventHubOptions.verify(message.azureEventHub);
                    if (error)
                        return "azureEventHub." + error;
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    let error = $root.protos.opts.DynamicGroupGCPPubSubOptions.verify(message.gcpPubsub);
                    if (error)
                        return "gcpPubsub." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    let error = $root.protos.opts.DynamicGroupKubeMQQueueOptions.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    let error = $root.protos.opts.DynamicGroupRedisPubSubOptions.verify(message.redisPubsub);
                    if (error)
                        return "redisPubsub." + error;
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    let error = $root.protos.opts.DynamicGroupRedisStreamsOptions.verify(message.redisStreams);
                    if (error)
                        return "redisStreams." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicOptions} DynamicOptions
             */
            DynamicOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicOptions)
                    return object;
                let message = new $root.protos.opts.DynamicOptions();
                if (object.apiToken != null)
                    message.apiToken = String(object.apiToken);
                if (object._grpcAddress != null)
                    message._grpcAddress = String(object._grpcAddress);
                if (object._grpcTimeoutSeconds != null)
                    message._grpcTimeoutSeconds = object._grpcTimeoutSeconds >>> 0;
                if (object._grpcInsecure != null)
                    message._grpcInsecure = Boolean(object._grpcInsecure);
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.kafka: object expected");
                    message.kafka = $root.protos.opts.DynamicGroupKafkaOptions.fromObject(object.kafka);
                }
                if (object.activemq != null) {
                    if (typeof object.activemq !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.activemq: object expected");
                    message.activemq = $root.protos.opts.DynamicGroupActiveMQOptions.fromObject(object.activemq);
                }
                if (object.awssqs != null) {
                    if (typeof object.awssqs !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.awssqs: object expected");
                    message.awssqs = $root.protos.opts.DynamicGroupAWSSQSOptions.fromObject(object.awssqs);
                }
                if (object.awssns != null) {
                    if (typeof object.awssns !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.awssns: object expected");
                    message.awssns = $root.protos.opts.DynamicGroupAWSSNSOptions.fromObject(object.awssns);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.nats: object expected");
                    message.nats = $root.protos.opts.DynamicGroupNatsOptions.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.opts.DynamicGroupNatsStreamingOptions.fromObject(object.natsStreaming);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.nsq: object expected");
                    message.nsq = $root.protos.opts.DynamicGroupNSQOptions.fromObject(object.nsq);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.rabbit: object expected");
                    message.rabbit = $root.protos.opts.DynamicGroupRabbitOptions.fromObject(object.rabbit);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.mqtt: object expected");
                    message.mqtt = $root.protos.opts.DynamicGroupMQTTOptions.fromObject(object.mqtt);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.opts.DynamicGroupAzureServiceBusOptions.fromObject(object.azureServiceBus);
                }
                if (object.azureEventHub != null) {
                    if (typeof object.azureEventHub !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.azureEventHub: object expected");
                    message.azureEventHub = $root.protos.opts.DynamicGroupAzureEventHubOptions.fromObject(object.azureEventHub);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.opts.DynamicGroupGCPPubSubOptions.fromObject(object.gcpPubsub);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.opts.DynamicGroupKubeMQQueueOptions.fromObject(object.kubemqQueue);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.opts.DynamicGroupRedisPubSubOptions.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.opts.DynamicGroupRedisStreamsOptions.fromObject(object.redisStreams);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {protos.opts.DynamicOptions} message DynamicOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.apiToken = "";
                    object._grpcAddress = "";
                    object._grpcTimeoutSeconds = 0;
                    object._grpcInsecure = false;
                    object.kafka = null;
                    object.activemq = null;
                    object.awssqs = null;
                    object.awssns = null;
                    object.nats = null;
                    object.natsStreaming = null;
                    object.nsq = null;
                    object.rabbit = null;
                    object.mqtt = null;
                    object.azureServiceBus = null;
                    object.azureEventHub = null;
                    object.gcpPubsub = null;
                    object.kubemqQueue = null;
                    object.redisPubsub = null;
                    object.redisStreams = null;
                }
                if (message.apiToken != null && message.hasOwnProperty("apiToken"))
                    object.apiToken = message.apiToken;
                if (message._grpcAddress != null && message.hasOwnProperty("_grpcAddress"))
                    object._grpcAddress = message._grpcAddress;
                if (message._grpcTimeoutSeconds != null && message.hasOwnProperty("_grpcTimeoutSeconds"))
                    object._grpcTimeoutSeconds = message._grpcTimeoutSeconds;
                if (message._grpcInsecure != null && message.hasOwnProperty("_grpcInsecure"))
                    object._grpcInsecure = message._grpcInsecure;
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.opts.DynamicGroupKafkaOptions.toObject(message.kafka, options);
                if (message.activemq != null && message.hasOwnProperty("activemq"))
                    object.activemq = $root.protos.opts.DynamicGroupActiveMQOptions.toObject(message.activemq, options);
                if (message.awssqs != null && message.hasOwnProperty("awssqs"))
                    object.awssqs = $root.protos.opts.DynamicGroupAWSSQSOptions.toObject(message.awssqs, options);
                if (message.awssns != null && message.hasOwnProperty("awssns"))
                    object.awssns = $root.protos.opts.DynamicGroupAWSSNSOptions.toObject(message.awssns, options);
                if (message.nats != null && message.hasOwnProperty("nats"))
                    object.nats = $root.protos.opts.DynamicGroupNatsOptions.toObject(message.nats, options);
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming"))
                    object.natsStreaming = $root.protos.opts.DynamicGroupNatsStreamingOptions.toObject(message.natsStreaming, options);
                if (message.nsq != null && message.hasOwnProperty("nsq"))
                    object.nsq = $root.protos.opts.DynamicGroupNSQOptions.toObject(message.nsq, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.opts.DynamicGroupRabbitOptions.toObject(message.rabbit, options);
                if (message.mqtt != null && message.hasOwnProperty("mqtt"))
                    object.mqtt = $root.protos.opts.DynamicGroupMQTTOptions.toObject(message.mqtt, options);
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus"))
                    object.azureServiceBus = $root.protos.opts.DynamicGroupAzureServiceBusOptions.toObject(message.azureServiceBus, options);
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub"))
                    object.azureEventHub = $root.protos.opts.DynamicGroupAzureEventHubOptions.toObject(message.azureEventHub, options);
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub"))
                    object.gcpPubsub = $root.protos.opts.DynamicGroupGCPPubSubOptions.toObject(message.gcpPubsub, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.opts.DynamicGroupKubeMQQueueOptions.toObject(message.kubemqQueue, options);
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub"))
                    object.redisPubsub = $root.protos.opts.DynamicGroupRedisPubSubOptions.toObject(message.redisPubsub, options);
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams"))
                    object.redisStreams = $root.protos.opts.DynamicGroupRedisStreamsOptions.toObject(message.redisStreams, options);
                return object;
            };

            /**
             * Converts this DynamicOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicOptions;
        })();

        opts.DynamicGroupKafkaOptions = (function() {

            /**
             * Properties of a DynamicGroupKafkaOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupKafkaOptions
             * @property {protos.args.IKafkaConn|null} [_conn] DynamicGroupKafkaOptions _conn
             * @property {protos.args.IKafkaWriteArgs|null} [args] DynamicGroupKafkaOptions args
             */

            /**
             * Constructs a new DynamicGroupKafkaOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupKafkaOptions.
             * @implements IDynamicGroupKafkaOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupKafkaOptions=} [properties] Properties to set
             */
            function DynamicGroupKafkaOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupKafkaOptions _conn.
             * @member {protos.args.IKafkaConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @instance
             */
            DynamicGroupKafkaOptions.prototype._conn = null;

            /**
             * DynamicGroupKafkaOptions args.
             * @member {protos.args.IKafkaWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @instance
             */
            DynamicGroupKafkaOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupKafkaOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {protos.opts.IDynamicGroupKafkaOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupKafkaOptions} DynamicGroupKafkaOptions instance
             */
            DynamicGroupKafkaOptions.create = function create(properties) {
                return new DynamicGroupKafkaOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupKafkaOptions message. Does not implicitly {@link protos.opts.DynamicGroupKafkaOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {protos.opts.IDynamicGroupKafkaOptions} message DynamicGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupKafkaOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KafkaConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KafkaWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupKafkaOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupKafkaOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {protos.opts.IDynamicGroupKafkaOptions} message DynamicGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupKafkaOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupKafkaOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupKafkaOptions} DynamicGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupKafkaOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupKafkaOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KafkaConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KafkaWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupKafkaOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupKafkaOptions} DynamicGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupKafkaOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupKafkaOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupKafkaOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.KafkaConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.KafkaWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupKafkaOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupKafkaOptions} DynamicGroupKafkaOptions
             */
            DynamicGroupKafkaOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupKafkaOptions)
                    return object;
                let message = new $root.protos.opts.DynamicGroupKafkaOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupKafkaOptions._conn: object expected");
                    message._conn = $root.protos.args.KafkaConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupKafkaOptions.args: object expected");
                    message.args = $root.protos.args.KafkaWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupKafkaOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {protos.opts.DynamicGroupKafkaOptions} message DynamicGroupKafkaOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupKafkaOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KafkaConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KafkaWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupKafkaOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupKafkaOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupKafkaOptions;
        })();

        opts.DynamicGroupActiveMQOptions = (function() {

            /**
             * Properties of a DynamicGroupActiveMQOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupActiveMQOptions
             * @property {protos.args.IActiveMQConn|null} [_conn] DynamicGroupActiveMQOptions _conn
             * @property {protos.args.IActiveMQWriteArgs|null} [args] DynamicGroupActiveMQOptions args
             */

            /**
             * Constructs a new DynamicGroupActiveMQOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupActiveMQOptions.
             * @implements IDynamicGroupActiveMQOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupActiveMQOptions=} [properties] Properties to set
             */
            function DynamicGroupActiveMQOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupActiveMQOptions _conn.
             * @member {protos.args.IActiveMQConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @instance
             */
            DynamicGroupActiveMQOptions.prototype._conn = null;

            /**
             * DynamicGroupActiveMQOptions args.
             * @member {protos.args.IActiveMQWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @instance
             */
            DynamicGroupActiveMQOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupActiveMQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {protos.opts.IDynamicGroupActiveMQOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupActiveMQOptions} DynamicGroupActiveMQOptions instance
             */
            DynamicGroupActiveMQOptions.create = function create(properties) {
                return new DynamicGroupActiveMQOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupActiveMQOptions message. Does not implicitly {@link protos.opts.DynamicGroupActiveMQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {protos.opts.IDynamicGroupActiveMQOptions} message DynamicGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupActiveMQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.ActiveMQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.ActiveMQWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupActiveMQOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupActiveMQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {protos.opts.IDynamicGroupActiveMQOptions} message DynamicGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupActiveMQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupActiveMQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupActiveMQOptions} DynamicGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupActiveMQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupActiveMQOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.ActiveMQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.ActiveMQWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupActiveMQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupActiveMQOptions} DynamicGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupActiveMQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupActiveMQOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupActiveMQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.ActiveMQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.ActiveMQWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupActiveMQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupActiveMQOptions} DynamicGroupActiveMQOptions
             */
            DynamicGroupActiveMQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupActiveMQOptions)
                    return object;
                let message = new $root.protos.opts.DynamicGroupActiveMQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupActiveMQOptions._conn: object expected");
                    message._conn = $root.protos.args.ActiveMQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupActiveMQOptions.args: object expected");
                    message.args = $root.protos.args.ActiveMQWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupActiveMQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {protos.opts.DynamicGroupActiveMQOptions} message DynamicGroupActiveMQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupActiveMQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.ActiveMQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.ActiveMQWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupActiveMQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupActiveMQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupActiveMQOptions;
        })();

        opts.DynamicGroupAWSSQSOptions = (function() {

            /**
             * Properties of a DynamicGroupAWSSQSOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupAWSSQSOptions
             * @property {protos.args.IAWSSQSConn|null} [_conn] DynamicGroupAWSSQSOptions _conn
             * @property {protos.args.IAWSSQSWriteArgs|null} [args] DynamicGroupAWSSQSOptions args
             */

            /**
             * Constructs a new DynamicGroupAWSSQSOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupAWSSQSOptions.
             * @implements IDynamicGroupAWSSQSOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupAWSSQSOptions=} [properties] Properties to set
             */
            function DynamicGroupAWSSQSOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupAWSSQSOptions _conn.
             * @member {protos.args.IAWSSQSConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @instance
             */
            DynamicGroupAWSSQSOptions.prototype._conn = null;

            /**
             * DynamicGroupAWSSQSOptions args.
             * @member {protos.args.IAWSSQSWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @instance
             */
            DynamicGroupAWSSQSOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupAWSSQSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IDynamicGroupAWSSQSOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupAWSSQSOptions} DynamicGroupAWSSQSOptions instance
             */
            DynamicGroupAWSSQSOptions.create = function create(properties) {
                return new DynamicGroupAWSSQSOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupAWSSQSOptions message. Does not implicitly {@link protos.opts.DynamicGroupAWSSQSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IDynamicGroupAWSSQSOptions} message DynamicGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAWSSQSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSQSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSQSWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupAWSSQSOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupAWSSQSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IDynamicGroupAWSSQSOptions} message DynamicGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAWSSQSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupAWSSQSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupAWSSQSOptions} DynamicGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAWSSQSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupAWSSQSOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSQSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSQSWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupAWSSQSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupAWSSQSOptions} DynamicGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAWSSQSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupAWSSQSOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupAWSSQSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.AWSSQSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.AWSSQSWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupAWSSQSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupAWSSQSOptions} DynamicGroupAWSSQSOptions
             */
            DynamicGroupAWSSQSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupAWSSQSOptions)
                    return object;
                let message = new $root.protos.opts.DynamicGroupAWSSQSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAWSSQSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSQSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAWSSQSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSQSWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupAWSSQSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {protos.opts.DynamicGroupAWSSQSOptions} message DynamicGroupAWSSQSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupAWSSQSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSQSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSQSWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupAWSSQSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupAWSSQSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupAWSSQSOptions;
        })();

        opts.DynamicGroupAWSSNSOptions = (function() {

            /**
             * Properties of a DynamicGroupAWSSNSOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupAWSSNSOptions
             * @property {protos.args.IAWSSNSConn|null} [_conn] DynamicGroupAWSSNSOptions _conn
             * @property {protos.args.IAWSSNSWriteArgs|null} [args] DynamicGroupAWSSNSOptions args
             */

            /**
             * Constructs a new DynamicGroupAWSSNSOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupAWSSNSOptions.
             * @implements IDynamicGroupAWSSNSOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupAWSSNSOptions=} [properties] Properties to set
             */
            function DynamicGroupAWSSNSOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupAWSSNSOptions _conn.
             * @member {protos.args.IAWSSNSConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @instance
             */
            DynamicGroupAWSSNSOptions.prototype._conn = null;

            /**
             * DynamicGroupAWSSNSOptions args.
             * @member {protos.args.IAWSSNSWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @instance
             */
            DynamicGroupAWSSNSOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupAWSSNSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {protos.opts.IDynamicGroupAWSSNSOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupAWSSNSOptions} DynamicGroupAWSSNSOptions instance
             */
            DynamicGroupAWSSNSOptions.create = function create(properties) {
                return new DynamicGroupAWSSNSOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupAWSSNSOptions message. Does not implicitly {@link protos.opts.DynamicGroupAWSSNSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {protos.opts.IDynamicGroupAWSSNSOptions} message DynamicGroupAWSSNSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAWSSNSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSNSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSNSWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupAWSSNSOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupAWSSNSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {protos.opts.IDynamicGroupAWSSNSOptions} message DynamicGroupAWSSNSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAWSSNSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupAWSSNSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupAWSSNSOptions} DynamicGroupAWSSNSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAWSSNSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupAWSSNSOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSNSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSNSWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupAWSSNSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupAWSSNSOptions} DynamicGroupAWSSNSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAWSSNSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupAWSSNSOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupAWSSNSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.AWSSNSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.AWSSNSWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupAWSSNSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupAWSSNSOptions} DynamicGroupAWSSNSOptions
             */
            DynamicGroupAWSSNSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupAWSSNSOptions)
                    return object;
                let message = new $root.protos.opts.DynamicGroupAWSSNSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAWSSNSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSNSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAWSSNSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSNSWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupAWSSNSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {protos.opts.DynamicGroupAWSSNSOptions} message DynamicGroupAWSSNSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupAWSSNSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSNSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSNSWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupAWSSNSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupAWSSNSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupAWSSNSOptions;
        })();

        opts.DynamicGroupNatsOptions = (function() {

            /**
             * Properties of a DynamicGroupNatsOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupNatsOptions
             * @property {protos.args.INatsConn|null} [_conn] DynamicGroupNatsOptions _conn
             * @property {protos.args.INatsWriteArgs|null} [args] DynamicGroupNatsOptions args
             */

            /**
             * Constructs a new DynamicGroupNatsOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupNatsOptions.
             * @implements IDynamicGroupNatsOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupNatsOptions=} [properties] Properties to set
             */
            function DynamicGroupNatsOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupNatsOptions _conn.
             * @member {protos.args.INatsConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @instance
             */
            DynamicGroupNatsOptions.prototype._conn = null;

            /**
             * DynamicGroupNatsOptions args.
             * @member {protos.args.INatsWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @instance
             */
            DynamicGroupNatsOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupNatsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {protos.opts.IDynamicGroupNatsOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupNatsOptions} DynamicGroupNatsOptions instance
             */
            DynamicGroupNatsOptions.create = function create(properties) {
                return new DynamicGroupNatsOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupNatsOptions message. Does not implicitly {@link protos.opts.DynamicGroupNatsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {protos.opts.IDynamicGroupNatsOptions} message DynamicGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupNatsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupNatsOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupNatsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {protos.opts.IDynamicGroupNatsOptions} message DynamicGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupNatsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupNatsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupNatsOptions} DynamicGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupNatsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupNatsOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupNatsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupNatsOptions} DynamicGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupNatsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupNatsOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupNatsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.NatsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.NatsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupNatsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupNatsOptions} DynamicGroupNatsOptions
             */
            DynamicGroupNatsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupNatsOptions)
                    return object;
                let message = new $root.protos.opts.DynamicGroupNatsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupNatsOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupNatsOptions.args: object expected");
                    message.args = $root.protos.args.NatsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupNatsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {protos.opts.DynamicGroupNatsOptions} message DynamicGroupNatsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupNatsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupNatsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupNatsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupNatsOptions;
        })();

        opts.DynamicGroupNatsStreamingOptions = (function() {

            /**
             * Properties of a DynamicGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupNatsStreamingOptions
             * @property {protos.args.INatsStreamingConn|null} [_conn] DynamicGroupNatsStreamingOptions _conn
             * @property {protos.args.INatsStreamingWriteArgs|null} [args] DynamicGroupNatsStreamingOptions args
             */

            /**
             * Constructs a new DynamicGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupNatsStreamingOptions.
             * @implements IDynamicGroupNatsStreamingOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupNatsStreamingOptions=} [properties] Properties to set
             */
            function DynamicGroupNatsStreamingOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupNatsStreamingOptions _conn.
             * @member {protos.args.INatsStreamingConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @instance
             */
            DynamicGroupNatsStreamingOptions.prototype._conn = null;

            /**
             * DynamicGroupNatsStreamingOptions args.
             * @member {protos.args.INatsStreamingWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @instance
             */
            DynamicGroupNatsStreamingOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupNatsStreamingOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IDynamicGroupNatsStreamingOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupNatsStreamingOptions} DynamicGroupNatsStreamingOptions instance
             */
            DynamicGroupNatsStreamingOptions.create = function create(properties) {
                return new DynamicGroupNatsStreamingOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupNatsStreamingOptions message. Does not implicitly {@link protos.opts.DynamicGroupNatsStreamingOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IDynamicGroupNatsStreamingOptions} message DynamicGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupNatsStreamingOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsStreamingConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsStreamingWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupNatsStreamingOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupNatsStreamingOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IDynamicGroupNatsStreamingOptions} message DynamicGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupNatsStreamingOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupNatsStreamingOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupNatsStreamingOptions} DynamicGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupNatsStreamingOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupNatsStreamingOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsStreamingConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsStreamingWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupNatsStreamingOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupNatsStreamingOptions} DynamicGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupNatsStreamingOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupNatsStreamingOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupNatsStreamingOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.NatsStreamingConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.NatsStreamingWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupNatsStreamingOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupNatsStreamingOptions} DynamicGroupNatsStreamingOptions
             */
            DynamicGroupNatsStreamingOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupNatsStreamingOptions)
                    return object;
                let message = new $root.protos.opts.DynamicGroupNatsStreamingOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupNatsStreamingOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsStreamingConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupNatsStreamingOptions.args: object expected");
                    message.args = $root.protos.args.NatsStreamingWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupNatsStreamingOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.DynamicGroupNatsStreamingOptions} message DynamicGroupNatsStreamingOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupNatsStreamingOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsStreamingConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsStreamingWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupNatsStreamingOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupNatsStreamingOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupNatsStreamingOptions;
        })();

        opts.DynamicGroupNSQOptions = (function() {

            /**
             * Properties of a DynamicGroupNSQOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupNSQOptions
             * @property {protos.args.INSQConn|null} [_conn] DynamicGroupNSQOptions _conn
             * @property {protos.args.INSQWriteArgs|null} [args] DynamicGroupNSQOptions args
             */

            /**
             * Constructs a new DynamicGroupNSQOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupNSQOptions.
             * @implements IDynamicGroupNSQOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupNSQOptions=} [properties] Properties to set
             */
            function DynamicGroupNSQOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupNSQOptions _conn.
             * @member {protos.args.INSQConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @instance
             */
            DynamicGroupNSQOptions.prototype._conn = null;

            /**
             * DynamicGroupNSQOptions args.
             * @member {protos.args.INSQWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @instance
             */
            DynamicGroupNSQOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupNSQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {protos.opts.IDynamicGroupNSQOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupNSQOptions} DynamicGroupNSQOptions instance
             */
            DynamicGroupNSQOptions.create = function create(properties) {
                return new DynamicGroupNSQOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupNSQOptions message. Does not implicitly {@link protos.opts.DynamicGroupNSQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {protos.opts.IDynamicGroupNSQOptions} message DynamicGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupNSQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NSQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NSQWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupNSQOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupNSQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {protos.opts.IDynamicGroupNSQOptions} message DynamicGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupNSQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupNSQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupNSQOptions} DynamicGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupNSQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupNSQOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NSQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NSQWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupNSQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupNSQOptions} DynamicGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupNSQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupNSQOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupNSQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.NSQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.NSQWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupNSQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupNSQOptions} DynamicGroupNSQOptions
             */
            DynamicGroupNSQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupNSQOptions)
                    return object;
                let message = new $root.protos.opts.DynamicGroupNSQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupNSQOptions._conn: object expected");
                    message._conn = $root.protos.args.NSQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupNSQOptions.args: object expected");
                    message.args = $root.protos.args.NSQWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupNSQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {protos.opts.DynamicGroupNSQOptions} message DynamicGroupNSQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupNSQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NSQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NSQWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupNSQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupNSQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupNSQOptions;
        })();

        opts.DynamicGroupRabbitOptions = (function() {

            /**
             * Properties of a DynamicGroupRabbitOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupRabbitOptions
             * @property {protos.args.IRabbitConn|null} [_conn] DynamicGroupRabbitOptions _conn
             * @property {protos.args.IRabbitWriteArgs|null} [args] DynamicGroupRabbitOptions args
             */

            /**
             * Constructs a new DynamicGroupRabbitOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupRabbitOptions.
             * @implements IDynamicGroupRabbitOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupRabbitOptions=} [properties] Properties to set
             */
            function DynamicGroupRabbitOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupRabbitOptions _conn.
             * @member {protos.args.IRabbitConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @instance
             */
            DynamicGroupRabbitOptions.prototype._conn = null;

            /**
             * DynamicGroupRabbitOptions args.
             * @member {protos.args.IRabbitWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @instance
             */
            DynamicGroupRabbitOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupRabbitOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {protos.opts.IDynamicGroupRabbitOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupRabbitOptions} DynamicGroupRabbitOptions instance
             */
            DynamicGroupRabbitOptions.create = function create(properties) {
                return new DynamicGroupRabbitOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupRabbitOptions message. Does not implicitly {@link protos.opts.DynamicGroupRabbitOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {protos.opts.IDynamicGroupRabbitOptions} message DynamicGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRabbitOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupRabbitOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupRabbitOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {protos.opts.IDynamicGroupRabbitOptions} message DynamicGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRabbitOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupRabbitOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupRabbitOptions} DynamicGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRabbitOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupRabbitOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupRabbitOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupRabbitOptions} DynamicGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRabbitOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupRabbitOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupRabbitOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.RabbitConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.RabbitWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupRabbitOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupRabbitOptions} DynamicGroupRabbitOptions
             */
            DynamicGroupRabbitOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupRabbitOptions)
                    return object;
                let message = new $root.protos.opts.DynamicGroupRabbitOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRabbitOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRabbitOptions.args: object expected");
                    message.args = $root.protos.args.RabbitWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupRabbitOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {protos.opts.DynamicGroupRabbitOptions} message DynamicGroupRabbitOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupRabbitOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupRabbitOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupRabbitOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupRabbitOptions;
        })();

        opts.DynamicGroupRabbitStreamsOptions = (function() {

            /**
             * Properties of a DynamicGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupRabbitStreamsOptions
             * @property {protos.args.IRabbitStreamsConn|null} [_conn] DynamicGroupRabbitStreamsOptions _conn
             * @property {protos.args.IRabbitStreamsWriteArgs|null} [args] DynamicGroupRabbitStreamsOptions args
             */

            /**
             * Constructs a new DynamicGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupRabbitStreamsOptions.
             * @implements IDynamicGroupRabbitStreamsOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupRabbitStreamsOptions=} [properties] Properties to set
             */
            function DynamicGroupRabbitStreamsOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupRabbitStreamsOptions _conn.
             * @member {protos.args.IRabbitStreamsConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @instance
             */
            DynamicGroupRabbitStreamsOptions.prototype._conn = null;

            /**
             * DynamicGroupRabbitStreamsOptions args.
             * @member {protos.args.IRabbitStreamsWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @instance
             */
            DynamicGroupRabbitStreamsOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupRabbitStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IDynamicGroupRabbitStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupRabbitStreamsOptions} DynamicGroupRabbitStreamsOptions instance
             */
            DynamicGroupRabbitStreamsOptions.create = function create(properties) {
                return new DynamicGroupRabbitStreamsOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupRabbitStreamsOptions message. Does not implicitly {@link protos.opts.DynamicGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IDynamicGroupRabbitStreamsOptions} message DynamicGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRabbitStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitStreamsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupRabbitStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IDynamicGroupRabbitStreamsOptions} message DynamicGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRabbitStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupRabbitStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupRabbitStreamsOptions} DynamicGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRabbitStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupRabbitStreamsOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitStreamsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupRabbitStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupRabbitStreamsOptions} DynamicGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRabbitStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupRabbitStreamsOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupRabbitStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.RabbitStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.RabbitStreamsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupRabbitStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupRabbitStreamsOptions} DynamicGroupRabbitStreamsOptions
             */
            DynamicGroupRabbitStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupRabbitStreamsOptions)
                    return object;
                let message = new $root.protos.opts.DynamicGroupRabbitStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRabbitStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRabbitStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RabbitStreamsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupRabbitStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.DynamicGroupRabbitStreamsOptions} message DynamicGroupRabbitStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupRabbitStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitStreamsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupRabbitStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupRabbitStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupRabbitStreamsOptions;
        })();

        opts.DynamicGroupRedisPubSubOptions = (function() {

            /**
             * Properties of a DynamicGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupRedisPubSubOptions
             * @property {protos.args.IRedisPubSubConn|null} [_conn] DynamicGroupRedisPubSubOptions _conn
             * @property {protos.args.IRedisPubSubWriteArgs|null} [args] DynamicGroupRedisPubSubOptions args
             */

            /**
             * Constructs a new DynamicGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupRedisPubSubOptions.
             * @implements IDynamicGroupRedisPubSubOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupRedisPubSubOptions=} [properties] Properties to set
             */
            function DynamicGroupRedisPubSubOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupRedisPubSubOptions _conn.
             * @member {protos.args.IRedisPubSubConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @instance
             */
            DynamicGroupRedisPubSubOptions.prototype._conn = null;

            /**
             * DynamicGroupRedisPubSubOptions args.
             * @member {protos.args.IRedisPubSubWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @instance
             */
            DynamicGroupRedisPubSubOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupRedisPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IDynamicGroupRedisPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupRedisPubSubOptions} DynamicGroupRedisPubSubOptions instance
             */
            DynamicGroupRedisPubSubOptions.create = function create(properties) {
                return new DynamicGroupRedisPubSubOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupRedisPubSubOptions message. Does not implicitly {@link protos.opts.DynamicGroupRedisPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IDynamicGroupRedisPubSubOptions} message DynamicGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRedisPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisPubSubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupRedisPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupRedisPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IDynamicGroupRedisPubSubOptions} message DynamicGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRedisPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupRedisPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupRedisPubSubOptions} DynamicGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRedisPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupRedisPubSubOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisPubSubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupRedisPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupRedisPubSubOptions} DynamicGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRedisPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupRedisPubSubOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupRedisPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.RedisPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.RedisPubSubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupRedisPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupRedisPubSubOptions} DynamicGroupRedisPubSubOptions
             */
            DynamicGroupRedisPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupRedisPubSubOptions)
                    return object;
                let message = new $root.protos.opts.DynamicGroupRedisPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRedisPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRedisPubSubOptions.args: object expected");
                    message.args = $root.protos.args.RedisPubSubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupRedisPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.DynamicGroupRedisPubSubOptions} message DynamicGroupRedisPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupRedisPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisPubSubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupRedisPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupRedisPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupRedisPubSubOptions;
        })();

        opts.DynamicGroupRedisStreamsOptions = (function() {

            /**
             * Properties of a DynamicGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupRedisStreamsOptions
             * @property {protos.args.IRedisStreamsConn|null} [_conn] DynamicGroupRedisStreamsOptions _conn
             * @property {protos.args.IRedisStreamsWriteArgs|null} [args] DynamicGroupRedisStreamsOptions args
             */

            /**
             * Constructs a new DynamicGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupRedisStreamsOptions.
             * @implements IDynamicGroupRedisStreamsOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupRedisStreamsOptions=} [properties] Properties to set
             */
            function DynamicGroupRedisStreamsOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupRedisStreamsOptions _conn.
             * @member {protos.args.IRedisStreamsConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @instance
             */
            DynamicGroupRedisStreamsOptions.prototype._conn = null;

            /**
             * DynamicGroupRedisStreamsOptions args.
             * @member {protos.args.IRedisStreamsWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @instance
             */
            DynamicGroupRedisStreamsOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupRedisStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IDynamicGroupRedisStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupRedisStreamsOptions} DynamicGroupRedisStreamsOptions instance
             */
            DynamicGroupRedisStreamsOptions.create = function create(properties) {
                return new DynamicGroupRedisStreamsOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupRedisStreamsOptions message. Does not implicitly {@link protos.opts.DynamicGroupRedisStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IDynamicGroupRedisStreamsOptions} message DynamicGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRedisStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisStreamsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupRedisStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupRedisStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IDynamicGroupRedisStreamsOptions} message DynamicGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRedisStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupRedisStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupRedisStreamsOptions} DynamicGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRedisStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupRedisStreamsOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisStreamsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupRedisStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupRedisStreamsOptions} DynamicGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRedisStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupRedisStreamsOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupRedisStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.RedisStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.RedisStreamsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupRedisStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupRedisStreamsOptions} DynamicGroupRedisStreamsOptions
             */
            DynamicGroupRedisStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupRedisStreamsOptions)
                    return object;
                let message = new $root.protos.opts.DynamicGroupRedisStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRedisStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRedisStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RedisStreamsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupRedisStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.DynamicGroupRedisStreamsOptions} message DynamicGroupRedisStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupRedisStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisStreamsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupRedisStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupRedisStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupRedisStreamsOptions;
        })();

        opts.DynamicGroupAzureEventHubOptions = (function() {

            /**
             * Properties of a DynamicGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupAzureEventHubOptions
             * @property {protos.args.IAzureEventHubConn|null} [_conn] DynamicGroupAzureEventHubOptions _conn
             * @property {protos.args.IAzureEventHubWriteArgs|null} [args] DynamicGroupAzureEventHubOptions args
             */

            /**
             * Constructs a new DynamicGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupAzureEventHubOptions.
             * @implements IDynamicGroupAzureEventHubOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupAzureEventHubOptions=} [properties] Properties to set
             */
            function DynamicGroupAzureEventHubOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupAzureEventHubOptions _conn.
             * @member {protos.args.IAzureEventHubConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @instance
             */
            DynamicGroupAzureEventHubOptions.prototype._conn = null;

            /**
             * DynamicGroupAzureEventHubOptions args.
             * @member {protos.args.IAzureEventHubWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @instance
             */
            DynamicGroupAzureEventHubOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupAzureEventHubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IDynamicGroupAzureEventHubOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupAzureEventHubOptions} DynamicGroupAzureEventHubOptions instance
             */
            DynamicGroupAzureEventHubOptions.create = function create(properties) {
                return new DynamicGroupAzureEventHubOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupAzureEventHubOptions message. Does not implicitly {@link protos.opts.DynamicGroupAzureEventHubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IDynamicGroupAzureEventHubOptions} message DynamicGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAzureEventHubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureEventHubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureEventHubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupAzureEventHubOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupAzureEventHubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IDynamicGroupAzureEventHubOptions} message DynamicGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAzureEventHubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupAzureEventHubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupAzureEventHubOptions} DynamicGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAzureEventHubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupAzureEventHubOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureEventHubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureEventHubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupAzureEventHubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupAzureEventHubOptions} DynamicGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAzureEventHubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupAzureEventHubOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupAzureEventHubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.AzureEventHubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.AzureEventHubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupAzureEventHubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupAzureEventHubOptions} DynamicGroupAzureEventHubOptions
             */
            DynamicGroupAzureEventHubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupAzureEventHubOptions)
                    return object;
                let message = new $root.protos.opts.DynamicGroupAzureEventHubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAzureEventHubOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureEventHubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAzureEventHubOptions.args: object expected");
                    message.args = $root.protos.args.AzureEventHubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupAzureEventHubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.DynamicGroupAzureEventHubOptions} message DynamicGroupAzureEventHubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupAzureEventHubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureEventHubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureEventHubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupAzureEventHubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupAzureEventHubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupAzureEventHubOptions;
        })();

        opts.DynamicGroupAzureServiceBusOptions = (function() {

            /**
             * Properties of a DynamicGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupAzureServiceBusOptions
             * @property {protos.args.IAzureServiceBusConn|null} [_conn] DynamicGroupAzureServiceBusOptions _conn
             * @property {protos.args.IAzureServiceBusWriteArgs|null} [args] DynamicGroupAzureServiceBusOptions args
             */

            /**
             * Constructs a new DynamicGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupAzureServiceBusOptions.
             * @implements IDynamicGroupAzureServiceBusOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupAzureServiceBusOptions=} [properties] Properties to set
             */
            function DynamicGroupAzureServiceBusOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupAzureServiceBusOptions _conn.
             * @member {protos.args.IAzureServiceBusConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @instance
             */
            DynamicGroupAzureServiceBusOptions.prototype._conn = null;

            /**
             * DynamicGroupAzureServiceBusOptions args.
             * @member {protos.args.IAzureServiceBusWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @instance
             */
            DynamicGroupAzureServiceBusOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupAzureServiceBusOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IDynamicGroupAzureServiceBusOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupAzureServiceBusOptions} DynamicGroupAzureServiceBusOptions instance
             */
            DynamicGroupAzureServiceBusOptions.create = function create(properties) {
                return new DynamicGroupAzureServiceBusOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupAzureServiceBusOptions message. Does not implicitly {@link protos.opts.DynamicGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IDynamicGroupAzureServiceBusOptions} message DynamicGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAzureServiceBusOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureServiceBusConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureServiceBusWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupAzureServiceBusOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IDynamicGroupAzureServiceBusOptions} message DynamicGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAzureServiceBusOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupAzureServiceBusOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupAzureServiceBusOptions} DynamicGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAzureServiceBusOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupAzureServiceBusOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureServiceBusConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureServiceBusWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupAzureServiceBusOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupAzureServiceBusOptions} DynamicGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAzureServiceBusOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupAzureServiceBusOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupAzureServiceBusOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.AzureServiceBusConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.AzureServiceBusWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupAzureServiceBusOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupAzureServiceBusOptions} DynamicGroupAzureServiceBusOptions
             */
            DynamicGroupAzureServiceBusOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupAzureServiceBusOptions)
                    return object;
                let message = new $root.protos.opts.DynamicGroupAzureServiceBusOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAzureServiceBusOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureServiceBusConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAzureServiceBusOptions.args: object expected");
                    message.args = $root.protos.args.AzureServiceBusWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupAzureServiceBusOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.DynamicGroupAzureServiceBusOptions} message DynamicGroupAzureServiceBusOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupAzureServiceBusOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureServiceBusConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureServiceBusWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupAzureServiceBusOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupAzureServiceBusOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupAzureServiceBusOptions;
        })();

        opts.DynamicGroupMQTTOptions = (function() {

            /**
             * Properties of a DynamicGroupMQTTOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupMQTTOptions
             * @property {protos.args.IMQTTConn|null} [_conn] DynamicGroupMQTTOptions _conn
             * @property {protos.args.IMQTTWriteArgs|null} [args] DynamicGroupMQTTOptions args
             */

            /**
             * Constructs a new DynamicGroupMQTTOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupMQTTOptions.
             * @implements IDynamicGroupMQTTOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupMQTTOptions=} [properties] Properties to set
             */
            function DynamicGroupMQTTOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupMQTTOptions _conn.
             * @member {protos.args.IMQTTConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @instance
             */
            DynamicGroupMQTTOptions.prototype._conn = null;

            /**
             * DynamicGroupMQTTOptions args.
             * @member {protos.args.IMQTTWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @instance
             */
            DynamicGroupMQTTOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupMQTTOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {protos.opts.IDynamicGroupMQTTOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupMQTTOptions} DynamicGroupMQTTOptions instance
             */
            DynamicGroupMQTTOptions.create = function create(properties) {
                return new DynamicGroupMQTTOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupMQTTOptions message. Does not implicitly {@link protos.opts.DynamicGroupMQTTOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {protos.opts.IDynamicGroupMQTTOptions} message DynamicGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupMQTTOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MQTTConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MQTTWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupMQTTOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupMQTTOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {protos.opts.IDynamicGroupMQTTOptions} message DynamicGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupMQTTOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupMQTTOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupMQTTOptions} DynamicGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupMQTTOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupMQTTOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MQTTConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MQTTWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupMQTTOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupMQTTOptions} DynamicGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupMQTTOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupMQTTOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupMQTTOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.MQTTConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.MQTTWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupMQTTOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupMQTTOptions} DynamicGroupMQTTOptions
             */
            DynamicGroupMQTTOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupMQTTOptions)
                    return object;
                let message = new $root.protos.opts.DynamicGroupMQTTOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupMQTTOptions._conn: object expected");
                    message._conn = $root.protos.args.MQTTConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupMQTTOptions.args: object expected");
                    message.args = $root.protos.args.MQTTWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupMQTTOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {protos.opts.DynamicGroupMQTTOptions} message DynamicGroupMQTTOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupMQTTOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MQTTConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MQTTWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupMQTTOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupMQTTOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupMQTTOptions;
        })();

        opts.DynamicGroupGCPPubSubOptions = (function() {

            /**
             * Properties of a DynamicGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupGCPPubSubOptions
             * @property {protos.args.IGCPPubSubConn|null} [_conn] DynamicGroupGCPPubSubOptions _conn
             * @property {protos.args.IGCPPubSubWriteArgs|null} [args] DynamicGroupGCPPubSubOptions args
             */

            /**
             * Constructs a new DynamicGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupGCPPubSubOptions.
             * @implements IDynamicGroupGCPPubSubOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupGCPPubSubOptions=} [properties] Properties to set
             */
            function DynamicGroupGCPPubSubOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupGCPPubSubOptions _conn.
             * @member {protos.args.IGCPPubSubConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @instance
             */
            DynamicGroupGCPPubSubOptions.prototype._conn = null;

            /**
             * DynamicGroupGCPPubSubOptions args.
             * @member {protos.args.IGCPPubSubWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @instance
             */
            DynamicGroupGCPPubSubOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupGCPPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IDynamicGroupGCPPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupGCPPubSubOptions} DynamicGroupGCPPubSubOptions instance
             */
            DynamicGroupGCPPubSubOptions.create = function create(properties) {
                return new DynamicGroupGCPPubSubOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupGCPPubSubOptions message. Does not implicitly {@link protos.opts.DynamicGroupGCPPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IDynamicGroupGCPPubSubOptions} message DynamicGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupGCPPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.GCPPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.GCPPubSubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupGCPPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupGCPPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IDynamicGroupGCPPubSubOptions} message DynamicGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupGCPPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupGCPPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupGCPPubSubOptions} DynamicGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupGCPPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupGCPPubSubOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.GCPPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.GCPPubSubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupGCPPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupGCPPubSubOptions} DynamicGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupGCPPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupGCPPubSubOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupGCPPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.GCPPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.GCPPubSubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupGCPPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupGCPPubSubOptions} DynamicGroupGCPPubSubOptions
             */
            DynamicGroupGCPPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupGCPPubSubOptions)
                    return object;
                let message = new $root.protos.opts.DynamicGroupGCPPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupGCPPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.GCPPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupGCPPubSubOptions.args: object expected");
                    message.args = $root.protos.args.GCPPubSubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupGCPPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.DynamicGroupGCPPubSubOptions} message DynamicGroupGCPPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupGCPPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.GCPPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.GCPPubSubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupGCPPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupGCPPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupGCPPubSubOptions;
        })();

        opts.DynamicGroupKubeMQQueueOptions = (function() {

            /**
             * Properties of a DynamicGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupKubeMQQueueOptions
             * @property {protos.args.IKubeMQQueueConn|null} [_conn] DynamicGroupKubeMQQueueOptions _conn
             * @property {protos.args.IKubeMQQueueWriteArgs|null} [args] DynamicGroupKubeMQQueueOptions args
             */

            /**
             * Constructs a new DynamicGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupKubeMQQueueOptions.
             * @implements IDynamicGroupKubeMQQueueOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupKubeMQQueueOptions=} [properties] Properties to set
             */
            function DynamicGroupKubeMQQueueOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupKubeMQQueueOptions _conn.
             * @member {protos.args.IKubeMQQueueConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @instance
             */
            DynamicGroupKubeMQQueueOptions.prototype._conn = null;

            /**
             * DynamicGroupKubeMQQueueOptions args.
             * @member {protos.args.IKubeMQQueueWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @instance
             */
            DynamicGroupKubeMQQueueOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupKubeMQQueueOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IDynamicGroupKubeMQQueueOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupKubeMQQueueOptions} DynamicGroupKubeMQQueueOptions instance
             */
            DynamicGroupKubeMQQueueOptions.create = function create(properties) {
                return new DynamicGroupKubeMQQueueOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupKubeMQQueueOptions message. Does not implicitly {@link protos.opts.DynamicGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IDynamicGroupKubeMQQueueOptions} message DynamicGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupKubeMQQueueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KubeMQQueueConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KubeMQQueueWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupKubeMQQueueOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IDynamicGroupKubeMQQueueOptions} message DynamicGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupKubeMQQueueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupKubeMQQueueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupKubeMQQueueOptions} DynamicGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupKubeMQQueueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupKubeMQQueueOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KubeMQQueueConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KubeMQQueueWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupKubeMQQueueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupKubeMQQueueOptions} DynamicGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupKubeMQQueueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupKubeMQQueueOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupKubeMQQueueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    let error = $root.protos.args.KubeMQQueueConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    let error = $root.protos.args.KubeMQQueueWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupKubeMQQueueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupKubeMQQueueOptions} DynamicGroupKubeMQQueueOptions
             */
            DynamicGroupKubeMQQueueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupKubeMQQueueOptions)
                    return object;
                let message = new $root.protos.opts.DynamicGroupKubeMQQueueOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupKubeMQQueueOptions._conn: object expected");
                    message._conn = $root.protos.args.KubeMQQueueConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupKubeMQQueueOptions.args: object expected");
                    message.args = $root.protos.args.KubeMQQueueWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupKubeMQQueueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.DynamicGroupKubeMQQueueOptions} message DynamicGroupKubeMQQueueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupKubeMQQueueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KubeMQQueueConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KubeMQQueueWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupKubeMQQueueOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupKubeMQQueueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupKubeMQQueueOptions;
        })();

        opts.ConnectionOptions = (function() {

            /**
             * Properties of a ConnectionOptions.
             * @memberof protos.opts
             * @interface IConnectionOptions
             * @property {string|null} [name] ConnectionOptions name
             * @property {string|null} [notes] ConnectionOptions notes
             * @property {protos.args.IKafkaConn|null} [kafka] ConnectionOptions kafka
             * @property {protos.args.IActiveMQConn|null} [activeMq] ConnectionOptions activeMq
             * @property {protos.args.IAWSSQSConn|null} [awssqs] ConnectionOptions awssqs
             * @property {protos.args.IAWSSNSConn|null} [awssns] ConnectionOptions awssns
             * @property {protos.args.IMongoConn|null} [mongo] ConnectionOptions mongo
             * @property {protos.args.INatsConn|null} [nats] ConnectionOptions nats
             * @property {protos.args.INatsStreamingConn|null} [natsStreaming] ConnectionOptions natsStreaming
             * @property {protos.args.INSQConn|null} [nsq] ConnectionOptions nsq
             * @property {protos.args.IPostgresConn|null} [postgres] ConnectionOptions postgres
             * @property {protos.args.IPulsarConn|null} [pulsar] ConnectionOptions pulsar
             * @property {protos.args.IRabbitConn|null} [rabbit] ConnectionOptions rabbit
             * @property {protos.args.IRabbitStreamsConn|null} [rabbitStreams] ConnectionOptions rabbitStreams
             * @property {protos.args.IRedisPubSubConn|null} [redisPubsub] ConnectionOptions redisPubsub
             * @property {protos.args.IRedisStreamsConn|null} [redisStreams] ConnectionOptions redisStreams
             * @property {protos.args.IAzureEventHubConn|null} [azureEventHub] ConnectionOptions azureEventHub
             * @property {protos.args.IAzureServiceBusConn|null} [azureServiceBus] ConnectionOptions azureServiceBus
             * @property {protos.args.IMQTTConn|null} [mqtt] ConnectionOptions mqtt
             * @property {protos.args.IKubeMQQueueConn|null} [kubemqQueue] ConnectionOptions kubemqQueue
             * @property {protos.args.IGCPPubSubConn|null} [gcpPubsub] ConnectionOptions gcpPubsub
             * @property {string|null} [_id] ConnectionOptions _id
             */

            /**
             * Constructs a new ConnectionOptions.
             * @memberof protos.opts
             * @classdesc Represents a ConnectionOptions.
             * @implements IConnectionOptions
             * @constructor
             * @param {protos.opts.IConnectionOptions=} [properties] Properties to set
             */
            function ConnectionOptions(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ConnectionOptions name.
             * @member {string} name
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.name = "";

            /**
             * ConnectionOptions notes.
             * @member {string} notes
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.notes = "";

            /**
             * ConnectionOptions kafka.
             * @member {protos.args.IKafkaConn|null|undefined} kafka
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.kafka = null;

            /**
             * ConnectionOptions activeMq.
             * @member {protos.args.IActiveMQConn|null|undefined} activeMq
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.activeMq = null;

            /**
             * ConnectionOptions awssqs.
             * @member {protos.args.IAWSSQSConn|null|undefined} awssqs
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.awssqs = null;

            /**
             * ConnectionOptions awssns.
             * @member {protos.args.IAWSSNSConn|null|undefined} awssns
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.awssns = null;

            /**
             * ConnectionOptions mongo.
             * @member {protos.args.IMongoConn|null|undefined} mongo
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.mongo = null;

            /**
             * ConnectionOptions nats.
             * @member {protos.args.INatsConn|null|undefined} nats
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.nats = null;

            /**
             * ConnectionOptions natsStreaming.
             * @member {protos.args.INatsStreamingConn|null|undefined} natsStreaming
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.natsStreaming = null;

            /**
             * ConnectionOptions nsq.
             * @member {protos.args.INSQConn|null|undefined} nsq
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.nsq = null;

            /**
             * ConnectionOptions postgres.
             * @member {protos.args.IPostgresConn|null|undefined} postgres
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.postgres = null;

            /**
             * ConnectionOptions pulsar.
             * @member {protos.args.IPulsarConn|null|undefined} pulsar
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.pulsar = null;

            /**
             * ConnectionOptions rabbit.
             * @member {protos.args.IRabbitConn|null|undefined} rabbit
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.rabbit = null;

            /**
             * ConnectionOptions rabbitStreams.
             * @member {protos.args.IRabbitStreamsConn|null|undefined} rabbitStreams
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.rabbitStreams = null;

            /**
             * ConnectionOptions redisPubsub.
             * @member {protos.args.IRedisPubSubConn|null|undefined} redisPubsub
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.redisPubsub = null;

            /**
             * ConnectionOptions redisStreams.
             * @member {protos.args.IRedisStreamsConn|null|undefined} redisStreams
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.redisStreams = null;

            /**
             * ConnectionOptions azureEventHub.
             * @member {protos.args.IAzureEventHubConn|null|undefined} azureEventHub
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.azureEventHub = null;

            /**
             * ConnectionOptions azureServiceBus.
             * @member {protos.args.IAzureServiceBusConn|null|undefined} azureServiceBus
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.azureServiceBus = null;

            /**
             * ConnectionOptions mqtt.
             * @member {protos.args.IMQTTConn|null|undefined} mqtt
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.mqtt = null;

            /**
             * ConnectionOptions kubemqQueue.
             * @member {protos.args.IKubeMQQueueConn|null|undefined} kubemqQueue
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.kubemqQueue = null;

            /**
             * ConnectionOptions gcpPubsub.
             * @member {protos.args.IGCPPubSubConn|null|undefined} gcpPubsub
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.gcpPubsub = null;

            /**
             * ConnectionOptions _id.
             * @member {string} _id
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype._id = "";

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ConnectionOptions conn.
             * @member {"kafka"|"activeMq"|"awssqs"|"awssns"|"mongo"|"nats"|"natsStreaming"|"nsq"|"postgres"|"pulsar"|"rabbit"|"rabbitStreams"|"redisPubsub"|"redisStreams"|"azureEventHub"|"azureServiceBus"|"mqtt"|"kubemqQueue"|"gcpPubsub"|undefined} conn
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            Object.defineProperty(ConnectionOptions.prototype, "conn", {
                get: $util.oneOfGetter($oneOfFields = ["kafka", "activeMq", "awssqs", "awssns", "mongo", "nats", "natsStreaming", "nsq", "postgres", "pulsar", "rabbit", "rabbitStreams", "redisPubsub", "redisStreams", "azureEventHub", "azureServiceBus", "mqtt", "kubemqQueue", "gcpPubsub"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ConnectionOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {protos.opts.IConnectionOptions=} [properties] Properties to set
             * @returns {protos.opts.ConnectionOptions} ConnectionOptions instance
             */
            ConnectionOptions.create = function create(properties) {
                return new ConnectionOptions(properties);
            };

            /**
             * Encodes the specified ConnectionOptions message. Does not implicitly {@link protos.opts.ConnectionOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {protos.opts.IConnectionOptions} message ConnectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectionOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.notes);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.args.KafkaConn.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.activeMq != null && Object.hasOwnProperty.call(message, "activeMq"))
                    $root.protos.args.ActiveMQConn.encode(message.activeMq, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.awssqs != null && Object.hasOwnProperty.call(message, "awssqs"))
                    $root.protos.args.AWSSQSConn.encode(message.awssqs, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.awssns != null && Object.hasOwnProperty.call(message, "awssns"))
                    $root.protos.args.AWSSNSConn.encode(message.awssns, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.mongo != null && Object.hasOwnProperty.call(message, "mongo"))
                    $root.protos.args.MongoConn.encode(message.mongo, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.args.NatsConn.encode(message.nats, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.args.NatsStreamingConn.encode(message.natsStreaming, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.args.NSQConn.encode(message.nsq, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.postgres != null && Object.hasOwnProperty.call(message, "postgres"))
                    $root.protos.args.PostgresConn.encode(message.postgres, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.pulsar != null && Object.hasOwnProperty.call(message, "pulsar"))
                    $root.protos.args.PulsarConn.encode(message.pulsar, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.args.RabbitConn.encode(message.rabbit, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
                if (message.rabbitStreams != null && Object.hasOwnProperty.call(message, "rabbitStreams"))
                    $root.protos.args.RabbitStreamsConn.encode(message.rabbitStreams, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.args.RedisPubSubConn.encode(message.redisPubsub, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.args.RedisStreamsConn.encode(message.redisStreams, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.azureEventHub != null && Object.hasOwnProperty.call(message, "azureEventHub"))
                    $root.protos.args.AzureEventHubConn.encode(message.azureEventHub, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.args.AzureServiceBusConn.encode(message.azureServiceBus, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.args.MQTTConn.encode(message.mqtt, writer.uint32(/* id 116, wireType 2 =*/930).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.args.KubeMQQueueConn.encode(message.kubemqQueue, writer.uint32(/* id 117, wireType 2 =*/938).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.args.GCPPubSubConn.encode(message.gcpPubsub, writer.uint32(/* id 118, wireType 2 =*/946).fork()).ldelim();
                if (message._id != null && Object.hasOwnProperty.call(message, "_id"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._id);
                return writer;
            };

            /**
             * Encodes the specified ConnectionOptions message, length delimited. Does not implicitly {@link protos.opts.ConnectionOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {protos.opts.IConnectionOptions} message ConnectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectionOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ConnectionOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ConnectionOptions} ConnectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectionOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ConnectionOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.notes = reader.string();
                        break;
                    case 100:
                        message.kafka = $root.protos.args.KafkaConn.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.activeMq = $root.protos.args.ActiveMQConn.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.awssqs = $root.protos.args.AWSSQSConn.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.awssns = $root.protos.args.AWSSNSConn.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.mongo = $root.protos.args.MongoConn.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.nats = $root.protos.args.NatsConn.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.natsStreaming = $root.protos.args.NatsStreamingConn.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.nsq = $root.protos.args.NSQConn.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.postgres = $root.protos.args.PostgresConn.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.pulsar = $root.protos.args.PulsarConn.decode(reader, reader.uint32());
                        break;
                    case 110:
                        message.rabbit = $root.protos.args.RabbitConn.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.rabbitStreams = $root.protos.args.RabbitStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.redisPubsub = $root.protos.args.RedisPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.redisStreams = $root.protos.args.RedisStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.azureEventHub = $root.protos.args.AzureEventHubConn.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.azureServiceBus = $root.protos.args.AzureServiceBusConn.decode(reader, reader.uint32());
                        break;
                    case 116:
                        message.mqtt = $root.protos.args.MQTTConn.decode(reader, reader.uint32());
                        break;
                    case 117:
                        message.kubemqQueue = $root.protos.args.KubeMQQueueConn.decode(reader, reader.uint32());
                        break;
                    case 118:
                        message.gcpPubsub = $root.protos.args.GCPPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 1000:
                        message._id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ConnectionOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ConnectionOptions} ConnectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectionOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ConnectionOptions message.
             * @function verify
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConnectionOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.notes != null && message.hasOwnProperty("notes"))
                    if (!$util.isString(message.notes))
                        return "notes: string expected";
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    properties.conn = 1;
                    {
                        let error = $root.protos.args.KafkaConn.verify(message.kafka);
                        if (error)
                            return "kafka." + error;
                    }
                }
                if (message.activeMq != null && message.hasOwnProperty("activeMq")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        let error = $root.protos.args.ActiveMQConn.verify(message.activeMq);
                        if (error)
                            return "activeMq." + error;
                    }
                }
                if (message.awssqs != null && message.hasOwnProperty("awssqs")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        let error = $root.protos.args.AWSSQSConn.verify(message.awssqs);
                        if (error)
                            return "awssqs." + error;
                    }
                }
                if (message.awssns != null && message.hasOwnProperty("awssns")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        let error = $root.protos.args.AWSSNSConn.verify(message.awssns);
                        if (error)
                            return "awssns." + error;
                    }
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        let error = $root.protos.args.MongoConn.verify(message.mongo);
                        if (error)
                            return "mongo." + error;
                    }
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        let error = $root.protos.args.NatsConn.verify(message.nats);
                        if (error)
                            return "nats." + error;
                    }
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        let error = $root.protos.args.NatsStreamingConn.verify(message.natsStreaming);
                        if (error)
                            return "natsStreaming." + error;
                    }
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        let error = $root.protos.args.NSQConn.verify(message.nsq);
                        if (error)
                            return "nsq." + error;
                    }
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        let error = $root.protos.args.PostgresConn.verify(message.postgres);
                        if (error)
                            return "postgres." + error;
                    }
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        let error = $root.protos.args.PulsarConn.verify(message.pulsar);
                        if (error)
                            return "pulsar." + error;
                    }
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        let error = $root.protos.args.RabbitConn.verify(message.rabbit);
                        if (error)
                            return "rabbit." + error;
                    }
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        let error = $root.protos.args.RabbitStreamsConn.verify(message.rabbitStreams);
                        if (error)
                            return "rabbitStreams." + error;
                    }
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        let error = $root.protos.args.RedisPubSubConn.verify(message.redisPubsub);
                        if (error)
                            return "redisPubsub." + error;
                    }
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        let error = $root.protos.args.RedisStreamsConn.verify(message.redisStreams);
                        if (error)
                            return "redisStreams." + error;
                    }
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        let error = $root.protos.args.AzureEventHubConn.verify(message.azureEventHub);
                        if (error)
                            return "azureEventHub." + error;
                    }
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        let error = $root.protos.args.AzureServiceBusConn.verify(message.azureServiceBus);
                        if (error)
                            return "azureServiceBus." + error;
                    }
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        let error = $root.protos.args.MQTTConn.verify(message.mqtt);
                        if (error)
                            return "mqtt." + error;
                    }
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        let error = $root.protos.args.KubeMQQueueConn.verify(message.kubemqQueue);
                        if (error)
                            return "kubemqQueue." + error;
                    }
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        let error = $root.protos.args.GCPPubSubConn.verify(message.gcpPubsub);
                        if (error)
                            return "gcpPubsub." + error;
                    }
                }
                if (message._id != null && message.hasOwnProperty("_id"))
                    if (!$util.isString(message._id))
                        return "_id: string expected";
                return null;
            };

            /**
             * Creates a ConnectionOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ConnectionOptions} ConnectionOptions
             */
            ConnectionOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ConnectionOptions)
                    return object;
                let message = new $root.protos.opts.ConnectionOptions();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.notes != null)
                    message.notes = String(object.notes);
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.kafka: object expected");
                    message.kafka = $root.protos.args.KafkaConn.fromObject(object.kafka);
                }
                if (object.activeMq != null) {
                    if (typeof object.activeMq !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.activeMq: object expected");
                    message.activeMq = $root.protos.args.ActiveMQConn.fromObject(object.activeMq);
                }
                if (object.awssqs != null) {
                    if (typeof object.awssqs !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.awssqs: object expected");
                    message.awssqs = $root.protos.args.AWSSQSConn.fromObject(object.awssqs);
                }
                if (object.awssns != null) {
                    if (typeof object.awssns !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.awssns: object expected");
                    message.awssns = $root.protos.args.AWSSNSConn.fromObject(object.awssns);
                }
                if (object.mongo != null) {
                    if (typeof object.mongo !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.mongo: object expected");
                    message.mongo = $root.protos.args.MongoConn.fromObject(object.mongo);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.nats: object expected");
                    message.nats = $root.protos.args.NatsConn.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.args.NatsStreamingConn.fromObject(object.natsStreaming);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.nsq: object expected");
                    message.nsq = $root.protos.args.NSQConn.fromObject(object.nsq);
                }
                if (object.postgres != null) {
                    if (typeof object.postgres !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.postgres: object expected");
                    message.postgres = $root.protos.args.PostgresConn.fromObject(object.postgres);
                }
                if (object.pulsar != null) {
                    if (typeof object.pulsar !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.pulsar: object expected");
                    message.pulsar = $root.protos.args.PulsarConn.fromObject(object.pulsar);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.rabbit: object expected");
                    message.rabbit = $root.protos.args.RabbitConn.fromObject(object.rabbit);
                }
                if (object.rabbitStreams != null) {
                    if (typeof object.rabbitStreams !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.rabbitStreams: object expected");
                    message.rabbitStreams = $root.protos.args.RabbitStreamsConn.fromObject(object.rabbitStreams);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.args.RedisPubSubConn.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.args.RedisStreamsConn.fromObject(object.redisStreams);
                }
                if (object.azureEventHub != null) {
                    if (typeof object.azureEventHub !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.azureEventHub: object expected");
                    message.azureEventHub = $root.protos.args.AzureEventHubConn.fromObject(object.azureEventHub);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.args.AzureServiceBusConn.fromObject(object.azureServiceBus);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.mqtt: object expected");
                    message.mqtt = $root.protos.args.MQTTConn.fromObject(object.mqtt);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.args.KubeMQQueueConn.fromObject(object.kubemqQueue);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.args.GCPPubSubConn.fromObject(object.gcpPubsub);
                }
                if (object._id != null)
                    message._id = String(object._id);
                return message;
            };

            /**
             * Creates a plain object from a ConnectionOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {protos.opts.ConnectionOptions} message ConnectionOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConnectionOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.notes = "";
                    object._id = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.notes != null && message.hasOwnProperty("notes"))
                    object.notes = message.notes;
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    object.kafka = $root.protos.args.KafkaConn.toObject(message.kafka, options);
                    if (options.oneofs)
                        object.conn = "kafka";
                }
                if (message.activeMq != null && message.hasOwnProperty("activeMq")) {
                    object.activeMq = $root.protos.args.ActiveMQConn.toObject(message.activeMq, options);
                    if (options.oneofs)
                        object.conn = "activeMq";
                }
                if (message.awssqs != null && message.hasOwnProperty("awssqs")) {
                    object.awssqs = $root.protos.args.AWSSQSConn.toObject(message.awssqs, options);
                    if (options.oneofs)
                        object.conn = "awssqs";
                }
                if (message.awssns != null && message.hasOwnProperty("awssns")) {
                    object.awssns = $root.protos.args.AWSSNSConn.toObject(message.awssns, options);
                    if (options.oneofs)
                        object.conn = "awssns";
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    object.mongo = $root.protos.args.MongoConn.toObject(message.mongo, options);
                    if (options.oneofs)
                        object.conn = "mongo";
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    object.nats = $root.protos.args.NatsConn.toObject(message.nats, options);
                    if (options.oneofs)
                        object.conn = "nats";
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    object.natsStreaming = $root.protos.args.NatsStreamingConn.toObject(message.natsStreaming, options);
                    if (options.oneofs)
                        object.conn = "natsStreaming";
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    object.nsq = $root.protos.args.NSQConn.toObject(message.nsq, options);
                    if (options.oneofs)
                        object.conn = "nsq";
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    object.postgres = $root.protos.args.PostgresConn.toObject(message.postgres, options);
                    if (options.oneofs)
                        object.conn = "postgres";
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    object.pulsar = $root.protos.args.PulsarConn.toObject(message.pulsar, options);
                    if (options.oneofs)
                        object.conn = "pulsar";
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    object.rabbit = $root.protos.args.RabbitConn.toObject(message.rabbit, options);
                    if (options.oneofs)
                        object.conn = "rabbit";
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    object.rabbitStreams = $root.protos.args.RabbitStreamsConn.toObject(message.rabbitStreams, options);
                    if (options.oneofs)
                        object.conn = "rabbitStreams";
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    object.redisPubsub = $root.protos.args.RedisPubSubConn.toObject(message.redisPubsub, options);
                    if (options.oneofs)
                        object.conn = "redisPubsub";
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    object.redisStreams = $root.protos.args.RedisStreamsConn.toObject(message.redisStreams, options);
                    if (options.oneofs)
                        object.conn = "redisStreams";
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    object.azureEventHub = $root.protos.args.AzureEventHubConn.toObject(message.azureEventHub, options);
                    if (options.oneofs)
                        object.conn = "azureEventHub";
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    object.azureServiceBus = $root.protos.args.AzureServiceBusConn.toObject(message.azureServiceBus, options);
                    if (options.oneofs)
                        object.conn = "azureServiceBus";
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    object.mqtt = $root.protos.args.MQTTConn.toObject(message.mqtt, options);
                    if (options.oneofs)
                        object.conn = "mqtt";
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    object.kubemqQueue = $root.protos.args.KubeMQQueueConn.toObject(message.kubemqQueue, options);
                    if (options.oneofs)
                        object.conn = "kubemqQueue";
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    object.gcpPubsub = $root.protos.args.GCPPubSubConn.toObject(message.gcpPubsub, options);
                    if (options.oneofs)
                        object.conn = "gcpPubsub";
                }
                if (message._id != null && message.hasOwnProperty("_id"))
                    object._id = message._id;
                return object;
            };

            /**
             * Converts this ConnectionOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ConnectionOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConnectionOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ConnectionOptions;
        })();

        return opts;
    })();

    protos.records = (function() {

        /**
         * Namespace records.
         * @memberof protos
         * @namespace
         */
        const records = {};

        records.ReadRecord = (function() {

            /**
             * Properties of a ReadRecord.
             * @memberof protos.records
             * @interface IReadRecord
             * @property {string|null} [messageId] ReadRecord messageId
             * @property {number|Long|null} [num] ReadRecord num
             * @property {Object.<string,string>|null} [metadata] ReadRecord metadata
             * @property {number|Long|null} [receivedAtUnixTsUtc] ReadRecord receivedAtUnixTsUtc
             * @property {Uint8Array|null} [payload] ReadRecord payload
             * @property {protos.records.IKafka|null} [kafka] ReadRecord kafka
             * @property {Uint8Array|null} [_raw] ReadRecord _raw
             * @property {string|null} [_plumberId] ReadRecord _plumberId
             */

            /**
             * Constructs a new ReadRecord.
             * @memberof protos.records
             * @classdesc Represents a ReadRecord.
             * @implements IReadRecord
             * @constructor
             * @param {protos.records.IReadRecord=} [properties] Properties to set
             */
            function ReadRecord(properties) {
                this.metadata = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadRecord messageId.
             * @member {string} messageId
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.messageId = "";

            /**
             * ReadRecord num.
             * @member {number|Long} num
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.num = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ReadRecord metadata.
             * @member {Object.<string,string>} metadata
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.metadata = $util.emptyObject;

            /**
             * ReadRecord receivedAtUnixTsUtc.
             * @member {number|Long} receivedAtUnixTsUtc
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.receivedAtUnixTsUtc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ReadRecord payload.
             * @member {Uint8Array} payload
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.payload = $util.newBuffer([]);

            /**
             * ReadRecord kafka.
             * @member {protos.records.IKafka|null|undefined} kafka
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.kafka = null;

            /**
             * ReadRecord _raw.
             * @member {Uint8Array} _raw
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype._raw = $util.newBuffer([]);

            /**
             * ReadRecord _plumberId.
             * @member {string} _plumberId
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype._plumberId = "";

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ReadRecord Record.
             * @member {"kafka"|undefined} Record
             * @memberof protos.records.ReadRecord
             * @instance
             */
            Object.defineProperty(ReadRecord.prototype, "Record", {
                get: $util.oneOfGetter($oneOfFields = ["kafka"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ReadRecord instance using the specified properties.
             * @function create
             * @memberof protos.records.ReadRecord
             * @static
             * @param {protos.records.IReadRecord=} [properties] Properties to set
             * @returns {protos.records.ReadRecord} ReadRecord instance
             */
            ReadRecord.create = function create(properties) {
                return new ReadRecord(properties);
            };

            /**
             * Encodes the specified ReadRecord message. Does not implicitly {@link protos.records.ReadRecord.verify|verify} messages.
             * @function encode
             * @memberof protos.records.ReadRecord
             * @static
             * @param {protos.records.IReadRecord} message ReadRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadRecord.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.messageId);
                if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.num);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    for (let keys = Object.keys(message.metadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.metadata[keys[i]]).ldelim();
                if (message.receivedAtUnixTsUtc != null && Object.hasOwnProperty.call(message, "receivedAtUnixTsUtc"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.receivedAtUnixTsUtc);
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 99, wireType 2 =*/794).bytes(message.payload);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.records.Kafka.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message._raw != null && Object.hasOwnProperty.call(message, "_raw"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).bytes(message._raw);
                if (message._plumberId != null && Object.hasOwnProperty.call(message, "_plumberId"))
                    writer.uint32(/* id 1001, wireType 2 =*/8010).string(message._plumberId);
                return writer;
            };

            /**
             * Encodes the specified ReadRecord message, length delimited. Does not implicitly {@link protos.records.ReadRecord.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.ReadRecord
             * @static
             * @param {protos.records.IReadRecord} message ReadRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadRecord.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadRecord message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.ReadRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.ReadRecord} ReadRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadRecord.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.ReadRecord(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageId = reader.string();
                        break;
                    case 3:
                        message.num = reader.int64();
                        break;
                    case 4:
                        if (message.metadata === $util.emptyObject)
                            message.metadata = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.metadata[key] = value;
                        break;
                    case 6:
                        message.receivedAtUnixTsUtc = reader.int64();
                        break;
                    case 99:
                        message.payload = reader.bytes();
                        break;
                    case 100:
                        message.kafka = $root.protos.records.Kafka.decode(reader, reader.uint32());
                        break;
                    case 1000:
                        message._raw = reader.bytes();
                        break;
                    case 1001:
                        message._plumberId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadRecord message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.ReadRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.ReadRecord} ReadRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadRecord.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadRecord message.
             * @function verify
             * @memberof protos.records.ReadRecord
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadRecord.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                if (message.num != null && message.hasOwnProperty("num"))
                    if (!$util.isInteger(message.num) && !(message.num && $util.isInteger(message.num.low) && $util.isInteger(message.num.high)))
                        return "num: integer|Long expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    if (!$util.isObject(message.metadata))
                        return "metadata: object expected";
                    let key = Object.keys(message.metadata);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isString(message.metadata[key[i]]))
                            return "metadata: string{k:string} expected";
                }
                if (message.receivedAtUnixTsUtc != null && message.hasOwnProperty("receivedAtUnixTsUtc"))
                    if (!$util.isInteger(message.receivedAtUnixTsUtc) && !(message.receivedAtUnixTsUtc && $util.isInteger(message.receivedAtUnixTsUtc.low) && $util.isInteger(message.receivedAtUnixTsUtc.high)))
                        return "receivedAtUnixTsUtc: integer|Long expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    properties.Record = 1;
                    {
                        let error = $root.protos.records.Kafka.verify(message.kafka);
                        if (error)
                            return "kafka." + error;
                    }
                }
                if (message._raw != null && message.hasOwnProperty("_raw"))
                    if (!(message._raw && typeof message._raw.length === "number" || $util.isString(message._raw)))
                        return "_raw: buffer expected";
                if (message._plumberId != null && message.hasOwnProperty("_plumberId"))
                    if (!$util.isString(message._plumberId))
                        return "_plumberId: string expected";
                return null;
            };

            /**
             * Creates a ReadRecord message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.ReadRecord
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.ReadRecord} ReadRecord
             */
            ReadRecord.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.ReadRecord)
                    return object;
                let message = new $root.protos.records.ReadRecord();
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.num != null)
                    if ($util.Long)
                        (message.num = $util.Long.fromValue(object.num)).unsigned = false;
                    else if (typeof object.num === "string")
                        message.num = parseInt(object.num, 10);
                    else if (typeof object.num === "number")
                        message.num = object.num;
                    else if (typeof object.num === "object")
                        message.num = new $util.LongBits(object.num.low >>> 0, object.num.high >>> 0).toNumber();
                if (object.metadata) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".protos.records.ReadRecord.metadata: object expected");
                    message.metadata = {};
                    for (let keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i)
                        message.metadata[keys[i]] = String(object.metadata[keys[i]]);
                }
                if (object.receivedAtUnixTsUtc != null)
                    if ($util.Long)
                        (message.receivedAtUnixTsUtc = $util.Long.fromValue(object.receivedAtUnixTsUtc)).unsigned = false;
                    else if (typeof object.receivedAtUnixTsUtc === "string")
                        message.receivedAtUnixTsUtc = parseInt(object.receivedAtUnixTsUtc, 10);
                    else if (typeof object.receivedAtUnixTsUtc === "number")
                        message.receivedAtUnixTsUtc = object.receivedAtUnixTsUtc;
                    else if (typeof object.receivedAtUnixTsUtc === "object")
                        message.receivedAtUnixTsUtc = new $util.LongBits(object.receivedAtUnixTsUtc.low >>> 0, object.receivedAtUnixTsUtc.high >>> 0).toNumber();
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.records.ReadRecord.kafka: object expected");
                    message.kafka = $root.protos.records.Kafka.fromObject(object.kafka);
                }
                if (object._raw != null)
                    if (typeof object._raw === "string")
                        $util.base64.decode(object._raw, message._raw = $util.newBuffer($util.base64.length(object._raw)), 0);
                    else if (object._raw.length)
                        message._raw = object._raw;
                if (object._plumberId != null)
                    message._plumberId = String(object._plumberId);
                return message;
            };

            /**
             * Creates a plain object from a ReadRecord message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.ReadRecord
             * @static
             * @param {protos.records.ReadRecord} message ReadRecord
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadRecord.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults)
                    object.metadata = {};
                if (options.defaults) {
                    object.messageId = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.num = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.receivedAtUnixTsUtc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.receivedAtUnixTsUtc = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    if (options.bytes === String)
                        object._raw = "";
                    else {
                        object._raw = [];
                        if (options.bytes !== Array)
                            object._raw = $util.newBuffer(object._raw);
                    }
                    object._plumberId = "";
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                if (message.num != null && message.hasOwnProperty("num"))
                    if (typeof message.num === "number")
                        object.num = options.longs === String ? String(message.num) : message.num;
                    else
                        object.num = options.longs === String ? $util.Long.prototype.toString.call(message.num) : options.longs === Number ? new $util.LongBits(message.num.low >>> 0, message.num.high >>> 0).toNumber() : message.num;
                let keys2;
                if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                    object.metadata = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.metadata[keys2[j]] = message.metadata[keys2[j]];
                }
                if (message.receivedAtUnixTsUtc != null && message.hasOwnProperty("receivedAtUnixTsUtc"))
                    if (typeof message.receivedAtUnixTsUtc === "number")
                        object.receivedAtUnixTsUtc = options.longs === String ? String(message.receivedAtUnixTsUtc) : message.receivedAtUnixTsUtc;
                    else
                        object.receivedAtUnixTsUtc = options.longs === String ? $util.Long.prototype.toString.call(message.receivedAtUnixTsUtc) : options.longs === Number ? new $util.LongBits(message.receivedAtUnixTsUtc.low >>> 0, message.receivedAtUnixTsUtc.high >>> 0).toNumber() : message.receivedAtUnixTsUtc;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    object.kafka = $root.protos.records.Kafka.toObject(message.kafka, options);
                    if (options.oneofs)
                        object.Record = "kafka";
                }
                if (message._raw != null && message.hasOwnProperty("_raw"))
                    object._raw = options.bytes === String ? $util.base64.encode(message._raw, 0, message._raw.length) : options.bytes === Array ? Array.prototype.slice.call(message._raw) : message._raw;
                if (message._plumberId != null && message.hasOwnProperty("_plumberId"))
                    object._plumberId = message._plumberId;
                return object;
            };

            /**
             * Converts this ReadRecord to JSON.
             * @function toJSON
             * @memberof protos.records.ReadRecord
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadRecord.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadRecord;
        })();

        records.WriteRecord = (function() {

            /**
             * Properties of a WriteRecord.
             * @memberof protos.records
             * @interface IWriteRecord
             * @property {string|null} [input] WriteRecord input
             * @property {Object.<string,string>|null} [inputMetadata] WriteRecord inputMetadata
             */

            /**
             * Constructs a new WriteRecord.
             * @memberof protos.records
             * @classdesc Represents a WriteRecord.
             * @implements IWriteRecord
             * @constructor
             * @param {protos.records.IWriteRecord=} [properties] Properties to set
             */
            function WriteRecord(properties) {
                this.inputMetadata = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteRecord input.
             * @member {string} input
             * @memberof protos.records.WriteRecord
             * @instance
             */
            WriteRecord.prototype.input = "";

            /**
             * WriteRecord inputMetadata.
             * @member {Object.<string,string>} inputMetadata
             * @memberof protos.records.WriteRecord
             * @instance
             */
            WriteRecord.prototype.inputMetadata = $util.emptyObject;

            /**
             * Creates a new WriteRecord instance using the specified properties.
             * @function create
             * @memberof protos.records.WriteRecord
             * @static
             * @param {protos.records.IWriteRecord=} [properties] Properties to set
             * @returns {protos.records.WriteRecord} WriteRecord instance
             */
            WriteRecord.create = function create(properties) {
                return new WriteRecord(properties);
            };

            /**
             * Encodes the specified WriteRecord message. Does not implicitly {@link protos.records.WriteRecord.verify|verify} messages.
             * @function encode
             * @memberof protos.records.WriteRecord
             * @static
             * @param {protos.records.IWriteRecord} message WriteRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteRecord.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.input != null && Object.hasOwnProperty.call(message, "input"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.input);
                if (message.inputMetadata != null && Object.hasOwnProperty.call(message, "inputMetadata"))
                    for (let keys = Object.keys(message.inputMetadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.inputMetadata[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteRecord message, length delimited. Does not implicitly {@link protos.records.WriteRecord.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.WriteRecord
             * @static
             * @param {protos.records.IWriteRecord} message WriteRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteRecord.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteRecord message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.WriteRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.WriteRecord} WriteRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteRecord.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.WriteRecord(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.input = reader.string();
                        break;
                    case 2:
                        if (message.inputMetadata === $util.emptyObject)
                            message.inputMetadata = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.inputMetadata[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteRecord message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.WriteRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.WriteRecord} WriteRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteRecord.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteRecord message.
             * @function verify
             * @memberof protos.records.WriteRecord
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteRecord.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.input != null && message.hasOwnProperty("input"))
                    if (!$util.isString(message.input))
                        return "input: string expected";
                if (message.inputMetadata != null && message.hasOwnProperty("inputMetadata")) {
                    if (!$util.isObject(message.inputMetadata))
                        return "inputMetadata: object expected";
                    let key = Object.keys(message.inputMetadata);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isString(message.inputMetadata[key[i]]))
                            return "inputMetadata: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a WriteRecord message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.WriteRecord
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.WriteRecord} WriteRecord
             */
            WriteRecord.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.WriteRecord)
                    return object;
                let message = new $root.protos.records.WriteRecord();
                if (object.input != null)
                    message.input = String(object.input);
                if (object.inputMetadata) {
                    if (typeof object.inputMetadata !== "object")
                        throw TypeError(".protos.records.WriteRecord.inputMetadata: object expected");
                    message.inputMetadata = {};
                    for (let keys = Object.keys(object.inputMetadata), i = 0; i < keys.length; ++i)
                        message.inputMetadata[keys[i]] = String(object.inputMetadata[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteRecord message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.WriteRecord
             * @static
             * @param {protos.records.WriteRecord} message WriteRecord
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteRecord.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults)
                    object.inputMetadata = {};
                if (options.defaults)
                    object.input = "";
                if (message.input != null && message.hasOwnProperty("input"))
                    object.input = message.input;
                let keys2;
                if (message.inputMetadata && (keys2 = Object.keys(message.inputMetadata)).length) {
                    object.inputMetadata = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.inputMetadata[keys2[j]] = message.inputMetadata[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this WriteRecord to JSON.
             * @function toJSON
             * @memberof protos.records.WriteRecord
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteRecord.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteRecord;
        })();

        records.ErrorRecord = (function() {

            /**
             * Properties of an ErrorRecord.
             * @memberof protos.records
             * @interface IErrorRecord
             * @property {number|Long|null} [occurredAtUnixTsUtc] ErrorRecord occurredAtUnixTsUtc
             * @property {string|null} [error] ErrorRecord error
             * @property {Object.<string,Uint8Array>|null} [metadata] ErrorRecord metadata
             */

            /**
             * Constructs a new ErrorRecord.
             * @memberof protos.records
             * @classdesc Represents an ErrorRecord.
             * @implements IErrorRecord
             * @constructor
             * @param {protos.records.IErrorRecord=} [properties] Properties to set
             */
            function ErrorRecord(properties) {
                this.metadata = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ErrorRecord occurredAtUnixTsUtc.
             * @member {number|Long} occurredAtUnixTsUtc
             * @memberof protos.records.ErrorRecord
             * @instance
             */
            ErrorRecord.prototype.occurredAtUnixTsUtc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ErrorRecord error.
             * @member {string} error
             * @memberof protos.records.ErrorRecord
             * @instance
             */
            ErrorRecord.prototype.error = "";

            /**
             * ErrorRecord metadata.
             * @member {Object.<string,Uint8Array>} metadata
             * @memberof protos.records.ErrorRecord
             * @instance
             */
            ErrorRecord.prototype.metadata = $util.emptyObject;

            /**
             * Creates a new ErrorRecord instance using the specified properties.
             * @function create
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {protos.records.IErrorRecord=} [properties] Properties to set
             * @returns {protos.records.ErrorRecord} ErrorRecord instance
             */
            ErrorRecord.create = function create(properties) {
                return new ErrorRecord(properties);
            };

            /**
             * Encodes the specified ErrorRecord message. Does not implicitly {@link protos.records.ErrorRecord.verify|verify} messages.
             * @function encode
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {protos.records.IErrorRecord} message ErrorRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorRecord.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.occurredAtUnixTsUtc != null && Object.hasOwnProperty.call(message, "occurredAtUnixTsUtc"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.occurredAtUnixTsUtc);
                if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.error);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    for (let keys = Object.keys(message.metadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).bytes(message.metadata[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ErrorRecord message, length delimited. Does not implicitly {@link protos.records.ErrorRecord.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {protos.records.IErrorRecord} message ErrorRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorRecord.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ErrorRecord message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.ErrorRecord} ErrorRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorRecord.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.ErrorRecord(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.occurredAtUnixTsUtc = reader.int64();
                        break;
                    case 2:
                        message.error = reader.string();
                        break;
                    case 3:
                        if (message.metadata === $util.emptyObject)
                            message.metadata = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = [];
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.metadata[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ErrorRecord message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.ErrorRecord} ErrorRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorRecord.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ErrorRecord message.
             * @function verify
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ErrorRecord.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.occurredAtUnixTsUtc != null && message.hasOwnProperty("occurredAtUnixTsUtc"))
                    if (!$util.isInteger(message.occurredAtUnixTsUtc) && !(message.occurredAtUnixTsUtc && $util.isInteger(message.occurredAtUnixTsUtc.low) && $util.isInteger(message.occurredAtUnixTsUtc.high)))
                        return "occurredAtUnixTsUtc: integer|Long expected";
                if (message.error != null && message.hasOwnProperty("error"))
                    if (!$util.isString(message.error))
                        return "error: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    if (!$util.isObject(message.metadata))
                        return "metadata: object expected";
                    let key = Object.keys(message.metadata);
                    for (let i = 0; i < key.length; ++i)
                        if (!(message.metadata[key[i]] && typeof message.metadata[key[i]].length === "number" || $util.isString(message.metadata[key[i]])))
                            return "metadata: buffer{k:string} expected";
                }
                return null;
            };

            /**
             * Creates an ErrorRecord message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.ErrorRecord} ErrorRecord
             */
            ErrorRecord.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.ErrorRecord)
                    return object;
                let message = new $root.protos.records.ErrorRecord();
                if (object.occurredAtUnixTsUtc != null)
                    if ($util.Long)
                        (message.occurredAtUnixTsUtc = $util.Long.fromValue(object.occurredAtUnixTsUtc)).unsigned = false;
                    else if (typeof object.occurredAtUnixTsUtc === "string")
                        message.occurredAtUnixTsUtc = parseInt(object.occurredAtUnixTsUtc, 10);
                    else if (typeof object.occurredAtUnixTsUtc === "number")
                        message.occurredAtUnixTsUtc = object.occurredAtUnixTsUtc;
                    else if (typeof object.occurredAtUnixTsUtc === "object")
                        message.occurredAtUnixTsUtc = new $util.LongBits(object.occurredAtUnixTsUtc.low >>> 0, object.occurredAtUnixTsUtc.high >>> 0).toNumber();
                if (object.error != null)
                    message.error = String(object.error);
                if (object.metadata) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".protos.records.ErrorRecord.metadata: object expected");
                    message.metadata = {};
                    for (let keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i)
                        if (typeof object.metadata[keys[i]] === "string")
                            $util.base64.decode(object.metadata[keys[i]], message.metadata[keys[i]] = $util.newBuffer($util.base64.length(object.metadata[keys[i]])), 0);
                        else if (object.metadata[keys[i]].length)
                            message.metadata[keys[i]] = object.metadata[keys[i]];
                }
                return message;
            };

            /**
             * Creates a plain object from an ErrorRecord message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {protos.records.ErrorRecord} message ErrorRecord
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ErrorRecord.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults)
                    object.metadata = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.occurredAtUnixTsUtc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.occurredAtUnixTsUtc = options.longs === String ? "0" : 0;
                    object.error = "";
                }
                if (message.occurredAtUnixTsUtc != null && message.hasOwnProperty("occurredAtUnixTsUtc"))
                    if (typeof message.occurredAtUnixTsUtc === "number")
                        object.occurredAtUnixTsUtc = options.longs === String ? String(message.occurredAtUnixTsUtc) : message.occurredAtUnixTsUtc;
                    else
                        object.occurredAtUnixTsUtc = options.longs === String ? $util.Long.prototype.toString.call(message.occurredAtUnixTsUtc) : options.longs === Number ? new $util.LongBits(message.occurredAtUnixTsUtc.low >>> 0, message.occurredAtUnixTsUtc.high >>> 0).toNumber() : message.occurredAtUnixTsUtc;
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = message.error;
                let keys2;
                if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                    object.metadata = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.metadata[keys2[j]] = options.bytes === String ? $util.base64.encode(message.metadata[keys2[j]], 0, message.metadata[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata[keys2[j]]) : message.metadata[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this ErrorRecord to JSON.
             * @function toJSON
             * @memberof protos.records.ErrorRecord
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ErrorRecord.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ErrorRecord;
        })();

        records.KafkaHeader = (function() {

            /**
             * Properties of a KafkaHeader.
             * @memberof protos.records
             * @interface IKafkaHeader
             * @property {string|null} [key] KafkaHeader key
             * @property {string|null} [value] KafkaHeader value
             */

            /**
             * Constructs a new KafkaHeader.
             * @memberof protos.records
             * @classdesc Represents a KafkaHeader.
             * @implements IKafkaHeader
             * @constructor
             * @param {protos.records.IKafkaHeader=} [properties] Properties to set
             */
            function KafkaHeader(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KafkaHeader key.
             * @member {string} key
             * @memberof protos.records.KafkaHeader
             * @instance
             */
            KafkaHeader.prototype.key = "";

            /**
             * KafkaHeader value.
             * @member {string} value
             * @memberof protos.records.KafkaHeader
             * @instance
             */
            KafkaHeader.prototype.value = "";

            /**
             * Creates a new KafkaHeader instance using the specified properties.
             * @function create
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {protos.records.IKafkaHeader=} [properties] Properties to set
             * @returns {protos.records.KafkaHeader} KafkaHeader instance
             */
            KafkaHeader.create = function create(properties) {
                return new KafkaHeader(properties);
            };

            /**
             * Encodes the specified KafkaHeader message. Does not implicitly {@link protos.records.KafkaHeader.verify|verify} messages.
             * @function encode
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {protos.records.IKafkaHeader} message KafkaHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaHeader.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };

            /**
             * Encodes the specified KafkaHeader message, length delimited. Does not implicitly {@link protos.records.KafkaHeader.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {protos.records.IKafkaHeader} message KafkaHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaHeader.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KafkaHeader message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.KafkaHeader} KafkaHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaHeader.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.KafkaHeader();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KafkaHeader message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.KafkaHeader} KafkaHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaHeader.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KafkaHeader message.
             * @function verify
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaHeader.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };

            /**
             * Creates a KafkaHeader message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.KafkaHeader} KafkaHeader
             */
            KafkaHeader.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.KafkaHeader)
                    return object;
                let message = new $root.protos.records.KafkaHeader();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };

            /**
             * Creates a plain object from a KafkaHeader message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {protos.records.KafkaHeader} message KafkaHeader
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaHeader.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.key = "";
                    object.value = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this KafkaHeader to JSON.
             * @function toJSON
             * @memberof protos.records.KafkaHeader
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaHeader.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KafkaHeader;
        })();

        records.Kafka = (function() {

            /**
             * Properties of a Kafka.
             * @memberof protos.records
             * @interface IKafka
             * @property {string|null} [topic] Kafka topic
             * @property {Uint8Array|null} [key] Kafka key
             * @property {Uint8Array|null} [value] Kafka value
             * @property {number|Long|null} [timestamp] Kafka timestamp
             * @property {number|Long|null} [offset] Kafka offset
             * @property {number|null} [partition] Kafka partition
             * @property {Array.<protos.records.IKafkaHeader>|null} [headers] Kafka headers
             */

            /**
             * Constructs a new Kafka.
             * @memberof protos.records
             * @classdesc Represents a Kafka.
             * @implements IKafka
             * @constructor
             * @param {protos.records.IKafka=} [properties] Properties to set
             */
            function Kafka(properties) {
                this.headers = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Kafka topic.
             * @member {string} topic
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.topic = "";

            /**
             * Kafka key.
             * @member {Uint8Array} key
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.key = $util.newBuffer([]);

            /**
             * Kafka value.
             * @member {Uint8Array} value
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.value = $util.newBuffer([]);

            /**
             * Kafka timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Kafka offset.
             * @member {number|Long} offset
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.offset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Kafka partition.
             * @member {number} partition
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.partition = 0;

            /**
             * Kafka headers.
             * @member {Array.<protos.records.IKafkaHeader>} headers
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.headers = $util.emptyArray;

            /**
             * Creates a new Kafka instance using the specified properties.
             * @function create
             * @memberof protos.records.Kafka
             * @static
             * @param {protos.records.IKafka=} [properties] Properties to set
             * @returns {protos.records.Kafka} Kafka instance
             */
            Kafka.create = function create(properties) {
                return new Kafka(properties);
            };

            /**
             * Encodes the specified Kafka message. Does not implicitly {@link protos.records.Kafka.verify|verify} messages.
             * @function encode
             * @memberof protos.records.Kafka
             * @static
             * @param {protos.records.IKafka} message Kafka message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Kafka.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestamp);
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.offset);
                if (message.partition != null && Object.hasOwnProperty.call(message, "partition"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.partition);
                if (message.headers != null && message.headers.length)
                    for (let i = 0; i < message.headers.length; ++i)
                        $root.protos.records.KafkaHeader.encode(message.headers[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Kafka message, length delimited. Does not implicitly {@link protos.records.Kafka.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.Kafka
             * @static
             * @param {protos.records.IKafka} message Kafka message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Kafka.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Kafka message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.Kafka
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.Kafka} Kafka
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Kafka.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.Kafka();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.key = reader.bytes();
                        break;
                    case 3:
                        message.value = reader.bytes();
                        break;
                    case 4:
                        message.timestamp = reader.int64();
                        break;
                    case 5:
                        message.offset = reader.int64();
                        break;
                    case 6:
                        message.partition = reader.int32();
                        break;
                    case 7:
                        if (!(message.headers && message.headers.length))
                            message.headers = [];
                        message.headers.push($root.protos.records.KafkaHeader.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Kafka message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.Kafka
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.Kafka} Kafka
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Kafka.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Kafka message.
             * @function verify
             * @memberof protos.records.Kafka
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Kafka.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high)))
                        return "offset: integer|Long expected";
                if (message.partition != null && message.hasOwnProperty("partition"))
                    if (!$util.isInteger(message.partition))
                        return "partition: integer expected";
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    if (!Array.isArray(message.headers))
                        return "headers: array expected";
                    for (let i = 0; i < message.headers.length; ++i) {
                        let error = $root.protos.records.KafkaHeader.verify(message.headers[i]);
                        if (error)
                            return "headers." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Kafka message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.Kafka
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.Kafka} Kafka
             */
            Kafka.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.Kafka)
                    return object;
                let message = new $root.protos.records.Kafka();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length)
                        message.key = object.key;
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.offset != null)
                    if ($util.Long)
                        (message.offset = $util.Long.fromValue(object.offset)).unsigned = false;
                    else if (typeof object.offset === "string")
                        message.offset = parseInt(object.offset, 10);
                    else if (typeof object.offset === "number")
                        message.offset = object.offset;
                    else if (typeof object.offset === "object")
                        message.offset = new $util.LongBits(object.offset.low >>> 0, object.offset.high >>> 0).toNumber();
                if (object.partition != null)
                    message.partition = object.partition | 0;
                if (object.headers) {
                    if (!Array.isArray(object.headers))
                        throw TypeError(".protos.records.Kafka.headers: array expected");
                    message.headers = [];
                    for (let i = 0; i < object.headers.length; ++i) {
                        if (typeof object.headers[i] !== "object")
                            throw TypeError(".protos.records.Kafka.headers: object expected");
                        message.headers[i] = $root.protos.records.KafkaHeader.fromObject(object.headers[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Kafka message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.Kafka
             * @static
             * @param {protos.records.Kafka} message Kafka
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Kafka.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.headers = [];
                if (options.defaults) {
                    object.topic = "";
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.offset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.offset = options.longs === String ? "0" : 0;
                    object.partition = 0;
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (typeof message.offset === "number")
                        object.offset = options.longs === String ? String(message.offset) : message.offset;
                    else
                        object.offset = options.longs === String ? $util.Long.prototype.toString.call(message.offset) : options.longs === Number ? new $util.LongBits(message.offset.low >>> 0, message.offset.high >>> 0).toNumber() : message.offset;
                if (message.partition != null && message.hasOwnProperty("partition"))
                    object.partition = message.partition;
                if (message.headers && message.headers.length) {
                    object.headers = [];
                    for (let j = 0; j < message.headers.length; ++j)
                        object.headers[j] = $root.protos.records.KafkaHeader.toObject(message.headers[j], options);
                }
                return object;
            };

            /**
             * Converts this Kafka to JSON.
             * @function toJSON
             * @memberof protos.records.Kafka
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Kafka.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Kafka;
        })();

        return records;
    })();

    return protos;
})();

export { $root as default };
