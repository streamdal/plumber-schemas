/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.protos = (function() {

    /**
     * Namespace protos.
     * @exports protos
     * @namespace
     */
    var protos = {};

    protos.PlumberServer = (function() {

        /**
         * Constructs a new PlumberServer service.
         * @memberof protos
         * @classdesc Represents a PlumberServer
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function PlumberServer(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (PlumberServer.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = PlumberServer;

        /**
         * Creates new PlumberServer service using the specified rpc implementation.
         * @function create
         * @memberof protos.PlumberServer
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {PlumberServer} RPC service. Useful where requests and/or responses are streamed.
         */
        PlumberServer.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link protos.PlumberServer#getAllConnections}.
         * @memberof protos.PlumberServer
         * @typedef GetAllConnectionsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetAllConnectionsResponse} [response] GetAllConnectionsResponse
         */

        /**
         * Calls GetAllConnections.
         * @function getAllConnections
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllConnectionsRequest} request GetAllConnectionsRequest message or plain object
         * @param {protos.PlumberServer.GetAllConnectionsCallback} callback Node-style callback called with the error, if any, and GetAllConnectionsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getAllConnections = function getAllConnections(request, callback) {
            return this.rpcCall(getAllConnections, $root.protos.GetAllConnectionsRequest, $root.protos.GetAllConnectionsResponse, request, callback);
        }, "name", { value: "GetAllConnections" });

        /**
         * Calls GetAllConnections.
         * @function getAllConnections
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllConnectionsRequest} request GetAllConnectionsRequest message or plain object
         * @returns {Promise<protos.GetAllConnectionsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getConnection}.
         * @memberof protos.PlumberServer
         * @typedef GetConnectionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetConnectionResponse} [response] GetConnectionResponse
         */

        /**
         * Calls GetConnection.
         * @function getConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetConnectionRequest} request GetConnectionRequest message or plain object
         * @param {protos.PlumberServer.GetConnectionCallback} callback Node-style callback called with the error, if any, and GetConnectionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getConnection = function getConnection(request, callback) {
            return this.rpcCall(getConnection, $root.protos.GetConnectionRequest, $root.protos.GetConnectionResponse, request, callback);
        }, "name", { value: "GetConnection" });

        /**
         * Calls GetConnection.
         * @function getConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetConnectionRequest} request GetConnectionRequest message or plain object
         * @returns {Promise<protos.GetConnectionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#createConnection}.
         * @memberof protos.PlumberServer
         * @typedef CreateConnectionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.CreateConnectionResponse} [response] CreateConnectionResponse
         */

        /**
         * Calls CreateConnection.
         * @function createConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateConnectionRequest} request CreateConnectionRequest message or plain object
         * @param {protos.PlumberServer.CreateConnectionCallback} callback Node-style callback called with the error, if any, and CreateConnectionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.createConnection = function createConnection(request, callback) {
            return this.rpcCall(createConnection, $root.protos.CreateConnectionRequest, $root.protos.CreateConnectionResponse, request, callback);
        }, "name", { value: "CreateConnection" });

        /**
         * Calls CreateConnection.
         * @function createConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateConnectionRequest} request CreateConnectionRequest message or plain object
         * @returns {Promise<protos.CreateConnectionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#testConnection}.
         * @memberof protos.PlumberServer
         * @typedef TestConnectionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.TestConnectionResponse} [response] TestConnectionResponse
         */

        /**
         * Calls TestConnection.
         * @function testConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ITestConnectionRequest} request TestConnectionRequest message or plain object
         * @param {protos.PlumberServer.TestConnectionCallback} callback Node-style callback called with the error, if any, and TestConnectionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.testConnection = function testConnection(request, callback) {
            return this.rpcCall(testConnection, $root.protos.TestConnectionRequest, $root.protos.TestConnectionResponse, request, callback);
        }, "name", { value: "TestConnection" });

        /**
         * Calls TestConnection.
         * @function testConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ITestConnectionRequest} request TestConnectionRequest message or plain object
         * @returns {Promise<protos.TestConnectionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#updateConnection}.
         * @memberof protos.PlumberServer
         * @typedef UpdateConnectionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.UpdateConnectionResponse} [response] UpdateConnectionResponse
         */

        /**
         * Calls UpdateConnection.
         * @function updateConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateConnectionRequest} request UpdateConnectionRequest message or plain object
         * @param {protos.PlumberServer.UpdateConnectionCallback} callback Node-style callback called with the error, if any, and UpdateConnectionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.updateConnection = function updateConnection(request, callback) {
            return this.rpcCall(updateConnection, $root.protos.UpdateConnectionRequest, $root.protos.UpdateConnectionResponse, request, callback);
        }, "name", { value: "UpdateConnection" });

        /**
         * Calls UpdateConnection.
         * @function updateConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateConnectionRequest} request UpdateConnectionRequest message or plain object
         * @returns {Promise<protos.UpdateConnectionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#deleteConnection}.
         * @memberof protos.PlumberServer
         * @typedef DeleteConnectionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.DeleteConnectionResponse} [response] DeleteConnectionResponse
         */

        /**
         * Calls DeleteConnection.
         * @function deleteConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteConnectionRequest} request DeleteConnectionRequest message or plain object
         * @param {protos.PlumberServer.DeleteConnectionCallback} callback Node-style callback called with the error, if any, and DeleteConnectionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.deleteConnection = function deleteConnection(request, callback) {
            return this.rpcCall(deleteConnection, $root.protos.DeleteConnectionRequest, $root.protos.DeleteConnectionResponse, request, callback);
        }, "name", { value: "DeleteConnection" });

        /**
         * Calls DeleteConnection.
         * @function deleteConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteConnectionRequest} request DeleteConnectionRequest message or plain object
         * @returns {Promise<protos.DeleteConnectionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getAllRelays}.
         * @memberof protos.PlumberServer
         * @typedef GetAllRelaysCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetAllRelaysResponse} [response] GetAllRelaysResponse
         */

        /**
         * Calls GetAllRelays.
         * @function getAllRelays
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllRelaysRequest} request GetAllRelaysRequest message or plain object
         * @param {protos.PlumberServer.GetAllRelaysCallback} callback Node-style callback called with the error, if any, and GetAllRelaysResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getAllRelays = function getAllRelays(request, callback) {
            return this.rpcCall(getAllRelays, $root.protos.GetAllRelaysRequest, $root.protos.GetAllRelaysResponse, request, callback);
        }, "name", { value: "GetAllRelays" });

        /**
         * Calls GetAllRelays.
         * @function getAllRelays
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllRelaysRequest} request GetAllRelaysRequest message or plain object
         * @returns {Promise<protos.GetAllRelaysResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getRelay}.
         * @memberof protos.PlumberServer
         * @typedef GetRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetRelayResponse} [response] GetRelayResponse
         */

        /**
         * Calls GetRelay.
         * @function getRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetRelayRequest} request GetRelayRequest message or plain object
         * @param {protos.PlumberServer.GetRelayCallback} callback Node-style callback called with the error, if any, and GetRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getRelay = function getRelay(request, callback) {
            return this.rpcCall(getRelay, $root.protos.GetRelayRequest, $root.protos.GetRelayResponse, request, callback);
        }, "name", { value: "GetRelay" });

        /**
         * Calls GetRelay.
         * @function getRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetRelayRequest} request GetRelayRequest message or plain object
         * @returns {Promise<protos.GetRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#createRelay}.
         * @memberof protos.PlumberServer
         * @typedef CreateRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.CreateRelayResponse} [response] CreateRelayResponse
         */

        /**
         * Calls CreateRelay.
         * @function createRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateRelayRequest} request CreateRelayRequest message or plain object
         * @param {protos.PlumberServer.CreateRelayCallback} callback Node-style callback called with the error, if any, and CreateRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.createRelay = function createRelay(request, callback) {
            return this.rpcCall(createRelay, $root.protos.CreateRelayRequest, $root.protos.CreateRelayResponse, request, callback);
        }, "name", { value: "CreateRelay" });

        /**
         * Calls CreateRelay.
         * @function createRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateRelayRequest} request CreateRelayRequest message or plain object
         * @returns {Promise<protos.CreateRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#updateRelay}.
         * @memberof protos.PlumberServer
         * @typedef UpdateRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.UpdateRelayResponse} [response] UpdateRelayResponse
         */

        /**
         * Calls UpdateRelay.
         * @function updateRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateRelayRequest} request UpdateRelayRequest message or plain object
         * @param {protos.PlumberServer.UpdateRelayCallback} callback Node-style callback called with the error, if any, and UpdateRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.updateRelay = function updateRelay(request, callback) {
            return this.rpcCall(updateRelay, $root.protos.UpdateRelayRequest, $root.protos.UpdateRelayResponse, request, callback);
        }, "name", { value: "UpdateRelay" });

        /**
         * Calls UpdateRelay.
         * @function updateRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateRelayRequest} request UpdateRelayRequest message or plain object
         * @returns {Promise<protos.UpdateRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#resumeRelay}.
         * @memberof protos.PlumberServer
         * @typedef ResumeRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.ResumeRelayResponse} [response] ResumeRelayResponse
         */

        /**
         * Calls ResumeRelay.
         * @function resumeRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IResumeRelayRequest} request ResumeRelayRequest message or plain object
         * @param {protos.PlumberServer.ResumeRelayCallback} callback Node-style callback called with the error, if any, and ResumeRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.resumeRelay = function resumeRelay(request, callback) {
            return this.rpcCall(resumeRelay, $root.protos.ResumeRelayRequest, $root.protos.ResumeRelayResponse, request, callback);
        }, "name", { value: "ResumeRelay" });

        /**
         * Calls ResumeRelay.
         * @function resumeRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IResumeRelayRequest} request ResumeRelayRequest message or plain object
         * @returns {Promise<protos.ResumeRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#stopRelay}.
         * @memberof protos.PlumberServer
         * @typedef StopRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.StopRelayResponse} [response] StopRelayResponse
         */

        /**
         * Calls StopRelay.
         * @function stopRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IStopRelayRequest} request StopRelayRequest message or plain object
         * @param {protos.PlumberServer.StopRelayCallback} callback Node-style callback called with the error, if any, and StopRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.stopRelay = function stopRelay(request, callback) {
            return this.rpcCall(stopRelay, $root.protos.StopRelayRequest, $root.protos.StopRelayResponse, request, callback);
        }, "name", { value: "StopRelay" });

        /**
         * Calls StopRelay.
         * @function stopRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IStopRelayRequest} request StopRelayRequest message or plain object
         * @returns {Promise<protos.StopRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#deleteRelay}.
         * @memberof protos.PlumberServer
         * @typedef DeleteRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.DeleteRelayResponse} [response] DeleteRelayResponse
         */

        /**
         * Calls DeleteRelay.
         * @function deleteRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteRelayRequest} request DeleteRelayRequest message or plain object
         * @param {protos.PlumberServer.DeleteRelayCallback} callback Node-style callback called with the error, if any, and DeleteRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.deleteRelay = function deleteRelay(request, callback) {
            return this.rpcCall(deleteRelay, $root.protos.DeleteRelayRequest, $root.protos.DeleteRelayResponse, request, callback);
        }, "name", { value: "DeleteRelay" });

        /**
         * Calls DeleteRelay.
         * @function deleteRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteRelayRequest} request DeleteRelayRequest message or plain object
         * @returns {Promise<protos.DeleteRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getTunnel}.
         * @memberof protos.PlumberServer
         * @typedef GetTunnelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetTunnelResponse} [response] GetTunnelResponse
         */

        /**
         * Calls GetTunnel.
         * @function getTunnel
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetTunnelRequest} request GetTunnelRequest message or plain object
         * @param {protos.PlumberServer.GetTunnelCallback} callback Node-style callback called with the error, if any, and GetTunnelResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getTunnel = function getTunnel(request, callback) {
            return this.rpcCall(getTunnel, $root.protos.GetTunnelRequest, $root.protos.GetTunnelResponse, request, callback);
        }, "name", { value: "GetTunnel" });

        /**
         * Calls GetTunnel.
         * @function getTunnel
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetTunnelRequest} request GetTunnelRequest message or plain object
         * @returns {Promise<protos.GetTunnelResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getAllTunnels}.
         * @memberof protos.PlumberServer
         * @typedef GetAllTunnelsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetAllTunnelsResponse} [response] GetAllTunnelsResponse
         */

        /**
         * Calls GetAllTunnels.
         * @function getAllTunnels
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllTunnelsRequest} request GetAllTunnelsRequest message or plain object
         * @param {protos.PlumberServer.GetAllTunnelsCallback} callback Node-style callback called with the error, if any, and GetAllTunnelsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getAllTunnels = function getAllTunnels(request, callback) {
            return this.rpcCall(getAllTunnels, $root.protos.GetAllTunnelsRequest, $root.protos.GetAllTunnelsResponse, request, callback);
        }, "name", { value: "GetAllTunnels" });

        /**
         * Calls GetAllTunnels.
         * @function getAllTunnels
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllTunnelsRequest} request GetAllTunnelsRequest message or plain object
         * @returns {Promise<protos.GetAllTunnelsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#createTunnel}.
         * @memberof protos.PlumberServer
         * @typedef CreateTunnelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.CreateTunnelResponse} [response] CreateTunnelResponse
         */

        /**
         * Calls CreateTunnel.
         * @function createTunnel
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateTunnelRequest} request CreateTunnelRequest message or plain object
         * @param {protos.PlumberServer.CreateTunnelCallback} callback Node-style callback called with the error, if any, and CreateTunnelResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.createTunnel = function createTunnel(request, callback) {
            return this.rpcCall(createTunnel, $root.protos.CreateTunnelRequest, $root.protos.CreateTunnelResponse, request, callback);
        }, "name", { value: "CreateTunnel" });

        /**
         * Calls CreateTunnel.
         * @function createTunnel
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateTunnelRequest} request CreateTunnelRequest message or plain object
         * @returns {Promise<protos.CreateTunnelResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#stopTunnel}.
         * @memberof protos.PlumberServer
         * @typedef StopTunnelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.StopTunnelResponse} [response] StopTunnelResponse
         */

        /**
         * Calls StopTunnel.
         * @function stopTunnel
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IStopTunnelRequest} request StopTunnelRequest message or plain object
         * @param {protos.PlumberServer.StopTunnelCallback} callback Node-style callback called with the error, if any, and StopTunnelResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.stopTunnel = function stopTunnel(request, callback) {
            return this.rpcCall(stopTunnel, $root.protos.StopTunnelRequest, $root.protos.StopTunnelResponse, request, callback);
        }, "name", { value: "StopTunnel" });

        /**
         * Calls StopTunnel.
         * @function stopTunnel
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IStopTunnelRequest} request StopTunnelRequest message or plain object
         * @returns {Promise<protos.StopTunnelResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#resumeTunnel}.
         * @memberof protos.PlumberServer
         * @typedef ResumeTunnelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.ResumeTunnelResponse} [response] ResumeTunnelResponse
         */

        /**
         * Calls ResumeTunnel.
         * @function resumeTunnel
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IResumeTunnelRequest} request ResumeTunnelRequest message or plain object
         * @param {protos.PlumberServer.ResumeTunnelCallback} callback Node-style callback called with the error, if any, and ResumeTunnelResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.resumeTunnel = function resumeTunnel(request, callback) {
            return this.rpcCall(resumeTunnel, $root.protos.ResumeTunnelRequest, $root.protos.ResumeTunnelResponse, request, callback);
        }, "name", { value: "ResumeTunnel" });

        /**
         * Calls ResumeTunnel.
         * @function resumeTunnel
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IResumeTunnelRequest} request ResumeTunnelRequest message or plain object
         * @returns {Promise<protos.ResumeTunnelResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#updateTunnel}.
         * @memberof protos.PlumberServer
         * @typedef UpdateTunnelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.UpdateTunnelResponse} [response] UpdateTunnelResponse
         */

        /**
         * Calls UpdateTunnel.
         * @function updateTunnel
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateTunnelRequest} request UpdateTunnelRequest message or plain object
         * @param {protos.PlumberServer.UpdateTunnelCallback} callback Node-style callback called with the error, if any, and UpdateTunnelResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.updateTunnel = function updateTunnel(request, callback) {
            return this.rpcCall(updateTunnel, $root.protos.UpdateTunnelRequest, $root.protos.UpdateTunnelResponse, request, callback);
        }, "name", { value: "UpdateTunnel" });

        /**
         * Calls UpdateTunnel.
         * @function updateTunnel
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateTunnelRequest} request UpdateTunnelRequest message or plain object
         * @returns {Promise<protos.UpdateTunnelResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#deleteTunnel}.
         * @memberof protos.PlumberServer
         * @typedef DeleteTunnelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.DeleteTunnelResponse} [response] DeleteTunnelResponse
         */

        /**
         * Calls DeleteTunnel.
         * @function deleteTunnel
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteTunnelRequest} request DeleteTunnelRequest message or plain object
         * @param {protos.PlumberServer.DeleteTunnelCallback} callback Node-style callback called with the error, if any, and DeleteTunnelResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.deleteTunnel = function deleteTunnel(request, callback) {
            return this.rpcCall(deleteTunnel, $root.protos.DeleteTunnelRequest, $root.protos.DeleteTunnelResponse, request, callback);
        }, "name", { value: "DeleteTunnel" });

        /**
         * Calls DeleteTunnel.
         * @function deleteTunnel
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteTunnelRequest} request DeleteTunnelRequest message or plain object
         * @returns {Promise<protos.DeleteTunnelResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getServerOptions}.
         * @memberof protos.PlumberServer
         * @typedef GetServerOptionsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetServerOptionsResponse} [response] GetServerOptionsResponse
         */

        /**
         * Calls GetServerOptions.
         * @function getServerOptions
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetServerOptionsRequest} request GetServerOptionsRequest message or plain object
         * @param {protos.PlumberServer.GetServerOptionsCallback} callback Node-style callback called with the error, if any, and GetServerOptionsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getServerOptions = function getServerOptions(request, callback) {
            return this.rpcCall(getServerOptions, $root.protos.GetServerOptionsRequest, $root.protos.GetServerOptionsResponse, request, callback);
        }, "name", { value: "GetServerOptions" });

        /**
         * Calls GetServerOptions.
         * @function getServerOptions
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetServerOptionsRequest} request GetServerOptionsRequest message or plain object
         * @returns {Promise<protos.GetServerOptionsResponse>} Promise
         * @variation 2
         */

        return PlumberServer;
    })();

    protos.GetAllConnectionsRequest = (function() {

        /**
         * Properties of a GetAllConnectionsRequest.
         * @memberof protos
         * @interface IGetAllConnectionsRequest
         * @property {protos.common.IAuth|null} [auth] GetAllConnectionsRequest auth
         */

        /**
         * Constructs a new GetAllConnectionsRequest.
         * @memberof protos
         * @classdesc Represents a GetAllConnectionsRequest.
         * @implements IGetAllConnectionsRequest
         * @constructor
         * @param {protos.IGetAllConnectionsRequest=} [properties] Properties to set
         */
        function GetAllConnectionsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllConnectionsRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetAllConnectionsRequest
         * @instance
         */
        GetAllConnectionsRequest.prototype.auth = null;

        /**
         * Creates a new GetAllConnectionsRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {protos.IGetAllConnectionsRequest=} [properties] Properties to set
         * @returns {protos.GetAllConnectionsRequest} GetAllConnectionsRequest instance
         */
        GetAllConnectionsRequest.create = function create(properties) {
            return new GetAllConnectionsRequest(properties);
        };

        /**
         * Encodes the specified GetAllConnectionsRequest message. Does not implicitly {@link protos.GetAllConnectionsRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {protos.IGetAllConnectionsRequest} message GetAllConnectionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllConnectionsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllConnectionsRequest message, length delimited. Does not implicitly {@link protos.GetAllConnectionsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {protos.IGetAllConnectionsRequest} message GetAllConnectionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllConnectionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllConnectionsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllConnectionsRequest} GetAllConnectionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllConnectionsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllConnectionsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllConnectionsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllConnectionsRequest} GetAllConnectionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllConnectionsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllConnectionsRequest message.
         * @function verify
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllConnectionsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };

        /**
         * Creates a GetAllConnectionsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllConnectionsRequest} GetAllConnectionsRequest
         */
        GetAllConnectionsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllConnectionsRequest)
                return object;
            var message = new $root.protos.GetAllConnectionsRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetAllConnectionsRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllConnectionsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {protos.GetAllConnectionsRequest} message GetAllConnectionsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllConnectionsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.auth = null;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetAllConnectionsRequest to JSON.
         * @function toJSON
         * @memberof protos.GetAllConnectionsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllConnectionsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllConnectionsRequest;
    })();

    protos.GetAllConnectionsResponse = (function() {

        /**
         * Properties of a GetAllConnectionsResponse.
         * @memberof protos
         * @interface IGetAllConnectionsResponse
         * @property {Array.<protos.opts.IConnectionOptions>|null} [options] GetAllConnectionsResponse options
         */

        /**
         * Constructs a new GetAllConnectionsResponse.
         * @memberof protos
         * @classdesc Represents a GetAllConnectionsResponse.
         * @implements IGetAllConnectionsResponse
         * @constructor
         * @param {protos.IGetAllConnectionsResponse=} [properties] Properties to set
         */
        function GetAllConnectionsResponse(properties) {
            this.options = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllConnectionsResponse options.
         * @member {Array.<protos.opts.IConnectionOptions>} options
         * @memberof protos.GetAllConnectionsResponse
         * @instance
         */
        GetAllConnectionsResponse.prototype.options = $util.emptyArray;

        /**
         * Creates a new GetAllConnectionsResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {protos.IGetAllConnectionsResponse=} [properties] Properties to set
         * @returns {protos.GetAllConnectionsResponse} GetAllConnectionsResponse instance
         */
        GetAllConnectionsResponse.create = function create(properties) {
            return new GetAllConnectionsResponse(properties);
        };

        /**
         * Encodes the specified GetAllConnectionsResponse message. Does not implicitly {@link protos.GetAllConnectionsResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {protos.IGetAllConnectionsResponse} message GetAllConnectionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllConnectionsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.options != null && message.options.length)
                for (var i = 0; i < message.options.length; ++i)
                    $root.protos.opts.ConnectionOptions.encode(message.options[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllConnectionsResponse message, length delimited. Does not implicitly {@link protos.GetAllConnectionsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {protos.IGetAllConnectionsResponse} message GetAllConnectionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllConnectionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllConnectionsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllConnectionsResponse} GetAllConnectionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllConnectionsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllConnectionsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.options && message.options.length))
                        message.options = [];
                    message.options.push($root.protos.opts.ConnectionOptions.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllConnectionsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllConnectionsResponse} GetAllConnectionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllConnectionsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllConnectionsResponse message.
         * @function verify
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllConnectionsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                if (!Array.isArray(message.options))
                    return "options: array expected";
                for (var i = 0; i < message.options.length; ++i) {
                    var error = $root.protos.opts.ConnectionOptions.verify(message.options[i]);
                    if (error)
                        return "options." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetAllConnectionsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllConnectionsResponse} GetAllConnectionsResponse
         */
        GetAllConnectionsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllConnectionsResponse)
                return object;
            var message = new $root.protos.GetAllConnectionsResponse();
            if (object.options) {
                if (!Array.isArray(object.options))
                    throw TypeError(".protos.GetAllConnectionsResponse.options: array expected");
                message.options = [];
                for (var i = 0; i < object.options.length; ++i) {
                    if (typeof object.options[i] !== "object")
                        throw TypeError(".protos.GetAllConnectionsResponse.options: object expected");
                    message.options[i] = $root.protos.opts.ConnectionOptions.fromObject(object.options[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllConnectionsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {protos.GetAllConnectionsResponse} message GetAllConnectionsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllConnectionsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.options = [];
            if (message.options && message.options.length) {
                object.options = [];
                for (var j = 0; j < message.options.length; ++j)
                    object.options[j] = $root.protos.opts.ConnectionOptions.toObject(message.options[j], options);
            }
            return object;
        };

        /**
         * Converts this GetAllConnectionsResponse to JSON.
         * @function toJSON
         * @memberof protos.GetAllConnectionsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllConnectionsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllConnectionsResponse;
    })();

    protos.GetConnectionRequest = (function() {

        /**
         * Properties of a GetConnectionRequest.
         * @memberof protos
         * @interface IGetConnectionRequest
         * @property {protos.common.IAuth|null} [auth] GetConnectionRequest auth
         * @property {string|null} [connectionId] GetConnectionRequest connectionId
         */

        /**
         * Constructs a new GetConnectionRequest.
         * @memberof protos
         * @classdesc Represents a GetConnectionRequest.
         * @implements IGetConnectionRequest
         * @constructor
         * @param {protos.IGetConnectionRequest=} [properties] Properties to set
         */
        function GetConnectionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetConnectionRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetConnectionRequest
         * @instance
         */
        GetConnectionRequest.prototype.auth = null;

        /**
         * GetConnectionRequest connectionId.
         * @member {string} connectionId
         * @memberof protos.GetConnectionRequest
         * @instance
         */
        GetConnectionRequest.prototype.connectionId = "";

        /**
         * Creates a new GetConnectionRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {protos.IGetConnectionRequest=} [properties] Properties to set
         * @returns {protos.GetConnectionRequest} GetConnectionRequest instance
         */
        GetConnectionRequest.create = function create(properties) {
            return new GetConnectionRequest(properties);
        };

        /**
         * Encodes the specified GetConnectionRequest message. Does not implicitly {@link protos.GetConnectionRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {protos.IGetConnectionRequest} message GetConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetConnectionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetConnectionRequest message, length delimited. Does not implicitly {@link protos.GetConnectionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {protos.IGetConnectionRequest} message GetConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetConnectionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetConnectionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetConnectionRequest} GetConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetConnectionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetConnectionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.connectionId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetConnectionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetConnectionRequest} GetConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetConnectionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetConnectionRequest message.
         * @function verify
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetConnectionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                if (!$util.isString(message.connectionId))
                    return "connectionId: string expected";
            return null;
        };

        /**
         * Creates a GetConnectionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetConnectionRequest} GetConnectionRequest
         */
        GetConnectionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetConnectionRequest)
                return object;
            var message = new $root.protos.GetConnectionRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetConnectionRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.connectionId != null)
                message.connectionId = String(object.connectionId);
            return message;
        };

        /**
         * Creates a plain object from a GetConnectionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {protos.GetConnectionRequest} message GetConnectionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetConnectionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.connectionId = "";
                object.auth = null;
            }
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                object.connectionId = message.connectionId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetConnectionRequest to JSON.
         * @function toJSON
         * @memberof protos.GetConnectionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetConnectionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetConnectionRequest;
    })();

    protos.GetConnectionResponse = (function() {

        /**
         * Properties of a GetConnectionResponse.
         * @memberof protos
         * @interface IGetConnectionResponse
         * @property {protos.opts.IConnectionOptions|null} [options] GetConnectionResponse options
         */

        /**
         * Constructs a new GetConnectionResponse.
         * @memberof protos
         * @classdesc Represents a GetConnectionResponse.
         * @implements IGetConnectionResponse
         * @constructor
         * @param {protos.IGetConnectionResponse=} [properties] Properties to set
         */
        function GetConnectionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetConnectionResponse options.
         * @member {protos.opts.IConnectionOptions|null|undefined} options
         * @memberof protos.GetConnectionResponse
         * @instance
         */
        GetConnectionResponse.prototype.options = null;

        /**
         * Creates a new GetConnectionResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {protos.IGetConnectionResponse=} [properties] Properties to set
         * @returns {protos.GetConnectionResponse} GetConnectionResponse instance
         */
        GetConnectionResponse.create = function create(properties) {
            return new GetConnectionResponse(properties);
        };

        /**
         * Encodes the specified GetConnectionResponse message. Does not implicitly {@link protos.GetConnectionResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {protos.IGetConnectionResponse} message GetConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetConnectionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.protos.opts.ConnectionOptions.encode(message.options, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetConnectionResponse message, length delimited. Does not implicitly {@link protos.GetConnectionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {protos.IGetConnectionResponse} message GetConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetConnectionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetConnectionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetConnectionResponse} GetConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetConnectionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetConnectionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.options = $root.protos.opts.ConnectionOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetConnectionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetConnectionResponse} GetConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetConnectionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetConnectionResponse message.
         * @function verify
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetConnectionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.protos.opts.ConnectionOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates a GetConnectionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetConnectionResponse} GetConnectionResponse
         */
        GetConnectionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetConnectionResponse)
                return object;
            var message = new $root.protos.GetConnectionResponse();
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".protos.GetConnectionResponse.options: object expected");
                message.options = $root.protos.opts.ConnectionOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetConnectionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {protos.GetConnectionResponse} message GetConnectionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetConnectionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.options = null;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.protos.opts.ConnectionOptions.toObject(message.options, options);
            return object;
        };

        /**
         * Converts this GetConnectionResponse to JSON.
         * @function toJSON
         * @memberof protos.GetConnectionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetConnectionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetConnectionResponse;
    })();

    protos.CreateConnectionRequest = (function() {

        /**
         * Properties of a CreateConnectionRequest.
         * @memberof protos
         * @interface ICreateConnectionRequest
         * @property {protos.common.IAuth|null} [auth] CreateConnectionRequest auth
         * @property {protos.opts.IConnectionOptions|null} [options] CreateConnectionRequest options
         */

        /**
         * Constructs a new CreateConnectionRequest.
         * @memberof protos
         * @classdesc Represents a CreateConnectionRequest.
         * @implements ICreateConnectionRequest
         * @constructor
         * @param {protos.ICreateConnectionRequest=} [properties] Properties to set
         */
        function CreateConnectionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateConnectionRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.CreateConnectionRequest
         * @instance
         */
        CreateConnectionRequest.prototype.auth = null;

        /**
         * CreateConnectionRequest options.
         * @member {protos.opts.IConnectionOptions|null|undefined} options
         * @memberof protos.CreateConnectionRequest
         * @instance
         */
        CreateConnectionRequest.prototype.options = null;

        /**
         * Creates a new CreateConnectionRequest instance using the specified properties.
         * @function create
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {protos.ICreateConnectionRequest=} [properties] Properties to set
         * @returns {protos.CreateConnectionRequest} CreateConnectionRequest instance
         */
        CreateConnectionRequest.create = function create(properties) {
            return new CreateConnectionRequest(properties);
        };

        /**
         * Encodes the specified CreateConnectionRequest message. Does not implicitly {@link protos.CreateConnectionRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {protos.ICreateConnectionRequest} message CreateConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateConnectionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.protos.opts.ConnectionOptions.encode(message.options, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateConnectionRequest message, length delimited. Does not implicitly {@link protos.CreateConnectionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {protos.ICreateConnectionRequest} message CreateConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateConnectionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateConnectionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateConnectionRequest} CreateConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateConnectionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateConnectionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.options = $root.protos.opts.ConnectionOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateConnectionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateConnectionRequest} CreateConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateConnectionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateConnectionRequest message.
         * @function verify
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateConnectionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.protos.opts.ConnectionOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates a CreateConnectionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateConnectionRequest} CreateConnectionRequest
         */
        CreateConnectionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateConnectionRequest)
                return object;
            var message = new $root.protos.CreateConnectionRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.CreateConnectionRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".protos.CreateConnectionRequest.options: object expected");
                message.options = $root.protos.opts.ConnectionOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateConnectionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {protos.CreateConnectionRequest} message CreateConnectionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateConnectionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.options = null;
                object.auth = null;
            }
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.protos.opts.ConnectionOptions.toObject(message.options, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this CreateConnectionRequest to JSON.
         * @function toJSON
         * @memberof protos.CreateConnectionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateConnectionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateConnectionRequest;
    })();

    protos.CreateConnectionResponse = (function() {

        /**
         * Properties of a CreateConnectionResponse.
         * @memberof protos
         * @interface ICreateConnectionResponse
         * @property {string|null} [connectionId] CreateConnectionResponse connectionId
         */

        /**
         * Constructs a new CreateConnectionResponse.
         * @memberof protos
         * @classdesc Represents a CreateConnectionResponse.
         * @implements ICreateConnectionResponse
         * @constructor
         * @param {protos.ICreateConnectionResponse=} [properties] Properties to set
         */
        function CreateConnectionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateConnectionResponse connectionId.
         * @member {string} connectionId
         * @memberof protos.CreateConnectionResponse
         * @instance
         */
        CreateConnectionResponse.prototype.connectionId = "";

        /**
         * Creates a new CreateConnectionResponse instance using the specified properties.
         * @function create
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {protos.ICreateConnectionResponse=} [properties] Properties to set
         * @returns {protos.CreateConnectionResponse} CreateConnectionResponse instance
         */
        CreateConnectionResponse.create = function create(properties) {
            return new CreateConnectionResponse(properties);
        };

        /**
         * Encodes the specified CreateConnectionResponse message. Does not implicitly {@link protos.CreateConnectionResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {protos.ICreateConnectionResponse} message CreateConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateConnectionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
            return writer;
        };

        /**
         * Encodes the specified CreateConnectionResponse message, length delimited. Does not implicitly {@link protos.CreateConnectionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {protos.ICreateConnectionResponse} message CreateConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateConnectionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateConnectionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateConnectionResponse} CreateConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateConnectionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateConnectionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.connectionId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateConnectionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateConnectionResponse} CreateConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateConnectionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateConnectionResponse message.
         * @function verify
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateConnectionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                if (!$util.isString(message.connectionId))
                    return "connectionId: string expected";
            return null;
        };

        /**
         * Creates a CreateConnectionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateConnectionResponse} CreateConnectionResponse
         */
        CreateConnectionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateConnectionResponse)
                return object;
            var message = new $root.protos.CreateConnectionResponse();
            if (object.connectionId != null)
                message.connectionId = String(object.connectionId);
            return message;
        };

        /**
         * Creates a plain object from a CreateConnectionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {protos.CreateConnectionResponse} message CreateConnectionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateConnectionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.connectionId = "";
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                object.connectionId = message.connectionId;
            return object;
        };

        /**
         * Converts this CreateConnectionResponse to JSON.
         * @function toJSON
         * @memberof protos.CreateConnectionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateConnectionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateConnectionResponse;
    })();

    protos.TestConnectionRequest = (function() {

        /**
         * Properties of a TestConnectionRequest.
         * @memberof protos
         * @interface ITestConnectionRequest
         * @property {protos.common.IAuth|null} [auth] TestConnectionRequest auth
         * @property {protos.opts.IConnectionOptions|null} [options] TestConnectionRequest options
         */

        /**
         * Constructs a new TestConnectionRequest.
         * @memberof protos
         * @classdesc Represents a TestConnectionRequest.
         * @implements ITestConnectionRequest
         * @constructor
         * @param {protos.ITestConnectionRequest=} [properties] Properties to set
         */
        function TestConnectionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TestConnectionRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.TestConnectionRequest
         * @instance
         */
        TestConnectionRequest.prototype.auth = null;

        /**
         * TestConnectionRequest options.
         * @member {protos.opts.IConnectionOptions|null|undefined} options
         * @memberof protos.TestConnectionRequest
         * @instance
         */
        TestConnectionRequest.prototype.options = null;

        /**
         * Creates a new TestConnectionRequest instance using the specified properties.
         * @function create
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {protos.ITestConnectionRequest=} [properties] Properties to set
         * @returns {protos.TestConnectionRequest} TestConnectionRequest instance
         */
        TestConnectionRequest.create = function create(properties) {
            return new TestConnectionRequest(properties);
        };

        /**
         * Encodes the specified TestConnectionRequest message. Does not implicitly {@link protos.TestConnectionRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {protos.ITestConnectionRequest} message TestConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestConnectionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.protos.opts.ConnectionOptions.encode(message.options, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TestConnectionRequest message, length delimited. Does not implicitly {@link protos.TestConnectionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {protos.ITestConnectionRequest} message TestConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestConnectionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TestConnectionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.TestConnectionRequest} TestConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestConnectionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.TestConnectionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.options = $root.protos.opts.ConnectionOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TestConnectionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.TestConnectionRequest} TestConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestConnectionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TestConnectionRequest message.
         * @function verify
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TestConnectionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.protos.opts.ConnectionOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates a TestConnectionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.TestConnectionRequest} TestConnectionRequest
         */
        TestConnectionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.TestConnectionRequest)
                return object;
            var message = new $root.protos.TestConnectionRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.TestConnectionRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".protos.TestConnectionRequest.options: object expected");
                message.options = $root.protos.opts.ConnectionOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from a TestConnectionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {protos.TestConnectionRequest} message TestConnectionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TestConnectionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.options = null;
                object.auth = null;
            }
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.protos.opts.ConnectionOptions.toObject(message.options, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this TestConnectionRequest to JSON.
         * @function toJSON
         * @memberof protos.TestConnectionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TestConnectionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TestConnectionRequest;
    })();

    protos.TestConnectionResponse = (function() {

        /**
         * Properties of a TestConnectionResponse.
         * @memberof protos
         * @interface ITestConnectionResponse
         * @property {protos.common.IStatus|null} [status] TestConnectionResponse status
         */

        /**
         * Constructs a new TestConnectionResponse.
         * @memberof protos
         * @classdesc Represents a TestConnectionResponse.
         * @implements ITestConnectionResponse
         * @constructor
         * @param {protos.ITestConnectionResponse=} [properties] Properties to set
         */
        function TestConnectionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TestConnectionResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.TestConnectionResponse
         * @instance
         */
        TestConnectionResponse.prototype.status = null;

        /**
         * Creates a new TestConnectionResponse instance using the specified properties.
         * @function create
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {protos.ITestConnectionResponse=} [properties] Properties to set
         * @returns {protos.TestConnectionResponse} TestConnectionResponse instance
         */
        TestConnectionResponse.create = function create(properties) {
            return new TestConnectionResponse(properties);
        };

        /**
         * Encodes the specified TestConnectionResponse message. Does not implicitly {@link protos.TestConnectionResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {protos.ITestConnectionResponse} message TestConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestConnectionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TestConnectionResponse message, length delimited. Does not implicitly {@link protos.TestConnectionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {protos.ITestConnectionResponse} message TestConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestConnectionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TestConnectionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.TestConnectionResponse} TestConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestConnectionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.TestConnectionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TestConnectionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.TestConnectionResponse} TestConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestConnectionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TestConnectionResponse message.
         * @function verify
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TestConnectionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a TestConnectionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.TestConnectionResponse} TestConnectionResponse
         */
        TestConnectionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.TestConnectionResponse)
                return object;
            var message = new $root.protos.TestConnectionResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.TestConnectionResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a TestConnectionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {protos.TestConnectionResponse} message TestConnectionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TestConnectionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this TestConnectionResponse to JSON.
         * @function toJSON
         * @memberof protos.TestConnectionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TestConnectionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TestConnectionResponse;
    })();

    protos.UpdateConnectionRequest = (function() {

        /**
         * Properties of an UpdateConnectionRequest.
         * @memberof protos
         * @interface IUpdateConnectionRequest
         * @property {protos.common.IAuth|null} [auth] UpdateConnectionRequest auth
         * @property {string|null} [connectionId] UpdateConnectionRequest connectionId
         * @property {protos.opts.IConnectionOptions|null} [options] UpdateConnectionRequest options
         */

        /**
         * Constructs a new UpdateConnectionRequest.
         * @memberof protos
         * @classdesc Represents an UpdateConnectionRequest.
         * @implements IUpdateConnectionRequest
         * @constructor
         * @param {protos.IUpdateConnectionRequest=} [properties] Properties to set
         */
        function UpdateConnectionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateConnectionRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.UpdateConnectionRequest
         * @instance
         */
        UpdateConnectionRequest.prototype.auth = null;

        /**
         * UpdateConnectionRequest connectionId.
         * @member {string} connectionId
         * @memberof protos.UpdateConnectionRequest
         * @instance
         */
        UpdateConnectionRequest.prototype.connectionId = "";

        /**
         * UpdateConnectionRequest options.
         * @member {protos.opts.IConnectionOptions|null|undefined} options
         * @memberof protos.UpdateConnectionRequest
         * @instance
         */
        UpdateConnectionRequest.prototype.options = null;

        /**
         * Creates a new UpdateConnectionRequest instance using the specified properties.
         * @function create
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {protos.IUpdateConnectionRequest=} [properties] Properties to set
         * @returns {protos.UpdateConnectionRequest} UpdateConnectionRequest instance
         */
        UpdateConnectionRequest.create = function create(properties) {
            return new UpdateConnectionRequest(properties);
        };

        /**
         * Encodes the specified UpdateConnectionRequest message. Does not implicitly {@link protos.UpdateConnectionRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {protos.IUpdateConnectionRequest} message UpdateConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateConnectionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.protos.opts.ConnectionOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateConnectionRequest message, length delimited. Does not implicitly {@link protos.UpdateConnectionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {protos.IUpdateConnectionRequest} message UpdateConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateConnectionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateConnectionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateConnectionRequest} UpdateConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateConnectionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateConnectionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.connectionId = reader.string();
                    break;
                case 2:
                    message.options = $root.protos.opts.ConnectionOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateConnectionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateConnectionRequest} UpdateConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateConnectionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateConnectionRequest message.
         * @function verify
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateConnectionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                if (!$util.isString(message.connectionId))
                    return "connectionId: string expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.protos.opts.ConnectionOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateConnectionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateConnectionRequest} UpdateConnectionRequest
         */
        UpdateConnectionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateConnectionRequest)
                return object;
            var message = new $root.protos.UpdateConnectionRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.UpdateConnectionRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.connectionId != null)
                message.connectionId = String(object.connectionId);
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".protos.UpdateConnectionRequest.options: object expected");
                message.options = $root.protos.opts.ConnectionOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateConnectionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {protos.UpdateConnectionRequest} message UpdateConnectionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateConnectionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.connectionId = "";
                object.options = null;
                object.auth = null;
            }
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                object.connectionId = message.connectionId;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.protos.opts.ConnectionOptions.toObject(message.options, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this UpdateConnectionRequest to JSON.
         * @function toJSON
         * @memberof protos.UpdateConnectionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateConnectionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateConnectionRequest;
    })();

    protos.UpdateConnectionResponse = (function() {

        /**
         * Properties of an UpdateConnectionResponse.
         * @memberof protos
         * @interface IUpdateConnectionResponse
         * @property {protos.common.IStatus|null} [status] UpdateConnectionResponse status
         */

        /**
         * Constructs a new UpdateConnectionResponse.
         * @memberof protos
         * @classdesc Represents an UpdateConnectionResponse.
         * @implements IUpdateConnectionResponse
         * @constructor
         * @param {protos.IUpdateConnectionResponse=} [properties] Properties to set
         */
        function UpdateConnectionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateConnectionResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.UpdateConnectionResponse
         * @instance
         */
        UpdateConnectionResponse.prototype.status = null;

        /**
         * Creates a new UpdateConnectionResponse instance using the specified properties.
         * @function create
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {protos.IUpdateConnectionResponse=} [properties] Properties to set
         * @returns {protos.UpdateConnectionResponse} UpdateConnectionResponse instance
         */
        UpdateConnectionResponse.create = function create(properties) {
            return new UpdateConnectionResponse(properties);
        };

        /**
         * Encodes the specified UpdateConnectionResponse message. Does not implicitly {@link protos.UpdateConnectionResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {protos.IUpdateConnectionResponse} message UpdateConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateConnectionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateConnectionResponse message, length delimited. Does not implicitly {@link protos.UpdateConnectionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {protos.IUpdateConnectionResponse} message UpdateConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateConnectionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateConnectionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateConnectionResponse} UpdateConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateConnectionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateConnectionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateConnectionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateConnectionResponse} UpdateConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateConnectionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateConnectionResponse message.
         * @function verify
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateConnectionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateConnectionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateConnectionResponse} UpdateConnectionResponse
         */
        UpdateConnectionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateConnectionResponse)
                return object;
            var message = new $root.protos.UpdateConnectionResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.UpdateConnectionResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateConnectionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {protos.UpdateConnectionResponse} message UpdateConnectionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateConnectionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this UpdateConnectionResponse to JSON.
         * @function toJSON
         * @memberof protos.UpdateConnectionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateConnectionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateConnectionResponse;
    })();

    protos.DeleteConnectionRequest = (function() {

        /**
         * Properties of a DeleteConnectionRequest.
         * @memberof protos
         * @interface IDeleteConnectionRequest
         * @property {protos.common.IAuth|null} [auth] DeleteConnectionRequest auth
         * @property {string|null} [connectionId] DeleteConnectionRequest connectionId
         */

        /**
         * Constructs a new DeleteConnectionRequest.
         * @memberof protos
         * @classdesc Represents a DeleteConnectionRequest.
         * @implements IDeleteConnectionRequest
         * @constructor
         * @param {protos.IDeleteConnectionRequest=} [properties] Properties to set
         */
        function DeleteConnectionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteConnectionRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.DeleteConnectionRequest
         * @instance
         */
        DeleteConnectionRequest.prototype.auth = null;

        /**
         * DeleteConnectionRequest connectionId.
         * @member {string} connectionId
         * @memberof protos.DeleteConnectionRequest
         * @instance
         */
        DeleteConnectionRequest.prototype.connectionId = "";

        /**
         * Creates a new DeleteConnectionRequest instance using the specified properties.
         * @function create
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {protos.IDeleteConnectionRequest=} [properties] Properties to set
         * @returns {protos.DeleteConnectionRequest} DeleteConnectionRequest instance
         */
        DeleteConnectionRequest.create = function create(properties) {
            return new DeleteConnectionRequest(properties);
        };

        /**
         * Encodes the specified DeleteConnectionRequest message. Does not implicitly {@link protos.DeleteConnectionRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {protos.IDeleteConnectionRequest} message DeleteConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteConnectionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteConnectionRequest message, length delimited. Does not implicitly {@link protos.DeleteConnectionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {protos.IDeleteConnectionRequest} message DeleteConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteConnectionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteConnectionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteConnectionRequest} DeleteConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteConnectionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteConnectionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.connectionId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteConnectionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteConnectionRequest} DeleteConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteConnectionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteConnectionRequest message.
         * @function verify
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteConnectionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                if (!$util.isString(message.connectionId))
                    return "connectionId: string expected";
            return null;
        };

        /**
         * Creates a DeleteConnectionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteConnectionRequest} DeleteConnectionRequest
         */
        DeleteConnectionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteConnectionRequest)
                return object;
            var message = new $root.protos.DeleteConnectionRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.DeleteConnectionRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.connectionId != null)
                message.connectionId = String(object.connectionId);
            return message;
        };

        /**
         * Creates a plain object from a DeleteConnectionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {protos.DeleteConnectionRequest} message DeleteConnectionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteConnectionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.connectionId = "";
                object.auth = null;
            }
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                object.connectionId = message.connectionId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this DeleteConnectionRequest to JSON.
         * @function toJSON
         * @memberof protos.DeleteConnectionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteConnectionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteConnectionRequest;
    })();

    protos.DeleteConnectionResponse = (function() {

        /**
         * Properties of a DeleteConnectionResponse.
         * @memberof protos
         * @interface IDeleteConnectionResponse
         * @property {protos.common.IStatus|null} [status] DeleteConnectionResponse status
         */

        /**
         * Constructs a new DeleteConnectionResponse.
         * @memberof protos
         * @classdesc Represents a DeleteConnectionResponse.
         * @implements IDeleteConnectionResponse
         * @constructor
         * @param {protos.IDeleteConnectionResponse=} [properties] Properties to set
         */
        function DeleteConnectionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteConnectionResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.DeleteConnectionResponse
         * @instance
         */
        DeleteConnectionResponse.prototype.status = null;

        /**
         * Creates a new DeleteConnectionResponse instance using the specified properties.
         * @function create
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {protos.IDeleteConnectionResponse=} [properties] Properties to set
         * @returns {protos.DeleteConnectionResponse} DeleteConnectionResponse instance
         */
        DeleteConnectionResponse.create = function create(properties) {
            return new DeleteConnectionResponse(properties);
        };

        /**
         * Encodes the specified DeleteConnectionResponse message. Does not implicitly {@link protos.DeleteConnectionResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {protos.IDeleteConnectionResponse} message DeleteConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteConnectionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteConnectionResponse message, length delimited. Does not implicitly {@link protos.DeleteConnectionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {protos.IDeleteConnectionResponse} message DeleteConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteConnectionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteConnectionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteConnectionResponse} DeleteConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteConnectionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteConnectionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteConnectionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteConnectionResponse} DeleteConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteConnectionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteConnectionResponse message.
         * @function verify
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteConnectionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a DeleteConnectionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteConnectionResponse} DeleteConnectionResponse
         */
        DeleteConnectionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteConnectionResponse)
                return object;
            var message = new $root.protos.DeleteConnectionResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.DeleteConnectionResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a DeleteConnectionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {protos.DeleteConnectionResponse} message DeleteConnectionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteConnectionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this DeleteConnectionResponse to JSON.
         * @function toJSON
         * @memberof protos.DeleteConnectionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteConnectionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteConnectionResponse;
    })();

    protos.common = (function() {

        /**
         * Namespace common.
         * @memberof protos
         * @namespace
         */
        var common = {};

        common.Foreman = (function() {

            /**
             * Properties of a Foreman.
             * @memberof protos.common
             * @interface IForeman
             * @property {string|null} [authToken] Foreman authToken
             * @property {string|null} [plumberClusterId] Foreman plumberClusterId
             * @property {string|null} [teamId] Foreman teamId
             */

            /**
             * Constructs a new Foreman.
             * @memberof protos.common
             * @classdesc Represents a Foreman.
             * @implements IForeman
             * @constructor
             * @param {protos.common.IForeman=} [properties] Properties to set
             */
            function Foreman(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Foreman authToken.
             * @member {string} authToken
             * @memberof protos.common.Foreman
             * @instance
             */
            Foreman.prototype.authToken = "";

            /**
             * Foreman plumberClusterId.
             * @member {string} plumberClusterId
             * @memberof protos.common.Foreman
             * @instance
             */
            Foreman.prototype.plumberClusterId = "";

            /**
             * Foreman teamId.
             * @member {string} teamId
             * @memberof protos.common.Foreman
             * @instance
             */
            Foreman.prototype.teamId = "";

            /**
             * Creates a new Foreman instance using the specified properties.
             * @function create
             * @memberof protos.common.Foreman
             * @static
             * @param {protos.common.IForeman=} [properties] Properties to set
             * @returns {protos.common.Foreman} Foreman instance
             */
            Foreman.create = function create(properties) {
                return new Foreman(properties);
            };

            /**
             * Encodes the specified Foreman message. Does not implicitly {@link protos.common.Foreman.verify|verify} messages.
             * @function encode
             * @memberof protos.common.Foreman
             * @static
             * @param {protos.common.IForeman} message Foreman message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Foreman.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.authToken != null && Object.hasOwnProperty.call(message, "authToken"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.authToken);
                if (message.plumberClusterId != null && Object.hasOwnProperty.call(message, "plumberClusterId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.plumberClusterId);
                if (message.teamId != null && Object.hasOwnProperty.call(message, "teamId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.teamId);
                return writer;
            };

            /**
             * Encodes the specified Foreman message, length delimited. Does not implicitly {@link protos.common.Foreman.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.common.Foreman
             * @static
             * @param {protos.common.IForeman} message Foreman message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Foreman.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Foreman message from the specified reader or buffer.
             * @function decode
             * @memberof protos.common.Foreman
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.common.Foreman} Foreman
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Foreman.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.common.Foreman();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.authToken = reader.string();
                        break;
                    case 2:
                        message.plumberClusterId = reader.string();
                        break;
                    case 3:
                        message.teamId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Foreman message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.common.Foreman
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.common.Foreman} Foreman
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Foreman.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Foreman message.
             * @function verify
             * @memberof protos.common.Foreman
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Foreman.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.authToken != null && message.hasOwnProperty("authToken"))
                    if (!$util.isString(message.authToken))
                        return "authToken: string expected";
                if (message.plumberClusterId != null && message.hasOwnProperty("plumberClusterId"))
                    if (!$util.isString(message.plumberClusterId))
                        return "plumberClusterId: string expected";
                if (message.teamId != null && message.hasOwnProperty("teamId"))
                    if (!$util.isString(message.teamId))
                        return "teamId: string expected";
                return null;
            };

            /**
             * Creates a Foreman message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.common.Foreman
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.common.Foreman} Foreman
             */
            Foreman.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.common.Foreman)
                    return object;
                var message = new $root.protos.common.Foreman();
                if (object.authToken != null)
                    message.authToken = String(object.authToken);
                if (object.plumberClusterId != null)
                    message.plumberClusterId = String(object.plumberClusterId);
                if (object.teamId != null)
                    message.teamId = String(object.teamId);
                return message;
            };

            /**
             * Creates a plain object from a Foreman message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.common.Foreman
             * @static
             * @param {protos.common.Foreman} message Foreman
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Foreman.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.authToken = "";
                    object.plumberClusterId = "";
                    object.teamId = "";
                }
                if (message.authToken != null && message.hasOwnProperty("authToken"))
                    object.authToken = message.authToken;
                if (message.plumberClusterId != null && message.hasOwnProperty("plumberClusterId"))
                    object.plumberClusterId = message.plumberClusterId;
                if (message.teamId != null && message.hasOwnProperty("teamId"))
                    object.teamId = message.teamId;
                return object;
            };

            /**
             * Converts this Foreman to JSON.
             * @function toJSON
             * @memberof protos.common.Foreman
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Foreman.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Foreman;
        })();

        common.SourceManager = (function() {

            /**
             * Properties of a SourceManager.
             * @memberof protos.common
             * @interface ISourceManager
             * @property {string|null} [serverToken] SourceManager serverToken
             * @property {string|null} [sourceId] SourceManager sourceId
             */

            /**
             * Constructs a new SourceManager.
             * @memberof protos.common
             * @classdesc Represents a SourceManager.
             * @implements ISourceManager
             * @constructor
             * @param {protos.common.ISourceManager=} [properties] Properties to set
             */
            function SourceManager(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SourceManager serverToken.
             * @member {string} serverToken
             * @memberof protos.common.SourceManager
             * @instance
             */
            SourceManager.prototype.serverToken = "";

            /**
             * SourceManager sourceId.
             * @member {string} sourceId
             * @memberof protos.common.SourceManager
             * @instance
             */
            SourceManager.prototype.sourceId = "";

            /**
             * Creates a new SourceManager instance using the specified properties.
             * @function create
             * @memberof protos.common.SourceManager
             * @static
             * @param {protos.common.ISourceManager=} [properties] Properties to set
             * @returns {protos.common.SourceManager} SourceManager instance
             */
            SourceManager.create = function create(properties) {
                return new SourceManager(properties);
            };

            /**
             * Encodes the specified SourceManager message. Does not implicitly {@link protos.common.SourceManager.verify|verify} messages.
             * @function encode
             * @memberof protos.common.SourceManager
             * @static
             * @param {protos.common.ISourceManager} message SourceManager message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceManager.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.serverToken != null && Object.hasOwnProperty.call(message, "serverToken"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.serverToken);
                if (message.sourceId != null && Object.hasOwnProperty.call(message, "sourceId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceId);
                return writer;
            };

            /**
             * Encodes the specified SourceManager message, length delimited. Does not implicitly {@link protos.common.SourceManager.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.common.SourceManager
             * @static
             * @param {protos.common.ISourceManager} message SourceManager message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceManager.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SourceManager message from the specified reader or buffer.
             * @function decode
             * @memberof protos.common.SourceManager
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.common.SourceManager} SourceManager
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceManager.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.common.SourceManager();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.serverToken = reader.string();
                        break;
                    case 2:
                        message.sourceId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SourceManager message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.common.SourceManager
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.common.SourceManager} SourceManager
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceManager.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SourceManager message.
             * @function verify
             * @memberof protos.common.SourceManager
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SourceManager.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.serverToken != null && message.hasOwnProperty("serverToken"))
                    if (!$util.isString(message.serverToken))
                        return "serverToken: string expected";
                if (message.sourceId != null && message.hasOwnProperty("sourceId"))
                    if (!$util.isString(message.sourceId))
                        return "sourceId: string expected";
                return null;
            };

            /**
             * Creates a SourceManager message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.common.SourceManager
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.common.SourceManager} SourceManager
             */
            SourceManager.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.common.SourceManager)
                    return object;
                var message = new $root.protos.common.SourceManager();
                if (object.serverToken != null)
                    message.serverToken = String(object.serverToken);
                if (object.sourceId != null)
                    message.sourceId = String(object.sourceId);
                return message;
            };

            /**
             * Creates a plain object from a SourceManager message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.common.SourceManager
             * @static
             * @param {protos.common.SourceManager} message SourceManager
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SourceManager.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.serverToken = "";
                    object.sourceId = "";
                }
                if (message.serverToken != null && message.hasOwnProperty("serverToken"))
                    object.serverToken = message.serverToken;
                if (message.sourceId != null && message.hasOwnProperty("sourceId"))
                    object.sourceId = message.sourceId;
                return object;
            };

            /**
             * Converts this SourceManager to JSON.
             * @function toJSON
             * @memberof protos.common.SourceManager
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SourceManager.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SourceManager;
        })();

        common.Auth = (function() {

            /**
             * Properties of an Auth.
             * @memberof protos.common
             * @interface IAuth
             * @property {string|null} [token] Auth token
             * @property {protos.common.IForeman|null} [_foreman] Auth _foreman
             * @property {protos.common.ISourceManager|null} [_sourceManager] Auth _sourceManager
             */

            /**
             * Constructs a new Auth.
             * @memberof protos.common
             * @classdesc Represents an Auth.
             * @implements IAuth
             * @constructor
             * @param {protos.common.IAuth=} [properties] Properties to set
             */
            function Auth(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Auth token.
             * @member {string} token
             * @memberof protos.common.Auth
             * @instance
             */
            Auth.prototype.token = "";

            /**
             * Auth _foreman.
             * @member {protos.common.IForeman|null|undefined} _foreman
             * @memberof protos.common.Auth
             * @instance
             */
            Auth.prototype._foreman = null;

            /**
             * Auth _sourceManager.
             * @member {protos.common.ISourceManager|null|undefined} _sourceManager
             * @memberof protos.common.Auth
             * @instance
             */
            Auth.prototype._sourceManager = null;

            /**
             * Creates a new Auth instance using the specified properties.
             * @function create
             * @memberof protos.common.Auth
             * @static
             * @param {protos.common.IAuth=} [properties] Properties to set
             * @returns {protos.common.Auth} Auth instance
             */
            Auth.create = function create(properties) {
                return new Auth(properties);
            };

            /**
             * Encodes the specified Auth message. Does not implicitly {@link protos.common.Auth.verify|verify} messages.
             * @function encode
             * @memberof protos.common.Auth
             * @static
             * @param {protos.common.IAuth} message Auth message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Auth.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
                if (message._foreman != null && Object.hasOwnProperty.call(message, "_foreman"))
                    $root.protos.common.Foreman.encode(message._foreman, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message._sourceManager != null && Object.hasOwnProperty.call(message, "_sourceManager"))
                    $root.protos.common.SourceManager.encode(message._sourceManager, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Auth message, length delimited. Does not implicitly {@link protos.common.Auth.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.common.Auth
             * @static
             * @param {protos.common.IAuth} message Auth message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Auth.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Auth message from the specified reader or buffer.
             * @function decode
             * @memberof protos.common.Auth
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.common.Auth} Auth
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Auth.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.common.Auth();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.token = reader.string();
                        break;
                    case 2:
                        message._foreman = $root.protos.common.Foreman.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message._sourceManager = $root.protos.common.SourceManager.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Auth message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.common.Auth
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.common.Auth} Auth
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Auth.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Auth message.
             * @function verify
             * @memberof protos.common.Auth
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Auth.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                if (message._foreman != null && message.hasOwnProperty("_foreman")) {
                    var error = $root.protos.common.Foreman.verify(message._foreman);
                    if (error)
                        return "_foreman." + error;
                }
                if (message._sourceManager != null && message.hasOwnProperty("_sourceManager")) {
                    var error = $root.protos.common.SourceManager.verify(message._sourceManager);
                    if (error)
                        return "_sourceManager." + error;
                }
                return null;
            };

            /**
             * Creates an Auth message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.common.Auth
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.common.Auth} Auth
             */
            Auth.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.common.Auth)
                    return object;
                var message = new $root.protos.common.Auth();
                if (object.token != null)
                    message.token = String(object.token);
                if (object._foreman != null) {
                    if (typeof object._foreman !== "object")
                        throw TypeError(".protos.common.Auth._foreman: object expected");
                    message._foreman = $root.protos.common.Foreman.fromObject(object._foreman);
                }
                if (object._sourceManager != null) {
                    if (typeof object._sourceManager !== "object")
                        throw TypeError(".protos.common.Auth._sourceManager: object expected");
                    message._sourceManager = $root.protos.common.SourceManager.fromObject(object._sourceManager);
                }
                return message;
            };

            /**
             * Creates a plain object from an Auth message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.common.Auth
             * @static
             * @param {protos.common.Auth} message Auth
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Auth.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.token = "";
                    object._foreman = null;
                    object._sourceManager = null;
                }
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = message.token;
                if (message._foreman != null && message.hasOwnProperty("_foreman"))
                    object._foreman = $root.protos.common.Foreman.toObject(message._foreman, options);
                if (message._sourceManager != null && message.hasOwnProperty("_sourceManager"))
                    object._sourceManager = $root.protos.common.SourceManager.toObject(message._sourceManager, options);
                return object;
            };

            /**
             * Converts this Auth to JSON.
             * @function toJSON
             * @memberof protos.common.Auth
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Auth.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Auth;
        })();

        /**
         * Code enum.
         * @name protos.common.Code
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} CANCELLED=1 CANCELLED value
         * @property {number} UNKNOWN=2 UNKNOWN value
         * @property {number} INVALID_ARGUMENT=3 INVALID_ARGUMENT value
         * @property {number} DEADLINE_EXCEEDED=4 DEADLINE_EXCEEDED value
         * @property {number} NOT_FOUND=5 NOT_FOUND value
         * @property {number} ALREADY_EXISTS=6 ALREADY_EXISTS value
         * @property {number} PERMISSION_DENIED=7 PERMISSION_DENIED value
         * @property {number} UNAUTHENTICATED=16 UNAUTHENTICATED value
         * @property {number} RESOURCE_EXHAUSTED=8 RESOURCE_EXHAUSTED value
         * @property {number} FAILED_PRECONDITION=9 FAILED_PRECONDITION value
         * @property {number} ABORTED=10 ABORTED value
         * @property {number} OUT_OF_RANGE=11 OUT_OF_RANGE value
         * @property {number} UNIMPLEMENTED=12 UNIMPLEMENTED value
         * @property {number} INTERNAL=13 INTERNAL value
         * @property {number} UNAVAILABLE=14 UNAVAILABLE value
         * @property {number} DATA_LOSS=15 DATA_LOSS value
         */
        common.Code = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "CANCELLED"] = 1;
            values[valuesById[2] = "UNKNOWN"] = 2;
            values[valuesById[3] = "INVALID_ARGUMENT"] = 3;
            values[valuesById[4] = "DEADLINE_EXCEEDED"] = 4;
            values[valuesById[5] = "NOT_FOUND"] = 5;
            values[valuesById[6] = "ALREADY_EXISTS"] = 6;
            values[valuesById[7] = "PERMISSION_DENIED"] = 7;
            values[valuesById[16] = "UNAUTHENTICATED"] = 16;
            values[valuesById[8] = "RESOURCE_EXHAUSTED"] = 8;
            values[valuesById[9] = "FAILED_PRECONDITION"] = 9;
            values[valuesById[10] = "ABORTED"] = 10;
            values[valuesById[11] = "OUT_OF_RANGE"] = 11;
            values[valuesById[12] = "UNIMPLEMENTED"] = 12;
            values[valuesById[13] = "INTERNAL"] = 13;
            values[valuesById[14] = "UNAVAILABLE"] = 14;
            values[valuesById[15] = "DATA_LOSS"] = 15;
            return values;
        })();

        common.Status = (function() {

            /**
             * Properties of a Status.
             * @memberof protos.common
             * @interface IStatus
             * @property {protos.common.Code|null} [code] Status code
             * @property {string|null} [message] Status message
             * @property {string|null} [requestId] Status requestId
             */

            /**
             * Constructs a new Status.
             * @memberof protos.common
             * @classdesc Represents a Status.
             * @implements IStatus
             * @constructor
             * @param {protos.common.IStatus=} [properties] Properties to set
             */
            function Status(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Status code.
             * @member {protos.common.Code} code
             * @memberof protos.common.Status
             * @instance
             */
            Status.prototype.code = 0;

            /**
             * Status message.
             * @member {string} message
             * @memberof protos.common.Status
             * @instance
             */
            Status.prototype.message = "";

            /**
             * Status requestId.
             * @member {string} requestId
             * @memberof protos.common.Status
             * @instance
             */
            Status.prototype.requestId = "";

            /**
             * Creates a new Status instance using the specified properties.
             * @function create
             * @memberof protos.common.Status
             * @static
             * @param {protos.common.IStatus=} [properties] Properties to set
             * @returns {protos.common.Status} Status instance
             */
            Status.create = function create(properties) {
                return new Status(properties);
            };

            /**
             * Encodes the specified Status message. Does not implicitly {@link protos.common.Status.verify|verify} messages.
             * @function encode
             * @memberof protos.common.Status
             * @static
             * @param {protos.common.IStatus} message Status message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Status.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.requestId);
                return writer;
            };

            /**
             * Encodes the specified Status message, length delimited. Does not implicitly {@link protos.common.Status.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.common.Status
             * @static
             * @param {protos.common.IStatus} message Status message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Status.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Status message from the specified reader or buffer.
             * @function decode
             * @memberof protos.common.Status
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.common.Status} Status
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Status.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.common.Status();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.message = reader.string();
                        break;
                    case 3:
                        message.requestId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Status message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.common.Status
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.common.Status} Status
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Status.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Status message.
             * @function verify
             * @memberof protos.common.Status
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Status.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    switch (message.code) {
                    default:
                        return "code: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 16:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                        break;
                    }
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.requestId != null && message.hasOwnProperty("requestId"))
                    if (!$util.isString(message.requestId))
                        return "requestId: string expected";
                return null;
            };

            /**
             * Creates a Status message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.common.Status
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.common.Status} Status
             */
            Status.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.common.Status)
                    return object;
                var message = new $root.protos.common.Status();
                switch (object.code) {
                case "OK":
                case 0:
                    message.code = 0;
                    break;
                case "CANCELLED":
                case 1:
                    message.code = 1;
                    break;
                case "UNKNOWN":
                case 2:
                    message.code = 2;
                    break;
                case "INVALID_ARGUMENT":
                case 3:
                    message.code = 3;
                    break;
                case "DEADLINE_EXCEEDED":
                case 4:
                    message.code = 4;
                    break;
                case "NOT_FOUND":
                case 5:
                    message.code = 5;
                    break;
                case "ALREADY_EXISTS":
                case 6:
                    message.code = 6;
                    break;
                case "PERMISSION_DENIED":
                case 7:
                    message.code = 7;
                    break;
                case "UNAUTHENTICATED":
                case 16:
                    message.code = 16;
                    break;
                case "RESOURCE_EXHAUSTED":
                case 8:
                    message.code = 8;
                    break;
                case "FAILED_PRECONDITION":
                case 9:
                    message.code = 9;
                    break;
                case "ABORTED":
                case 10:
                    message.code = 10;
                    break;
                case "OUT_OF_RANGE":
                case 11:
                    message.code = 11;
                    break;
                case "UNIMPLEMENTED":
                case 12:
                    message.code = 12;
                    break;
                case "INTERNAL":
                case 13:
                    message.code = 13;
                    break;
                case "UNAVAILABLE":
                case 14:
                    message.code = 14;
                    break;
                case "DATA_LOSS":
                case 15:
                    message.code = 15;
                    break;
                }
                if (object.message != null)
                    message.message = String(object.message);
                if (object.requestId != null)
                    message.requestId = String(object.requestId);
                return message;
            };

            /**
             * Creates a plain object from a Status message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.common.Status
             * @static
             * @param {protos.common.Status} message Status
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Status.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.code = options.enums === String ? "OK" : 0;
                    object.message = "";
                    object.requestId = "";
                }
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = options.enums === String ? $root.protos.common.Code[message.code] : message.code;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                if (message.requestId != null && message.hasOwnProperty("requestId"))
                    object.requestId = message.requestId;
                return object;
            };

            /**
             * Converts this Status to JSON.
             * @function toJSON
             * @memberof protos.common.Status
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Status.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Status;
        })();

        /**
         * BackendType enum.
         * @name protos.common.BackendType
         * @enum {number}
         * @property {number} BACKEND_TYPE_UNSET=0 BACKEND_TYPE_UNSET value
         * @property {number} BACKEND_TYPE_KAFKA=1 BACKEND_TYPE_KAFKA value
         * @property {number} BACKEND_TYPE_RABBIT=2 BACKEND_TYPE_RABBIT value
         * @property {number} BACKEND_TYPE_RABBIT_STREAMS=3 BACKEND_TYPE_RABBIT_STREAMS value
         * @property {number} BACKEND_TYPE_NSQ=4 BACKEND_TYPE_NSQ value
         * @property {number} BACKEND_TYPE_NATS=5 BACKEND_TYPE_NATS value
         * @property {number} BACKEND_TYPE_NATS_STREAMING=6 BACKEND_TYPE_NATS_STREAMING value
         * @property {number} BACKEND_TYPE_GCP_PUBSUB=7 BACKEND_TYPE_GCP_PUBSUB value
         * @property {number} BACKEND_TYPE_AZURE_SERVICE_BUS=8 BACKEND_TYPE_AZURE_SERVICE_BUS value
         * @property {number} BACKEND_TYPE_AZURE_EVENT_HUB=9 BACKEND_TYPE_AZURE_EVENT_HUB value
         * @property {number} BACKEND_TYPE_AWS_SQS=10 BACKEND_TYPE_AWS_SQS value
         * @property {number} BACKEND_TYPE_AWS_SNS=11 BACKEND_TYPE_AWS_SNS value
         * @property {number} BACKEND_TYPE_REDIS_PUBSUB=12 BACKEND_TYPE_REDIS_PUBSUB value
         * @property {number} BACKEND_TYPE_REDIS_STREAMS=13 BACKEND_TYPE_REDIS_STREAMS value
         * @property {number} BACKEND_TYPE_ACTIVEMQ=14 BACKEND_TYPE_ACTIVEMQ value
         * @property {number} BACKEND_TYPE_PULSAR=15 BACKEND_TYPE_PULSAR value
         * @property {number} BACKEND_TYPE_MQTT=16 BACKEND_TYPE_MQTT value
         * @property {number} BACKEND_TYPE_POSTGRES_CDC=17 BACKEND_TYPE_POSTGRES_CDC value
         * @property {number} BACKEND_TYPE_MONGODB_CDC=18 BACKEND_TYPE_MONGODB_CDC value
         * @property {number} BACKEND_TYPE_KUBE_MQ=19 BACKEND_TYPE_KUBE_MQ value
         * @property {number} BACKEND_TYPE_AWS_KINESIS=20 BACKEND_TYPE_AWS_KINESIS value
         */
        common.BackendType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "BACKEND_TYPE_UNSET"] = 0;
            values[valuesById[1] = "BACKEND_TYPE_KAFKA"] = 1;
            values[valuesById[2] = "BACKEND_TYPE_RABBIT"] = 2;
            values[valuesById[3] = "BACKEND_TYPE_RABBIT_STREAMS"] = 3;
            values[valuesById[4] = "BACKEND_TYPE_NSQ"] = 4;
            values[valuesById[5] = "BACKEND_TYPE_NATS"] = 5;
            values[valuesById[6] = "BACKEND_TYPE_NATS_STREAMING"] = 6;
            values[valuesById[7] = "BACKEND_TYPE_GCP_PUBSUB"] = 7;
            values[valuesById[8] = "BACKEND_TYPE_AZURE_SERVICE_BUS"] = 8;
            values[valuesById[9] = "BACKEND_TYPE_AZURE_EVENT_HUB"] = 9;
            values[valuesById[10] = "BACKEND_TYPE_AWS_SQS"] = 10;
            values[valuesById[11] = "BACKEND_TYPE_AWS_SNS"] = 11;
            values[valuesById[12] = "BACKEND_TYPE_REDIS_PUBSUB"] = 12;
            values[valuesById[13] = "BACKEND_TYPE_REDIS_STREAMS"] = 13;
            values[valuesById[14] = "BACKEND_TYPE_ACTIVEMQ"] = 14;
            values[valuesById[15] = "BACKEND_TYPE_PULSAR"] = 15;
            values[valuesById[16] = "BACKEND_TYPE_MQTT"] = 16;
            values[valuesById[17] = "BACKEND_TYPE_POSTGRES_CDC"] = 17;
            values[valuesById[18] = "BACKEND_TYPE_MONGODB_CDC"] = 18;
            values[valuesById[19] = "BACKEND_TYPE_KUBE_MQ"] = 19;
            values[valuesById[20] = "BACKEND_TYPE_AWS_KINESIS"] = 20;
            return values;
        })();

        common.Validation = (function() {

            /**
             * Properties of a Validation.
             * @memberof protos.common
             * @interface IValidation
             * @property {string|null} [_id] Validation _id
             * @property {string|null} [schemaId] Validation schemaId
             * @property {Array.<protos.common.Validation.IField>|null} [fields] Validation fields
             */

            /**
             * Constructs a new Validation.
             * @memberof protos.common
             * @classdesc Represents a Validation.
             * @implements IValidation
             * @constructor
             * @param {protos.common.IValidation=} [properties] Properties to set
             */
            function Validation(properties) {
                this.fields = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Validation _id.
             * @member {string} _id
             * @memberof protos.common.Validation
             * @instance
             */
            Validation.prototype._id = "";

            /**
             * Validation schemaId.
             * @member {string} schemaId
             * @memberof protos.common.Validation
             * @instance
             */
            Validation.prototype.schemaId = "";

            /**
             * Validation fields.
             * @member {Array.<protos.common.Validation.IField>} fields
             * @memberof protos.common.Validation
             * @instance
             */
            Validation.prototype.fields = $util.emptyArray;

            /**
             * Creates a new Validation instance using the specified properties.
             * @function create
             * @memberof protos.common.Validation
             * @static
             * @param {protos.common.IValidation=} [properties] Properties to set
             * @returns {protos.common.Validation} Validation instance
             */
            Validation.create = function create(properties) {
                return new Validation(properties);
            };

            /**
             * Encodes the specified Validation message. Does not implicitly {@link protos.common.Validation.verify|verify} messages.
             * @function encode
             * @memberof protos.common.Validation
             * @static
             * @param {protos.common.IValidation} message Validation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Validation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._id != null && Object.hasOwnProperty.call(message, "_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message._id);
                if (message.schemaId != null && Object.hasOwnProperty.call(message, "schemaId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.schemaId);
                if (message.fields != null && message.fields.length)
                    for (var i = 0; i < message.fields.length; ++i)
                        $root.protos.common.Validation.Field.encode(message.fields[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Validation message, length delimited. Does not implicitly {@link protos.common.Validation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.common.Validation
             * @static
             * @param {protos.common.IValidation} message Validation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Validation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Validation message from the specified reader or buffer.
             * @function decode
             * @memberof protos.common.Validation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.common.Validation} Validation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Validation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.common.Validation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._id = reader.string();
                        break;
                    case 2:
                        message.schemaId = reader.string();
                        break;
                    case 3:
                        if (!(message.fields && message.fields.length))
                            message.fields = [];
                        message.fields.push($root.protos.common.Validation.Field.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Validation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.common.Validation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.common.Validation} Validation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Validation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Validation message.
             * @function verify
             * @memberof protos.common.Validation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Validation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._id != null && message.hasOwnProperty("_id"))
                    if (!$util.isString(message._id))
                        return "_id: string expected";
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    if (!$util.isString(message.schemaId))
                        return "schemaId: string expected";
                if (message.fields != null && message.hasOwnProperty("fields")) {
                    if (!Array.isArray(message.fields))
                        return "fields: array expected";
                    for (var i = 0; i < message.fields.length; ++i) {
                        var error = $root.protos.common.Validation.Field.verify(message.fields[i]);
                        if (error)
                            return "fields." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Validation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.common.Validation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.common.Validation} Validation
             */
            Validation.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.common.Validation)
                    return object;
                var message = new $root.protos.common.Validation();
                if (object._id != null)
                    message._id = String(object._id);
                if (object.schemaId != null)
                    message.schemaId = String(object.schemaId);
                if (object.fields) {
                    if (!Array.isArray(object.fields))
                        throw TypeError(".protos.common.Validation.fields: array expected");
                    message.fields = [];
                    for (var i = 0; i < object.fields.length; ++i) {
                        if (typeof object.fields[i] !== "object")
                            throw TypeError(".protos.common.Validation.fields: object expected");
                        message.fields[i] = $root.protos.common.Validation.Field.fromObject(object.fields[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Validation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.common.Validation
             * @static
             * @param {protos.common.Validation} message Validation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Validation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.fields = [];
                if (options.defaults) {
                    object._id = "";
                    object.schemaId = "";
                }
                if (message._id != null && message.hasOwnProperty("_id"))
                    object._id = message._id;
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    object.schemaId = message.schemaId;
                if (message.fields && message.fields.length) {
                    object.fields = [];
                    for (var j = 0; j < message.fields.length; ++j)
                        object.fields[j] = $root.protos.common.Validation.Field.toObject(message.fields[j], options);
                }
                return object;
            };

            /**
             * Converts this Validation to JSON.
             * @function toJSON
             * @memberof protos.common.Validation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Validation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Validation.Field = (function() {

                /**
                 * Properties of a Field.
                 * @memberof protos.common.Validation
                 * @interface IField
                 * @property {string|null} [path] Field path
                 * @property {string|null} [validationType] Field validationType
                 * @property {string|null} [matchValue] Field matchValue
                 */

                /**
                 * Constructs a new Field.
                 * @memberof protos.common.Validation
                 * @classdesc Represents a Field.
                 * @implements IField
                 * @constructor
                 * @param {protos.common.Validation.IField=} [properties] Properties to set
                 */
                function Field(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Field path.
                 * @member {string} path
                 * @memberof protos.common.Validation.Field
                 * @instance
                 */
                Field.prototype.path = "";

                /**
                 * Field validationType.
                 * @member {string} validationType
                 * @memberof protos.common.Validation.Field
                 * @instance
                 */
                Field.prototype.validationType = "";

                /**
                 * Field matchValue.
                 * @member {string} matchValue
                 * @memberof protos.common.Validation.Field
                 * @instance
                 */
                Field.prototype.matchValue = "";

                /**
                 * Creates a new Field instance using the specified properties.
                 * @function create
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {protos.common.Validation.IField=} [properties] Properties to set
                 * @returns {protos.common.Validation.Field} Field instance
                 */
                Field.create = function create(properties) {
                    return new Field(properties);
                };

                /**
                 * Encodes the specified Field message. Does not implicitly {@link protos.common.Validation.Field.verify|verify} messages.
                 * @function encode
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {protos.common.Validation.IField} message Field message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Field.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                    if (message.validationType != null && Object.hasOwnProperty.call(message, "validationType"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.validationType);
                    if (message.matchValue != null && Object.hasOwnProperty.call(message, "matchValue"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.matchValue);
                    return writer;
                };

                /**
                 * Encodes the specified Field message, length delimited. Does not implicitly {@link protos.common.Validation.Field.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {protos.common.Validation.IField} message Field message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Field.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Field message from the specified reader or buffer.
                 * @function decode
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {protos.common.Validation.Field} Field
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Field.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.common.Validation.Field();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.path = reader.string();
                            break;
                        case 2:
                            message.validationType = reader.string();
                            break;
                        case 3:
                            message.matchValue = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Field message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {protos.common.Validation.Field} Field
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Field.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Field message.
                 * @function verify
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Field.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path"))
                        if (!$util.isString(message.path))
                            return "path: string expected";
                    if (message.validationType != null && message.hasOwnProperty("validationType"))
                        if (!$util.isString(message.validationType))
                            return "validationType: string expected";
                    if (message.matchValue != null && message.hasOwnProperty("matchValue"))
                        if (!$util.isString(message.matchValue))
                            return "matchValue: string expected";
                    return null;
                };

                /**
                 * Creates a Field message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {protos.common.Validation.Field} Field
                 */
                Field.fromObject = function fromObject(object) {
                    if (object instanceof $root.protos.common.Validation.Field)
                        return object;
                    var message = new $root.protos.common.Validation.Field();
                    if (object.path != null)
                        message.path = String(object.path);
                    if (object.validationType != null)
                        message.validationType = String(object.validationType);
                    if (object.matchValue != null)
                        message.matchValue = String(object.matchValue);
                    return message;
                };

                /**
                 * Creates a plain object from a Field message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {protos.common.Validation.Field} message Field
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Field.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.path = "";
                        object.validationType = "";
                        object.matchValue = "";
                    }
                    if (message.path != null && message.hasOwnProperty("path"))
                        object.path = message.path;
                    if (message.validationType != null && message.hasOwnProperty("validationType"))
                        object.validationType = message.validationType;
                    if (message.matchValue != null && message.hasOwnProperty("matchValue"))
                        object.matchValue = message.matchValue;
                    return object;
                };

                /**
                 * Converts this Field to JSON.
                 * @function toJSON
                 * @memberof protos.common.Validation.Field
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Field.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Field;
            })();

            return Validation;
        })();

        return common;
    })();

    protos.opts = (function() {

        /**
         * Namespace opts.
         * @memberof protos
         * @namespace
         */
        var opts = {};

        opts.ConnectionOptions = (function() {

            /**
             * Properties of a ConnectionOptions.
             * @memberof protos.opts
             * @interface IConnectionOptions
             * @property {string|null} [name] ConnectionOptions name
             * @property {string|null} [notes] ConnectionOptions notes
             * @property {protos.args.IKafkaConn|null} [kafka] ConnectionOptions kafka
             * @property {protos.args.IActiveMQConn|null} [activeMq] ConnectionOptions activeMq
             * @property {protos.args.IAWSSQSConn|null} [awsSqs] ConnectionOptions awsSqs
             * @property {protos.args.IAWSSNSConn|null} [awsSns] ConnectionOptions awsSns
             * @property {protos.args.IMongoConn|null} [mongo] ConnectionOptions mongo
             * @property {protos.args.INatsConn|null} [nats] ConnectionOptions nats
             * @property {protos.args.INatsStreamingConn|null} [natsStreaming] ConnectionOptions natsStreaming
             * @property {protos.args.INSQConn|null} [nsq] ConnectionOptions nsq
             * @property {protos.args.IPostgresConn|null} [postgres] ConnectionOptions postgres
             * @property {protos.args.IPulsarConn|null} [pulsar] ConnectionOptions pulsar
             * @property {protos.args.IRabbitConn|null} [rabbit] ConnectionOptions rabbit
             * @property {protos.args.IRabbitStreamsConn|null} [rabbitStreams] ConnectionOptions rabbitStreams
             * @property {protos.args.IRedisPubSubConn|null} [redisPubsub] ConnectionOptions redisPubsub
             * @property {protos.args.IRedisStreamsConn|null} [redisStreams] ConnectionOptions redisStreams
             * @property {protos.args.IAzureEventHubConn|null} [azureEventHub] ConnectionOptions azureEventHub
             * @property {protos.args.IAzureServiceBusConn|null} [azureServiceBus] ConnectionOptions azureServiceBus
             * @property {protos.args.IMQTTConn|null} [mqtt] ConnectionOptions mqtt
             * @property {protos.args.IKubeMQQueueConn|null} [kubemqQueue] ConnectionOptions kubemqQueue
             * @property {protos.args.IGCPPubSubConn|null} [gcpPubsub] ConnectionOptions gcpPubsub
             * @property {protos.args.INatsJetstreamConn|null} [natsJetstream] ConnectionOptions natsJetstream
             * @property {protos.args.IAWSKinesisConn|null} [awsKinesis] ConnectionOptions awsKinesis
             * @property {protos.args.IMemphisConn|null} [memphis] ConnectionOptions memphis
             * @property {string|null} [_id] ConnectionOptions _id
             */

            /**
             * Constructs a new ConnectionOptions.
             * @memberof protos.opts
             * @classdesc Represents a ConnectionOptions.
             * @implements IConnectionOptions
             * @constructor
             * @param {protos.opts.IConnectionOptions=} [properties] Properties to set
             */
            function ConnectionOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ConnectionOptions name.
             * @member {string} name
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.name = "";

            /**
             * ConnectionOptions notes.
             * @member {string} notes
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.notes = "";

            /**
             * ConnectionOptions kafka.
             * @member {protos.args.IKafkaConn|null|undefined} kafka
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.kafka = null;

            /**
             * ConnectionOptions activeMq.
             * @member {protos.args.IActiveMQConn|null|undefined} activeMq
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.activeMq = null;

            /**
             * ConnectionOptions awsSqs.
             * @member {protos.args.IAWSSQSConn|null|undefined} awsSqs
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.awsSqs = null;

            /**
             * ConnectionOptions awsSns.
             * @member {protos.args.IAWSSNSConn|null|undefined} awsSns
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.awsSns = null;

            /**
             * ConnectionOptions mongo.
             * @member {protos.args.IMongoConn|null|undefined} mongo
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.mongo = null;

            /**
             * ConnectionOptions nats.
             * @member {protos.args.INatsConn|null|undefined} nats
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.nats = null;

            /**
             * ConnectionOptions natsStreaming.
             * @member {protos.args.INatsStreamingConn|null|undefined} natsStreaming
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.natsStreaming = null;

            /**
             * ConnectionOptions nsq.
             * @member {protos.args.INSQConn|null|undefined} nsq
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.nsq = null;

            /**
             * ConnectionOptions postgres.
             * @member {protos.args.IPostgresConn|null|undefined} postgres
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.postgres = null;

            /**
             * ConnectionOptions pulsar.
             * @member {protos.args.IPulsarConn|null|undefined} pulsar
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.pulsar = null;

            /**
             * ConnectionOptions rabbit.
             * @member {protos.args.IRabbitConn|null|undefined} rabbit
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.rabbit = null;

            /**
             * ConnectionOptions rabbitStreams.
             * @member {protos.args.IRabbitStreamsConn|null|undefined} rabbitStreams
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.rabbitStreams = null;

            /**
             * ConnectionOptions redisPubsub.
             * @member {protos.args.IRedisPubSubConn|null|undefined} redisPubsub
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.redisPubsub = null;

            /**
             * ConnectionOptions redisStreams.
             * @member {protos.args.IRedisStreamsConn|null|undefined} redisStreams
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.redisStreams = null;

            /**
             * ConnectionOptions azureEventHub.
             * @member {protos.args.IAzureEventHubConn|null|undefined} azureEventHub
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.azureEventHub = null;

            /**
             * ConnectionOptions azureServiceBus.
             * @member {protos.args.IAzureServiceBusConn|null|undefined} azureServiceBus
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.azureServiceBus = null;

            /**
             * ConnectionOptions mqtt.
             * @member {protos.args.IMQTTConn|null|undefined} mqtt
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.mqtt = null;

            /**
             * ConnectionOptions kubemqQueue.
             * @member {protos.args.IKubeMQQueueConn|null|undefined} kubemqQueue
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.kubemqQueue = null;

            /**
             * ConnectionOptions gcpPubsub.
             * @member {protos.args.IGCPPubSubConn|null|undefined} gcpPubsub
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.gcpPubsub = null;

            /**
             * ConnectionOptions natsJetstream.
             * @member {protos.args.INatsJetstreamConn|null|undefined} natsJetstream
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.natsJetstream = null;

            /**
             * ConnectionOptions awsKinesis.
             * @member {protos.args.IAWSKinesisConn|null|undefined} awsKinesis
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.awsKinesis = null;

            /**
             * ConnectionOptions memphis.
             * @member {protos.args.IMemphisConn|null|undefined} memphis
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.memphis = null;

            /**
             * ConnectionOptions _id.
             * @member {string} _id
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype._id = "";

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * ConnectionOptions conn.
             * @member {"kafka"|"activeMq"|"awsSqs"|"awsSns"|"mongo"|"nats"|"natsStreaming"|"nsq"|"postgres"|"pulsar"|"rabbit"|"rabbitStreams"|"redisPubsub"|"redisStreams"|"azureEventHub"|"azureServiceBus"|"mqtt"|"kubemqQueue"|"gcpPubsub"|"natsJetstream"|"awsKinesis"|"memphis"|undefined} conn
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            Object.defineProperty(ConnectionOptions.prototype, "conn", {
                get: $util.oneOfGetter($oneOfFields = ["kafka", "activeMq", "awsSqs", "awsSns", "mongo", "nats", "natsStreaming", "nsq", "postgres", "pulsar", "rabbit", "rabbitStreams", "redisPubsub", "redisStreams", "azureEventHub", "azureServiceBus", "mqtt", "kubemqQueue", "gcpPubsub", "natsJetstream", "awsKinesis", "memphis"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ConnectionOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {protos.opts.IConnectionOptions=} [properties] Properties to set
             * @returns {protos.opts.ConnectionOptions} ConnectionOptions instance
             */
            ConnectionOptions.create = function create(properties) {
                return new ConnectionOptions(properties);
            };

            /**
             * Encodes the specified ConnectionOptions message. Does not implicitly {@link protos.opts.ConnectionOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {protos.opts.IConnectionOptions} message ConnectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectionOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.notes);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.args.KafkaConn.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.activeMq != null && Object.hasOwnProperty.call(message, "activeMq"))
                    $root.protos.args.ActiveMQConn.encode(message.activeMq, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.awsSqs != null && Object.hasOwnProperty.call(message, "awsSqs"))
                    $root.protos.args.AWSSQSConn.encode(message.awsSqs, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.awsSns != null && Object.hasOwnProperty.call(message, "awsSns"))
                    $root.protos.args.AWSSNSConn.encode(message.awsSns, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.mongo != null && Object.hasOwnProperty.call(message, "mongo"))
                    $root.protos.args.MongoConn.encode(message.mongo, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.args.NatsConn.encode(message.nats, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.args.NatsStreamingConn.encode(message.natsStreaming, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.args.NSQConn.encode(message.nsq, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.postgres != null && Object.hasOwnProperty.call(message, "postgres"))
                    $root.protos.args.PostgresConn.encode(message.postgres, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.pulsar != null && Object.hasOwnProperty.call(message, "pulsar"))
                    $root.protos.args.PulsarConn.encode(message.pulsar, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.args.RabbitConn.encode(message.rabbit, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
                if (message.rabbitStreams != null && Object.hasOwnProperty.call(message, "rabbitStreams"))
                    $root.protos.args.RabbitStreamsConn.encode(message.rabbitStreams, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.args.RedisPubSubConn.encode(message.redisPubsub, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.args.RedisStreamsConn.encode(message.redisStreams, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.azureEventHub != null && Object.hasOwnProperty.call(message, "azureEventHub"))
                    $root.protos.args.AzureEventHubConn.encode(message.azureEventHub, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.args.AzureServiceBusConn.encode(message.azureServiceBus, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.args.MQTTConn.encode(message.mqtt, writer.uint32(/* id 116, wireType 2 =*/930).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.args.KubeMQQueueConn.encode(message.kubemqQueue, writer.uint32(/* id 117, wireType 2 =*/938).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.args.GCPPubSubConn.encode(message.gcpPubsub, writer.uint32(/* id 118, wireType 2 =*/946).fork()).ldelim();
                if (message.natsJetstream != null && Object.hasOwnProperty.call(message, "natsJetstream"))
                    $root.protos.args.NatsJetstreamConn.encode(message.natsJetstream, writer.uint32(/* id 119, wireType 2 =*/954).fork()).ldelim();
                if (message.awsKinesis != null && Object.hasOwnProperty.call(message, "awsKinesis"))
                    $root.protos.args.AWSKinesisConn.encode(message.awsKinesis, writer.uint32(/* id 120, wireType 2 =*/962).fork()).ldelim();
                if (message.memphis != null && Object.hasOwnProperty.call(message, "memphis"))
                    $root.protos.args.MemphisConn.encode(message.memphis, writer.uint32(/* id 121, wireType 2 =*/970).fork()).ldelim();
                if (message._id != null && Object.hasOwnProperty.call(message, "_id"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._id);
                return writer;
            };

            /**
             * Encodes the specified ConnectionOptions message, length delimited. Does not implicitly {@link protos.opts.ConnectionOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {protos.opts.IConnectionOptions} message ConnectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectionOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ConnectionOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ConnectionOptions} ConnectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectionOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ConnectionOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.notes = reader.string();
                        break;
                    case 100:
                        message.kafka = $root.protos.args.KafkaConn.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.activeMq = $root.protos.args.ActiveMQConn.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.awsSqs = $root.protos.args.AWSSQSConn.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.awsSns = $root.protos.args.AWSSNSConn.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.mongo = $root.protos.args.MongoConn.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.nats = $root.protos.args.NatsConn.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.natsStreaming = $root.protos.args.NatsStreamingConn.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.nsq = $root.protos.args.NSQConn.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.postgres = $root.protos.args.PostgresConn.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.pulsar = $root.protos.args.PulsarConn.decode(reader, reader.uint32());
                        break;
                    case 110:
                        message.rabbit = $root.protos.args.RabbitConn.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.rabbitStreams = $root.protos.args.RabbitStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.redisPubsub = $root.protos.args.RedisPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.redisStreams = $root.protos.args.RedisStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.azureEventHub = $root.protos.args.AzureEventHubConn.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.azureServiceBus = $root.protos.args.AzureServiceBusConn.decode(reader, reader.uint32());
                        break;
                    case 116:
                        message.mqtt = $root.protos.args.MQTTConn.decode(reader, reader.uint32());
                        break;
                    case 117:
                        message.kubemqQueue = $root.protos.args.KubeMQQueueConn.decode(reader, reader.uint32());
                        break;
                    case 118:
                        message.gcpPubsub = $root.protos.args.GCPPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 119:
                        message.natsJetstream = $root.protos.args.NatsJetstreamConn.decode(reader, reader.uint32());
                        break;
                    case 120:
                        message.awsKinesis = $root.protos.args.AWSKinesisConn.decode(reader, reader.uint32());
                        break;
                    case 121:
                        message.memphis = $root.protos.args.MemphisConn.decode(reader, reader.uint32());
                        break;
                    case 1000:
                        message._id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ConnectionOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ConnectionOptions} ConnectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectionOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ConnectionOptions message.
             * @function verify
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConnectionOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.notes != null && message.hasOwnProperty("notes"))
                    if (!$util.isString(message.notes))
                        return "notes: string expected";
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.KafkaConn.verify(message.kafka);
                        if (error)
                            return "kafka." + error;
                    }
                }
                if (message.activeMq != null && message.hasOwnProperty("activeMq")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.ActiveMQConn.verify(message.activeMq);
                        if (error)
                            return "activeMq." + error;
                    }
                }
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.AWSSQSConn.verify(message.awsSqs);
                        if (error)
                            return "awsSqs." + error;
                    }
                }
                if (message.awsSns != null && message.hasOwnProperty("awsSns")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.AWSSNSConn.verify(message.awsSns);
                        if (error)
                            return "awsSns." + error;
                    }
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.MongoConn.verify(message.mongo);
                        if (error)
                            return "mongo." + error;
                    }
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.NatsConn.verify(message.nats);
                        if (error)
                            return "nats." + error;
                    }
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.NatsStreamingConn.verify(message.natsStreaming);
                        if (error)
                            return "natsStreaming." + error;
                    }
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.NSQConn.verify(message.nsq);
                        if (error)
                            return "nsq." + error;
                    }
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.PostgresConn.verify(message.postgres);
                        if (error)
                            return "postgres." + error;
                    }
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.PulsarConn.verify(message.pulsar);
                        if (error)
                            return "pulsar." + error;
                    }
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.RabbitConn.verify(message.rabbit);
                        if (error)
                            return "rabbit." + error;
                    }
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.RabbitStreamsConn.verify(message.rabbitStreams);
                        if (error)
                            return "rabbitStreams." + error;
                    }
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.RedisPubSubConn.verify(message.redisPubsub);
                        if (error)
                            return "redisPubsub." + error;
                    }
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.RedisStreamsConn.verify(message.redisStreams);
                        if (error)
                            return "redisStreams." + error;
                    }
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.AzureEventHubConn.verify(message.azureEventHub);
                        if (error)
                            return "azureEventHub." + error;
                    }
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.AzureServiceBusConn.verify(message.azureServiceBus);
                        if (error)
                            return "azureServiceBus." + error;
                    }
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.MQTTConn.verify(message.mqtt);
                        if (error)
                            return "mqtt." + error;
                    }
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.KubeMQQueueConn.verify(message.kubemqQueue);
                        if (error)
                            return "kubemqQueue." + error;
                    }
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.GCPPubSubConn.verify(message.gcpPubsub);
                        if (error)
                            return "gcpPubsub." + error;
                    }
                }
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.NatsJetstreamConn.verify(message.natsJetstream);
                        if (error)
                            return "natsJetstream." + error;
                    }
                }
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.AWSKinesisConn.verify(message.awsKinesis);
                        if (error)
                            return "awsKinesis." + error;
                    }
                }
                if (message.memphis != null && message.hasOwnProperty("memphis")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.MemphisConn.verify(message.memphis);
                        if (error)
                            return "memphis." + error;
                    }
                }
                if (message._id != null && message.hasOwnProperty("_id"))
                    if (!$util.isString(message._id))
                        return "_id: string expected";
                return null;
            };

            /**
             * Creates a ConnectionOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ConnectionOptions} ConnectionOptions
             */
            ConnectionOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ConnectionOptions)
                    return object;
                var message = new $root.protos.opts.ConnectionOptions();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.notes != null)
                    message.notes = String(object.notes);
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.kafka: object expected");
                    message.kafka = $root.protos.args.KafkaConn.fromObject(object.kafka);
                }
                if (object.activeMq != null) {
                    if (typeof object.activeMq !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.activeMq: object expected");
                    message.activeMq = $root.protos.args.ActiveMQConn.fromObject(object.activeMq);
                }
                if (object.awsSqs != null) {
                    if (typeof object.awsSqs !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.awsSqs: object expected");
                    message.awsSqs = $root.protos.args.AWSSQSConn.fromObject(object.awsSqs);
                }
                if (object.awsSns != null) {
                    if (typeof object.awsSns !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.awsSns: object expected");
                    message.awsSns = $root.protos.args.AWSSNSConn.fromObject(object.awsSns);
                }
                if (object.mongo != null) {
                    if (typeof object.mongo !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.mongo: object expected");
                    message.mongo = $root.protos.args.MongoConn.fromObject(object.mongo);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.nats: object expected");
                    message.nats = $root.protos.args.NatsConn.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.args.NatsStreamingConn.fromObject(object.natsStreaming);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.nsq: object expected");
                    message.nsq = $root.protos.args.NSQConn.fromObject(object.nsq);
                }
                if (object.postgres != null) {
                    if (typeof object.postgres !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.postgres: object expected");
                    message.postgres = $root.protos.args.PostgresConn.fromObject(object.postgres);
                }
                if (object.pulsar != null) {
                    if (typeof object.pulsar !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.pulsar: object expected");
                    message.pulsar = $root.protos.args.PulsarConn.fromObject(object.pulsar);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.rabbit: object expected");
                    message.rabbit = $root.protos.args.RabbitConn.fromObject(object.rabbit);
                }
                if (object.rabbitStreams != null) {
                    if (typeof object.rabbitStreams !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.rabbitStreams: object expected");
                    message.rabbitStreams = $root.protos.args.RabbitStreamsConn.fromObject(object.rabbitStreams);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.args.RedisPubSubConn.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.args.RedisStreamsConn.fromObject(object.redisStreams);
                }
                if (object.azureEventHub != null) {
                    if (typeof object.azureEventHub !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.azureEventHub: object expected");
                    message.azureEventHub = $root.protos.args.AzureEventHubConn.fromObject(object.azureEventHub);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.args.AzureServiceBusConn.fromObject(object.azureServiceBus);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.mqtt: object expected");
                    message.mqtt = $root.protos.args.MQTTConn.fromObject(object.mqtt);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.args.KubeMQQueueConn.fromObject(object.kubemqQueue);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.args.GCPPubSubConn.fromObject(object.gcpPubsub);
                }
                if (object.natsJetstream != null) {
                    if (typeof object.natsJetstream !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.natsJetstream: object expected");
                    message.natsJetstream = $root.protos.args.NatsJetstreamConn.fromObject(object.natsJetstream);
                }
                if (object.awsKinesis != null) {
                    if (typeof object.awsKinesis !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.awsKinesis: object expected");
                    message.awsKinesis = $root.protos.args.AWSKinesisConn.fromObject(object.awsKinesis);
                }
                if (object.memphis != null) {
                    if (typeof object.memphis !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.memphis: object expected");
                    message.memphis = $root.protos.args.MemphisConn.fromObject(object.memphis);
                }
                if (object._id != null)
                    message._id = String(object._id);
                return message;
            };

            /**
             * Creates a plain object from a ConnectionOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {protos.opts.ConnectionOptions} message ConnectionOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConnectionOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.notes = "";
                    object._id = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.notes != null && message.hasOwnProperty("notes"))
                    object.notes = message.notes;
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    object.kafka = $root.protos.args.KafkaConn.toObject(message.kafka, options);
                    if (options.oneofs)
                        object.conn = "kafka";
                }
                if (message.activeMq != null && message.hasOwnProperty("activeMq")) {
                    object.activeMq = $root.protos.args.ActiveMQConn.toObject(message.activeMq, options);
                    if (options.oneofs)
                        object.conn = "activeMq";
                }
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs")) {
                    object.awsSqs = $root.protos.args.AWSSQSConn.toObject(message.awsSqs, options);
                    if (options.oneofs)
                        object.conn = "awsSqs";
                }
                if (message.awsSns != null && message.hasOwnProperty("awsSns")) {
                    object.awsSns = $root.protos.args.AWSSNSConn.toObject(message.awsSns, options);
                    if (options.oneofs)
                        object.conn = "awsSns";
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    object.mongo = $root.protos.args.MongoConn.toObject(message.mongo, options);
                    if (options.oneofs)
                        object.conn = "mongo";
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    object.nats = $root.protos.args.NatsConn.toObject(message.nats, options);
                    if (options.oneofs)
                        object.conn = "nats";
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    object.natsStreaming = $root.protos.args.NatsStreamingConn.toObject(message.natsStreaming, options);
                    if (options.oneofs)
                        object.conn = "natsStreaming";
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    object.nsq = $root.protos.args.NSQConn.toObject(message.nsq, options);
                    if (options.oneofs)
                        object.conn = "nsq";
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    object.postgres = $root.protos.args.PostgresConn.toObject(message.postgres, options);
                    if (options.oneofs)
                        object.conn = "postgres";
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    object.pulsar = $root.protos.args.PulsarConn.toObject(message.pulsar, options);
                    if (options.oneofs)
                        object.conn = "pulsar";
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    object.rabbit = $root.protos.args.RabbitConn.toObject(message.rabbit, options);
                    if (options.oneofs)
                        object.conn = "rabbit";
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    object.rabbitStreams = $root.protos.args.RabbitStreamsConn.toObject(message.rabbitStreams, options);
                    if (options.oneofs)
                        object.conn = "rabbitStreams";
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    object.redisPubsub = $root.protos.args.RedisPubSubConn.toObject(message.redisPubsub, options);
                    if (options.oneofs)
                        object.conn = "redisPubsub";
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    object.redisStreams = $root.protos.args.RedisStreamsConn.toObject(message.redisStreams, options);
                    if (options.oneofs)
                        object.conn = "redisStreams";
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    object.azureEventHub = $root.protos.args.AzureEventHubConn.toObject(message.azureEventHub, options);
                    if (options.oneofs)
                        object.conn = "azureEventHub";
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    object.azureServiceBus = $root.protos.args.AzureServiceBusConn.toObject(message.azureServiceBus, options);
                    if (options.oneofs)
                        object.conn = "azureServiceBus";
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    object.mqtt = $root.protos.args.MQTTConn.toObject(message.mqtt, options);
                    if (options.oneofs)
                        object.conn = "mqtt";
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    object.kubemqQueue = $root.protos.args.KubeMQQueueConn.toObject(message.kubemqQueue, options);
                    if (options.oneofs)
                        object.conn = "kubemqQueue";
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    object.gcpPubsub = $root.protos.args.GCPPubSubConn.toObject(message.gcpPubsub, options);
                    if (options.oneofs)
                        object.conn = "gcpPubsub";
                }
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream")) {
                    object.natsJetstream = $root.protos.args.NatsJetstreamConn.toObject(message.natsJetstream, options);
                    if (options.oneofs)
                        object.conn = "natsJetstream";
                }
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis")) {
                    object.awsKinesis = $root.protos.args.AWSKinesisConn.toObject(message.awsKinesis, options);
                    if (options.oneofs)
                        object.conn = "awsKinesis";
                }
                if (message.memphis != null && message.hasOwnProperty("memphis")) {
                    object.memphis = $root.protos.args.MemphisConn.toObject(message.memphis, options);
                    if (options.oneofs)
                        object.conn = "memphis";
                }
                if (message._id != null && message.hasOwnProperty("_id"))
                    object._id = message._id;
                return object;
            };

            /**
             * Converts this ConnectionOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ConnectionOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConnectionOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ConnectionOptions;
        })();

        opts.RelayCLIOptions = (function() {

            /**
             * Properties of a RelayCLIOptions.
             * @memberof protos.opts
             * @interface IRelayCLIOptions
             * @property {string|null} [httpListenAddress] RelayCLIOptions httpListenAddress
             */

            /**
             * Constructs a new RelayCLIOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayCLIOptions.
             * @implements IRelayCLIOptions
             * @constructor
             * @param {protos.opts.IRelayCLIOptions=} [properties] Properties to set
             */
            function RelayCLIOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayCLIOptions httpListenAddress.
             * @member {string} httpListenAddress
             * @memberof protos.opts.RelayCLIOptions
             * @instance
             */
            RelayCLIOptions.prototype.httpListenAddress = "";

            /**
             * Creates a new RelayCLIOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {protos.opts.IRelayCLIOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayCLIOptions} RelayCLIOptions instance
             */
            RelayCLIOptions.create = function create(properties) {
                return new RelayCLIOptions(properties);
            };

            /**
             * Encodes the specified RelayCLIOptions message. Does not implicitly {@link protos.opts.RelayCLIOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {protos.opts.IRelayCLIOptions} message RelayCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayCLIOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.httpListenAddress != null && Object.hasOwnProperty.call(message, "httpListenAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.httpListenAddress);
                return writer;
            };

            /**
             * Encodes the specified RelayCLIOptions message, length delimited. Does not implicitly {@link protos.opts.RelayCLIOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {protos.opts.IRelayCLIOptions} message RelayCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayCLIOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayCLIOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayCLIOptions} RelayCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayCLIOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayCLIOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.httpListenAddress = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayCLIOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayCLIOptions} RelayCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayCLIOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayCLIOptions message.
             * @function verify
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayCLIOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.httpListenAddress != null && message.hasOwnProperty("httpListenAddress"))
                    if (!$util.isString(message.httpListenAddress))
                        return "httpListenAddress: string expected";
                return null;
            };

            /**
             * Creates a RelayCLIOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayCLIOptions} RelayCLIOptions
             */
            RelayCLIOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayCLIOptions)
                    return object;
                var message = new $root.protos.opts.RelayCLIOptions();
                if (object.httpListenAddress != null)
                    message.httpListenAddress = String(object.httpListenAddress);
                return message;
            };

            /**
             * Creates a plain object from a RelayCLIOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {protos.opts.RelayCLIOptions} message RelayCLIOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayCLIOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.httpListenAddress = "";
                if (message.httpListenAddress != null && message.hasOwnProperty("httpListenAddress"))
                    object.httpListenAddress = message.httpListenAddress;
                return object;
            };

            /**
             * Converts this RelayCLIOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayCLIOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayCLIOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayCLIOptions;
        })();

        opts.RelayOptions = (function() {

            /**
             * Properties of a RelayOptions.
             * @memberof protos.opts
             * @interface IRelayOptions
             * @property {string|null} [collectionToken] RelayOptions collectionToken
             * @property {number|null} [batchSize] RelayOptions batchSize
             * @property {number|null} [batchMaxRetry] RelayOptions batchMaxRetry
             * @property {string|null} [connectionId] RelayOptions connectionId
             * @property {number|null} [numWorkers] RelayOptions numWorkers
             * @property {boolean|null} [statsEnable] RelayOptions statsEnable
             * @property {number|null} [statsReportIntervalSec] RelayOptions statsReportIntervalSec
             * @property {boolean|null} [deadLetter] RelayOptions deadLetter
             * @property {string|null} [_streamdalGrpcAddress] RelayOptions _streamdalGrpcAddress
             * @property {boolean|null} [_streamdalGrpcDisableTls] RelayOptions _streamdalGrpcDisableTls
             * @property {number|null} [_streamdalGrpcTimeoutSeconds] RelayOptions _streamdalGrpcTimeoutSeconds
             * @property {string|null} [_relayId] RelayOptions _relayId
             * @property {protos.opts.IRelayCLIOptions|null} [_cliOptions] RelayOptions _cliOptions
             * @property {boolean|null} [_active] RelayOptions _active
             * @property {protos.opts.IRelayGroupKafkaOptions|null} [kafka] RelayOptions kafka
             * @property {protos.opts.IRelayGroupAWSSQSOptions|null} [awsSqs] RelayOptions awsSqs
             * @property {protos.opts.IRelayGroupMongoOptions|null} [mongo] RelayOptions mongo
             * @property {protos.opts.IRelayGroupNSQOptions|null} [nsq] RelayOptions nsq
             * @property {protos.opts.IRelayGroupRabbitOptions|null} [rabbit] RelayOptions rabbit
             * @property {protos.opts.IRelayGroupMQTTOptions|null} [mqtt] RelayOptions mqtt
             * @property {protos.opts.IRelayGroupAzureServiceBusOptions|null} [azureServiceBus] RelayOptions azureServiceBus
             * @property {protos.opts.IRelayGroupGCPPubSubOptions|null} [gcpPubsub] RelayOptions gcpPubsub
             * @property {protos.opts.IRelayGroupKubeMQQueueOptions|null} [kubemqQueue] RelayOptions kubemqQueue
             * @property {protos.opts.IRelayGroupRedisPubSubOptions|null} [redisPubsub] RelayOptions redisPubsub
             * @property {protos.opts.IRelayGroupRedisStreamsOptions|null} [redisStreams] RelayOptions redisStreams
             * @property {protos.opts.IRelayGroupPostgresOptions|null} [postgres] RelayOptions postgres
             * @property {protos.opts.IRelayGroupNatsOptions|null} [nats] RelayOptions nats
             * @property {protos.opts.IRelayGroupNatsStreamingOptions|null} [natsStreaming] RelayOptions natsStreaming
             * @property {protos.opts.IRelayGroupNatsJetStreamOptions|null} [natsJetstream] RelayOptions natsJetstream
             */

            /**
             * Constructs a new RelayOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayOptions.
             * @implements IRelayOptions
             * @constructor
             * @param {protos.opts.IRelayOptions=} [properties] Properties to set
             */
            function RelayOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayOptions collectionToken.
             * @member {string} collectionToken
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.collectionToken = "";

            /**
             * RelayOptions batchSize.
             * @member {number} batchSize
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.batchSize = 0;

            /**
             * RelayOptions batchMaxRetry.
             * @member {number} batchMaxRetry
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.batchMaxRetry = 0;

            /**
             * RelayOptions connectionId.
             * @member {string} connectionId
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.connectionId = "";

            /**
             * RelayOptions numWorkers.
             * @member {number} numWorkers
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.numWorkers = 0;

            /**
             * RelayOptions statsEnable.
             * @member {boolean} statsEnable
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.statsEnable = false;

            /**
             * RelayOptions statsReportIntervalSec.
             * @member {number} statsReportIntervalSec
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.statsReportIntervalSec = 0;

            /**
             * RelayOptions deadLetter.
             * @member {boolean} deadLetter
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.deadLetter = false;

            /**
             * RelayOptions _streamdalGrpcAddress.
             * @member {string} _streamdalGrpcAddress
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._streamdalGrpcAddress = "";

            /**
             * RelayOptions _streamdalGrpcDisableTls.
             * @member {boolean} _streamdalGrpcDisableTls
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._streamdalGrpcDisableTls = false;

            /**
             * RelayOptions _streamdalGrpcTimeoutSeconds.
             * @member {number} _streamdalGrpcTimeoutSeconds
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._streamdalGrpcTimeoutSeconds = 0;

            /**
             * RelayOptions _relayId.
             * @member {string} _relayId
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._relayId = "";

            /**
             * RelayOptions _cliOptions.
             * @member {protos.opts.IRelayCLIOptions|null|undefined} _cliOptions
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._cliOptions = null;

            /**
             * RelayOptions _active.
             * @member {boolean} _active
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._active = false;

            /**
             * RelayOptions kafka.
             * @member {protos.opts.IRelayGroupKafkaOptions|null|undefined} kafka
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.kafka = null;

            /**
             * RelayOptions awsSqs.
             * @member {protos.opts.IRelayGroupAWSSQSOptions|null|undefined} awsSqs
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.awsSqs = null;

            /**
             * RelayOptions mongo.
             * @member {protos.opts.IRelayGroupMongoOptions|null|undefined} mongo
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.mongo = null;

            /**
             * RelayOptions nsq.
             * @member {protos.opts.IRelayGroupNSQOptions|null|undefined} nsq
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.nsq = null;

            /**
             * RelayOptions rabbit.
             * @member {protos.opts.IRelayGroupRabbitOptions|null|undefined} rabbit
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.rabbit = null;

            /**
             * RelayOptions mqtt.
             * @member {protos.opts.IRelayGroupMQTTOptions|null|undefined} mqtt
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.mqtt = null;

            /**
             * RelayOptions azureServiceBus.
             * @member {protos.opts.IRelayGroupAzureServiceBusOptions|null|undefined} azureServiceBus
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.azureServiceBus = null;

            /**
             * RelayOptions gcpPubsub.
             * @member {protos.opts.IRelayGroupGCPPubSubOptions|null|undefined} gcpPubsub
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.gcpPubsub = null;

            /**
             * RelayOptions kubemqQueue.
             * @member {protos.opts.IRelayGroupKubeMQQueueOptions|null|undefined} kubemqQueue
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.kubemqQueue = null;

            /**
             * RelayOptions redisPubsub.
             * @member {protos.opts.IRelayGroupRedisPubSubOptions|null|undefined} redisPubsub
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.redisPubsub = null;

            /**
             * RelayOptions redisStreams.
             * @member {protos.opts.IRelayGroupRedisStreamsOptions|null|undefined} redisStreams
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.redisStreams = null;

            /**
             * RelayOptions postgres.
             * @member {protos.opts.IRelayGroupPostgresOptions|null|undefined} postgres
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.postgres = null;

            /**
             * RelayOptions nats.
             * @member {protos.opts.IRelayGroupNatsOptions|null|undefined} nats
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.nats = null;

            /**
             * RelayOptions natsStreaming.
             * @member {protos.opts.IRelayGroupNatsStreamingOptions|null|undefined} natsStreaming
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.natsStreaming = null;

            /**
             * RelayOptions natsJetstream.
             * @member {protos.opts.IRelayGroupNatsJetStreamOptions|null|undefined} natsJetstream
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.natsJetstream = null;

            /**
             * Creates a new RelayOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {protos.opts.IRelayOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayOptions} RelayOptions instance
             */
            RelayOptions.create = function create(properties) {
                return new RelayOptions(properties);
            };

            /**
             * Encodes the specified RelayOptions message. Does not implicitly {@link protos.opts.RelayOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {protos.opts.IRelayOptions} message RelayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collectionToken != null && Object.hasOwnProperty.call(message, "collectionToken"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.collectionToken);
                if (message.batchSize != null && Object.hasOwnProperty.call(message, "batchSize"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.batchSize);
                if (message.batchMaxRetry != null && Object.hasOwnProperty.call(message, "batchMaxRetry"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.batchMaxRetry);
                if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.connectionId);
                if (message.numWorkers != null && Object.hasOwnProperty.call(message, "numWorkers"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.numWorkers);
                if (message.statsEnable != null && Object.hasOwnProperty.call(message, "statsEnable"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.statsEnable);
                if (message.statsReportIntervalSec != null && Object.hasOwnProperty.call(message, "statsReportIntervalSec"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.statsReportIntervalSec);
                if (message.deadLetter != null && Object.hasOwnProperty.call(message, "deadLetter"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.deadLetter);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.opts.RelayGroupKafkaOptions.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.awsSqs != null && Object.hasOwnProperty.call(message, "awsSqs"))
                    $root.protos.opts.RelayGroupAWSSQSOptions.encode(message.awsSqs, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.mongo != null && Object.hasOwnProperty.call(message, "mongo"))
                    $root.protos.opts.RelayGroupMongoOptions.encode(message.mongo, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.opts.RelayGroupNSQOptions.encode(message.nsq, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.opts.RelayGroupRabbitOptions.encode(message.rabbit, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.opts.RelayGroupMQTTOptions.encode(message.mqtt, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.opts.RelayGroupAzureServiceBusOptions.encode(message.azureServiceBus, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.opts.RelayGroupGCPPubSubOptions.encode(message.gcpPubsub, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.opts.RelayGroupKubeMQQueueOptions.encode(message.kubemqQueue, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.opts.RelayGroupRedisPubSubOptions.encode(message.redisPubsub, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.opts.RelayGroupRedisStreamsOptions.encode(message.redisStreams, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.postgres != null && Object.hasOwnProperty.call(message, "postgres"))
                    $root.protos.opts.RelayGroupPostgresOptions.encode(message.postgres, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.opts.RelayGroupNatsOptions.encode(message.nats, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.opts.RelayGroupNatsStreamingOptions.encode(message.natsStreaming, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.natsJetstream != null && Object.hasOwnProperty.call(message, "natsJetstream"))
                    $root.protos.opts.RelayGroupNatsJetStreamOptions.encode(message.natsJetstream, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                if (message._streamdalGrpcAddress != null && Object.hasOwnProperty.call(message, "_streamdalGrpcAddress"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._streamdalGrpcAddress);
                if (message._streamdalGrpcDisableTls != null && Object.hasOwnProperty.call(message, "_streamdalGrpcDisableTls"))
                    writer.uint32(/* id 1001, wireType 0 =*/8008).bool(message._streamdalGrpcDisableTls);
                if (message._streamdalGrpcTimeoutSeconds != null && Object.hasOwnProperty.call(message, "_streamdalGrpcTimeoutSeconds"))
                    writer.uint32(/* id 1002, wireType 0 =*/8016).int32(message._streamdalGrpcTimeoutSeconds);
                if (message._relayId != null && Object.hasOwnProperty.call(message, "_relayId"))
                    writer.uint32(/* id 1003, wireType 2 =*/8026).string(message._relayId);
                if (message._cliOptions != null && Object.hasOwnProperty.call(message, "_cliOptions"))
                    $root.protos.opts.RelayCLIOptions.encode(message._cliOptions, writer.uint32(/* id 1004, wireType 2 =*/8034).fork()).ldelim();
                if (message._active != null && Object.hasOwnProperty.call(message, "_active"))
                    writer.uint32(/* id 1005, wireType 0 =*/8040).bool(message._active);
                return writer;
            };

            /**
             * Encodes the specified RelayOptions message, length delimited. Does not implicitly {@link protos.opts.RelayOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {protos.opts.IRelayOptions} message RelayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayOptions} RelayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collectionToken = reader.string();
                        break;
                    case 2:
                        message.batchSize = reader.int32();
                        break;
                    case 3:
                        message.batchMaxRetry = reader.int32();
                        break;
                    case 4:
                        message.connectionId = reader.string();
                        break;
                    case 5:
                        message.numWorkers = reader.int32();
                        break;
                    case 6:
                        message.statsEnable = reader.bool();
                        break;
                    case 7:
                        message.statsReportIntervalSec = reader.int32();
                        break;
                    case 8:
                        message.deadLetter = reader.bool();
                        break;
                    case 1000:
                        message._streamdalGrpcAddress = reader.string();
                        break;
                    case 1001:
                        message._streamdalGrpcDisableTls = reader.bool();
                        break;
                    case 1002:
                        message._streamdalGrpcTimeoutSeconds = reader.int32();
                        break;
                    case 1003:
                        message._relayId = reader.string();
                        break;
                    case 1004:
                        message._cliOptions = $root.protos.opts.RelayCLIOptions.decode(reader, reader.uint32());
                        break;
                    case 1005:
                        message._active = reader.bool();
                        break;
                    case 100:
                        message.kafka = $root.protos.opts.RelayGroupKafkaOptions.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.awsSqs = $root.protos.opts.RelayGroupAWSSQSOptions.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.mongo = $root.protos.opts.RelayGroupMongoOptions.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.nsq = $root.protos.opts.RelayGroupNSQOptions.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.rabbit = $root.protos.opts.RelayGroupRabbitOptions.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.mqtt = $root.protos.opts.RelayGroupMQTTOptions.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.azureServiceBus = $root.protos.opts.RelayGroupAzureServiceBusOptions.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.gcpPubsub = $root.protos.opts.RelayGroupGCPPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.kubemqQueue = $root.protos.opts.RelayGroupKubeMQQueueOptions.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.redisPubsub = $root.protos.opts.RelayGroupRedisPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.redisStreams = $root.protos.opts.RelayGroupRedisStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.postgres = $root.protos.opts.RelayGroupPostgresOptions.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.nats = $root.protos.opts.RelayGroupNatsOptions.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.natsStreaming = $root.protos.opts.RelayGroupNatsStreamingOptions.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.natsJetstream = $root.protos.opts.RelayGroupNatsJetStreamOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayOptions} RelayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayOptions message.
             * @function verify
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collectionToken != null && message.hasOwnProperty("collectionToken"))
                    if (!$util.isString(message.collectionToken))
                        return "collectionToken: string expected";
                if (message.batchSize != null && message.hasOwnProperty("batchSize"))
                    if (!$util.isInteger(message.batchSize))
                        return "batchSize: integer expected";
                if (message.batchMaxRetry != null && message.hasOwnProperty("batchMaxRetry"))
                    if (!$util.isInteger(message.batchMaxRetry))
                        return "batchMaxRetry: integer expected";
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    if (!$util.isString(message.connectionId))
                        return "connectionId: string expected";
                if (message.numWorkers != null && message.hasOwnProperty("numWorkers"))
                    if (!$util.isInteger(message.numWorkers))
                        return "numWorkers: integer expected";
                if (message.statsEnable != null && message.hasOwnProperty("statsEnable"))
                    if (typeof message.statsEnable !== "boolean")
                        return "statsEnable: boolean expected";
                if (message.statsReportIntervalSec != null && message.hasOwnProperty("statsReportIntervalSec"))
                    if (!$util.isInteger(message.statsReportIntervalSec))
                        return "statsReportIntervalSec: integer expected";
                if (message.deadLetter != null && message.hasOwnProperty("deadLetter"))
                    if (typeof message.deadLetter !== "boolean")
                        return "deadLetter: boolean expected";
                if (message._streamdalGrpcAddress != null && message.hasOwnProperty("_streamdalGrpcAddress"))
                    if (!$util.isString(message._streamdalGrpcAddress))
                        return "_streamdalGrpcAddress: string expected";
                if (message._streamdalGrpcDisableTls != null && message.hasOwnProperty("_streamdalGrpcDisableTls"))
                    if (typeof message._streamdalGrpcDisableTls !== "boolean")
                        return "_streamdalGrpcDisableTls: boolean expected";
                if (message._streamdalGrpcTimeoutSeconds != null && message.hasOwnProperty("_streamdalGrpcTimeoutSeconds"))
                    if (!$util.isInteger(message._streamdalGrpcTimeoutSeconds))
                        return "_streamdalGrpcTimeoutSeconds: integer expected";
                if (message._relayId != null && message.hasOwnProperty("_relayId"))
                    if (!$util.isString(message._relayId))
                        return "_relayId: string expected";
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions")) {
                    var error = $root.protos.opts.RelayCLIOptions.verify(message._cliOptions);
                    if (error)
                        return "_cliOptions." + error;
                }
                if (message._active != null && message.hasOwnProperty("_active"))
                    if (typeof message._active !== "boolean")
                        return "_active: boolean expected";
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    var error = $root.protos.opts.RelayGroupKafkaOptions.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs")) {
                    var error = $root.protos.opts.RelayGroupAWSSQSOptions.verify(message.awsSqs);
                    if (error)
                        return "awsSqs." + error;
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    var error = $root.protos.opts.RelayGroupMongoOptions.verify(message.mongo);
                    if (error)
                        return "mongo." + error;
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    var error = $root.protos.opts.RelayGroupNSQOptions.verify(message.nsq);
                    if (error)
                        return "nsq." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    var error = $root.protos.opts.RelayGroupRabbitOptions.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    var error = $root.protos.opts.RelayGroupMQTTOptions.verify(message.mqtt);
                    if (error)
                        return "mqtt." + error;
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    var error = $root.protos.opts.RelayGroupAzureServiceBusOptions.verify(message.azureServiceBus);
                    if (error)
                        return "azureServiceBus." + error;
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    var error = $root.protos.opts.RelayGroupGCPPubSubOptions.verify(message.gcpPubsub);
                    if (error)
                        return "gcpPubsub." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    var error = $root.protos.opts.RelayGroupKubeMQQueueOptions.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    var error = $root.protos.opts.RelayGroupRedisPubSubOptions.verify(message.redisPubsub);
                    if (error)
                        return "redisPubsub." + error;
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    var error = $root.protos.opts.RelayGroupRedisStreamsOptions.verify(message.redisStreams);
                    if (error)
                        return "redisStreams." + error;
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    var error = $root.protos.opts.RelayGroupPostgresOptions.verify(message.postgres);
                    if (error)
                        return "postgres." + error;
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    var error = $root.protos.opts.RelayGroupNatsOptions.verify(message.nats);
                    if (error)
                        return "nats." + error;
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    var error = $root.protos.opts.RelayGroupNatsStreamingOptions.verify(message.natsStreaming);
                    if (error)
                        return "natsStreaming." + error;
                }
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream")) {
                    var error = $root.protos.opts.RelayGroupNatsJetStreamOptions.verify(message.natsJetstream);
                    if (error)
                        return "natsJetstream." + error;
                }
                return null;
            };

            /**
             * Creates a RelayOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayOptions} RelayOptions
             */
            RelayOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayOptions)
                    return object;
                var message = new $root.protos.opts.RelayOptions();
                if (object.collectionToken != null)
                    message.collectionToken = String(object.collectionToken);
                if (object.batchSize != null)
                    message.batchSize = object.batchSize | 0;
                if (object.batchMaxRetry != null)
                    message.batchMaxRetry = object.batchMaxRetry | 0;
                if (object.connectionId != null)
                    message.connectionId = String(object.connectionId);
                if (object.numWorkers != null)
                    message.numWorkers = object.numWorkers | 0;
                if (object.statsEnable != null)
                    message.statsEnable = Boolean(object.statsEnable);
                if (object.statsReportIntervalSec != null)
                    message.statsReportIntervalSec = object.statsReportIntervalSec | 0;
                if (object.deadLetter != null)
                    message.deadLetter = Boolean(object.deadLetter);
                if (object._streamdalGrpcAddress != null)
                    message._streamdalGrpcAddress = String(object._streamdalGrpcAddress);
                if (object._streamdalGrpcDisableTls != null)
                    message._streamdalGrpcDisableTls = Boolean(object._streamdalGrpcDisableTls);
                if (object._streamdalGrpcTimeoutSeconds != null)
                    message._streamdalGrpcTimeoutSeconds = object._streamdalGrpcTimeoutSeconds | 0;
                if (object._relayId != null)
                    message._relayId = String(object._relayId);
                if (object._cliOptions != null) {
                    if (typeof object._cliOptions !== "object")
                        throw TypeError(".protos.opts.RelayOptions._cliOptions: object expected");
                    message._cliOptions = $root.protos.opts.RelayCLIOptions.fromObject(object._cliOptions);
                }
                if (object._active != null)
                    message._active = Boolean(object._active);
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.RelayOptions.kafka: object expected");
                    message.kafka = $root.protos.opts.RelayGroupKafkaOptions.fromObject(object.kafka);
                }
                if (object.awsSqs != null) {
                    if (typeof object.awsSqs !== "object")
                        throw TypeError(".protos.opts.RelayOptions.awsSqs: object expected");
                    message.awsSqs = $root.protos.opts.RelayGroupAWSSQSOptions.fromObject(object.awsSqs);
                }
                if (object.mongo != null) {
                    if (typeof object.mongo !== "object")
                        throw TypeError(".protos.opts.RelayOptions.mongo: object expected");
                    message.mongo = $root.protos.opts.RelayGroupMongoOptions.fromObject(object.mongo);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.RelayOptions.nsq: object expected");
                    message.nsq = $root.protos.opts.RelayGroupNSQOptions.fromObject(object.nsq);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.RelayOptions.rabbit: object expected");
                    message.rabbit = $root.protos.opts.RelayGroupRabbitOptions.fromObject(object.rabbit);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.RelayOptions.mqtt: object expected");
                    message.mqtt = $root.protos.opts.RelayGroupMQTTOptions.fromObject(object.mqtt);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.RelayOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.opts.RelayGroupAzureServiceBusOptions.fromObject(object.azureServiceBus);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.RelayOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.opts.RelayGroupGCPPubSubOptions.fromObject(object.gcpPubsub);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.RelayOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.opts.RelayGroupKubeMQQueueOptions.fromObject(object.kubemqQueue);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.RelayOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.opts.RelayGroupRedisPubSubOptions.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.RelayOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.opts.RelayGroupRedisStreamsOptions.fromObject(object.redisStreams);
                }
                if (object.postgres != null) {
                    if (typeof object.postgres !== "object")
                        throw TypeError(".protos.opts.RelayOptions.postgres: object expected");
                    message.postgres = $root.protos.opts.RelayGroupPostgresOptions.fromObject(object.postgres);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.opts.RelayOptions.nats: object expected");
                    message.nats = $root.protos.opts.RelayGroupNatsOptions.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.opts.RelayOptions.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.opts.RelayGroupNatsStreamingOptions.fromObject(object.natsStreaming);
                }
                if (object.natsJetstream != null) {
                    if (typeof object.natsJetstream !== "object")
                        throw TypeError(".protos.opts.RelayOptions.natsJetstream: object expected");
                    message.natsJetstream = $root.protos.opts.RelayGroupNatsJetStreamOptions.fromObject(object.natsJetstream);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {protos.opts.RelayOptions} message RelayOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.collectionToken = "";
                    object.batchSize = 0;
                    object.batchMaxRetry = 0;
                    object.connectionId = "";
                    object.numWorkers = 0;
                    object.statsEnable = false;
                    object.statsReportIntervalSec = 0;
                    object.deadLetter = false;
                    object.kafka = null;
                    object.awsSqs = null;
                    object.mongo = null;
                    object.nsq = null;
                    object.rabbit = null;
                    object.mqtt = null;
                    object.azureServiceBus = null;
                    object.gcpPubsub = null;
                    object.kubemqQueue = null;
                    object.redisPubsub = null;
                    object.redisStreams = null;
                    object.postgres = null;
                    object.nats = null;
                    object.natsStreaming = null;
                    object.natsJetstream = null;
                    object._streamdalGrpcAddress = "";
                    object._streamdalGrpcDisableTls = false;
                    object._streamdalGrpcTimeoutSeconds = 0;
                    object._relayId = "";
                    object._cliOptions = null;
                    object._active = false;
                }
                if (message.collectionToken != null && message.hasOwnProperty("collectionToken"))
                    object.collectionToken = message.collectionToken;
                if (message.batchSize != null && message.hasOwnProperty("batchSize"))
                    object.batchSize = message.batchSize;
                if (message.batchMaxRetry != null && message.hasOwnProperty("batchMaxRetry"))
                    object.batchMaxRetry = message.batchMaxRetry;
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    object.connectionId = message.connectionId;
                if (message.numWorkers != null && message.hasOwnProperty("numWorkers"))
                    object.numWorkers = message.numWorkers;
                if (message.statsEnable != null && message.hasOwnProperty("statsEnable"))
                    object.statsEnable = message.statsEnable;
                if (message.statsReportIntervalSec != null && message.hasOwnProperty("statsReportIntervalSec"))
                    object.statsReportIntervalSec = message.statsReportIntervalSec;
                if (message.deadLetter != null && message.hasOwnProperty("deadLetter"))
                    object.deadLetter = message.deadLetter;
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.opts.RelayGroupKafkaOptions.toObject(message.kafka, options);
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs"))
                    object.awsSqs = $root.protos.opts.RelayGroupAWSSQSOptions.toObject(message.awsSqs, options);
                if (message.mongo != null && message.hasOwnProperty("mongo"))
                    object.mongo = $root.protos.opts.RelayGroupMongoOptions.toObject(message.mongo, options);
                if (message.nsq != null && message.hasOwnProperty("nsq"))
                    object.nsq = $root.protos.opts.RelayGroupNSQOptions.toObject(message.nsq, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.opts.RelayGroupRabbitOptions.toObject(message.rabbit, options);
                if (message.mqtt != null && message.hasOwnProperty("mqtt"))
                    object.mqtt = $root.protos.opts.RelayGroupMQTTOptions.toObject(message.mqtt, options);
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus"))
                    object.azureServiceBus = $root.protos.opts.RelayGroupAzureServiceBusOptions.toObject(message.azureServiceBus, options);
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub"))
                    object.gcpPubsub = $root.protos.opts.RelayGroupGCPPubSubOptions.toObject(message.gcpPubsub, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.opts.RelayGroupKubeMQQueueOptions.toObject(message.kubemqQueue, options);
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub"))
                    object.redisPubsub = $root.protos.opts.RelayGroupRedisPubSubOptions.toObject(message.redisPubsub, options);
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams"))
                    object.redisStreams = $root.protos.opts.RelayGroupRedisStreamsOptions.toObject(message.redisStreams, options);
                if (message.postgres != null && message.hasOwnProperty("postgres"))
                    object.postgres = $root.protos.opts.RelayGroupPostgresOptions.toObject(message.postgres, options);
                if (message.nats != null && message.hasOwnProperty("nats"))
                    object.nats = $root.protos.opts.RelayGroupNatsOptions.toObject(message.nats, options);
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming"))
                    object.natsStreaming = $root.protos.opts.RelayGroupNatsStreamingOptions.toObject(message.natsStreaming, options);
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream"))
                    object.natsJetstream = $root.protos.opts.RelayGroupNatsJetStreamOptions.toObject(message.natsJetstream, options);
                if (message._streamdalGrpcAddress != null && message.hasOwnProperty("_streamdalGrpcAddress"))
                    object._streamdalGrpcAddress = message._streamdalGrpcAddress;
                if (message._streamdalGrpcDisableTls != null && message.hasOwnProperty("_streamdalGrpcDisableTls"))
                    object._streamdalGrpcDisableTls = message._streamdalGrpcDisableTls;
                if (message._streamdalGrpcTimeoutSeconds != null && message.hasOwnProperty("_streamdalGrpcTimeoutSeconds"))
                    object._streamdalGrpcTimeoutSeconds = message._streamdalGrpcTimeoutSeconds;
                if (message._relayId != null && message.hasOwnProperty("_relayId"))
                    object._relayId = message._relayId;
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions"))
                    object._cliOptions = $root.protos.opts.RelayCLIOptions.toObject(message._cliOptions, options);
                if (message._active != null && message.hasOwnProperty("_active"))
                    object._active = message._active;
                return object;
            };

            /**
             * Converts this RelayOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayOptions;
        })();

        opts.RelayGroupKafkaOptions = (function() {

            /**
             * Properties of a RelayGroupKafkaOptions.
             * @memberof protos.opts
             * @interface IRelayGroupKafkaOptions
             * @property {protos.args.IKafkaConn|null} [_conn] RelayGroupKafkaOptions _conn
             * @property {protos.args.IKafkaRelayArgs|null} [args] RelayGroupKafkaOptions args
             */

            /**
             * Constructs a new RelayGroupKafkaOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupKafkaOptions.
             * @implements IRelayGroupKafkaOptions
             * @constructor
             * @param {protos.opts.IRelayGroupKafkaOptions=} [properties] Properties to set
             */
            function RelayGroupKafkaOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupKafkaOptions _conn.
             * @member {protos.args.IKafkaConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @instance
             */
            RelayGroupKafkaOptions.prototype._conn = null;

            /**
             * RelayGroupKafkaOptions args.
             * @member {protos.args.IKafkaRelayArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @instance
             */
            RelayGroupKafkaOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupKafkaOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {protos.opts.IRelayGroupKafkaOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupKafkaOptions} RelayGroupKafkaOptions instance
             */
            RelayGroupKafkaOptions.create = function create(properties) {
                return new RelayGroupKafkaOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupKafkaOptions message. Does not implicitly {@link protos.opts.RelayGroupKafkaOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {protos.opts.IRelayGroupKafkaOptions} message RelayGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupKafkaOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KafkaConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KafkaRelayArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupKafkaOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupKafkaOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {protos.opts.IRelayGroupKafkaOptions} message RelayGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupKafkaOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupKafkaOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupKafkaOptions} RelayGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupKafkaOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupKafkaOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KafkaConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KafkaRelayArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupKafkaOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupKafkaOptions} RelayGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupKafkaOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupKafkaOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupKafkaOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KafkaConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KafkaRelayArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupKafkaOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupKafkaOptions} RelayGroupKafkaOptions
             */
            RelayGroupKafkaOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupKafkaOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupKafkaOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupKafkaOptions._conn: object expected");
                    message._conn = $root.protos.args.KafkaConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupKafkaOptions.args: object expected");
                    message.args = $root.protos.args.KafkaRelayArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupKafkaOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {protos.opts.RelayGroupKafkaOptions} message RelayGroupKafkaOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupKafkaOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KafkaConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KafkaRelayArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupKafkaOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupKafkaOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupKafkaOptions;
        })();

        opts.RelayGroupAWSSQSOptions = (function() {

            /**
             * Properties of a RelayGroupAWSSQSOptions.
             * @memberof protos.opts
             * @interface IRelayGroupAWSSQSOptions
             * @property {protos.args.IAWSSQSConn|null} [_conn] RelayGroupAWSSQSOptions _conn
             * @property {protos.args.IAWSSQSRelayArgs|null} [args] RelayGroupAWSSQSOptions args
             */

            /**
             * Constructs a new RelayGroupAWSSQSOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupAWSSQSOptions.
             * @implements IRelayGroupAWSSQSOptions
             * @constructor
             * @param {protos.opts.IRelayGroupAWSSQSOptions=} [properties] Properties to set
             */
            function RelayGroupAWSSQSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupAWSSQSOptions _conn.
             * @member {protos.args.IAWSSQSConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @instance
             */
            RelayGroupAWSSQSOptions.prototype._conn = null;

            /**
             * RelayGroupAWSSQSOptions args.
             * @member {protos.args.IAWSSQSRelayArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @instance
             */
            RelayGroupAWSSQSOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupAWSSQSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IRelayGroupAWSSQSOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupAWSSQSOptions} RelayGroupAWSSQSOptions instance
             */
            RelayGroupAWSSQSOptions.create = function create(properties) {
                return new RelayGroupAWSSQSOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupAWSSQSOptions message. Does not implicitly {@link protos.opts.RelayGroupAWSSQSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IRelayGroupAWSSQSOptions} message RelayGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupAWSSQSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSQSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSQSRelayArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupAWSSQSOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupAWSSQSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IRelayGroupAWSSQSOptions} message RelayGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupAWSSQSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupAWSSQSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupAWSSQSOptions} RelayGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupAWSSQSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupAWSSQSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSQSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSQSRelayArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupAWSSQSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupAWSSQSOptions} RelayGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupAWSSQSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupAWSSQSOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupAWSSQSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSSQSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSSQSRelayArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupAWSSQSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupAWSSQSOptions} RelayGroupAWSSQSOptions
             */
            RelayGroupAWSSQSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupAWSSQSOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupAWSSQSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupAWSSQSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSQSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupAWSSQSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSQSRelayArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupAWSSQSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {protos.opts.RelayGroupAWSSQSOptions} message RelayGroupAWSSQSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupAWSSQSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSQSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSQSRelayArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupAWSSQSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupAWSSQSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupAWSSQSOptions;
        })();

        opts.RelayGroupMongoOptions = (function() {

            /**
             * Properties of a RelayGroupMongoOptions.
             * @memberof protos.opts
             * @interface IRelayGroupMongoOptions
             * @property {protos.args.IMongoConn|null} [_conn] RelayGroupMongoOptions _conn
             * @property {protos.args.IMongoReadArgs|null} [args] RelayGroupMongoOptions args
             */

            /**
             * Constructs a new RelayGroupMongoOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupMongoOptions.
             * @implements IRelayGroupMongoOptions
             * @constructor
             * @param {protos.opts.IRelayGroupMongoOptions=} [properties] Properties to set
             */
            function RelayGroupMongoOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupMongoOptions _conn.
             * @member {protos.args.IMongoConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupMongoOptions
             * @instance
             */
            RelayGroupMongoOptions.prototype._conn = null;

            /**
             * RelayGroupMongoOptions args.
             * @member {protos.args.IMongoReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupMongoOptions
             * @instance
             */
            RelayGroupMongoOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupMongoOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {protos.opts.IRelayGroupMongoOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupMongoOptions} RelayGroupMongoOptions instance
             */
            RelayGroupMongoOptions.create = function create(properties) {
                return new RelayGroupMongoOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupMongoOptions message. Does not implicitly {@link protos.opts.RelayGroupMongoOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {protos.opts.IRelayGroupMongoOptions} message RelayGroupMongoOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupMongoOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MongoConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MongoReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupMongoOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupMongoOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {protos.opts.IRelayGroupMongoOptions} message RelayGroupMongoOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupMongoOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupMongoOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupMongoOptions} RelayGroupMongoOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupMongoOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupMongoOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MongoConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MongoReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupMongoOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupMongoOptions} RelayGroupMongoOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupMongoOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupMongoOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupMongoOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.MongoConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.MongoReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupMongoOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupMongoOptions} RelayGroupMongoOptions
             */
            RelayGroupMongoOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupMongoOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupMongoOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupMongoOptions._conn: object expected");
                    message._conn = $root.protos.args.MongoConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupMongoOptions.args: object expected");
                    message.args = $root.protos.args.MongoReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupMongoOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {protos.opts.RelayGroupMongoOptions} message RelayGroupMongoOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupMongoOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MongoConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MongoReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupMongoOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupMongoOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupMongoOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupMongoOptions;
        })();

        opts.RelayGroupNSQOptions = (function() {

            /**
             * Properties of a RelayGroupNSQOptions.
             * @memberof protos.opts
             * @interface IRelayGroupNSQOptions
             * @property {protos.args.INSQConn|null} [_conn] RelayGroupNSQOptions _conn
             * @property {protos.args.INSQReadArgs|null} [args] RelayGroupNSQOptions args
             */

            /**
             * Constructs a new RelayGroupNSQOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupNSQOptions.
             * @implements IRelayGroupNSQOptions
             * @constructor
             * @param {protos.opts.IRelayGroupNSQOptions=} [properties] Properties to set
             */
            function RelayGroupNSQOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupNSQOptions _conn.
             * @member {protos.args.INSQConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupNSQOptions
             * @instance
             */
            RelayGroupNSQOptions.prototype._conn = null;

            /**
             * RelayGroupNSQOptions args.
             * @member {protos.args.INSQReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupNSQOptions
             * @instance
             */
            RelayGroupNSQOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupNSQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {protos.opts.IRelayGroupNSQOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupNSQOptions} RelayGroupNSQOptions instance
             */
            RelayGroupNSQOptions.create = function create(properties) {
                return new RelayGroupNSQOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupNSQOptions message. Does not implicitly {@link protos.opts.RelayGroupNSQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {protos.opts.IRelayGroupNSQOptions} message RelayGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupNSQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NSQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NSQReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupNSQOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupNSQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {protos.opts.IRelayGroupNSQOptions} message RelayGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupNSQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupNSQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupNSQOptions} RelayGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupNSQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupNSQOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NSQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NSQReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupNSQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupNSQOptions} RelayGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupNSQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupNSQOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupNSQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NSQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NSQReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupNSQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupNSQOptions} RelayGroupNSQOptions
             */
            RelayGroupNSQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupNSQOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupNSQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupNSQOptions._conn: object expected");
                    message._conn = $root.protos.args.NSQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupNSQOptions.args: object expected");
                    message.args = $root.protos.args.NSQReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupNSQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {protos.opts.RelayGroupNSQOptions} message RelayGroupNSQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupNSQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NSQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NSQReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupNSQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupNSQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupNSQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupNSQOptions;
        })();

        opts.RelayGroupPostgresOptions = (function() {

            /**
             * Properties of a RelayGroupPostgresOptions.
             * @memberof protos.opts
             * @interface IRelayGroupPostgresOptions
             * @property {protos.args.IPostgresConn|null} [_conn] RelayGroupPostgresOptions _conn
             * @property {protos.args.IPostgresReadArgs|null} [args] RelayGroupPostgresOptions args
             */

            /**
             * Constructs a new RelayGroupPostgresOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupPostgresOptions.
             * @implements IRelayGroupPostgresOptions
             * @constructor
             * @param {protos.opts.IRelayGroupPostgresOptions=} [properties] Properties to set
             */
            function RelayGroupPostgresOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupPostgresOptions _conn.
             * @member {protos.args.IPostgresConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @instance
             */
            RelayGroupPostgresOptions.prototype._conn = null;

            /**
             * RelayGroupPostgresOptions args.
             * @member {protos.args.IPostgresReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @instance
             */
            RelayGroupPostgresOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupPostgresOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {protos.opts.IRelayGroupPostgresOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupPostgresOptions} RelayGroupPostgresOptions instance
             */
            RelayGroupPostgresOptions.create = function create(properties) {
                return new RelayGroupPostgresOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupPostgresOptions message. Does not implicitly {@link protos.opts.RelayGroupPostgresOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {protos.opts.IRelayGroupPostgresOptions} message RelayGroupPostgresOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupPostgresOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.PostgresConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.PostgresReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupPostgresOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupPostgresOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {protos.opts.IRelayGroupPostgresOptions} message RelayGroupPostgresOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupPostgresOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupPostgresOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupPostgresOptions} RelayGroupPostgresOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupPostgresOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupPostgresOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.PostgresConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.PostgresReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupPostgresOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupPostgresOptions} RelayGroupPostgresOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupPostgresOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupPostgresOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupPostgresOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.PostgresConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.PostgresReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupPostgresOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupPostgresOptions} RelayGroupPostgresOptions
             */
            RelayGroupPostgresOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupPostgresOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupPostgresOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupPostgresOptions._conn: object expected");
                    message._conn = $root.protos.args.PostgresConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupPostgresOptions.args: object expected");
                    message.args = $root.protos.args.PostgresReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupPostgresOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {protos.opts.RelayGroupPostgresOptions} message RelayGroupPostgresOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupPostgresOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.PostgresConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.PostgresReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupPostgresOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupPostgresOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupPostgresOptions;
        })();

        opts.RelayGroupRabbitOptions = (function() {

            /**
             * Properties of a RelayGroupRabbitOptions.
             * @memberof protos.opts
             * @interface IRelayGroupRabbitOptions
             * @property {protos.args.IRabbitConn|null} [_conn] RelayGroupRabbitOptions _conn
             * @property {protos.args.IRabbitReadArgs|null} [args] RelayGroupRabbitOptions args
             */

            /**
             * Constructs a new RelayGroupRabbitOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupRabbitOptions.
             * @implements IRelayGroupRabbitOptions
             * @constructor
             * @param {protos.opts.IRelayGroupRabbitOptions=} [properties] Properties to set
             */
            function RelayGroupRabbitOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupRabbitOptions _conn.
             * @member {protos.args.IRabbitConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @instance
             */
            RelayGroupRabbitOptions.prototype._conn = null;

            /**
             * RelayGroupRabbitOptions args.
             * @member {protos.args.IRabbitReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @instance
             */
            RelayGroupRabbitOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupRabbitOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {protos.opts.IRelayGroupRabbitOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupRabbitOptions} RelayGroupRabbitOptions instance
             */
            RelayGroupRabbitOptions.create = function create(properties) {
                return new RelayGroupRabbitOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupRabbitOptions message. Does not implicitly {@link protos.opts.RelayGroupRabbitOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {protos.opts.IRelayGroupRabbitOptions} message RelayGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRabbitOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupRabbitOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupRabbitOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {protos.opts.IRelayGroupRabbitOptions} message RelayGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRabbitOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupRabbitOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupRabbitOptions} RelayGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRabbitOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupRabbitOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupRabbitOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupRabbitOptions} RelayGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRabbitOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupRabbitOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupRabbitOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RabbitConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RabbitReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupRabbitOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupRabbitOptions} RelayGroupRabbitOptions
             */
            RelayGroupRabbitOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupRabbitOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupRabbitOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupRabbitOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupRabbitOptions.args: object expected");
                    message.args = $root.protos.args.RabbitReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupRabbitOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {protos.opts.RelayGroupRabbitOptions} message RelayGroupRabbitOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupRabbitOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupRabbitOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupRabbitOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupRabbitOptions;
        })();

        opts.RelayGroupRedisPubSubOptions = (function() {

            /**
             * Properties of a RelayGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @interface IRelayGroupRedisPubSubOptions
             * @property {protos.args.IRedisPubSubConn|null} [_conn] RelayGroupRedisPubSubOptions _conn
             * @property {protos.args.IRedisPubSubReadArgs|null} [args] RelayGroupRedisPubSubOptions args
             */

            /**
             * Constructs a new RelayGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupRedisPubSubOptions.
             * @implements IRelayGroupRedisPubSubOptions
             * @constructor
             * @param {protos.opts.IRelayGroupRedisPubSubOptions=} [properties] Properties to set
             */
            function RelayGroupRedisPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupRedisPubSubOptions _conn.
             * @member {protos.args.IRedisPubSubConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @instance
             */
            RelayGroupRedisPubSubOptions.prototype._conn = null;

            /**
             * RelayGroupRedisPubSubOptions args.
             * @member {protos.args.IRedisPubSubReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @instance
             */
            RelayGroupRedisPubSubOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupRedisPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupRedisPubSubOptions} RelayGroupRedisPubSubOptions instance
             */
            RelayGroupRedisPubSubOptions.create = function create(properties) {
                return new RelayGroupRedisPubSubOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupRedisPubSubOptions message. Does not implicitly {@link protos.opts.RelayGroupRedisPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisPubSubOptions} message RelayGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRedisPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisPubSubReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupRedisPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupRedisPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisPubSubOptions} message RelayGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRedisPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupRedisPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupRedisPubSubOptions} RelayGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRedisPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupRedisPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisPubSubReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupRedisPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupRedisPubSubOptions} RelayGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRedisPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupRedisPubSubOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupRedisPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisPubSubReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupRedisPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupRedisPubSubOptions} RelayGroupRedisPubSubOptions
             */
            RelayGroupRedisPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupRedisPubSubOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupRedisPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupRedisPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupRedisPubSubOptions.args: object expected");
                    message.args = $root.protos.args.RedisPubSubReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupRedisPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.RelayGroupRedisPubSubOptions} message RelayGroupRedisPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupRedisPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisPubSubReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupRedisPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupRedisPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupRedisPubSubOptions;
        })();

        opts.RelayGroupRedisStreamsOptions = (function() {

            /**
             * Properties of a RelayGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @interface IRelayGroupRedisStreamsOptions
             * @property {protos.args.IRedisStreamsConn|null} [_conn] RelayGroupRedisStreamsOptions _conn
             * @property {protos.args.IRedisStreamsReadArgs|null} [args] RelayGroupRedisStreamsOptions args
             */

            /**
             * Constructs a new RelayGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupRedisStreamsOptions.
             * @implements IRelayGroupRedisStreamsOptions
             * @constructor
             * @param {protos.opts.IRelayGroupRedisStreamsOptions=} [properties] Properties to set
             */
            function RelayGroupRedisStreamsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupRedisStreamsOptions _conn.
             * @member {protos.args.IRedisStreamsConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @instance
             */
            RelayGroupRedisStreamsOptions.prototype._conn = null;

            /**
             * RelayGroupRedisStreamsOptions args.
             * @member {protos.args.IRedisStreamsReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @instance
             */
            RelayGroupRedisStreamsOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupRedisStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupRedisStreamsOptions} RelayGroupRedisStreamsOptions instance
             */
            RelayGroupRedisStreamsOptions.create = function create(properties) {
                return new RelayGroupRedisStreamsOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupRedisStreamsOptions message. Does not implicitly {@link protos.opts.RelayGroupRedisStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisStreamsOptions} message RelayGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRedisStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisStreamsReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupRedisStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupRedisStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisStreamsOptions} message RelayGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRedisStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupRedisStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupRedisStreamsOptions} RelayGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRedisStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupRedisStreamsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisStreamsReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupRedisStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupRedisStreamsOptions} RelayGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRedisStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupRedisStreamsOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupRedisStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisStreamsReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupRedisStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupRedisStreamsOptions} RelayGroupRedisStreamsOptions
             */
            RelayGroupRedisStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupRedisStreamsOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupRedisStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupRedisStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupRedisStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RedisStreamsReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupRedisStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.RelayGroupRedisStreamsOptions} message RelayGroupRedisStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupRedisStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisStreamsReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupRedisStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupRedisStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupRedisStreamsOptions;
        })();

        opts.RelayGroupAzureServiceBusOptions = (function() {

            /**
             * Properties of a RelayGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @interface IRelayGroupAzureServiceBusOptions
             * @property {protos.args.IAzureServiceBusConn|null} [_conn] RelayGroupAzureServiceBusOptions _conn
             * @property {protos.args.IAzureServiceBusReadArgs|null} [args] RelayGroupAzureServiceBusOptions args
             */

            /**
             * Constructs a new RelayGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupAzureServiceBusOptions.
             * @implements IRelayGroupAzureServiceBusOptions
             * @constructor
             * @param {protos.opts.IRelayGroupAzureServiceBusOptions=} [properties] Properties to set
             */
            function RelayGroupAzureServiceBusOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupAzureServiceBusOptions _conn.
             * @member {protos.args.IAzureServiceBusConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @instance
             */
            RelayGroupAzureServiceBusOptions.prototype._conn = null;

            /**
             * RelayGroupAzureServiceBusOptions args.
             * @member {protos.args.IAzureServiceBusReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @instance
             */
            RelayGroupAzureServiceBusOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupAzureServiceBusOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IRelayGroupAzureServiceBusOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupAzureServiceBusOptions} RelayGroupAzureServiceBusOptions instance
             */
            RelayGroupAzureServiceBusOptions.create = function create(properties) {
                return new RelayGroupAzureServiceBusOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupAzureServiceBusOptions message. Does not implicitly {@link protos.opts.RelayGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IRelayGroupAzureServiceBusOptions} message RelayGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupAzureServiceBusOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureServiceBusConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureServiceBusReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupAzureServiceBusOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IRelayGroupAzureServiceBusOptions} message RelayGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupAzureServiceBusOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupAzureServiceBusOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupAzureServiceBusOptions} RelayGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupAzureServiceBusOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupAzureServiceBusOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureServiceBusConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureServiceBusReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupAzureServiceBusOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupAzureServiceBusOptions} RelayGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupAzureServiceBusOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupAzureServiceBusOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupAzureServiceBusOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AzureServiceBusConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AzureServiceBusReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupAzureServiceBusOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupAzureServiceBusOptions} RelayGroupAzureServiceBusOptions
             */
            RelayGroupAzureServiceBusOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupAzureServiceBusOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupAzureServiceBusOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupAzureServiceBusOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureServiceBusConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupAzureServiceBusOptions.args: object expected");
                    message.args = $root.protos.args.AzureServiceBusReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupAzureServiceBusOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.RelayGroupAzureServiceBusOptions} message RelayGroupAzureServiceBusOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupAzureServiceBusOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureServiceBusConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureServiceBusReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupAzureServiceBusOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupAzureServiceBusOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupAzureServiceBusOptions;
        })();

        opts.RelayGroupMQTTOptions = (function() {

            /**
             * Properties of a RelayGroupMQTTOptions.
             * @memberof protos.opts
             * @interface IRelayGroupMQTTOptions
             * @property {protos.args.IMQTTConn|null} [_conn] RelayGroupMQTTOptions _conn
             * @property {protos.args.IMQTTReadArgs|null} [args] RelayGroupMQTTOptions args
             */

            /**
             * Constructs a new RelayGroupMQTTOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupMQTTOptions.
             * @implements IRelayGroupMQTTOptions
             * @constructor
             * @param {protos.opts.IRelayGroupMQTTOptions=} [properties] Properties to set
             */
            function RelayGroupMQTTOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupMQTTOptions _conn.
             * @member {protos.args.IMQTTConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @instance
             */
            RelayGroupMQTTOptions.prototype._conn = null;

            /**
             * RelayGroupMQTTOptions args.
             * @member {protos.args.IMQTTReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @instance
             */
            RelayGroupMQTTOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupMQTTOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {protos.opts.IRelayGroupMQTTOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupMQTTOptions} RelayGroupMQTTOptions instance
             */
            RelayGroupMQTTOptions.create = function create(properties) {
                return new RelayGroupMQTTOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupMQTTOptions message. Does not implicitly {@link protos.opts.RelayGroupMQTTOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {protos.opts.IRelayGroupMQTTOptions} message RelayGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupMQTTOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MQTTConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MQTTReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupMQTTOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupMQTTOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {protos.opts.IRelayGroupMQTTOptions} message RelayGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupMQTTOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupMQTTOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupMQTTOptions} RelayGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupMQTTOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupMQTTOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MQTTConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MQTTReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupMQTTOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupMQTTOptions} RelayGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupMQTTOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupMQTTOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupMQTTOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.MQTTConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.MQTTReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupMQTTOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupMQTTOptions} RelayGroupMQTTOptions
             */
            RelayGroupMQTTOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupMQTTOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupMQTTOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupMQTTOptions._conn: object expected");
                    message._conn = $root.protos.args.MQTTConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupMQTTOptions.args: object expected");
                    message.args = $root.protos.args.MQTTReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupMQTTOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {protos.opts.RelayGroupMQTTOptions} message RelayGroupMQTTOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupMQTTOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MQTTConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MQTTReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupMQTTOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupMQTTOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupMQTTOptions;
        })();

        opts.RelayGroupGCPPubSubOptions = (function() {

            /**
             * Properties of a RelayGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @interface IRelayGroupGCPPubSubOptions
             * @property {protos.args.IGCPPubSubConn|null} [_conn] RelayGroupGCPPubSubOptions _conn
             * @property {protos.args.IGCPPubSubReadArgs|null} [args] RelayGroupGCPPubSubOptions args
             */

            /**
             * Constructs a new RelayGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupGCPPubSubOptions.
             * @implements IRelayGroupGCPPubSubOptions
             * @constructor
             * @param {protos.opts.IRelayGroupGCPPubSubOptions=} [properties] Properties to set
             */
            function RelayGroupGCPPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupGCPPubSubOptions _conn.
             * @member {protos.args.IGCPPubSubConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @instance
             */
            RelayGroupGCPPubSubOptions.prototype._conn = null;

            /**
             * RelayGroupGCPPubSubOptions args.
             * @member {protos.args.IGCPPubSubReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @instance
             */
            RelayGroupGCPPubSubOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupGCPPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupGCPPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupGCPPubSubOptions} RelayGroupGCPPubSubOptions instance
             */
            RelayGroupGCPPubSubOptions.create = function create(properties) {
                return new RelayGroupGCPPubSubOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupGCPPubSubOptions message. Does not implicitly {@link protos.opts.RelayGroupGCPPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupGCPPubSubOptions} message RelayGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupGCPPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.GCPPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.GCPPubSubReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupGCPPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupGCPPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupGCPPubSubOptions} message RelayGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupGCPPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupGCPPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupGCPPubSubOptions} RelayGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupGCPPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupGCPPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.GCPPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.GCPPubSubReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupGCPPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupGCPPubSubOptions} RelayGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupGCPPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupGCPPubSubOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupGCPPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.GCPPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.GCPPubSubReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupGCPPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupGCPPubSubOptions} RelayGroupGCPPubSubOptions
             */
            RelayGroupGCPPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupGCPPubSubOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupGCPPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupGCPPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.GCPPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupGCPPubSubOptions.args: object expected");
                    message.args = $root.protos.args.GCPPubSubReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupGCPPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.RelayGroupGCPPubSubOptions} message RelayGroupGCPPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupGCPPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.GCPPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.GCPPubSubReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupGCPPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupGCPPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupGCPPubSubOptions;
        })();

        opts.RelayGroupKubeMQQueueOptions = (function() {

            /**
             * Properties of a RelayGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @interface IRelayGroupKubeMQQueueOptions
             * @property {protos.args.IKubeMQQueueConn|null} [_conn] RelayGroupKubeMQQueueOptions _conn
             * @property {protos.args.IKubeMQQueueReadArgs|null} [args] RelayGroupKubeMQQueueOptions args
             */

            /**
             * Constructs a new RelayGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupKubeMQQueueOptions.
             * @implements IRelayGroupKubeMQQueueOptions
             * @constructor
             * @param {protos.opts.IRelayGroupKubeMQQueueOptions=} [properties] Properties to set
             */
            function RelayGroupKubeMQQueueOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupKubeMQQueueOptions _conn.
             * @member {protos.args.IKubeMQQueueConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @instance
             */
            RelayGroupKubeMQQueueOptions.prototype._conn = null;

            /**
             * RelayGroupKubeMQQueueOptions args.
             * @member {protos.args.IKubeMQQueueReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @instance
             */
            RelayGroupKubeMQQueueOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupKubeMQQueueOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IRelayGroupKubeMQQueueOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupKubeMQQueueOptions} RelayGroupKubeMQQueueOptions instance
             */
            RelayGroupKubeMQQueueOptions.create = function create(properties) {
                return new RelayGroupKubeMQQueueOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupKubeMQQueueOptions message. Does not implicitly {@link protos.opts.RelayGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IRelayGroupKubeMQQueueOptions} message RelayGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupKubeMQQueueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KubeMQQueueConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KubeMQQueueReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupKubeMQQueueOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IRelayGroupKubeMQQueueOptions} message RelayGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupKubeMQQueueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupKubeMQQueueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupKubeMQQueueOptions} RelayGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupKubeMQQueueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupKubeMQQueueOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KubeMQQueueConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KubeMQQueueReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupKubeMQQueueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupKubeMQQueueOptions} RelayGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupKubeMQQueueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupKubeMQQueueOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupKubeMQQueueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KubeMQQueueConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KubeMQQueueReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupKubeMQQueueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupKubeMQQueueOptions} RelayGroupKubeMQQueueOptions
             */
            RelayGroupKubeMQQueueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupKubeMQQueueOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupKubeMQQueueOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupKubeMQQueueOptions._conn: object expected");
                    message._conn = $root.protos.args.KubeMQQueueConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupKubeMQQueueOptions.args: object expected");
                    message.args = $root.protos.args.KubeMQQueueReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupKubeMQQueueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.RelayGroupKubeMQQueueOptions} message RelayGroupKubeMQQueueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupKubeMQQueueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KubeMQQueueConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KubeMQQueueReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupKubeMQQueueOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupKubeMQQueueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupKubeMQQueueOptions;
        })();

        opts.RelayGroupNatsOptions = (function() {

            /**
             * Properties of a RelayGroupNatsOptions.
             * @memberof protos.opts
             * @interface IRelayGroupNatsOptions
             * @property {protos.args.INatsConn|null} [_conn] RelayGroupNatsOptions _conn
             * @property {protos.args.INatsReadArgs|null} [args] RelayGroupNatsOptions args
             */

            /**
             * Constructs a new RelayGroupNatsOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupNatsOptions.
             * @implements IRelayGroupNatsOptions
             * @constructor
             * @param {protos.opts.IRelayGroupNatsOptions=} [properties] Properties to set
             */
            function RelayGroupNatsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupNatsOptions _conn.
             * @member {protos.args.INatsConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupNatsOptions
             * @instance
             */
            RelayGroupNatsOptions.prototype._conn = null;

            /**
             * RelayGroupNatsOptions args.
             * @member {protos.args.INatsReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupNatsOptions
             * @instance
             */
            RelayGroupNatsOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupNatsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupNatsOptions
             * @static
             * @param {protos.opts.IRelayGroupNatsOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupNatsOptions} RelayGroupNatsOptions instance
             */
            RelayGroupNatsOptions.create = function create(properties) {
                return new RelayGroupNatsOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupNatsOptions message. Does not implicitly {@link protos.opts.RelayGroupNatsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupNatsOptions
             * @static
             * @param {protos.opts.IRelayGroupNatsOptions} message RelayGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupNatsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupNatsOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupNatsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupNatsOptions
             * @static
             * @param {protos.opts.IRelayGroupNatsOptions} message RelayGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupNatsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupNatsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupNatsOptions} RelayGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupNatsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupNatsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupNatsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupNatsOptions} RelayGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupNatsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupNatsOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupNatsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupNatsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupNatsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupNatsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupNatsOptions} RelayGroupNatsOptions
             */
            RelayGroupNatsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupNatsOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupNatsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupNatsOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupNatsOptions.args: object expected");
                    message.args = $root.protos.args.NatsReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupNatsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupNatsOptions
             * @static
             * @param {protos.opts.RelayGroupNatsOptions} message RelayGroupNatsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupNatsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupNatsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupNatsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupNatsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupNatsOptions;
        })();

        opts.RelayGroupNatsStreamingOptions = (function() {

            /**
             * Properties of a RelayGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @interface IRelayGroupNatsStreamingOptions
             * @property {protos.args.INatsStreamingConn|null} [_conn] RelayGroupNatsStreamingOptions _conn
             * @property {protos.args.INatsStreamingReadArgs|null} [args] RelayGroupNatsStreamingOptions args
             */

            /**
             * Constructs a new RelayGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupNatsStreamingOptions.
             * @implements IRelayGroupNatsStreamingOptions
             * @constructor
             * @param {protos.opts.IRelayGroupNatsStreamingOptions=} [properties] Properties to set
             */
            function RelayGroupNatsStreamingOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupNatsStreamingOptions _conn.
             * @member {protos.args.INatsStreamingConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @instance
             */
            RelayGroupNatsStreamingOptions.prototype._conn = null;

            /**
             * RelayGroupNatsStreamingOptions args.
             * @member {protos.args.INatsStreamingReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @instance
             */
            RelayGroupNatsStreamingOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupNatsStreamingOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IRelayGroupNatsStreamingOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupNatsStreamingOptions} RelayGroupNatsStreamingOptions instance
             */
            RelayGroupNatsStreamingOptions.create = function create(properties) {
                return new RelayGroupNatsStreamingOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupNatsStreamingOptions message. Does not implicitly {@link protos.opts.RelayGroupNatsStreamingOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IRelayGroupNatsStreamingOptions} message RelayGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupNatsStreamingOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsStreamingConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsStreamingReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupNatsStreamingOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupNatsStreamingOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IRelayGroupNatsStreamingOptions} message RelayGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupNatsStreamingOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupNatsStreamingOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupNatsStreamingOptions} RelayGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupNatsStreamingOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupNatsStreamingOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsStreamingConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsStreamingReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupNatsStreamingOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupNatsStreamingOptions} RelayGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupNatsStreamingOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupNatsStreamingOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupNatsStreamingOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsStreamingConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsStreamingReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupNatsStreamingOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupNatsStreamingOptions} RelayGroupNatsStreamingOptions
             */
            RelayGroupNatsStreamingOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupNatsStreamingOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupNatsStreamingOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupNatsStreamingOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsStreamingConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupNatsStreamingOptions.args: object expected");
                    message.args = $root.protos.args.NatsStreamingReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupNatsStreamingOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.RelayGroupNatsStreamingOptions} message RelayGroupNatsStreamingOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupNatsStreamingOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsStreamingConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsStreamingReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupNatsStreamingOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupNatsStreamingOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupNatsStreamingOptions;
        })();

        opts.RelayGroupNatsJetStreamOptions = (function() {

            /**
             * Properties of a RelayGroupNatsJetStreamOptions.
             * @memberof protos.opts
             * @interface IRelayGroupNatsJetStreamOptions
             * @property {protos.args.INatsJetstreamConn|null} [_conn] RelayGroupNatsJetStreamOptions _conn
             * @property {protos.args.INatsJetstreamReadArgs|null} [args] RelayGroupNatsJetStreamOptions args
             */

            /**
             * Constructs a new RelayGroupNatsJetStreamOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupNatsJetStreamOptions.
             * @implements IRelayGroupNatsJetStreamOptions
             * @constructor
             * @param {protos.opts.IRelayGroupNatsJetStreamOptions=} [properties] Properties to set
             */
            function RelayGroupNatsJetStreamOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupNatsJetStreamOptions _conn.
             * @member {protos.args.INatsJetstreamConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @instance
             */
            RelayGroupNatsJetStreamOptions.prototype._conn = null;

            /**
             * RelayGroupNatsJetStreamOptions args.
             * @member {protos.args.INatsJetstreamReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @instance
             */
            RelayGroupNatsJetStreamOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupNatsJetStreamOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @static
             * @param {protos.opts.IRelayGroupNatsJetStreamOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupNatsJetStreamOptions} RelayGroupNatsJetStreamOptions instance
             */
            RelayGroupNatsJetStreamOptions.create = function create(properties) {
                return new RelayGroupNatsJetStreamOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupNatsJetStreamOptions message. Does not implicitly {@link protos.opts.RelayGroupNatsJetStreamOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @static
             * @param {protos.opts.IRelayGroupNatsJetStreamOptions} message RelayGroupNatsJetStreamOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupNatsJetStreamOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsJetstreamConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsJetstreamReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupNatsJetStreamOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupNatsJetStreamOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @static
             * @param {protos.opts.IRelayGroupNatsJetStreamOptions} message RelayGroupNatsJetStreamOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupNatsJetStreamOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupNatsJetStreamOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupNatsJetStreamOptions} RelayGroupNatsJetStreamOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupNatsJetStreamOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupNatsJetStreamOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsJetstreamConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsJetstreamReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupNatsJetStreamOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupNatsJetStreamOptions} RelayGroupNatsJetStreamOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupNatsJetStreamOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupNatsJetStreamOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupNatsJetStreamOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsJetstreamConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsJetstreamReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupNatsJetStreamOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupNatsJetStreamOptions} RelayGroupNatsJetStreamOptions
             */
            RelayGroupNatsJetStreamOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupNatsJetStreamOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupNatsJetStreamOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupNatsJetStreamOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsJetstreamConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupNatsJetStreamOptions.args: object expected");
                    message.args = $root.protos.args.NatsJetstreamReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupNatsJetStreamOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @static
             * @param {protos.opts.RelayGroupNatsJetStreamOptions} message RelayGroupNatsJetStreamOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupNatsJetStreamOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsJetstreamConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsJetstreamReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupNatsJetStreamOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupNatsJetStreamOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupNatsJetStreamOptions;
        })();

        opts.ServerOptions = (function() {

            /**
             * Properties of a ServerOptions.
             * @memberof protos.opts
             * @interface IServerOptions
             * @property {string|null} [nodeId] ServerOptions nodeId
             * @property {string|null} [clusterId] ServerOptions clusterId
             * @property {string|null} [grpcListenAddress] ServerOptions grpcListenAddress
             * @property {string|null} [authToken] ServerOptions authToken
             * @property {Array.<string>|null} [natsUrl] ServerOptions natsUrl
             * @property {boolean|null} [useTls] ServerOptions useTls
             * @property {string|null} [tlsCertFile] ServerOptions tlsCertFile
             * @property {string|null} [tlsKeyFile] ServerOptions tlsKeyFile
             * @property {string|null} [tlsCaFile] ServerOptions tlsCaFile
             * @property {boolean|null} [tlsSkipVerify] ServerOptions tlsSkipVerify
             * @property {boolean|null} [enableCluster] ServerOptions enableCluster
             * @property {string|null} [statsDatabasePath] ServerOptions statsDatabasePath
             * @property {number|null} [statsFlushIntervalSeconds] ServerOptions statsFlushIntervalSeconds
             * @property {string|null} [httpListenAddress] ServerOptions httpListenAddress
             * @property {boolean|null} [remoteControlEnabled] ServerOptions remoteControlEnabled
             * @property {string|null} [remoteControlAddress] ServerOptions remoteControlAddress
             * @property {string|null} [remoteControlApiToken] ServerOptions remoteControlApiToken
             * @property {boolean|null} [remoteControlDisableTls] ServerOptions remoteControlDisableTls
             */

            /**
             * Constructs a new ServerOptions.
             * @memberof protos.opts
             * @classdesc Represents a ServerOptions.
             * @implements IServerOptions
             * @constructor
             * @param {protos.opts.IServerOptions=} [properties] Properties to set
             */
            function ServerOptions(properties) {
                this.natsUrl = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServerOptions nodeId.
             * @member {string} nodeId
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.nodeId = "";

            /**
             * ServerOptions clusterId.
             * @member {string} clusterId
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.clusterId = "";

            /**
             * ServerOptions grpcListenAddress.
             * @member {string} grpcListenAddress
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.grpcListenAddress = "";

            /**
             * ServerOptions authToken.
             * @member {string} authToken
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.authToken = "";

            /**
             * ServerOptions natsUrl.
             * @member {Array.<string>} natsUrl
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.natsUrl = $util.emptyArray;

            /**
             * ServerOptions useTls.
             * @member {boolean} useTls
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.useTls = false;

            /**
             * ServerOptions tlsCertFile.
             * @member {string} tlsCertFile
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.tlsCertFile = "";

            /**
             * ServerOptions tlsKeyFile.
             * @member {string} tlsKeyFile
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.tlsKeyFile = "";

            /**
             * ServerOptions tlsCaFile.
             * @member {string} tlsCaFile
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.tlsCaFile = "";

            /**
             * ServerOptions tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.tlsSkipVerify = false;

            /**
             * ServerOptions enableCluster.
             * @member {boolean} enableCluster
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.enableCluster = false;

            /**
             * ServerOptions statsDatabasePath.
             * @member {string} statsDatabasePath
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.statsDatabasePath = "";

            /**
             * ServerOptions statsFlushIntervalSeconds.
             * @member {number} statsFlushIntervalSeconds
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.statsFlushIntervalSeconds = 0;

            /**
             * ServerOptions httpListenAddress.
             * @member {string} httpListenAddress
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.httpListenAddress = "";

            /**
             * ServerOptions remoteControlEnabled.
             * @member {boolean} remoteControlEnabled
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.remoteControlEnabled = false;

            /**
             * ServerOptions remoteControlAddress.
             * @member {string} remoteControlAddress
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.remoteControlAddress = "";

            /**
             * ServerOptions remoteControlApiToken.
             * @member {string} remoteControlApiToken
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.remoteControlApiToken = "";

            /**
             * ServerOptions remoteControlDisableTls.
             * @member {boolean} remoteControlDisableTls
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.remoteControlDisableTls = false;

            /**
             * Creates a new ServerOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {protos.opts.IServerOptions=} [properties] Properties to set
             * @returns {protos.opts.ServerOptions} ServerOptions instance
             */
            ServerOptions.create = function create(properties) {
                return new ServerOptions(properties);
            };

            /**
             * Encodes the specified ServerOptions message. Does not implicitly {@link protos.opts.ServerOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {protos.opts.IServerOptions} message ServerOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServerOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nodeId);
                if (message.clusterId != null && Object.hasOwnProperty.call(message, "clusterId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.clusterId);
                if (message.grpcListenAddress != null && Object.hasOwnProperty.call(message, "grpcListenAddress"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.grpcListenAddress);
                if (message.authToken != null && Object.hasOwnProperty.call(message, "authToken"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.authToken);
                if (message.natsUrl != null && message.natsUrl.length)
                    for (var i = 0; i < message.natsUrl.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.natsUrl[i]);
                if (message.tlsCertFile != null && Object.hasOwnProperty.call(message, "tlsCertFile"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.tlsCertFile);
                if (message.tlsKeyFile != null && Object.hasOwnProperty.call(message, "tlsKeyFile"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.tlsKeyFile);
                if (message.tlsCaFile != null && Object.hasOwnProperty.call(message, "tlsCaFile"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.tlsCaFile);
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.tlsSkipVerify);
                if (message.enableCluster != null && Object.hasOwnProperty.call(message, "enableCluster"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.enableCluster);
                if (message.statsDatabasePath != null && Object.hasOwnProperty.call(message, "statsDatabasePath"))
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.statsDatabasePath);
                if (message.statsFlushIntervalSeconds != null && Object.hasOwnProperty.call(message, "statsFlushIntervalSeconds"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.statsFlushIntervalSeconds);
                if (message.httpListenAddress != null && Object.hasOwnProperty.call(message, "httpListenAddress"))
                    writer.uint32(/* id 16, wireType 2 =*/130).string(message.httpListenAddress);
                if (message.remoteControlEnabled != null && Object.hasOwnProperty.call(message, "remoteControlEnabled"))
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.remoteControlEnabled);
                if (message.remoteControlAddress != null && Object.hasOwnProperty.call(message, "remoteControlAddress"))
                    writer.uint32(/* id 18, wireType 2 =*/146).string(message.remoteControlAddress);
                if (message.remoteControlApiToken != null && Object.hasOwnProperty.call(message, "remoteControlApiToken"))
                    writer.uint32(/* id 19, wireType 2 =*/154).string(message.remoteControlApiToken);
                if (message.remoteControlDisableTls != null && Object.hasOwnProperty.call(message, "remoteControlDisableTls"))
                    writer.uint32(/* id 20, wireType 0 =*/160).bool(message.remoteControlDisableTls);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 500, wireType 0 =*/4000).bool(message.useTls);
                return writer;
            };

            /**
             * Encodes the specified ServerOptions message, length delimited. Does not implicitly {@link protos.opts.ServerOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {protos.opts.IServerOptions} message ServerOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServerOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServerOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ServerOptions} ServerOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServerOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ServerOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nodeId = reader.string();
                        break;
                    case 2:
                        message.clusterId = reader.string();
                        break;
                    case 3:
                        message.grpcListenAddress = reader.string();
                        break;
                    case 4:
                        message.authToken = reader.string();
                        break;
                    case 5:
                        if (!(message.natsUrl && message.natsUrl.length))
                            message.natsUrl = [];
                        message.natsUrl.push(reader.string());
                        break;
                    case 500:
                        message.useTls = reader.bool();
                        break;
                    case 6:
                        message.tlsCertFile = reader.string();
                        break;
                    case 7:
                        message.tlsKeyFile = reader.string();
                        break;
                    case 8:
                        message.tlsCaFile = reader.string();
                        break;
                    case 9:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    case 10:
                        message.enableCluster = reader.bool();
                        break;
                    case 14:
                        message.statsDatabasePath = reader.string();
                        break;
                    case 15:
                        message.statsFlushIntervalSeconds = reader.int32();
                        break;
                    case 16:
                        message.httpListenAddress = reader.string();
                        break;
                    case 17:
                        message.remoteControlEnabled = reader.bool();
                        break;
                    case 18:
                        message.remoteControlAddress = reader.string();
                        break;
                    case 19:
                        message.remoteControlApiToken = reader.string();
                        break;
                    case 20:
                        message.remoteControlDisableTls = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServerOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ServerOptions} ServerOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServerOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServerOptions message.
             * @function verify
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServerOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    if (!$util.isString(message.nodeId))
                        return "nodeId: string expected";
                if (message.clusterId != null && message.hasOwnProperty("clusterId"))
                    if (!$util.isString(message.clusterId))
                        return "clusterId: string expected";
                if (message.grpcListenAddress != null && message.hasOwnProperty("grpcListenAddress"))
                    if (!$util.isString(message.grpcListenAddress))
                        return "grpcListenAddress: string expected";
                if (message.authToken != null && message.hasOwnProperty("authToken"))
                    if (!$util.isString(message.authToken))
                        return "authToken: string expected";
                if (message.natsUrl != null && message.hasOwnProperty("natsUrl")) {
                    if (!Array.isArray(message.natsUrl))
                        return "natsUrl: array expected";
                    for (var i = 0; i < message.natsUrl.length; ++i)
                        if (!$util.isString(message.natsUrl[i]))
                            return "natsUrl: string[] expected";
                }
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.tlsCertFile != null && message.hasOwnProperty("tlsCertFile"))
                    if (!$util.isString(message.tlsCertFile))
                        return "tlsCertFile: string expected";
                if (message.tlsKeyFile != null && message.hasOwnProperty("tlsKeyFile"))
                    if (!$util.isString(message.tlsKeyFile))
                        return "tlsKeyFile: string expected";
                if (message.tlsCaFile != null && message.hasOwnProperty("tlsCaFile"))
                    if (!$util.isString(message.tlsCaFile))
                        return "tlsCaFile: string expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                if (message.enableCluster != null && message.hasOwnProperty("enableCluster"))
                    if (typeof message.enableCluster !== "boolean")
                        return "enableCluster: boolean expected";
                if (message.statsDatabasePath != null && message.hasOwnProperty("statsDatabasePath"))
                    if (!$util.isString(message.statsDatabasePath))
                        return "statsDatabasePath: string expected";
                if (message.statsFlushIntervalSeconds != null && message.hasOwnProperty("statsFlushIntervalSeconds"))
                    if (!$util.isInteger(message.statsFlushIntervalSeconds))
                        return "statsFlushIntervalSeconds: integer expected";
                if (message.httpListenAddress != null && message.hasOwnProperty("httpListenAddress"))
                    if (!$util.isString(message.httpListenAddress))
                        return "httpListenAddress: string expected";
                if (message.remoteControlEnabled != null && message.hasOwnProperty("remoteControlEnabled"))
                    if (typeof message.remoteControlEnabled !== "boolean")
                        return "remoteControlEnabled: boolean expected";
                if (message.remoteControlAddress != null && message.hasOwnProperty("remoteControlAddress"))
                    if (!$util.isString(message.remoteControlAddress))
                        return "remoteControlAddress: string expected";
                if (message.remoteControlApiToken != null && message.hasOwnProperty("remoteControlApiToken"))
                    if (!$util.isString(message.remoteControlApiToken))
                        return "remoteControlApiToken: string expected";
                if (message.remoteControlDisableTls != null && message.hasOwnProperty("remoteControlDisableTls"))
                    if (typeof message.remoteControlDisableTls !== "boolean")
                        return "remoteControlDisableTls: boolean expected";
                return null;
            };

            /**
             * Creates a ServerOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ServerOptions} ServerOptions
             */
            ServerOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ServerOptions)
                    return object;
                var message = new $root.protos.opts.ServerOptions();
                if (object.nodeId != null)
                    message.nodeId = String(object.nodeId);
                if (object.clusterId != null)
                    message.clusterId = String(object.clusterId);
                if (object.grpcListenAddress != null)
                    message.grpcListenAddress = String(object.grpcListenAddress);
                if (object.authToken != null)
                    message.authToken = String(object.authToken);
                if (object.natsUrl) {
                    if (!Array.isArray(object.natsUrl))
                        throw TypeError(".protos.opts.ServerOptions.natsUrl: array expected");
                    message.natsUrl = [];
                    for (var i = 0; i < object.natsUrl.length; ++i)
                        message.natsUrl[i] = String(object.natsUrl[i]);
                }
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.tlsCertFile != null)
                    message.tlsCertFile = String(object.tlsCertFile);
                if (object.tlsKeyFile != null)
                    message.tlsKeyFile = String(object.tlsKeyFile);
                if (object.tlsCaFile != null)
                    message.tlsCaFile = String(object.tlsCaFile);
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                if (object.enableCluster != null)
                    message.enableCluster = Boolean(object.enableCluster);
                if (object.statsDatabasePath != null)
                    message.statsDatabasePath = String(object.statsDatabasePath);
                if (object.statsFlushIntervalSeconds != null)
                    message.statsFlushIntervalSeconds = object.statsFlushIntervalSeconds | 0;
                if (object.httpListenAddress != null)
                    message.httpListenAddress = String(object.httpListenAddress);
                if (object.remoteControlEnabled != null)
                    message.remoteControlEnabled = Boolean(object.remoteControlEnabled);
                if (object.remoteControlAddress != null)
                    message.remoteControlAddress = String(object.remoteControlAddress);
                if (object.remoteControlApiToken != null)
                    message.remoteControlApiToken = String(object.remoteControlApiToken);
                if (object.remoteControlDisableTls != null)
                    message.remoteControlDisableTls = Boolean(object.remoteControlDisableTls);
                return message;
            };

            /**
             * Creates a plain object from a ServerOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {protos.opts.ServerOptions} message ServerOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServerOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.natsUrl = [];
                if (options.defaults) {
                    object.nodeId = "";
                    object.clusterId = "";
                    object.grpcListenAddress = "";
                    object.authToken = "";
                    object.tlsCertFile = "";
                    object.tlsKeyFile = "";
                    object.tlsCaFile = "";
                    object.tlsSkipVerify = false;
                    object.enableCluster = false;
                    object.statsDatabasePath = "";
                    object.statsFlushIntervalSeconds = 0;
                    object.httpListenAddress = "";
                    object.remoteControlEnabled = false;
                    object.remoteControlAddress = "";
                    object.remoteControlApiToken = "";
                    object.remoteControlDisableTls = false;
                    object.useTls = false;
                }
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    object.nodeId = message.nodeId;
                if (message.clusterId != null && message.hasOwnProperty("clusterId"))
                    object.clusterId = message.clusterId;
                if (message.grpcListenAddress != null && message.hasOwnProperty("grpcListenAddress"))
                    object.grpcListenAddress = message.grpcListenAddress;
                if (message.authToken != null && message.hasOwnProperty("authToken"))
                    object.authToken = message.authToken;
                if (message.natsUrl && message.natsUrl.length) {
                    object.natsUrl = [];
                    for (var j = 0; j < message.natsUrl.length; ++j)
                        object.natsUrl[j] = message.natsUrl[j];
                }
                if (message.tlsCertFile != null && message.hasOwnProperty("tlsCertFile"))
                    object.tlsCertFile = message.tlsCertFile;
                if (message.tlsKeyFile != null && message.hasOwnProperty("tlsKeyFile"))
                    object.tlsKeyFile = message.tlsKeyFile;
                if (message.tlsCaFile != null && message.hasOwnProperty("tlsCaFile"))
                    object.tlsCaFile = message.tlsCaFile;
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                if (message.enableCluster != null && message.hasOwnProperty("enableCluster"))
                    object.enableCluster = message.enableCluster;
                if (message.statsDatabasePath != null && message.hasOwnProperty("statsDatabasePath"))
                    object.statsDatabasePath = message.statsDatabasePath;
                if (message.statsFlushIntervalSeconds != null && message.hasOwnProperty("statsFlushIntervalSeconds"))
                    object.statsFlushIntervalSeconds = message.statsFlushIntervalSeconds;
                if (message.httpListenAddress != null && message.hasOwnProperty("httpListenAddress"))
                    object.httpListenAddress = message.httpListenAddress;
                if (message.remoteControlEnabled != null && message.hasOwnProperty("remoteControlEnabled"))
                    object.remoteControlEnabled = message.remoteControlEnabled;
                if (message.remoteControlAddress != null && message.hasOwnProperty("remoteControlAddress"))
                    object.remoteControlAddress = message.remoteControlAddress;
                if (message.remoteControlApiToken != null && message.hasOwnProperty("remoteControlApiToken"))
                    object.remoteControlApiToken = message.remoteControlApiToken;
                if (message.remoteControlDisableTls != null && message.hasOwnProperty("remoteControlDisableTls"))
                    object.remoteControlDisableTls = message.remoteControlDisableTls;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                return object;
            };

            /**
             * Converts this ServerOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ServerOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServerOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServerOptions;
        })();

        opts.TunnelOptions = (function() {

            /**
             * Properties of a TunnelOptions.
             * @memberof protos.opts
             * @interface ITunnelOptions
             * @property {string|null} [apiToken] TunnelOptions apiToken
             * @property {string|null} [connectionId] TunnelOptions connectionId
             * @property {string|null} [_grpcAddress] TunnelOptions _grpcAddress
             * @property {number|null} [_grpcTimeoutSeconds] TunnelOptions _grpcTimeoutSeconds
             * @property {boolean|null} [_grpcInsecure] TunnelOptions _grpcInsecure
             * @property {string|null} [name] TunnelOptions name
             * @property {string|null} [_tunnelId] TunnelOptions _tunnelId
             * @property {boolean|null} [_active] TunnelOptions _active
             * @property {protos.opts.ITunnelGroupKafkaOptions|null} [kafka] TunnelOptions kafka
             * @property {protos.opts.ITunnelGroupActiveMQOptions|null} [activemq] TunnelOptions activemq
             * @property {protos.opts.ITunnelGroupAWSSQSOptions|null} [awsSqs] TunnelOptions awsSqs
             * @property {protos.opts.ITunnelGroupAWSSNSOptions|null} [awsSns] TunnelOptions awsSns
             * @property {protos.opts.ITunnelGroupNatsOptions|null} [nats] TunnelOptions nats
             * @property {protos.opts.ITunnelGroupNatsStreamingOptions|null} [natsStreaming] TunnelOptions natsStreaming
             * @property {protos.opts.ITunnelGroupNSQOptions|null} [nsq] TunnelOptions nsq
             * @property {protos.opts.ITunnelGroupRabbitOptions|null} [rabbit] TunnelOptions rabbit
             * @property {protos.opts.ITunnelGroupMQTTOptions|null} [mqtt] TunnelOptions mqtt
             * @property {protos.opts.ITunnelGroupAzureServiceBusOptions|null} [azureServiceBus] TunnelOptions azureServiceBus
             * @property {protos.opts.ITunnelGroupAzureEventHubOptions|null} [azureEventHub] TunnelOptions azureEventHub
             * @property {protos.opts.ITunnelGroupGCPPubSubOptions|null} [gcpPubsub] TunnelOptions gcpPubsub
             * @property {protos.opts.ITunnelGroupKubeMQQueueOptions|null} [kubemqQueue] TunnelOptions kubemqQueue
             * @property {protos.opts.ITunnelGroupRedisPubSubOptions|null} [redisPubsub] TunnelOptions redisPubsub
             * @property {protos.opts.ITunnelGroupRedisStreamsOptions|null} [redisStreams] TunnelOptions redisStreams
             * @property {protos.opts.ITunnelGroupPulsarOptions|null} [pulsar] TunnelOptions pulsar
             * @property {protos.opts.ITunnelGroupRabbitStreamsOptions|null} [rabbitStreams] TunnelOptions rabbitStreams
             * @property {protos.opts.ITunnelGroupNatsJetstreamOptions|null} [natsJetstream] TunnelOptions natsJetstream
             * @property {protos.opts.ITunnelGroupAWSKinesisOptions|null} [awsKinesis] TunnelOptions awsKinesis
             * @property {protos.opts.ITunnelGroupMemphisOptions|null} [memphis] TunnelOptions memphis
             */

            /**
             * Constructs a new TunnelOptions.
             * @memberof protos.opts
             * @classdesc Represents a TunnelOptions.
             * @implements ITunnelOptions
             * @constructor
             * @param {protos.opts.ITunnelOptions=} [properties] Properties to set
             */
            function TunnelOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TunnelOptions apiToken.
             * @member {string} apiToken
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.apiToken = "";

            /**
             * TunnelOptions connectionId.
             * @member {string} connectionId
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.connectionId = "";

            /**
             * TunnelOptions _grpcAddress.
             * @member {string} _grpcAddress
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype._grpcAddress = "";

            /**
             * TunnelOptions _grpcTimeoutSeconds.
             * @member {number} _grpcTimeoutSeconds
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype._grpcTimeoutSeconds = 0;

            /**
             * TunnelOptions _grpcInsecure.
             * @member {boolean} _grpcInsecure
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype._grpcInsecure = false;

            /**
             * TunnelOptions name.
             * @member {string} name
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.name = "";

            /**
             * TunnelOptions _tunnelId.
             * @member {string} _tunnelId
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype._tunnelId = "";

            /**
             * TunnelOptions _active.
             * @member {boolean} _active
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype._active = false;

            /**
             * TunnelOptions kafka.
             * @member {protos.opts.ITunnelGroupKafkaOptions|null|undefined} kafka
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.kafka = null;

            /**
             * TunnelOptions activemq.
             * @member {protos.opts.ITunnelGroupActiveMQOptions|null|undefined} activemq
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.activemq = null;

            /**
             * TunnelOptions awsSqs.
             * @member {protos.opts.ITunnelGroupAWSSQSOptions|null|undefined} awsSqs
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.awsSqs = null;

            /**
             * TunnelOptions awsSns.
             * @member {protos.opts.ITunnelGroupAWSSNSOptions|null|undefined} awsSns
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.awsSns = null;

            /**
             * TunnelOptions nats.
             * @member {protos.opts.ITunnelGroupNatsOptions|null|undefined} nats
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.nats = null;

            /**
             * TunnelOptions natsStreaming.
             * @member {protos.opts.ITunnelGroupNatsStreamingOptions|null|undefined} natsStreaming
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.natsStreaming = null;

            /**
             * TunnelOptions nsq.
             * @member {protos.opts.ITunnelGroupNSQOptions|null|undefined} nsq
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.nsq = null;

            /**
             * TunnelOptions rabbit.
             * @member {protos.opts.ITunnelGroupRabbitOptions|null|undefined} rabbit
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.rabbit = null;

            /**
             * TunnelOptions mqtt.
             * @member {protos.opts.ITunnelGroupMQTTOptions|null|undefined} mqtt
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.mqtt = null;

            /**
             * TunnelOptions azureServiceBus.
             * @member {protos.opts.ITunnelGroupAzureServiceBusOptions|null|undefined} azureServiceBus
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.azureServiceBus = null;

            /**
             * TunnelOptions azureEventHub.
             * @member {protos.opts.ITunnelGroupAzureEventHubOptions|null|undefined} azureEventHub
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.azureEventHub = null;

            /**
             * TunnelOptions gcpPubsub.
             * @member {protos.opts.ITunnelGroupGCPPubSubOptions|null|undefined} gcpPubsub
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.gcpPubsub = null;

            /**
             * TunnelOptions kubemqQueue.
             * @member {protos.opts.ITunnelGroupKubeMQQueueOptions|null|undefined} kubemqQueue
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.kubemqQueue = null;

            /**
             * TunnelOptions redisPubsub.
             * @member {protos.opts.ITunnelGroupRedisPubSubOptions|null|undefined} redisPubsub
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.redisPubsub = null;

            /**
             * TunnelOptions redisStreams.
             * @member {protos.opts.ITunnelGroupRedisStreamsOptions|null|undefined} redisStreams
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.redisStreams = null;

            /**
             * TunnelOptions pulsar.
             * @member {protos.opts.ITunnelGroupPulsarOptions|null|undefined} pulsar
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.pulsar = null;

            /**
             * TunnelOptions rabbitStreams.
             * @member {protos.opts.ITunnelGroupRabbitStreamsOptions|null|undefined} rabbitStreams
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.rabbitStreams = null;

            /**
             * TunnelOptions natsJetstream.
             * @member {protos.opts.ITunnelGroupNatsJetstreamOptions|null|undefined} natsJetstream
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.natsJetstream = null;

            /**
             * TunnelOptions awsKinesis.
             * @member {protos.opts.ITunnelGroupAWSKinesisOptions|null|undefined} awsKinesis
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.awsKinesis = null;

            /**
             * TunnelOptions memphis.
             * @member {protos.opts.ITunnelGroupMemphisOptions|null|undefined} memphis
             * @memberof protos.opts.TunnelOptions
             * @instance
             */
            TunnelOptions.prototype.memphis = null;

            /**
             * Creates a new TunnelOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.TunnelOptions
             * @static
             * @param {protos.opts.ITunnelOptions=} [properties] Properties to set
             * @returns {protos.opts.TunnelOptions} TunnelOptions instance
             */
            TunnelOptions.create = function create(properties) {
                return new TunnelOptions(properties);
            };

            /**
             * Encodes the specified TunnelOptions message. Does not implicitly {@link protos.opts.TunnelOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.TunnelOptions
             * @static
             * @param {protos.opts.ITunnelOptions} message TunnelOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.apiToken != null && Object.hasOwnProperty.call(message, "apiToken"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.apiToken);
                if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.connectionId);
                if (message._grpcAddress != null && Object.hasOwnProperty.call(message, "_grpcAddress"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message._grpcAddress);
                if (message._grpcTimeoutSeconds != null && Object.hasOwnProperty.call(message, "_grpcTimeoutSeconds"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message._grpcTimeoutSeconds);
                if (message._grpcInsecure != null && Object.hasOwnProperty.call(message, "_grpcInsecure"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message._grpcInsecure);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.name);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.opts.TunnelGroupKafkaOptions.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.activemq != null && Object.hasOwnProperty.call(message, "activemq"))
                    $root.protos.opts.TunnelGroupActiveMQOptions.encode(message.activemq, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.awsSqs != null && Object.hasOwnProperty.call(message, "awsSqs"))
                    $root.protos.opts.TunnelGroupAWSSQSOptions.encode(message.awsSqs, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.awsSns != null && Object.hasOwnProperty.call(message, "awsSns"))
                    $root.protos.opts.TunnelGroupAWSSNSOptions.encode(message.awsSns, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.opts.TunnelGroupNatsOptions.encode(message.nats, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.opts.TunnelGroupNatsStreamingOptions.encode(message.natsStreaming, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.opts.TunnelGroupNSQOptions.encode(message.nsq, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.opts.TunnelGroupRabbitOptions.encode(message.rabbit, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.opts.TunnelGroupMQTTOptions.encode(message.mqtt, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.opts.TunnelGroupAzureServiceBusOptions.encode(message.azureServiceBus, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.azureEventHub != null && Object.hasOwnProperty.call(message, "azureEventHub"))
                    $root.protos.opts.TunnelGroupAzureEventHubOptions.encode(message.azureEventHub, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.opts.TunnelGroupGCPPubSubOptions.encode(message.gcpPubsub, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.opts.TunnelGroupKubeMQQueueOptions.encode(message.kubemqQueue, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.opts.TunnelGroupRedisPubSubOptions.encode(message.redisPubsub, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.opts.TunnelGroupRedisStreamsOptions.encode(message.redisStreams, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.pulsar != null && Object.hasOwnProperty.call(message, "pulsar"))
                    $root.protos.opts.TunnelGroupPulsarOptions.encode(message.pulsar, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                if (message.rabbitStreams != null && Object.hasOwnProperty.call(message, "rabbitStreams"))
                    $root.protos.opts.TunnelGroupRabbitStreamsOptions.encode(message.rabbitStreams, writer.uint32(/* id 116, wireType 2 =*/930).fork()).ldelim();
                if (message.natsJetstream != null && Object.hasOwnProperty.call(message, "natsJetstream"))
                    $root.protos.opts.TunnelGroupNatsJetstreamOptions.encode(message.natsJetstream, writer.uint32(/* id 117, wireType 2 =*/938).fork()).ldelim();
                if (message.awsKinesis != null && Object.hasOwnProperty.call(message, "awsKinesis"))
                    $root.protos.opts.TunnelGroupAWSKinesisOptions.encode(message.awsKinesis, writer.uint32(/* id 118, wireType 2 =*/946).fork()).ldelim();
                if (message.memphis != null && Object.hasOwnProperty.call(message, "memphis"))
                    $root.protos.opts.TunnelGroupMemphisOptions.encode(message.memphis, writer.uint32(/* id 119, wireType 2 =*/954).fork()).ldelim();
                if (message._tunnelId != null && Object.hasOwnProperty.call(message, "_tunnelId"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._tunnelId);
                if (message._active != null && Object.hasOwnProperty.call(message, "_active"))
                    writer.uint32(/* id 1001, wireType 0 =*/8008).bool(message._active);
                return writer;
            };

            /**
             * Encodes the specified TunnelOptions message, length delimited. Does not implicitly {@link protos.opts.TunnelOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.TunnelOptions
             * @static
             * @param {protos.opts.ITunnelOptions} message TunnelOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TunnelOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.TunnelOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.TunnelOptions} TunnelOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.TunnelOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.apiToken = reader.string();
                        break;
                    case 2:
                        message.connectionId = reader.string();
                        break;
                    case 3:
                        message._grpcAddress = reader.string();
                        break;
                    case 4:
                        message._grpcTimeoutSeconds = reader.uint32();
                        break;
                    case 5:
                        message._grpcInsecure = reader.bool();
                        break;
                    case 6:
                        message.name = reader.string();
                        break;
                    case 1000:
                        message._tunnelId = reader.string();
                        break;
                    case 1001:
                        message._active = reader.bool();
                        break;
                    case 100:
                        message.kafka = $root.protos.opts.TunnelGroupKafkaOptions.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.activemq = $root.protos.opts.TunnelGroupActiveMQOptions.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.awsSqs = $root.protos.opts.TunnelGroupAWSSQSOptions.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.awsSns = $root.protos.opts.TunnelGroupAWSSNSOptions.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.nats = $root.protos.opts.TunnelGroupNatsOptions.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.natsStreaming = $root.protos.opts.TunnelGroupNatsStreamingOptions.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.nsq = $root.protos.opts.TunnelGroupNSQOptions.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.rabbit = $root.protos.opts.TunnelGroupRabbitOptions.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.mqtt = $root.protos.opts.TunnelGroupMQTTOptions.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.azureServiceBus = $root.protos.opts.TunnelGroupAzureServiceBusOptions.decode(reader, reader.uint32());
                        break;
                    case 110:
                        message.azureEventHub = $root.protos.opts.TunnelGroupAzureEventHubOptions.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.gcpPubsub = $root.protos.opts.TunnelGroupGCPPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.kubemqQueue = $root.protos.opts.TunnelGroupKubeMQQueueOptions.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.redisPubsub = $root.protos.opts.TunnelGroupRedisPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.redisStreams = $root.protos.opts.TunnelGroupRedisStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.pulsar = $root.protos.opts.TunnelGroupPulsarOptions.decode(reader, reader.uint32());
                        break;
                    case 116:
                        message.rabbitStreams = $root.protos.opts.TunnelGroupRabbitStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 117:
                        message.natsJetstream = $root.protos.opts.TunnelGroupNatsJetstreamOptions.decode(reader, reader.uint32());
                        break;
                    case 118:
                        message.awsKinesis = $root.protos.opts.TunnelGroupAWSKinesisOptions.decode(reader, reader.uint32());
                        break;
                    case 119:
                        message.memphis = $root.protos.opts.TunnelGroupMemphisOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TunnelOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.TunnelOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.TunnelOptions} TunnelOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TunnelOptions message.
             * @function verify
             * @memberof protos.opts.TunnelOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TunnelOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.apiToken != null && message.hasOwnProperty("apiToken"))
                    if (!$util.isString(message.apiToken))
                        return "apiToken: string expected";
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    if (!$util.isString(message.connectionId))
                        return "connectionId: string expected";
                if (message._grpcAddress != null && message.hasOwnProperty("_grpcAddress"))
                    if (!$util.isString(message._grpcAddress))
                        return "_grpcAddress: string expected";
                if (message._grpcTimeoutSeconds != null && message.hasOwnProperty("_grpcTimeoutSeconds"))
                    if (!$util.isInteger(message._grpcTimeoutSeconds))
                        return "_grpcTimeoutSeconds: integer expected";
                if (message._grpcInsecure != null && message.hasOwnProperty("_grpcInsecure"))
                    if (typeof message._grpcInsecure !== "boolean")
                        return "_grpcInsecure: boolean expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message._tunnelId != null && message.hasOwnProperty("_tunnelId"))
                    if (!$util.isString(message._tunnelId))
                        return "_tunnelId: string expected";
                if (message._active != null && message.hasOwnProperty("_active"))
                    if (typeof message._active !== "boolean")
                        return "_active: boolean expected";
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    var error = $root.protos.opts.TunnelGroupKafkaOptions.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.activemq != null && message.hasOwnProperty("activemq")) {
                    var error = $root.protos.opts.TunnelGroupActiveMQOptions.verify(message.activemq);
                    if (error)
                        return "activemq." + error;
                }
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs")) {
                    var error = $root.protos.opts.TunnelGroupAWSSQSOptions.verify(message.awsSqs);
                    if (error)
                        return "awsSqs." + error;
                }
                if (message.awsSns != null && message.hasOwnProperty("awsSns")) {
                    var error = $root.protos.opts.TunnelGroupAWSSNSOptions.verify(message.awsSns);
                    if (error)
                        return "awsSns." + error;
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    var error = $root.protos.opts.TunnelGroupNatsOptions.verify(message.nats);
                    if (error)
                        return "nats." + error;
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    var error = $root.protos.opts.TunnelGroupNatsStreamingOptions.verify(message.natsStreaming);
                    if (error)
                        return "natsStreaming." + error;
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    var error = $root.protos.opts.TunnelGroupNSQOptions.verify(message.nsq);
                    if (error)
                        return "nsq." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    var error = $root.protos.opts.TunnelGroupRabbitOptions.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    var error = $root.protos.opts.TunnelGroupMQTTOptions.verify(message.mqtt);
                    if (error)
                        return "mqtt." + error;
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    var error = $root.protos.opts.TunnelGroupAzureServiceBusOptions.verify(message.azureServiceBus);
                    if (error)
                        return "azureServiceBus." + error;
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    var error = $root.protos.opts.TunnelGroupAzureEventHubOptions.verify(message.azureEventHub);
                    if (error)
                        return "azureEventHub." + error;
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    var error = $root.protos.opts.TunnelGroupGCPPubSubOptions.verify(message.gcpPubsub);
                    if (error)
                        return "gcpPubsub." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    var error = $root.protos.opts.TunnelGroupKubeMQQueueOptions.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    var error = $root.protos.opts.TunnelGroupRedisPubSubOptions.verify(message.redisPubsub);
                    if (error)
                        return "redisPubsub." + error;
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    var error = $root.protos.opts.TunnelGroupRedisStreamsOptions.verify(message.redisStreams);
                    if (error)
                        return "redisStreams." + error;
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    var error = $root.protos.opts.TunnelGroupPulsarOptions.verify(message.pulsar);
                    if (error)
                        return "pulsar." + error;
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    var error = $root.protos.opts.TunnelGroupRabbitStreamsOptions.verify(message.rabbitStreams);
                    if (error)
                        return "rabbitStreams." + error;
                }
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream")) {
                    var error = $root.protos.opts.TunnelGroupNatsJetstreamOptions.verify(message.natsJetstream);
                    if (error)
                        return "natsJetstream." + error;
                }
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis")) {
                    var error = $root.protos.opts.TunnelGroupAWSKinesisOptions.verify(message.awsKinesis);
                    if (error)
                        return "awsKinesis." + error;
                }
                if (message.memphis != null && message.hasOwnProperty("memphis")) {
                    var error = $root.protos.opts.TunnelGroupMemphisOptions.verify(message.memphis);
                    if (error)
                        return "memphis." + error;
                }
                return null;
            };

            /**
             * Creates a TunnelOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.TunnelOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.TunnelOptions} TunnelOptions
             */
            TunnelOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.TunnelOptions)
                    return object;
                var message = new $root.protos.opts.TunnelOptions();
                if (object.apiToken != null)
                    message.apiToken = String(object.apiToken);
                if (object.connectionId != null)
                    message.connectionId = String(object.connectionId);
                if (object._grpcAddress != null)
                    message._grpcAddress = String(object._grpcAddress);
                if (object._grpcTimeoutSeconds != null)
                    message._grpcTimeoutSeconds = object._grpcTimeoutSeconds >>> 0;
                if (object._grpcInsecure != null)
                    message._grpcInsecure = Boolean(object._grpcInsecure);
                if (object.name != null)
                    message.name = String(object.name);
                if (object._tunnelId != null)
                    message._tunnelId = String(object._tunnelId);
                if (object._active != null)
                    message._active = Boolean(object._active);
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.TunnelOptions.kafka: object expected");
                    message.kafka = $root.protos.opts.TunnelGroupKafkaOptions.fromObject(object.kafka);
                }
                if (object.activemq != null) {
                    if (typeof object.activemq !== "object")
                        throw TypeError(".protos.opts.TunnelOptions.activemq: object expected");
                    message.activemq = $root.protos.opts.TunnelGroupActiveMQOptions.fromObject(object.activemq);
                }
                if (object.awsSqs != null) {
                    if (typeof object.awsSqs !== "object")
                        throw TypeError(".protos.opts.TunnelOptions.awsSqs: object expected");
                    message.awsSqs = $root.protos.opts.TunnelGroupAWSSQSOptions.fromObject(object.awsSqs);
                }
                if (object.awsSns != null) {
                    if (typeof object.awsSns !== "object")
                        throw TypeError(".protos.opts.TunnelOptions.awsSns: object expected");
                    message.awsSns = $root.protos.opts.TunnelGroupAWSSNSOptions.fromObject(object.awsSns);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.opts.TunnelOptions.nats: object expected");
                    message.nats = $root.protos.opts.TunnelGroupNatsOptions.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.opts.TunnelOptions.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.opts.TunnelGroupNatsStreamingOptions.fromObject(object.natsStreaming);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.TunnelOptions.nsq: object expected");
                    message.nsq = $root.protos.opts.TunnelGroupNSQOptions.fromObject(object.nsq);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.TunnelOptions.rabbit: object expected");
                    message.rabbit = $root.protos.opts.TunnelGroupRabbitOptions.fromObject(object.rabbit);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.TunnelOptions.mqtt: object expected");
                    message.mqtt = $root.protos.opts.TunnelGroupMQTTOptions.fromObject(object.mqtt);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.TunnelOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.opts.TunnelGroupAzureServiceBusOptions.fromObject(object.azureServiceBus);
                }
                if (object.azureEventHub != null) {
                    if (typeof object.azureEventHub !== "object")
                        throw TypeError(".protos.opts.TunnelOptions.azureEventHub: object expected");
                    message.azureEventHub = $root.protos.opts.TunnelGroupAzureEventHubOptions.fromObject(object.azureEventHub);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.TunnelOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.opts.TunnelGroupGCPPubSubOptions.fromObject(object.gcpPubsub);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.TunnelOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.opts.TunnelGroupKubeMQQueueOptions.fromObject(object.kubemqQueue);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.TunnelOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.opts.TunnelGroupRedisPubSubOptions.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.TunnelOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.opts.TunnelGroupRedisStreamsOptions.fromObject(object.redisStreams);
                }
                if (object.pulsar != null) {
                    if (typeof object.pulsar !== "object")
                        throw TypeError(".protos.opts.TunnelOptions.pulsar: object expected");
                    message.pulsar = $root.protos.opts.TunnelGroupPulsarOptions.fromObject(object.pulsar);
                }
                if (object.rabbitStreams != null) {
                    if (typeof object.rabbitStreams !== "object")
                        throw TypeError(".protos.opts.TunnelOptions.rabbitStreams: object expected");
                    message.rabbitStreams = $root.protos.opts.TunnelGroupRabbitStreamsOptions.fromObject(object.rabbitStreams);
                }
                if (object.natsJetstream != null) {
                    if (typeof object.natsJetstream !== "object")
                        throw TypeError(".protos.opts.TunnelOptions.natsJetstream: object expected");
                    message.natsJetstream = $root.protos.opts.TunnelGroupNatsJetstreamOptions.fromObject(object.natsJetstream);
                }
                if (object.awsKinesis != null) {
                    if (typeof object.awsKinesis !== "object")
                        throw TypeError(".protos.opts.TunnelOptions.awsKinesis: object expected");
                    message.awsKinesis = $root.protos.opts.TunnelGroupAWSKinesisOptions.fromObject(object.awsKinesis);
                }
                if (object.memphis != null) {
                    if (typeof object.memphis !== "object")
                        throw TypeError(".protos.opts.TunnelOptions.memphis: object expected");
                    message.memphis = $root.protos.opts.TunnelGroupMemphisOptions.fromObject(object.memphis);
                }
                return message;
            };

            /**
             * Creates a plain object from a TunnelOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.TunnelOptions
             * @static
             * @param {protos.opts.TunnelOptions} message TunnelOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TunnelOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.apiToken = "";
                    object.connectionId = "";
                    object._grpcAddress = "";
                    object._grpcTimeoutSeconds = 0;
                    object._grpcInsecure = false;
                    object.name = "";
                    object.kafka = null;
                    object.activemq = null;
                    object.awsSqs = null;
                    object.awsSns = null;
                    object.nats = null;
                    object.natsStreaming = null;
                    object.nsq = null;
                    object.rabbit = null;
                    object.mqtt = null;
                    object.azureServiceBus = null;
                    object.azureEventHub = null;
                    object.gcpPubsub = null;
                    object.kubemqQueue = null;
                    object.redisPubsub = null;
                    object.redisStreams = null;
                    object.pulsar = null;
                    object.rabbitStreams = null;
                    object.natsJetstream = null;
                    object.awsKinesis = null;
                    object.memphis = null;
                    object._tunnelId = "";
                    object._active = false;
                }
                if (message.apiToken != null && message.hasOwnProperty("apiToken"))
                    object.apiToken = message.apiToken;
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    object.connectionId = message.connectionId;
                if (message._grpcAddress != null && message.hasOwnProperty("_grpcAddress"))
                    object._grpcAddress = message._grpcAddress;
                if (message._grpcTimeoutSeconds != null && message.hasOwnProperty("_grpcTimeoutSeconds"))
                    object._grpcTimeoutSeconds = message._grpcTimeoutSeconds;
                if (message._grpcInsecure != null && message.hasOwnProperty("_grpcInsecure"))
                    object._grpcInsecure = message._grpcInsecure;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.opts.TunnelGroupKafkaOptions.toObject(message.kafka, options);
                if (message.activemq != null && message.hasOwnProperty("activemq"))
                    object.activemq = $root.protos.opts.TunnelGroupActiveMQOptions.toObject(message.activemq, options);
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs"))
                    object.awsSqs = $root.protos.opts.TunnelGroupAWSSQSOptions.toObject(message.awsSqs, options);
                if (message.awsSns != null && message.hasOwnProperty("awsSns"))
                    object.awsSns = $root.protos.opts.TunnelGroupAWSSNSOptions.toObject(message.awsSns, options);
                if (message.nats != null && message.hasOwnProperty("nats"))
                    object.nats = $root.protos.opts.TunnelGroupNatsOptions.toObject(message.nats, options);
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming"))
                    object.natsStreaming = $root.protos.opts.TunnelGroupNatsStreamingOptions.toObject(message.natsStreaming, options);
                if (message.nsq != null && message.hasOwnProperty("nsq"))
                    object.nsq = $root.protos.opts.TunnelGroupNSQOptions.toObject(message.nsq, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.opts.TunnelGroupRabbitOptions.toObject(message.rabbit, options);
                if (message.mqtt != null && message.hasOwnProperty("mqtt"))
                    object.mqtt = $root.protos.opts.TunnelGroupMQTTOptions.toObject(message.mqtt, options);
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus"))
                    object.azureServiceBus = $root.protos.opts.TunnelGroupAzureServiceBusOptions.toObject(message.azureServiceBus, options);
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub"))
                    object.azureEventHub = $root.protos.opts.TunnelGroupAzureEventHubOptions.toObject(message.azureEventHub, options);
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub"))
                    object.gcpPubsub = $root.protos.opts.TunnelGroupGCPPubSubOptions.toObject(message.gcpPubsub, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.opts.TunnelGroupKubeMQQueueOptions.toObject(message.kubemqQueue, options);
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub"))
                    object.redisPubsub = $root.protos.opts.TunnelGroupRedisPubSubOptions.toObject(message.redisPubsub, options);
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams"))
                    object.redisStreams = $root.protos.opts.TunnelGroupRedisStreamsOptions.toObject(message.redisStreams, options);
                if (message.pulsar != null && message.hasOwnProperty("pulsar"))
                    object.pulsar = $root.protos.opts.TunnelGroupPulsarOptions.toObject(message.pulsar, options);
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams"))
                    object.rabbitStreams = $root.protos.opts.TunnelGroupRabbitStreamsOptions.toObject(message.rabbitStreams, options);
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream"))
                    object.natsJetstream = $root.protos.opts.TunnelGroupNatsJetstreamOptions.toObject(message.natsJetstream, options);
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis"))
                    object.awsKinesis = $root.protos.opts.TunnelGroupAWSKinesisOptions.toObject(message.awsKinesis, options);
                if (message.memphis != null && message.hasOwnProperty("memphis"))
                    object.memphis = $root.protos.opts.TunnelGroupMemphisOptions.toObject(message.memphis, options);
                if (message._tunnelId != null && message.hasOwnProperty("_tunnelId"))
                    object._tunnelId = message._tunnelId;
                if (message._active != null && message.hasOwnProperty("_active"))
                    object._active = message._active;
                return object;
            };

            /**
             * Converts this TunnelOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.TunnelOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TunnelOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TunnelOptions;
        })();

        opts.TunnelGroupKafkaOptions = (function() {

            /**
             * Properties of a TunnelGroupKafkaOptions.
             * @memberof protos.opts
             * @interface ITunnelGroupKafkaOptions
             * @property {protos.args.IKafkaConn|null} [_conn] TunnelGroupKafkaOptions _conn
             * @property {protos.args.IKafkaWriteArgs|null} [args] TunnelGroupKafkaOptions args
             */

            /**
             * Constructs a new TunnelGroupKafkaOptions.
             * @memberof protos.opts
             * @classdesc Represents a TunnelGroupKafkaOptions.
             * @implements ITunnelGroupKafkaOptions
             * @constructor
             * @param {protos.opts.ITunnelGroupKafkaOptions=} [properties] Properties to set
             */
            function TunnelGroupKafkaOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TunnelGroupKafkaOptions _conn.
             * @member {protos.args.IKafkaConn|null|undefined} _conn
             * @memberof protos.opts.TunnelGroupKafkaOptions
             * @instance
             */
            TunnelGroupKafkaOptions.prototype._conn = null;

            /**
             * TunnelGroupKafkaOptions args.
             * @member {protos.args.IKafkaWriteArgs|null|undefined} args
             * @memberof protos.opts.TunnelGroupKafkaOptions
             * @instance
             */
            TunnelGroupKafkaOptions.prototype.args = null;

            /**
             * Creates a new TunnelGroupKafkaOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.TunnelGroupKafkaOptions
             * @static
             * @param {protos.opts.ITunnelGroupKafkaOptions=} [properties] Properties to set
             * @returns {protos.opts.TunnelGroupKafkaOptions} TunnelGroupKafkaOptions instance
             */
            TunnelGroupKafkaOptions.create = function create(properties) {
                return new TunnelGroupKafkaOptions(properties);
            };

            /**
             * Encodes the specified TunnelGroupKafkaOptions message. Does not implicitly {@link protos.opts.TunnelGroupKafkaOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.TunnelGroupKafkaOptions
             * @static
             * @param {protos.opts.ITunnelGroupKafkaOptions} message TunnelGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupKafkaOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KafkaConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KafkaWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TunnelGroupKafkaOptions message, length delimited. Does not implicitly {@link protos.opts.TunnelGroupKafkaOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.TunnelGroupKafkaOptions
             * @static
             * @param {protos.opts.ITunnelGroupKafkaOptions} message TunnelGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupKafkaOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TunnelGroupKafkaOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.TunnelGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.TunnelGroupKafkaOptions} TunnelGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupKafkaOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.TunnelGroupKafkaOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KafkaConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KafkaWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TunnelGroupKafkaOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.TunnelGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.TunnelGroupKafkaOptions} TunnelGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupKafkaOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TunnelGroupKafkaOptions message.
             * @function verify
             * @memberof protos.opts.TunnelGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TunnelGroupKafkaOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KafkaConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KafkaWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a TunnelGroupKafkaOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.TunnelGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.TunnelGroupKafkaOptions} TunnelGroupKafkaOptions
             */
            TunnelGroupKafkaOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.TunnelGroupKafkaOptions)
                    return object;
                var message = new $root.protos.opts.TunnelGroupKafkaOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.TunnelGroupKafkaOptions._conn: object expected");
                    message._conn = $root.protos.args.KafkaConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.TunnelGroupKafkaOptions.args: object expected");
                    message.args = $root.protos.args.KafkaWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a TunnelGroupKafkaOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.TunnelGroupKafkaOptions
             * @static
             * @param {protos.opts.TunnelGroupKafkaOptions} message TunnelGroupKafkaOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TunnelGroupKafkaOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KafkaConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KafkaWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this TunnelGroupKafkaOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.TunnelGroupKafkaOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TunnelGroupKafkaOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TunnelGroupKafkaOptions;
        })();

        opts.TunnelGroupActiveMQOptions = (function() {

            /**
             * Properties of a TunnelGroupActiveMQOptions.
             * @memberof protos.opts
             * @interface ITunnelGroupActiveMQOptions
             * @property {protos.args.IActiveMQConn|null} [_conn] TunnelGroupActiveMQOptions _conn
             * @property {protos.args.IActiveMQWriteArgs|null} [args] TunnelGroupActiveMQOptions args
             */

            /**
             * Constructs a new TunnelGroupActiveMQOptions.
             * @memberof protos.opts
             * @classdesc Represents a TunnelGroupActiveMQOptions.
             * @implements ITunnelGroupActiveMQOptions
             * @constructor
             * @param {protos.opts.ITunnelGroupActiveMQOptions=} [properties] Properties to set
             */
            function TunnelGroupActiveMQOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TunnelGroupActiveMQOptions _conn.
             * @member {protos.args.IActiveMQConn|null|undefined} _conn
             * @memberof protos.opts.TunnelGroupActiveMQOptions
             * @instance
             */
            TunnelGroupActiveMQOptions.prototype._conn = null;

            /**
             * TunnelGroupActiveMQOptions args.
             * @member {protos.args.IActiveMQWriteArgs|null|undefined} args
             * @memberof protos.opts.TunnelGroupActiveMQOptions
             * @instance
             */
            TunnelGroupActiveMQOptions.prototype.args = null;

            /**
             * Creates a new TunnelGroupActiveMQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.TunnelGroupActiveMQOptions
             * @static
             * @param {protos.opts.ITunnelGroupActiveMQOptions=} [properties] Properties to set
             * @returns {protos.opts.TunnelGroupActiveMQOptions} TunnelGroupActiveMQOptions instance
             */
            TunnelGroupActiveMQOptions.create = function create(properties) {
                return new TunnelGroupActiveMQOptions(properties);
            };

            /**
             * Encodes the specified TunnelGroupActiveMQOptions message. Does not implicitly {@link protos.opts.TunnelGroupActiveMQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.TunnelGroupActiveMQOptions
             * @static
             * @param {protos.opts.ITunnelGroupActiveMQOptions} message TunnelGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupActiveMQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.ActiveMQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.ActiveMQWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TunnelGroupActiveMQOptions message, length delimited. Does not implicitly {@link protos.opts.TunnelGroupActiveMQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.TunnelGroupActiveMQOptions
             * @static
             * @param {protos.opts.ITunnelGroupActiveMQOptions} message TunnelGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupActiveMQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TunnelGroupActiveMQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.TunnelGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.TunnelGroupActiveMQOptions} TunnelGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupActiveMQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.TunnelGroupActiveMQOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.ActiveMQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.ActiveMQWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TunnelGroupActiveMQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.TunnelGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.TunnelGroupActiveMQOptions} TunnelGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupActiveMQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TunnelGroupActiveMQOptions message.
             * @function verify
             * @memberof protos.opts.TunnelGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TunnelGroupActiveMQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.ActiveMQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.ActiveMQWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a TunnelGroupActiveMQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.TunnelGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.TunnelGroupActiveMQOptions} TunnelGroupActiveMQOptions
             */
            TunnelGroupActiveMQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.TunnelGroupActiveMQOptions)
                    return object;
                var message = new $root.protos.opts.TunnelGroupActiveMQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.TunnelGroupActiveMQOptions._conn: object expected");
                    message._conn = $root.protos.args.ActiveMQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.TunnelGroupActiveMQOptions.args: object expected");
                    message.args = $root.protos.args.ActiveMQWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a TunnelGroupActiveMQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.TunnelGroupActiveMQOptions
             * @static
             * @param {protos.opts.TunnelGroupActiveMQOptions} message TunnelGroupActiveMQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TunnelGroupActiveMQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.ActiveMQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.ActiveMQWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this TunnelGroupActiveMQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.TunnelGroupActiveMQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TunnelGroupActiveMQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TunnelGroupActiveMQOptions;
        })();

        opts.TunnelGroupAWSSQSOptions = (function() {

            /**
             * Properties of a TunnelGroupAWSSQSOptions.
             * @memberof protos.opts
             * @interface ITunnelGroupAWSSQSOptions
             * @property {protos.args.IAWSSQSConn|null} [_conn] TunnelGroupAWSSQSOptions _conn
             * @property {protos.args.IAWSSQSWriteArgs|null} [args] TunnelGroupAWSSQSOptions args
             */

            /**
             * Constructs a new TunnelGroupAWSSQSOptions.
             * @memberof protos.opts
             * @classdesc Represents a TunnelGroupAWSSQSOptions.
             * @implements ITunnelGroupAWSSQSOptions
             * @constructor
             * @param {protos.opts.ITunnelGroupAWSSQSOptions=} [properties] Properties to set
             */
            function TunnelGroupAWSSQSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TunnelGroupAWSSQSOptions _conn.
             * @member {protos.args.IAWSSQSConn|null|undefined} _conn
             * @memberof protos.opts.TunnelGroupAWSSQSOptions
             * @instance
             */
            TunnelGroupAWSSQSOptions.prototype._conn = null;

            /**
             * TunnelGroupAWSSQSOptions args.
             * @member {protos.args.IAWSSQSWriteArgs|null|undefined} args
             * @memberof protos.opts.TunnelGroupAWSSQSOptions
             * @instance
             */
            TunnelGroupAWSSQSOptions.prototype.args = null;

            /**
             * Creates a new TunnelGroupAWSSQSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.TunnelGroupAWSSQSOptions
             * @static
             * @param {protos.opts.ITunnelGroupAWSSQSOptions=} [properties] Properties to set
             * @returns {protos.opts.TunnelGroupAWSSQSOptions} TunnelGroupAWSSQSOptions instance
             */
            TunnelGroupAWSSQSOptions.create = function create(properties) {
                return new TunnelGroupAWSSQSOptions(properties);
            };

            /**
             * Encodes the specified TunnelGroupAWSSQSOptions message. Does not implicitly {@link protos.opts.TunnelGroupAWSSQSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.TunnelGroupAWSSQSOptions
             * @static
             * @param {protos.opts.ITunnelGroupAWSSQSOptions} message TunnelGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupAWSSQSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSQSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSQSWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TunnelGroupAWSSQSOptions message, length delimited. Does not implicitly {@link protos.opts.TunnelGroupAWSSQSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.TunnelGroupAWSSQSOptions
             * @static
             * @param {protos.opts.ITunnelGroupAWSSQSOptions} message TunnelGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupAWSSQSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TunnelGroupAWSSQSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.TunnelGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.TunnelGroupAWSSQSOptions} TunnelGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupAWSSQSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.TunnelGroupAWSSQSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSQSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSQSWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TunnelGroupAWSSQSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.TunnelGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.TunnelGroupAWSSQSOptions} TunnelGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupAWSSQSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TunnelGroupAWSSQSOptions message.
             * @function verify
             * @memberof protos.opts.TunnelGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TunnelGroupAWSSQSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSSQSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSSQSWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a TunnelGroupAWSSQSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.TunnelGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.TunnelGroupAWSSQSOptions} TunnelGroupAWSSQSOptions
             */
            TunnelGroupAWSSQSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.TunnelGroupAWSSQSOptions)
                    return object;
                var message = new $root.protos.opts.TunnelGroupAWSSQSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.TunnelGroupAWSSQSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSQSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.TunnelGroupAWSSQSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSQSWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a TunnelGroupAWSSQSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.TunnelGroupAWSSQSOptions
             * @static
             * @param {protos.opts.TunnelGroupAWSSQSOptions} message TunnelGroupAWSSQSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TunnelGroupAWSSQSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSQSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSQSWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this TunnelGroupAWSSQSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.TunnelGroupAWSSQSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TunnelGroupAWSSQSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TunnelGroupAWSSQSOptions;
        })();

        opts.TunnelGroupAWSSNSOptions = (function() {

            /**
             * Properties of a TunnelGroupAWSSNSOptions.
             * @memberof protos.opts
             * @interface ITunnelGroupAWSSNSOptions
             * @property {protos.args.IAWSSNSConn|null} [_conn] TunnelGroupAWSSNSOptions _conn
             * @property {protos.args.IAWSSNSWriteArgs|null} [args] TunnelGroupAWSSNSOptions args
             */

            /**
             * Constructs a new TunnelGroupAWSSNSOptions.
             * @memberof protos.opts
             * @classdesc Represents a TunnelGroupAWSSNSOptions.
             * @implements ITunnelGroupAWSSNSOptions
             * @constructor
             * @param {protos.opts.ITunnelGroupAWSSNSOptions=} [properties] Properties to set
             */
            function TunnelGroupAWSSNSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TunnelGroupAWSSNSOptions _conn.
             * @member {protos.args.IAWSSNSConn|null|undefined} _conn
             * @memberof protos.opts.TunnelGroupAWSSNSOptions
             * @instance
             */
            TunnelGroupAWSSNSOptions.prototype._conn = null;

            /**
             * TunnelGroupAWSSNSOptions args.
             * @member {protos.args.IAWSSNSWriteArgs|null|undefined} args
             * @memberof protos.opts.TunnelGroupAWSSNSOptions
             * @instance
             */
            TunnelGroupAWSSNSOptions.prototype.args = null;

            /**
             * Creates a new TunnelGroupAWSSNSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.TunnelGroupAWSSNSOptions
             * @static
             * @param {protos.opts.ITunnelGroupAWSSNSOptions=} [properties] Properties to set
             * @returns {protos.opts.TunnelGroupAWSSNSOptions} TunnelGroupAWSSNSOptions instance
             */
            TunnelGroupAWSSNSOptions.create = function create(properties) {
                return new TunnelGroupAWSSNSOptions(properties);
            };

            /**
             * Encodes the specified TunnelGroupAWSSNSOptions message. Does not implicitly {@link protos.opts.TunnelGroupAWSSNSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.TunnelGroupAWSSNSOptions
             * @static
             * @param {protos.opts.ITunnelGroupAWSSNSOptions} message TunnelGroupAWSSNSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupAWSSNSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSNSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSNSWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TunnelGroupAWSSNSOptions message, length delimited. Does not implicitly {@link protos.opts.TunnelGroupAWSSNSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.TunnelGroupAWSSNSOptions
             * @static
             * @param {protos.opts.ITunnelGroupAWSSNSOptions} message TunnelGroupAWSSNSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupAWSSNSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TunnelGroupAWSSNSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.TunnelGroupAWSSNSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.TunnelGroupAWSSNSOptions} TunnelGroupAWSSNSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupAWSSNSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.TunnelGroupAWSSNSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSNSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSNSWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TunnelGroupAWSSNSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.TunnelGroupAWSSNSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.TunnelGroupAWSSNSOptions} TunnelGroupAWSSNSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupAWSSNSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TunnelGroupAWSSNSOptions message.
             * @function verify
             * @memberof protos.opts.TunnelGroupAWSSNSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TunnelGroupAWSSNSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSSNSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSSNSWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a TunnelGroupAWSSNSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.TunnelGroupAWSSNSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.TunnelGroupAWSSNSOptions} TunnelGroupAWSSNSOptions
             */
            TunnelGroupAWSSNSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.TunnelGroupAWSSNSOptions)
                    return object;
                var message = new $root.protos.opts.TunnelGroupAWSSNSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.TunnelGroupAWSSNSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSNSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.TunnelGroupAWSSNSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSNSWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a TunnelGroupAWSSNSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.TunnelGroupAWSSNSOptions
             * @static
             * @param {protos.opts.TunnelGroupAWSSNSOptions} message TunnelGroupAWSSNSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TunnelGroupAWSSNSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSNSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSNSWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this TunnelGroupAWSSNSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.TunnelGroupAWSSNSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TunnelGroupAWSSNSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TunnelGroupAWSSNSOptions;
        })();

        opts.TunnelGroupNatsOptions = (function() {

            /**
             * Properties of a TunnelGroupNatsOptions.
             * @memberof protos.opts
             * @interface ITunnelGroupNatsOptions
             * @property {protos.args.INatsConn|null} [_conn] TunnelGroupNatsOptions _conn
             * @property {protos.args.INatsWriteArgs|null} [args] TunnelGroupNatsOptions args
             */

            /**
             * Constructs a new TunnelGroupNatsOptions.
             * @memberof protos.opts
             * @classdesc Represents a TunnelGroupNatsOptions.
             * @implements ITunnelGroupNatsOptions
             * @constructor
             * @param {protos.opts.ITunnelGroupNatsOptions=} [properties] Properties to set
             */
            function TunnelGroupNatsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TunnelGroupNatsOptions _conn.
             * @member {protos.args.INatsConn|null|undefined} _conn
             * @memberof protos.opts.TunnelGroupNatsOptions
             * @instance
             */
            TunnelGroupNatsOptions.prototype._conn = null;

            /**
             * TunnelGroupNatsOptions args.
             * @member {protos.args.INatsWriteArgs|null|undefined} args
             * @memberof protos.opts.TunnelGroupNatsOptions
             * @instance
             */
            TunnelGroupNatsOptions.prototype.args = null;

            /**
             * Creates a new TunnelGroupNatsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.TunnelGroupNatsOptions
             * @static
             * @param {protos.opts.ITunnelGroupNatsOptions=} [properties] Properties to set
             * @returns {protos.opts.TunnelGroupNatsOptions} TunnelGroupNatsOptions instance
             */
            TunnelGroupNatsOptions.create = function create(properties) {
                return new TunnelGroupNatsOptions(properties);
            };

            /**
             * Encodes the specified TunnelGroupNatsOptions message. Does not implicitly {@link protos.opts.TunnelGroupNatsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.TunnelGroupNatsOptions
             * @static
             * @param {protos.opts.ITunnelGroupNatsOptions} message TunnelGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupNatsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TunnelGroupNatsOptions message, length delimited. Does not implicitly {@link protos.opts.TunnelGroupNatsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.TunnelGroupNatsOptions
             * @static
             * @param {protos.opts.ITunnelGroupNatsOptions} message TunnelGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupNatsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TunnelGroupNatsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.TunnelGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.TunnelGroupNatsOptions} TunnelGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupNatsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.TunnelGroupNatsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TunnelGroupNatsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.TunnelGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.TunnelGroupNatsOptions} TunnelGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupNatsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TunnelGroupNatsOptions message.
             * @function verify
             * @memberof protos.opts.TunnelGroupNatsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TunnelGroupNatsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a TunnelGroupNatsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.TunnelGroupNatsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.TunnelGroupNatsOptions} TunnelGroupNatsOptions
             */
            TunnelGroupNatsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.TunnelGroupNatsOptions)
                    return object;
                var message = new $root.protos.opts.TunnelGroupNatsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.TunnelGroupNatsOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.TunnelGroupNatsOptions.args: object expected");
                    message.args = $root.protos.args.NatsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a TunnelGroupNatsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.TunnelGroupNatsOptions
             * @static
             * @param {protos.opts.TunnelGroupNatsOptions} message TunnelGroupNatsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TunnelGroupNatsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this TunnelGroupNatsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.TunnelGroupNatsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TunnelGroupNatsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TunnelGroupNatsOptions;
        })();

        opts.TunnelGroupNatsJetstreamOptions = (function() {

            /**
             * Properties of a TunnelGroupNatsJetstreamOptions.
             * @memberof protos.opts
             * @interface ITunnelGroupNatsJetstreamOptions
             * @property {protos.args.INatsJetstreamConn|null} [_conn] TunnelGroupNatsJetstreamOptions _conn
             * @property {protos.args.INatsJetstreamWriteArgs|null} [args] TunnelGroupNatsJetstreamOptions args
             */

            /**
             * Constructs a new TunnelGroupNatsJetstreamOptions.
             * @memberof protos.opts
             * @classdesc Represents a TunnelGroupNatsJetstreamOptions.
             * @implements ITunnelGroupNatsJetstreamOptions
             * @constructor
             * @param {protos.opts.ITunnelGroupNatsJetstreamOptions=} [properties] Properties to set
             */
            function TunnelGroupNatsJetstreamOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TunnelGroupNatsJetstreamOptions _conn.
             * @member {protos.args.INatsJetstreamConn|null|undefined} _conn
             * @memberof protos.opts.TunnelGroupNatsJetstreamOptions
             * @instance
             */
            TunnelGroupNatsJetstreamOptions.prototype._conn = null;

            /**
             * TunnelGroupNatsJetstreamOptions args.
             * @member {protos.args.INatsJetstreamWriteArgs|null|undefined} args
             * @memberof protos.opts.TunnelGroupNatsJetstreamOptions
             * @instance
             */
            TunnelGroupNatsJetstreamOptions.prototype.args = null;

            /**
             * Creates a new TunnelGroupNatsJetstreamOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.TunnelGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.ITunnelGroupNatsJetstreamOptions=} [properties] Properties to set
             * @returns {protos.opts.TunnelGroupNatsJetstreamOptions} TunnelGroupNatsJetstreamOptions instance
             */
            TunnelGroupNatsJetstreamOptions.create = function create(properties) {
                return new TunnelGroupNatsJetstreamOptions(properties);
            };

            /**
             * Encodes the specified TunnelGroupNatsJetstreamOptions message. Does not implicitly {@link protos.opts.TunnelGroupNatsJetstreamOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.TunnelGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.ITunnelGroupNatsJetstreamOptions} message TunnelGroupNatsJetstreamOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupNatsJetstreamOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsJetstreamConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsJetstreamWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TunnelGroupNatsJetstreamOptions message, length delimited. Does not implicitly {@link protos.opts.TunnelGroupNatsJetstreamOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.TunnelGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.ITunnelGroupNatsJetstreamOptions} message TunnelGroupNatsJetstreamOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupNatsJetstreamOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TunnelGroupNatsJetstreamOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.TunnelGroupNatsJetstreamOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.TunnelGroupNatsJetstreamOptions} TunnelGroupNatsJetstreamOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupNatsJetstreamOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.TunnelGroupNatsJetstreamOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsJetstreamConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsJetstreamWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TunnelGroupNatsJetstreamOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.TunnelGroupNatsJetstreamOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.TunnelGroupNatsJetstreamOptions} TunnelGroupNatsJetstreamOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupNatsJetstreamOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TunnelGroupNatsJetstreamOptions message.
             * @function verify
             * @memberof protos.opts.TunnelGroupNatsJetstreamOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TunnelGroupNatsJetstreamOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsJetstreamConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsJetstreamWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a TunnelGroupNatsJetstreamOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.TunnelGroupNatsJetstreamOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.TunnelGroupNatsJetstreamOptions} TunnelGroupNatsJetstreamOptions
             */
            TunnelGroupNatsJetstreamOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.TunnelGroupNatsJetstreamOptions)
                    return object;
                var message = new $root.protos.opts.TunnelGroupNatsJetstreamOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.TunnelGroupNatsJetstreamOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsJetstreamConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.TunnelGroupNatsJetstreamOptions.args: object expected");
                    message.args = $root.protos.args.NatsJetstreamWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a TunnelGroupNatsJetstreamOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.TunnelGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.TunnelGroupNatsJetstreamOptions} message TunnelGroupNatsJetstreamOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TunnelGroupNatsJetstreamOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsJetstreamConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsJetstreamWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this TunnelGroupNatsJetstreamOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.TunnelGroupNatsJetstreamOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TunnelGroupNatsJetstreamOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TunnelGroupNatsJetstreamOptions;
        })();

        opts.TunnelGroupNatsStreamingOptions = (function() {

            /**
             * Properties of a TunnelGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @interface ITunnelGroupNatsStreamingOptions
             * @property {protos.args.INatsStreamingConn|null} [_conn] TunnelGroupNatsStreamingOptions _conn
             * @property {protos.args.INatsStreamingWriteArgs|null} [args] TunnelGroupNatsStreamingOptions args
             */

            /**
             * Constructs a new TunnelGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @classdesc Represents a TunnelGroupNatsStreamingOptions.
             * @implements ITunnelGroupNatsStreamingOptions
             * @constructor
             * @param {protos.opts.ITunnelGroupNatsStreamingOptions=} [properties] Properties to set
             */
            function TunnelGroupNatsStreamingOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TunnelGroupNatsStreamingOptions _conn.
             * @member {protos.args.INatsStreamingConn|null|undefined} _conn
             * @memberof protos.opts.TunnelGroupNatsStreamingOptions
             * @instance
             */
            TunnelGroupNatsStreamingOptions.prototype._conn = null;

            /**
             * TunnelGroupNatsStreamingOptions args.
             * @member {protos.args.INatsStreamingWriteArgs|null|undefined} args
             * @memberof protos.opts.TunnelGroupNatsStreamingOptions
             * @instance
             */
            TunnelGroupNatsStreamingOptions.prototype.args = null;

            /**
             * Creates a new TunnelGroupNatsStreamingOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.TunnelGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.ITunnelGroupNatsStreamingOptions=} [properties] Properties to set
             * @returns {protos.opts.TunnelGroupNatsStreamingOptions} TunnelGroupNatsStreamingOptions instance
             */
            TunnelGroupNatsStreamingOptions.create = function create(properties) {
                return new TunnelGroupNatsStreamingOptions(properties);
            };

            /**
             * Encodes the specified TunnelGroupNatsStreamingOptions message. Does not implicitly {@link protos.opts.TunnelGroupNatsStreamingOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.TunnelGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.ITunnelGroupNatsStreamingOptions} message TunnelGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupNatsStreamingOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsStreamingConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsStreamingWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TunnelGroupNatsStreamingOptions message, length delimited. Does not implicitly {@link protos.opts.TunnelGroupNatsStreamingOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.TunnelGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.ITunnelGroupNatsStreamingOptions} message TunnelGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupNatsStreamingOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TunnelGroupNatsStreamingOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.TunnelGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.TunnelGroupNatsStreamingOptions} TunnelGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupNatsStreamingOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.TunnelGroupNatsStreamingOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsStreamingConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsStreamingWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TunnelGroupNatsStreamingOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.TunnelGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.TunnelGroupNatsStreamingOptions} TunnelGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupNatsStreamingOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TunnelGroupNatsStreamingOptions message.
             * @function verify
             * @memberof protos.opts.TunnelGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TunnelGroupNatsStreamingOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsStreamingConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsStreamingWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a TunnelGroupNatsStreamingOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.TunnelGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.TunnelGroupNatsStreamingOptions} TunnelGroupNatsStreamingOptions
             */
            TunnelGroupNatsStreamingOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.TunnelGroupNatsStreamingOptions)
                    return object;
                var message = new $root.protos.opts.TunnelGroupNatsStreamingOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.TunnelGroupNatsStreamingOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsStreamingConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.TunnelGroupNatsStreamingOptions.args: object expected");
                    message.args = $root.protos.args.NatsStreamingWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a TunnelGroupNatsStreamingOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.TunnelGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.TunnelGroupNatsStreamingOptions} message TunnelGroupNatsStreamingOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TunnelGroupNatsStreamingOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsStreamingConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsStreamingWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this TunnelGroupNatsStreamingOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.TunnelGroupNatsStreamingOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TunnelGroupNatsStreamingOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TunnelGroupNatsStreamingOptions;
        })();

        opts.TunnelGroupNSQOptions = (function() {

            /**
             * Properties of a TunnelGroupNSQOptions.
             * @memberof protos.opts
             * @interface ITunnelGroupNSQOptions
             * @property {protos.args.INSQConn|null} [_conn] TunnelGroupNSQOptions _conn
             * @property {protos.args.INSQWriteArgs|null} [args] TunnelGroupNSQOptions args
             */

            /**
             * Constructs a new TunnelGroupNSQOptions.
             * @memberof protos.opts
             * @classdesc Represents a TunnelGroupNSQOptions.
             * @implements ITunnelGroupNSQOptions
             * @constructor
             * @param {protos.opts.ITunnelGroupNSQOptions=} [properties] Properties to set
             */
            function TunnelGroupNSQOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TunnelGroupNSQOptions _conn.
             * @member {protos.args.INSQConn|null|undefined} _conn
             * @memberof protos.opts.TunnelGroupNSQOptions
             * @instance
             */
            TunnelGroupNSQOptions.prototype._conn = null;

            /**
             * TunnelGroupNSQOptions args.
             * @member {protos.args.INSQWriteArgs|null|undefined} args
             * @memberof protos.opts.TunnelGroupNSQOptions
             * @instance
             */
            TunnelGroupNSQOptions.prototype.args = null;

            /**
             * Creates a new TunnelGroupNSQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.TunnelGroupNSQOptions
             * @static
             * @param {protos.opts.ITunnelGroupNSQOptions=} [properties] Properties to set
             * @returns {protos.opts.TunnelGroupNSQOptions} TunnelGroupNSQOptions instance
             */
            TunnelGroupNSQOptions.create = function create(properties) {
                return new TunnelGroupNSQOptions(properties);
            };

            /**
             * Encodes the specified TunnelGroupNSQOptions message. Does not implicitly {@link protos.opts.TunnelGroupNSQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.TunnelGroupNSQOptions
             * @static
             * @param {protos.opts.ITunnelGroupNSQOptions} message TunnelGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupNSQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NSQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NSQWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TunnelGroupNSQOptions message, length delimited. Does not implicitly {@link protos.opts.TunnelGroupNSQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.TunnelGroupNSQOptions
             * @static
             * @param {protos.opts.ITunnelGroupNSQOptions} message TunnelGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupNSQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TunnelGroupNSQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.TunnelGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.TunnelGroupNSQOptions} TunnelGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupNSQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.TunnelGroupNSQOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NSQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NSQWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TunnelGroupNSQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.TunnelGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.TunnelGroupNSQOptions} TunnelGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupNSQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TunnelGroupNSQOptions message.
             * @function verify
             * @memberof protos.opts.TunnelGroupNSQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TunnelGroupNSQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NSQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NSQWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a TunnelGroupNSQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.TunnelGroupNSQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.TunnelGroupNSQOptions} TunnelGroupNSQOptions
             */
            TunnelGroupNSQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.TunnelGroupNSQOptions)
                    return object;
                var message = new $root.protos.opts.TunnelGroupNSQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.TunnelGroupNSQOptions._conn: object expected");
                    message._conn = $root.protos.args.NSQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.TunnelGroupNSQOptions.args: object expected");
                    message.args = $root.protos.args.NSQWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a TunnelGroupNSQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.TunnelGroupNSQOptions
             * @static
             * @param {protos.opts.TunnelGroupNSQOptions} message TunnelGroupNSQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TunnelGroupNSQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NSQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NSQWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this TunnelGroupNSQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.TunnelGroupNSQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TunnelGroupNSQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TunnelGroupNSQOptions;
        })();

        opts.TunnelGroupRabbitOptions = (function() {

            /**
             * Properties of a TunnelGroupRabbitOptions.
             * @memberof protos.opts
             * @interface ITunnelGroupRabbitOptions
             * @property {protos.args.IRabbitConn|null} [_conn] TunnelGroupRabbitOptions _conn
             * @property {protos.args.IRabbitWriteArgs|null} [args] TunnelGroupRabbitOptions args
             */

            /**
             * Constructs a new TunnelGroupRabbitOptions.
             * @memberof protos.opts
             * @classdesc Represents a TunnelGroupRabbitOptions.
             * @implements ITunnelGroupRabbitOptions
             * @constructor
             * @param {protos.opts.ITunnelGroupRabbitOptions=} [properties] Properties to set
             */
            function TunnelGroupRabbitOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TunnelGroupRabbitOptions _conn.
             * @member {protos.args.IRabbitConn|null|undefined} _conn
             * @memberof protos.opts.TunnelGroupRabbitOptions
             * @instance
             */
            TunnelGroupRabbitOptions.prototype._conn = null;

            /**
             * TunnelGroupRabbitOptions args.
             * @member {protos.args.IRabbitWriteArgs|null|undefined} args
             * @memberof protos.opts.TunnelGroupRabbitOptions
             * @instance
             */
            TunnelGroupRabbitOptions.prototype.args = null;

            /**
             * Creates a new TunnelGroupRabbitOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.TunnelGroupRabbitOptions
             * @static
             * @param {protos.opts.ITunnelGroupRabbitOptions=} [properties] Properties to set
             * @returns {protos.opts.TunnelGroupRabbitOptions} TunnelGroupRabbitOptions instance
             */
            TunnelGroupRabbitOptions.create = function create(properties) {
                return new TunnelGroupRabbitOptions(properties);
            };

            /**
             * Encodes the specified TunnelGroupRabbitOptions message. Does not implicitly {@link protos.opts.TunnelGroupRabbitOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.TunnelGroupRabbitOptions
             * @static
             * @param {protos.opts.ITunnelGroupRabbitOptions} message TunnelGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupRabbitOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TunnelGroupRabbitOptions message, length delimited. Does not implicitly {@link protos.opts.TunnelGroupRabbitOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.TunnelGroupRabbitOptions
             * @static
             * @param {protos.opts.ITunnelGroupRabbitOptions} message TunnelGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupRabbitOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TunnelGroupRabbitOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.TunnelGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.TunnelGroupRabbitOptions} TunnelGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupRabbitOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.TunnelGroupRabbitOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TunnelGroupRabbitOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.TunnelGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.TunnelGroupRabbitOptions} TunnelGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupRabbitOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TunnelGroupRabbitOptions message.
             * @function verify
             * @memberof protos.opts.TunnelGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TunnelGroupRabbitOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RabbitConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RabbitWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a TunnelGroupRabbitOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.TunnelGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.TunnelGroupRabbitOptions} TunnelGroupRabbitOptions
             */
            TunnelGroupRabbitOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.TunnelGroupRabbitOptions)
                    return object;
                var message = new $root.protos.opts.TunnelGroupRabbitOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.TunnelGroupRabbitOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.TunnelGroupRabbitOptions.args: object expected");
                    message.args = $root.protos.args.RabbitWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a TunnelGroupRabbitOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.TunnelGroupRabbitOptions
             * @static
             * @param {protos.opts.TunnelGroupRabbitOptions} message TunnelGroupRabbitOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TunnelGroupRabbitOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this TunnelGroupRabbitOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.TunnelGroupRabbitOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TunnelGroupRabbitOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TunnelGroupRabbitOptions;
        })();

        opts.TunnelGroupRabbitStreamsOptions = (function() {

            /**
             * Properties of a TunnelGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @interface ITunnelGroupRabbitStreamsOptions
             * @property {protos.args.IRabbitStreamsConn|null} [_conn] TunnelGroupRabbitStreamsOptions _conn
             * @property {protos.args.IRabbitStreamsWriteArgs|null} [args] TunnelGroupRabbitStreamsOptions args
             */

            /**
             * Constructs a new TunnelGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a TunnelGroupRabbitStreamsOptions.
             * @implements ITunnelGroupRabbitStreamsOptions
             * @constructor
             * @param {protos.opts.ITunnelGroupRabbitStreamsOptions=} [properties] Properties to set
             */
            function TunnelGroupRabbitStreamsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TunnelGroupRabbitStreamsOptions _conn.
             * @member {protos.args.IRabbitStreamsConn|null|undefined} _conn
             * @memberof protos.opts.TunnelGroupRabbitStreamsOptions
             * @instance
             */
            TunnelGroupRabbitStreamsOptions.prototype._conn = null;

            /**
             * TunnelGroupRabbitStreamsOptions args.
             * @member {protos.args.IRabbitStreamsWriteArgs|null|undefined} args
             * @memberof protos.opts.TunnelGroupRabbitStreamsOptions
             * @instance
             */
            TunnelGroupRabbitStreamsOptions.prototype.args = null;

            /**
             * Creates a new TunnelGroupRabbitStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.TunnelGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.ITunnelGroupRabbitStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.TunnelGroupRabbitStreamsOptions} TunnelGroupRabbitStreamsOptions instance
             */
            TunnelGroupRabbitStreamsOptions.create = function create(properties) {
                return new TunnelGroupRabbitStreamsOptions(properties);
            };

            /**
             * Encodes the specified TunnelGroupRabbitStreamsOptions message. Does not implicitly {@link protos.opts.TunnelGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.TunnelGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.ITunnelGroupRabbitStreamsOptions} message TunnelGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupRabbitStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitStreamsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TunnelGroupRabbitStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.TunnelGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.TunnelGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.ITunnelGroupRabbitStreamsOptions} message TunnelGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupRabbitStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TunnelGroupRabbitStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.TunnelGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.TunnelGroupRabbitStreamsOptions} TunnelGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupRabbitStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.TunnelGroupRabbitStreamsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitStreamsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TunnelGroupRabbitStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.TunnelGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.TunnelGroupRabbitStreamsOptions} TunnelGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupRabbitStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TunnelGroupRabbitStreamsOptions message.
             * @function verify
             * @memberof protos.opts.TunnelGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TunnelGroupRabbitStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RabbitStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RabbitStreamsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a TunnelGroupRabbitStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.TunnelGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.TunnelGroupRabbitStreamsOptions} TunnelGroupRabbitStreamsOptions
             */
            TunnelGroupRabbitStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.TunnelGroupRabbitStreamsOptions)
                    return object;
                var message = new $root.protos.opts.TunnelGroupRabbitStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.TunnelGroupRabbitStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.TunnelGroupRabbitStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RabbitStreamsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a TunnelGroupRabbitStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.TunnelGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.TunnelGroupRabbitStreamsOptions} message TunnelGroupRabbitStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TunnelGroupRabbitStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitStreamsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this TunnelGroupRabbitStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.TunnelGroupRabbitStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TunnelGroupRabbitStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TunnelGroupRabbitStreamsOptions;
        })();

        opts.TunnelGroupRedisPubSubOptions = (function() {

            /**
             * Properties of a TunnelGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @interface ITunnelGroupRedisPubSubOptions
             * @property {protos.args.IRedisPubSubConn|null} [_conn] TunnelGroupRedisPubSubOptions _conn
             * @property {protos.args.IRedisPubSubWriteArgs|null} [args] TunnelGroupRedisPubSubOptions args
             */

            /**
             * Constructs a new TunnelGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a TunnelGroupRedisPubSubOptions.
             * @implements ITunnelGroupRedisPubSubOptions
             * @constructor
             * @param {protos.opts.ITunnelGroupRedisPubSubOptions=} [properties] Properties to set
             */
            function TunnelGroupRedisPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TunnelGroupRedisPubSubOptions _conn.
             * @member {protos.args.IRedisPubSubConn|null|undefined} _conn
             * @memberof protos.opts.TunnelGroupRedisPubSubOptions
             * @instance
             */
            TunnelGroupRedisPubSubOptions.prototype._conn = null;

            /**
             * TunnelGroupRedisPubSubOptions args.
             * @member {protos.args.IRedisPubSubWriteArgs|null|undefined} args
             * @memberof protos.opts.TunnelGroupRedisPubSubOptions
             * @instance
             */
            TunnelGroupRedisPubSubOptions.prototype.args = null;

            /**
             * Creates a new TunnelGroupRedisPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.TunnelGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.ITunnelGroupRedisPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.TunnelGroupRedisPubSubOptions} TunnelGroupRedisPubSubOptions instance
             */
            TunnelGroupRedisPubSubOptions.create = function create(properties) {
                return new TunnelGroupRedisPubSubOptions(properties);
            };

            /**
             * Encodes the specified TunnelGroupRedisPubSubOptions message. Does not implicitly {@link protos.opts.TunnelGroupRedisPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.TunnelGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.ITunnelGroupRedisPubSubOptions} message TunnelGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupRedisPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisPubSubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TunnelGroupRedisPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.TunnelGroupRedisPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.TunnelGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.ITunnelGroupRedisPubSubOptions} message TunnelGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupRedisPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TunnelGroupRedisPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.TunnelGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.TunnelGroupRedisPubSubOptions} TunnelGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupRedisPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.TunnelGroupRedisPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisPubSubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TunnelGroupRedisPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.TunnelGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.TunnelGroupRedisPubSubOptions} TunnelGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupRedisPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TunnelGroupRedisPubSubOptions message.
             * @function verify
             * @memberof protos.opts.TunnelGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TunnelGroupRedisPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisPubSubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a TunnelGroupRedisPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.TunnelGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.TunnelGroupRedisPubSubOptions} TunnelGroupRedisPubSubOptions
             */
            TunnelGroupRedisPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.TunnelGroupRedisPubSubOptions)
                    return object;
                var message = new $root.protos.opts.TunnelGroupRedisPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.TunnelGroupRedisPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.TunnelGroupRedisPubSubOptions.args: object expected");
                    message.args = $root.protos.args.RedisPubSubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a TunnelGroupRedisPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.TunnelGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.TunnelGroupRedisPubSubOptions} message TunnelGroupRedisPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TunnelGroupRedisPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisPubSubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this TunnelGroupRedisPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.TunnelGroupRedisPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TunnelGroupRedisPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TunnelGroupRedisPubSubOptions;
        })();

        opts.TunnelGroupRedisStreamsOptions = (function() {

            /**
             * Properties of a TunnelGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @interface ITunnelGroupRedisStreamsOptions
             * @property {protos.args.IRedisStreamsConn|null} [_conn] TunnelGroupRedisStreamsOptions _conn
             * @property {protos.args.IRedisStreamsWriteArgs|null} [args] TunnelGroupRedisStreamsOptions args
             */

            /**
             * Constructs a new TunnelGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a TunnelGroupRedisStreamsOptions.
             * @implements ITunnelGroupRedisStreamsOptions
             * @constructor
             * @param {protos.opts.ITunnelGroupRedisStreamsOptions=} [properties] Properties to set
             */
            function TunnelGroupRedisStreamsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TunnelGroupRedisStreamsOptions _conn.
             * @member {protos.args.IRedisStreamsConn|null|undefined} _conn
             * @memberof protos.opts.TunnelGroupRedisStreamsOptions
             * @instance
             */
            TunnelGroupRedisStreamsOptions.prototype._conn = null;

            /**
             * TunnelGroupRedisStreamsOptions args.
             * @member {protos.args.IRedisStreamsWriteArgs|null|undefined} args
             * @memberof protos.opts.TunnelGroupRedisStreamsOptions
             * @instance
             */
            TunnelGroupRedisStreamsOptions.prototype.args = null;

            /**
             * Creates a new TunnelGroupRedisStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.TunnelGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.ITunnelGroupRedisStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.TunnelGroupRedisStreamsOptions} TunnelGroupRedisStreamsOptions instance
             */
            TunnelGroupRedisStreamsOptions.create = function create(properties) {
                return new TunnelGroupRedisStreamsOptions(properties);
            };

            /**
             * Encodes the specified TunnelGroupRedisStreamsOptions message. Does not implicitly {@link protos.opts.TunnelGroupRedisStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.TunnelGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.ITunnelGroupRedisStreamsOptions} message TunnelGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupRedisStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisStreamsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TunnelGroupRedisStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.TunnelGroupRedisStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.TunnelGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.ITunnelGroupRedisStreamsOptions} message TunnelGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupRedisStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TunnelGroupRedisStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.TunnelGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.TunnelGroupRedisStreamsOptions} TunnelGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupRedisStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.TunnelGroupRedisStreamsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisStreamsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TunnelGroupRedisStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.TunnelGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.TunnelGroupRedisStreamsOptions} TunnelGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupRedisStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TunnelGroupRedisStreamsOptions message.
             * @function verify
             * @memberof protos.opts.TunnelGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TunnelGroupRedisStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisStreamsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a TunnelGroupRedisStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.TunnelGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.TunnelGroupRedisStreamsOptions} TunnelGroupRedisStreamsOptions
             */
            TunnelGroupRedisStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.TunnelGroupRedisStreamsOptions)
                    return object;
                var message = new $root.protos.opts.TunnelGroupRedisStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.TunnelGroupRedisStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.TunnelGroupRedisStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RedisStreamsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a TunnelGroupRedisStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.TunnelGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.TunnelGroupRedisStreamsOptions} message TunnelGroupRedisStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TunnelGroupRedisStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisStreamsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this TunnelGroupRedisStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.TunnelGroupRedisStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TunnelGroupRedisStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TunnelGroupRedisStreamsOptions;
        })();

        opts.TunnelGroupAzureEventHubOptions = (function() {

            /**
             * Properties of a TunnelGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @interface ITunnelGroupAzureEventHubOptions
             * @property {protos.args.IAzureEventHubConn|null} [_conn] TunnelGroupAzureEventHubOptions _conn
             * @property {protos.args.IAzureEventHubWriteArgs|null} [args] TunnelGroupAzureEventHubOptions args
             */

            /**
             * Constructs a new TunnelGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @classdesc Represents a TunnelGroupAzureEventHubOptions.
             * @implements ITunnelGroupAzureEventHubOptions
             * @constructor
             * @param {protos.opts.ITunnelGroupAzureEventHubOptions=} [properties] Properties to set
             */
            function TunnelGroupAzureEventHubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TunnelGroupAzureEventHubOptions _conn.
             * @member {protos.args.IAzureEventHubConn|null|undefined} _conn
             * @memberof protos.opts.TunnelGroupAzureEventHubOptions
             * @instance
             */
            TunnelGroupAzureEventHubOptions.prototype._conn = null;

            /**
             * TunnelGroupAzureEventHubOptions args.
             * @member {protos.args.IAzureEventHubWriteArgs|null|undefined} args
             * @memberof protos.opts.TunnelGroupAzureEventHubOptions
             * @instance
             */
            TunnelGroupAzureEventHubOptions.prototype.args = null;

            /**
             * Creates a new TunnelGroupAzureEventHubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.TunnelGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.ITunnelGroupAzureEventHubOptions=} [properties] Properties to set
             * @returns {protos.opts.TunnelGroupAzureEventHubOptions} TunnelGroupAzureEventHubOptions instance
             */
            TunnelGroupAzureEventHubOptions.create = function create(properties) {
                return new TunnelGroupAzureEventHubOptions(properties);
            };

            /**
             * Encodes the specified TunnelGroupAzureEventHubOptions message. Does not implicitly {@link protos.opts.TunnelGroupAzureEventHubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.TunnelGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.ITunnelGroupAzureEventHubOptions} message TunnelGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupAzureEventHubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureEventHubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureEventHubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TunnelGroupAzureEventHubOptions message, length delimited. Does not implicitly {@link protos.opts.TunnelGroupAzureEventHubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.TunnelGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.ITunnelGroupAzureEventHubOptions} message TunnelGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupAzureEventHubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TunnelGroupAzureEventHubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.TunnelGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.TunnelGroupAzureEventHubOptions} TunnelGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupAzureEventHubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.TunnelGroupAzureEventHubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureEventHubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureEventHubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TunnelGroupAzureEventHubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.TunnelGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.TunnelGroupAzureEventHubOptions} TunnelGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupAzureEventHubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TunnelGroupAzureEventHubOptions message.
             * @function verify
             * @memberof protos.opts.TunnelGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TunnelGroupAzureEventHubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AzureEventHubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AzureEventHubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a TunnelGroupAzureEventHubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.TunnelGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.TunnelGroupAzureEventHubOptions} TunnelGroupAzureEventHubOptions
             */
            TunnelGroupAzureEventHubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.TunnelGroupAzureEventHubOptions)
                    return object;
                var message = new $root.protos.opts.TunnelGroupAzureEventHubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.TunnelGroupAzureEventHubOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureEventHubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.TunnelGroupAzureEventHubOptions.args: object expected");
                    message.args = $root.protos.args.AzureEventHubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a TunnelGroupAzureEventHubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.TunnelGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.TunnelGroupAzureEventHubOptions} message TunnelGroupAzureEventHubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TunnelGroupAzureEventHubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureEventHubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureEventHubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this TunnelGroupAzureEventHubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.TunnelGroupAzureEventHubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TunnelGroupAzureEventHubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TunnelGroupAzureEventHubOptions;
        })();

        opts.TunnelGroupAzureServiceBusOptions = (function() {

            /**
             * Properties of a TunnelGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @interface ITunnelGroupAzureServiceBusOptions
             * @property {protos.args.IAzureServiceBusConn|null} [_conn] TunnelGroupAzureServiceBusOptions _conn
             * @property {protos.args.IAzureServiceBusWriteArgs|null} [args] TunnelGroupAzureServiceBusOptions args
             */

            /**
             * Constructs a new TunnelGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @classdesc Represents a TunnelGroupAzureServiceBusOptions.
             * @implements ITunnelGroupAzureServiceBusOptions
             * @constructor
             * @param {protos.opts.ITunnelGroupAzureServiceBusOptions=} [properties] Properties to set
             */
            function TunnelGroupAzureServiceBusOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TunnelGroupAzureServiceBusOptions _conn.
             * @member {protos.args.IAzureServiceBusConn|null|undefined} _conn
             * @memberof protos.opts.TunnelGroupAzureServiceBusOptions
             * @instance
             */
            TunnelGroupAzureServiceBusOptions.prototype._conn = null;

            /**
             * TunnelGroupAzureServiceBusOptions args.
             * @member {protos.args.IAzureServiceBusWriteArgs|null|undefined} args
             * @memberof protos.opts.TunnelGroupAzureServiceBusOptions
             * @instance
             */
            TunnelGroupAzureServiceBusOptions.prototype.args = null;

            /**
             * Creates a new TunnelGroupAzureServiceBusOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.TunnelGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.ITunnelGroupAzureServiceBusOptions=} [properties] Properties to set
             * @returns {protos.opts.TunnelGroupAzureServiceBusOptions} TunnelGroupAzureServiceBusOptions instance
             */
            TunnelGroupAzureServiceBusOptions.create = function create(properties) {
                return new TunnelGroupAzureServiceBusOptions(properties);
            };

            /**
             * Encodes the specified TunnelGroupAzureServiceBusOptions message. Does not implicitly {@link protos.opts.TunnelGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.TunnelGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.ITunnelGroupAzureServiceBusOptions} message TunnelGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupAzureServiceBusOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureServiceBusConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureServiceBusWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TunnelGroupAzureServiceBusOptions message, length delimited. Does not implicitly {@link protos.opts.TunnelGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.TunnelGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.ITunnelGroupAzureServiceBusOptions} message TunnelGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupAzureServiceBusOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TunnelGroupAzureServiceBusOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.TunnelGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.TunnelGroupAzureServiceBusOptions} TunnelGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupAzureServiceBusOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.TunnelGroupAzureServiceBusOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureServiceBusConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureServiceBusWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TunnelGroupAzureServiceBusOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.TunnelGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.TunnelGroupAzureServiceBusOptions} TunnelGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupAzureServiceBusOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TunnelGroupAzureServiceBusOptions message.
             * @function verify
             * @memberof protos.opts.TunnelGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TunnelGroupAzureServiceBusOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AzureServiceBusConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AzureServiceBusWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a TunnelGroupAzureServiceBusOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.TunnelGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.TunnelGroupAzureServiceBusOptions} TunnelGroupAzureServiceBusOptions
             */
            TunnelGroupAzureServiceBusOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.TunnelGroupAzureServiceBusOptions)
                    return object;
                var message = new $root.protos.opts.TunnelGroupAzureServiceBusOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.TunnelGroupAzureServiceBusOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureServiceBusConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.TunnelGroupAzureServiceBusOptions.args: object expected");
                    message.args = $root.protos.args.AzureServiceBusWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a TunnelGroupAzureServiceBusOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.TunnelGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.TunnelGroupAzureServiceBusOptions} message TunnelGroupAzureServiceBusOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TunnelGroupAzureServiceBusOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureServiceBusConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureServiceBusWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this TunnelGroupAzureServiceBusOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.TunnelGroupAzureServiceBusOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TunnelGroupAzureServiceBusOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TunnelGroupAzureServiceBusOptions;
        })();

        opts.TunnelGroupMQTTOptions = (function() {

            /**
             * Properties of a TunnelGroupMQTTOptions.
             * @memberof protos.opts
             * @interface ITunnelGroupMQTTOptions
             * @property {protos.args.IMQTTConn|null} [_conn] TunnelGroupMQTTOptions _conn
             * @property {protos.args.IMQTTWriteArgs|null} [args] TunnelGroupMQTTOptions args
             */

            /**
             * Constructs a new TunnelGroupMQTTOptions.
             * @memberof protos.opts
             * @classdesc Represents a TunnelGroupMQTTOptions.
             * @implements ITunnelGroupMQTTOptions
             * @constructor
             * @param {protos.opts.ITunnelGroupMQTTOptions=} [properties] Properties to set
             */
            function TunnelGroupMQTTOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TunnelGroupMQTTOptions _conn.
             * @member {protos.args.IMQTTConn|null|undefined} _conn
             * @memberof protos.opts.TunnelGroupMQTTOptions
             * @instance
             */
            TunnelGroupMQTTOptions.prototype._conn = null;

            /**
             * TunnelGroupMQTTOptions args.
             * @member {protos.args.IMQTTWriteArgs|null|undefined} args
             * @memberof protos.opts.TunnelGroupMQTTOptions
             * @instance
             */
            TunnelGroupMQTTOptions.prototype.args = null;

            /**
             * Creates a new TunnelGroupMQTTOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.TunnelGroupMQTTOptions
             * @static
             * @param {protos.opts.ITunnelGroupMQTTOptions=} [properties] Properties to set
             * @returns {protos.opts.TunnelGroupMQTTOptions} TunnelGroupMQTTOptions instance
             */
            TunnelGroupMQTTOptions.create = function create(properties) {
                return new TunnelGroupMQTTOptions(properties);
            };

            /**
             * Encodes the specified TunnelGroupMQTTOptions message. Does not implicitly {@link protos.opts.TunnelGroupMQTTOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.TunnelGroupMQTTOptions
             * @static
             * @param {protos.opts.ITunnelGroupMQTTOptions} message TunnelGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupMQTTOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MQTTConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MQTTWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TunnelGroupMQTTOptions message, length delimited. Does not implicitly {@link protos.opts.TunnelGroupMQTTOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.TunnelGroupMQTTOptions
             * @static
             * @param {protos.opts.ITunnelGroupMQTTOptions} message TunnelGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupMQTTOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TunnelGroupMQTTOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.TunnelGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.TunnelGroupMQTTOptions} TunnelGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupMQTTOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.TunnelGroupMQTTOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MQTTConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MQTTWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TunnelGroupMQTTOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.TunnelGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.TunnelGroupMQTTOptions} TunnelGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupMQTTOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TunnelGroupMQTTOptions message.
             * @function verify
             * @memberof protos.opts.TunnelGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TunnelGroupMQTTOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.MQTTConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.MQTTWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a TunnelGroupMQTTOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.TunnelGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.TunnelGroupMQTTOptions} TunnelGroupMQTTOptions
             */
            TunnelGroupMQTTOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.TunnelGroupMQTTOptions)
                    return object;
                var message = new $root.protos.opts.TunnelGroupMQTTOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.TunnelGroupMQTTOptions._conn: object expected");
                    message._conn = $root.protos.args.MQTTConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.TunnelGroupMQTTOptions.args: object expected");
                    message.args = $root.protos.args.MQTTWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a TunnelGroupMQTTOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.TunnelGroupMQTTOptions
             * @static
             * @param {protos.opts.TunnelGroupMQTTOptions} message TunnelGroupMQTTOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TunnelGroupMQTTOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MQTTConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MQTTWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this TunnelGroupMQTTOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.TunnelGroupMQTTOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TunnelGroupMQTTOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TunnelGroupMQTTOptions;
        })();

        opts.TunnelGroupGCPPubSubOptions = (function() {

            /**
             * Properties of a TunnelGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @interface ITunnelGroupGCPPubSubOptions
             * @property {protos.args.IGCPPubSubConn|null} [_conn] TunnelGroupGCPPubSubOptions _conn
             * @property {protos.args.IGCPPubSubWriteArgs|null} [args] TunnelGroupGCPPubSubOptions args
             */

            /**
             * Constructs a new TunnelGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a TunnelGroupGCPPubSubOptions.
             * @implements ITunnelGroupGCPPubSubOptions
             * @constructor
             * @param {protos.opts.ITunnelGroupGCPPubSubOptions=} [properties] Properties to set
             */
            function TunnelGroupGCPPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TunnelGroupGCPPubSubOptions _conn.
             * @member {protos.args.IGCPPubSubConn|null|undefined} _conn
             * @memberof protos.opts.TunnelGroupGCPPubSubOptions
             * @instance
             */
            TunnelGroupGCPPubSubOptions.prototype._conn = null;

            /**
             * TunnelGroupGCPPubSubOptions args.
             * @member {protos.args.IGCPPubSubWriteArgs|null|undefined} args
             * @memberof protos.opts.TunnelGroupGCPPubSubOptions
             * @instance
             */
            TunnelGroupGCPPubSubOptions.prototype.args = null;

            /**
             * Creates a new TunnelGroupGCPPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.TunnelGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.ITunnelGroupGCPPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.TunnelGroupGCPPubSubOptions} TunnelGroupGCPPubSubOptions instance
             */
            TunnelGroupGCPPubSubOptions.create = function create(properties) {
                return new TunnelGroupGCPPubSubOptions(properties);
            };

            /**
             * Encodes the specified TunnelGroupGCPPubSubOptions message. Does not implicitly {@link protos.opts.TunnelGroupGCPPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.TunnelGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.ITunnelGroupGCPPubSubOptions} message TunnelGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupGCPPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.GCPPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.GCPPubSubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TunnelGroupGCPPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.TunnelGroupGCPPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.TunnelGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.ITunnelGroupGCPPubSubOptions} message TunnelGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupGCPPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TunnelGroupGCPPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.TunnelGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.TunnelGroupGCPPubSubOptions} TunnelGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupGCPPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.TunnelGroupGCPPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.GCPPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.GCPPubSubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TunnelGroupGCPPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.TunnelGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.TunnelGroupGCPPubSubOptions} TunnelGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupGCPPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TunnelGroupGCPPubSubOptions message.
             * @function verify
             * @memberof protos.opts.TunnelGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TunnelGroupGCPPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.GCPPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.GCPPubSubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a TunnelGroupGCPPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.TunnelGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.TunnelGroupGCPPubSubOptions} TunnelGroupGCPPubSubOptions
             */
            TunnelGroupGCPPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.TunnelGroupGCPPubSubOptions)
                    return object;
                var message = new $root.protos.opts.TunnelGroupGCPPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.TunnelGroupGCPPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.GCPPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.TunnelGroupGCPPubSubOptions.args: object expected");
                    message.args = $root.protos.args.GCPPubSubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a TunnelGroupGCPPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.TunnelGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.TunnelGroupGCPPubSubOptions} message TunnelGroupGCPPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TunnelGroupGCPPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.GCPPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.GCPPubSubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this TunnelGroupGCPPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.TunnelGroupGCPPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TunnelGroupGCPPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TunnelGroupGCPPubSubOptions;
        })();

        opts.TunnelGroupKubeMQQueueOptions = (function() {

            /**
             * Properties of a TunnelGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @interface ITunnelGroupKubeMQQueueOptions
             * @property {protos.args.IKubeMQQueueConn|null} [_conn] TunnelGroupKubeMQQueueOptions _conn
             * @property {protos.args.IKubeMQQueueWriteArgs|null} [args] TunnelGroupKubeMQQueueOptions args
             */

            /**
             * Constructs a new TunnelGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @classdesc Represents a TunnelGroupKubeMQQueueOptions.
             * @implements ITunnelGroupKubeMQQueueOptions
             * @constructor
             * @param {protos.opts.ITunnelGroupKubeMQQueueOptions=} [properties] Properties to set
             */
            function TunnelGroupKubeMQQueueOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TunnelGroupKubeMQQueueOptions _conn.
             * @member {protos.args.IKubeMQQueueConn|null|undefined} _conn
             * @memberof protos.opts.TunnelGroupKubeMQQueueOptions
             * @instance
             */
            TunnelGroupKubeMQQueueOptions.prototype._conn = null;

            /**
             * TunnelGroupKubeMQQueueOptions args.
             * @member {protos.args.IKubeMQQueueWriteArgs|null|undefined} args
             * @memberof protos.opts.TunnelGroupKubeMQQueueOptions
             * @instance
             */
            TunnelGroupKubeMQQueueOptions.prototype.args = null;

            /**
             * Creates a new TunnelGroupKubeMQQueueOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.TunnelGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.ITunnelGroupKubeMQQueueOptions=} [properties] Properties to set
             * @returns {protos.opts.TunnelGroupKubeMQQueueOptions} TunnelGroupKubeMQQueueOptions instance
             */
            TunnelGroupKubeMQQueueOptions.create = function create(properties) {
                return new TunnelGroupKubeMQQueueOptions(properties);
            };

            /**
             * Encodes the specified TunnelGroupKubeMQQueueOptions message. Does not implicitly {@link protos.opts.TunnelGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.TunnelGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.ITunnelGroupKubeMQQueueOptions} message TunnelGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupKubeMQQueueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KubeMQQueueConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KubeMQQueueWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TunnelGroupKubeMQQueueOptions message, length delimited. Does not implicitly {@link protos.opts.TunnelGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.TunnelGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.ITunnelGroupKubeMQQueueOptions} message TunnelGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupKubeMQQueueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TunnelGroupKubeMQQueueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.TunnelGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.TunnelGroupKubeMQQueueOptions} TunnelGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupKubeMQQueueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.TunnelGroupKubeMQQueueOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KubeMQQueueConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KubeMQQueueWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TunnelGroupKubeMQQueueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.TunnelGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.TunnelGroupKubeMQQueueOptions} TunnelGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupKubeMQQueueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TunnelGroupKubeMQQueueOptions message.
             * @function verify
             * @memberof protos.opts.TunnelGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TunnelGroupKubeMQQueueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KubeMQQueueConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KubeMQQueueWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a TunnelGroupKubeMQQueueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.TunnelGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.TunnelGroupKubeMQQueueOptions} TunnelGroupKubeMQQueueOptions
             */
            TunnelGroupKubeMQQueueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.TunnelGroupKubeMQQueueOptions)
                    return object;
                var message = new $root.protos.opts.TunnelGroupKubeMQQueueOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.TunnelGroupKubeMQQueueOptions._conn: object expected");
                    message._conn = $root.protos.args.KubeMQQueueConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.TunnelGroupKubeMQQueueOptions.args: object expected");
                    message.args = $root.protos.args.KubeMQQueueWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a TunnelGroupKubeMQQueueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.TunnelGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.TunnelGroupKubeMQQueueOptions} message TunnelGroupKubeMQQueueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TunnelGroupKubeMQQueueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KubeMQQueueConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KubeMQQueueWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this TunnelGroupKubeMQQueueOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.TunnelGroupKubeMQQueueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TunnelGroupKubeMQQueueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TunnelGroupKubeMQQueueOptions;
        })();

        opts.TunnelGroupPulsarOptions = (function() {

            /**
             * Properties of a TunnelGroupPulsarOptions.
             * @memberof protos.opts
             * @interface ITunnelGroupPulsarOptions
             * @property {protos.args.IPulsarConn|null} [_conn] TunnelGroupPulsarOptions _conn
             * @property {protos.args.IPulsarWriteArgs|null} [args] TunnelGroupPulsarOptions args
             */

            /**
             * Constructs a new TunnelGroupPulsarOptions.
             * @memberof protos.opts
             * @classdesc Represents a TunnelGroupPulsarOptions.
             * @implements ITunnelGroupPulsarOptions
             * @constructor
             * @param {protos.opts.ITunnelGroupPulsarOptions=} [properties] Properties to set
             */
            function TunnelGroupPulsarOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TunnelGroupPulsarOptions _conn.
             * @member {protos.args.IPulsarConn|null|undefined} _conn
             * @memberof protos.opts.TunnelGroupPulsarOptions
             * @instance
             */
            TunnelGroupPulsarOptions.prototype._conn = null;

            /**
             * TunnelGroupPulsarOptions args.
             * @member {protos.args.IPulsarWriteArgs|null|undefined} args
             * @memberof protos.opts.TunnelGroupPulsarOptions
             * @instance
             */
            TunnelGroupPulsarOptions.prototype.args = null;

            /**
             * Creates a new TunnelGroupPulsarOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.TunnelGroupPulsarOptions
             * @static
             * @param {protos.opts.ITunnelGroupPulsarOptions=} [properties] Properties to set
             * @returns {protos.opts.TunnelGroupPulsarOptions} TunnelGroupPulsarOptions instance
             */
            TunnelGroupPulsarOptions.create = function create(properties) {
                return new TunnelGroupPulsarOptions(properties);
            };

            /**
             * Encodes the specified TunnelGroupPulsarOptions message. Does not implicitly {@link protos.opts.TunnelGroupPulsarOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.TunnelGroupPulsarOptions
             * @static
             * @param {protos.opts.ITunnelGroupPulsarOptions} message TunnelGroupPulsarOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupPulsarOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.PulsarConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.PulsarWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TunnelGroupPulsarOptions message, length delimited. Does not implicitly {@link protos.opts.TunnelGroupPulsarOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.TunnelGroupPulsarOptions
             * @static
             * @param {protos.opts.ITunnelGroupPulsarOptions} message TunnelGroupPulsarOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupPulsarOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TunnelGroupPulsarOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.TunnelGroupPulsarOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.TunnelGroupPulsarOptions} TunnelGroupPulsarOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupPulsarOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.TunnelGroupPulsarOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.PulsarConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.PulsarWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TunnelGroupPulsarOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.TunnelGroupPulsarOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.TunnelGroupPulsarOptions} TunnelGroupPulsarOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupPulsarOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TunnelGroupPulsarOptions message.
             * @function verify
             * @memberof protos.opts.TunnelGroupPulsarOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TunnelGroupPulsarOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.PulsarConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.PulsarWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a TunnelGroupPulsarOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.TunnelGroupPulsarOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.TunnelGroupPulsarOptions} TunnelGroupPulsarOptions
             */
            TunnelGroupPulsarOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.TunnelGroupPulsarOptions)
                    return object;
                var message = new $root.protos.opts.TunnelGroupPulsarOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.TunnelGroupPulsarOptions._conn: object expected");
                    message._conn = $root.protos.args.PulsarConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.TunnelGroupPulsarOptions.args: object expected");
                    message.args = $root.protos.args.PulsarWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a TunnelGroupPulsarOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.TunnelGroupPulsarOptions
             * @static
             * @param {protos.opts.TunnelGroupPulsarOptions} message TunnelGroupPulsarOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TunnelGroupPulsarOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.PulsarConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.PulsarWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this TunnelGroupPulsarOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.TunnelGroupPulsarOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TunnelGroupPulsarOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TunnelGroupPulsarOptions;
        })();

        opts.TunnelGroupAWSKinesisOptions = (function() {

            /**
             * Properties of a TunnelGroupAWSKinesisOptions.
             * @memberof protos.opts
             * @interface ITunnelGroupAWSKinesisOptions
             * @property {protos.args.IAWSKinesisConn|null} [_conn] TunnelGroupAWSKinesisOptions _conn
             * @property {protos.args.IAWSKinesisWriteArgs|null} [args] TunnelGroupAWSKinesisOptions args
             */

            /**
             * Constructs a new TunnelGroupAWSKinesisOptions.
             * @memberof protos.opts
             * @classdesc Represents a TunnelGroupAWSKinesisOptions.
             * @implements ITunnelGroupAWSKinesisOptions
             * @constructor
             * @param {protos.opts.ITunnelGroupAWSKinesisOptions=} [properties] Properties to set
             */
            function TunnelGroupAWSKinesisOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TunnelGroupAWSKinesisOptions _conn.
             * @member {protos.args.IAWSKinesisConn|null|undefined} _conn
             * @memberof protos.opts.TunnelGroupAWSKinesisOptions
             * @instance
             */
            TunnelGroupAWSKinesisOptions.prototype._conn = null;

            /**
             * TunnelGroupAWSKinesisOptions args.
             * @member {protos.args.IAWSKinesisWriteArgs|null|undefined} args
             * @memberof protos.opts.TunnelGroupAWSKinesisOptions
             * @instance
             */
            TunnelGroupAWSKinesisOptions.prototype.args = null;

            /**
             * Creates a new TunnelGroupAWSKinesisOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.TunnelGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.ITunnelGroupAWSKinesisOptions=} [properties] Properties to set
             * @returns {protos.opts.TunnelGroupAWSKinesisOptions} TunnelGroupAWSKinesisOptions instance
             */
            TunnelGroupAWSKinesisOptions.create = function create(properties) {
                return new TunnelGroupAWSKinesisOptions(properties);
            };

            /**
             * Encodes the specified TunnelGroupAWSKinesisOptions message. Does not implicitly {@link protos.opts.TunnelGroupAWSKinesisOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.TunnelGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.ITunnelGroupAWSKinesisOptions} message TunnelGroupAWSKinesisOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupAWSKinesisOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSKinesisConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSKinesisWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TunnelGroupAWSKinesisOptions message, length delimited. Does not implicitly {@link protos.opts.TunnelGroupAWSKinesisOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.TunnelGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.ITunnelGroupAWSKinesisOptions} message TunnelGroupAWSKinesisOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupAWSKinesisOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TunnelGroupAWSKinesisOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.TunnelGroupAWSKinesisOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.TunnelGroupAWSKinesisOptions} TunnelGroupAWSKinesisOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupAWSKinesisOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.TunnelGroupAWSKinesisOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSKinesisConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSKinesisWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TunnelGroupAWSKinesisOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.TunnelGroupAWSKinesisOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.TunnelGroupAWSKinesisOptions} TunnelGroupAWSKinesisOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupAWSKinesisOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TunnelGroupAWSKinesisOptions message.
             * @function verify
             * @memberof protos.opts.TunnelGroupAWSKinesisOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TunnelGroupAWSKinesisOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSKinesisConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSKinesisWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a TunnelGroupAWSKinesisOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.TunnelGroupAWSKinesisOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.TunnelGroupAWSKinesisOptions} TunnelGroupAWSKinesisOptions
             */
            TunnelGroupAWSKinesisOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.TunnelGroupAWSKinesisOptions)
                    return object;
                var message = new $root.protos.opts.TunnelGroupAWSKinesisOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.TunnelGroupAWSKinesisOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSKinesisConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.TunnelGroupAWSKinesisOptions.args: object expected");
                    message.args = $root.protos.args.AWSKinesisWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a TunnelGroupAWSKinesisOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.TunnelGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.TunnelGroupAWSKinesisOptions} message TunnelGroupAWSKinesisOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TunnelGroupAWSKinesisOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSKinesisConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSKinesisWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this TunnelGroupAWSKinesisOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.TunnelGroupAWSKinesisOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TunnelGroupAWSKinesisOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TunnelGroupAWSKinesisOptions;
        })();

        opts.TunnelGroupMemphisOptions = (function() {

            /**
             * Properties of a TunnelGroupMemphisOptions.
             * @memberof protos.opts
             * @interface ITunnelGroupMemphisOptions
             * @property {protos.args.IMemphisConn|null} [_conn] TunnelGroupMemphisOptions _conn
             * @property {protos.args.IMemphisWriteArgs|null} [args] TunnelGroupMemphisOptions args
             */

            /**
             * Constructs a new TunnelGroupMemphisOptions.
             * @memberof protos.opts
             * @classdesc Represents a TunnelGroupMemphisOptions.
             * @implements ITunnelGroupMemphisOptions
             * @constructor
             * @param {protos.opts.ITunnelGroupMemphisOptions=} [properties] Properties to set
             */
            function TunnelGroupMemphisOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TunnelGroupMemphisOptions _conn.
             * @member {protos.args.IMemphisConn|null|undefined} _conn
             * @memberof protos.opts.TunnelGroupMemphisOptions
             * @instance
             */
            TunnelGroupMemphisOptions.prototype._conn = null;

            /**
             * TunnelGroupMemphisOptions args.
             * @member {protos.args.IMemphisWriteArgs|null|undefined} args
             * @memberof protos.opts.TunnelGroupMemphisOptions
             * @instance
             */
            TunnelGroupMemphisOptions.prototype.args = null;

            /**
             * Creates a new TunnelGroupMemphisOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.TunnelGroupMemphisOptions
             * @static
             * @param {protos.opts.ITunnelGroupMemphisOptions=} [properties] Properties to set
             * @returns {protos.opts.TunnelGroupMemphisOptions} TunnelGroupMemphisOptions instance
             */
            TunnelGroupMemphisOptions.create = function create(properties) {
                return new TunnelGroupMemphisOptions(properties);
            };

            /**
             * Encodes the specified TunnelGroupMemphisOptions message. Does not implicitly {@link protos.opts.TunnelGroupMemphisOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.TunnelGroupMemphisOptions
             * @static
             * @param {protos.opts.ITunnelGroupMemphisOptions} message TunnelGroupMemphisOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupMemphisOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MemphisConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MemphisWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TunnelGroupMemphisOptions message, length delimited. Does not implicitly {@link protos.opts.TunnelGroupMemphisOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.TunnelGroupMemphisOptions
             * @static
             * @param {protos.opts.ITunnelGroupMemphisOptions} message TunnelGroupMemphisOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TunnelGroupMemphisOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TunnelGroupMemphisOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.TunnelGroupMemphisOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.TunnelGroupMemphisOptions} TunnelGroupMemphisOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupMemphisOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.TunnelGroupMemphisOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MemphisConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MemphisWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TunnelGroupMemphisOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.TunnelGroupMemphisOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.TunnelGroupMemphisOptions} TunnelGroupMemphisOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TunnelGroupMemphisOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TunnelGroupMemphisOptions message.
             * @function verify
             * @memberof protos.opts.TunnelGroupMemphisOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TunnelGroupMemphisOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.MemphisConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.MemphisWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a TunnelGroupMemphisOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.TunnelGroupMemphisOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.TunnelGroupMemphisOptions} TunnelGroupMemphisOptions
             */
            TunnelGroupMemphisOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.TunnelGroupMemphisOptions)
                    return object;
                var message = new $root.protos.opts.TunnelGroupMemphisOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.TunnelGroupMemphisOptions._conn: object expected");
                    message._conn = $root.protos.args.MemphisConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.TunnelGroupMemphisOptions.args: object expected");
                    message.args = $root.protos.args.MemphisWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a TunnelGroupMemphisOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.TunnelGroupMemphisOptions
             * @static
             * @param {protos.opts.TunnelGroupMemphisOptions} message TunnelGroupMemphisOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TunnelGroupMemphisOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MemphisConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MemphisWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this TunnelGroupMemphisOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.TunnelGroupMemphisOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TunnelGroupMemphisOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TunnelGroupMemphisOptions;
        })();

        opts.GlobalCLIOptions = (function() {

            /**
             * Properties of a GlobalCLIOptions.
             * @memberof protos.opts
             * @interface IGlobalCLIOptions
             * @property {boolean|null} [debug] GlobalCLIOptions debug
             * @property {boolean|null} [quiet] GlobalCLIOptions quiet
             * @property {boolean|null} [version] GlobalCLIOptions version
             * @property {string|null} [_fullCommand] GlobalCLIOptions _fullCommand
             * @property {string|null} [_action] GlobalCLIOptions _action
             * @property {string|null} [_backend] GlobalCLIOptions _backend
             * @property {Array.<string>|null} [_commands] GlobalCLIOptions _commands
             */

            /**
             * Constructs a new GlobalCLIOptions.
             * @memberof protos.opts
             * @classdesc Represents a GlobalCLIOptions.
             * @implements IGlobalCLIOptions
             * @constructor
             * @param {protos.opts.IGlobalCLIOptions=} [properties] Properties to set
             */
            function GlobalCLIOptions(properties) {
                this._commands = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GlobalCLIOptions debug.
             * @member {boolean} debug
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype.debug = false;

            /**
             * GlobalCLIOptions quiet.
             * @member {boolean} quiet
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype.quiet = false;

            /**
             * GlobalCLIOptions version.
             * @member {boolean} version
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype.version = false;

            /**
             * GlobalCLIOptions _fullCommand.
             * @member {string} _fullCommand
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype._fullCommand = "";

            /**
             * GlobalCLIOptions _action.
             * @member {string} _action
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype._action = "";

            /**
             * GlobalCLIOptions _backend.
             * @member {string} _backend
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype._backend = "";

            /**
             * GlobalCLIOptions _commands.
             * @member {Array.<string>} _commands
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype._commands = $util.emptyArray;

            /**
             * Creates a new GlobalCLIOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {protos.opts.IGlobalCLIOptions=} [properties] Properties to set
             * @returns {protos.opts.GlobalCLIOptions} GlobalCLIOptions instance
             */
            GlobalCLIOptions.create = function create(properties) {
                return new GlobalCLIOptions(properties);
            };

            /**
             * Encodes the specified GlobalCLIOptions message. Does not implicitly {@link protos.opts.GlobalCLIOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {protos.opts.IGlobalCLIOptions} message GlobalCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlobalCLIOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.debug != null && Object.hasOwnProperty.call(message, "debug"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.debug);
                if (message.quiet != null && Object.hasOwnProperty.call(message, "quiet"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.quiet);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.version);
                if (message._fullCommand != null && Object.hasOwnProperty.call(message, "_fullCommand"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._fullCommand);
                if (message._action != null && Object.hasOwnProperty.call(message, "_action"))
                    writer.uint32(/* id 1001, wireType 2 =*/8010).string(message._action);
                if (message._backend != null && Object.hasOwnProperty.call(message, "_backend"))
                    writer.uint32(/* id 1002, wireType 2 =*/8018).string(message._backend);
                if (message._commands != null && message._commands.length)
                    for (var i = 0; i < message._commands.length; ++i)
                        writer.uint32(/* id 1003, wireType 2 =*/8026).string(message._commands[i]);
                return writer;
            };

            /**
             * Encodes the specified GlobalCLIOptions message, length delimited. Does not implicitly {@link protos.opts.GlobalCLIOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {protos.opts.IGlobalCLIOptions} message GlobalCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlobalCLIOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GlobalCLIOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.GlobalCLIOptions} GlobalCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlobalCLIOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.GlobalCLIOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.debug = reader.bool();
                        break;
                    case 2:
                        message.quiet = reader.bool();
                        break;
                    case 3:
                        message.version = reader.bool();
                        break;
                    case 1000:
                        message._fullCommand = reader.string();
                        break;
                    case 1001:
                        message._action = reader.string();
                        break;
                    case 1002:
                        message._backend = reader.string();
                        break;
                    case 1003:
                        if (!(message._commands && message._commands.length))
                            message._commands = [];
                        message._commands.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GlobalCLIOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.GlobalCLIOptions} GlobalCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlobalCLIOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GlobalCLIOptions message.
             * @function verify
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GlobalCLIOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.debug != null && message.hasOwnProperty("debug"))
                    if (typeof message.debug !== "boolean")
                        return "debug: boolean expected";
                if (message.quiet != null && message.hasOwnProperty("quiet"))
                    if (typeof message.quiet !== "boolean")
                        return "quiet: boolean expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (typeof message.version !== "boolean")
                        return "version: boolean expected";
                if (message._fullCommand != null && message.hasOwnProperty("_fullCommand"))
                    if (!$util.isString(message._fullCommand))
                        return "_fullCommand: string expected";
                if (message._action != null && message.hasOwnProperty("_action"))
                    if (!$util.isString(message._action))
                        return "_action: string expected";
                if (message._backend != null && message.hasOwnProperty("_backend"))
                    if (!$util.isString(message._backend))
                        return "_backend: string expected";
                if (message._commands != null && message.hasOwnProperty("_commands")) {
                    if (!Array.isArray(message._commands))
                        return "_commands: array expected";
                    for (var i = 0; i < message._commands.length; ++i)
                        if (!$util.isString(message._commands[i]))
                            return "_commands: string[] expected";
                }
                return null;
            };

            /**
             * Creates a GlobalCLIOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.GlobalCLIOptions} GlobalCLIOptions
             */
            GlobalCLIOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.GlobalCLIOptions)
                    return object;
                var message = new $root.protos.opts.GlobalCLIOptions();
                if (object.debug != null)
                    message.debug = Boolean(object.debug);
                if (object.quiet != null)
                    message.quiet = Boolean(object.quiet);
                if (object.version != null)
                    message.version = Boolean(object.version);
                if (object._fullCommand != null)
                    message._fullCommand = String(object._fullCommand);
                if (object._action != null)
                    message._action = String(object._action);
                if (object._backend != null)
                    message._backend = String(object._backend);
                if (object._commands) {
                    if (!Array.isArray(object._commands))
                        throw TypeError(".protos.opts.GlobalCLIOptions._commands: array expected");
                    message._commands = [];
                    for (var i = 0; i < object._commands.length; ++i)
                        message._commands[i] = String(object._commands[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a GlobalCLIOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {protos.opts.GlobalCLIOptions} message GlobalCLIOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GlobalCLIOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object._commands = [];
                if (options.defaults) {
                    object.debug = false;
                    object.quiet = false;
                    object.version = false;
                    object._fullCommand = "";
                    object._action = "";
                    object._backend = "";
                }
                if (message.debug != null && message.hasOwnProperty("debug"))
                    object.debug = message.debug;
                if (message.quiet != null && message.hasOwnProperty("quiet"))
                    object.quiet = message.quiet;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message._fullCommand != null && message.hasOwnProperty("_fullCommand"))
                    object._fullCommand = message._fullCommand;
                if (message._action != null && message.hasOwnProperty("_action"))
                    object._action = message._action;
                if (message._backend != null && message.hasOwnProperty("_backend"))
                    object._backend = message._backend;
                if (message._commands && message._commands.length) {
                    object._commands = [];
                    for (var j = 0; j < message._commands.length; ++j)
                        object._commands[j] = message._commands[j];
                }
                return object;
            };

            /**
             * Converts this GlobalCLIOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GlobalCLIOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GlobalCLIOptions;
        })();

        opts.CLIOptions = (function() {

            /**
             * Properties of a CLIOptions.
             * @memberof protos.opts
             * @interface ICLIOptions
             * @property {protos.opts.IGlobalCLIOptions|null} [global] CLIOptions global
             * @property {protos.opts.IReadOptions|null} [read] CLIOptions read
             * @property {protos.opts.IWriteOptions|null} [write] CLIOptions write
             * @property {protos.opts.IRelayOptions|null} [relay] CLIOptions relay
             * @property {protos.opts.ITunnelOptions|null} [tunnel] CLIOptions tunnel
             * @property {protos.opts.IStreamdalOptions|null} [streamdal] CLIOptions streamdal
             * @property {protos.opts.IServerOptions|null} [server] CLIOptions server
             * @property {protos.opts.IManageOptions|null} [manage] CLIOptions manage
             */

            /**
             * Constructs a new CLIOptions.
             * @memberof protos.opts
             * @classdesc Represents a CLIOptions.
             * @implements ICLIOptions
             * @constructor
             * @param {protos.opts.ICLIOptions=} [properties] Properties to set
             */
            function CLIOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CLIOptions global.
             * @member {protos.opts.IGlobalCLIOptions|null|undefined} global
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.global = null;

            /**
             * CLIOptions read.
             * @member {protos.opts.IReadOptions|null|undefined} read
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.read = null;

            /**
             * CLIOptions write.
             * @member {protos.opts.IWriteOptions|null|undefined} write
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.write = null;

            /**
             * CLIOptions relay.
             * @member {protos.opts.IRelayOptions|null|undefined} relay
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.relay = null;

            /**
             * CLIOptions tunnel.
             * @member {protos.opts.ITunnelOptions|null|undefined} tunnel
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.tunnel = null;

            /**
             * CLIOptions streamdal.
             * @member {protos.opts.IStreamdalOptions|null|undefined} streamdal
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.streamdal = null;

            /**
             * CLIOptions server.
             * @member {protos.opts.IServerOptions|null|undefined} server
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.server = null;

            /**
             * CLIOptions manage.
             * @member {protos.opts.IManageOptions|null|undefined} manage
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.manage = null;

            /**
             * Creates a new CLIOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {protos.opts.ICLIOptions=} [properties] Properties to set
             * @returns {protos.opts.CLIOptions} CLIOptions instance
             */
            CLIOptions.create = function create(properties) {
                return new CLIOptions(properties);
            };

            /**
             * Encodes the specified CLIOptions message. Does not implicitly {@link protos.opts.CLIOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {protos.opts.ICLIOptions} message CLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CLIOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.global != null && Object.hasOwnProperty.call(message, "global"))
                    $root.protos.opts.GlobalCLIOptions.encode(message.global, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.read != null && Object.hasOwnProperty.call(message, "read"))
                    $root.protos.opts.ReadOptions.encode(message.read, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.write != null && Object.hasOwnProperty.call(message, "write"))
                    $root.protos.opts.WriteOptions.encode(message.write, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.relay != null && Object.hasOwnProperty.call(message, "relay"))
                    $root.protos.opts.RelayOptions.encode(message.relay, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.tunnel != null && Object.hasOwnProperty.call(message, "tunnel"))
                    $root.protos.opts.TunnelOptions.encode(message.tunnel, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.streamdal != null && Object.hasOwnProperty.call(message, "streamdal"))
                    $root.protos.opts.StreamdalOptions.encode(message.streamdal, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.server != null && Object.hasOwnProperty.call(message, "server"))
                    $root.protos.opts.ServerOptions.encode(message.server, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.manage != null && Object.hasOwnProperty.call(message, "manage"))
                    $root.protos.opts.ManageOptions.encode(message.manage, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CLIOptions message, length delimited. Does not implicitly {@link protos.opts.CLIOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {protos.opts.ICLIOptions} message CLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CLIOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CLIOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.CLIOptions} CLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CLIOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.CLIOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.global = $root.protos.opts.GlobalCLIOptions.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.read = $root.protos.opts.ReadOptions.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.write = $root.protos.opts.WriteOptions.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.relay = $root.protos.opts.RelayOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.tunnel = $root.protos.opts.TunnelOptions.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.streamdal = $root.protos.opts.StreamdalOptions.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.server = $root.protos.opts.ServerOptions.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.manage = $root.protos.opts.ManageOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CLIOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.CLIOptions} CLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CLIOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CLIOptions message.
             * @function verify
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CLIOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.global != null && message.hasOwnProperty("global")) {
                    var error = $root.protos.opts.GlobalCLIOptions.verify(message.global);
                    if (error)
                        return "global." + error;
                }
                if (message.read != null && message.hasOwnProperty("read")) {
                    var error = $root.protos.opts.ReadOptions.verify(message.read);
                    if (error)
                        return "read." + error;
                }
                if (message.write != null && message.hasOwnProperty("write")) {
                    var error = $root.protos.opts.WriteOptions.verify(message.write);
                    if (error)
                        return "write." + error;
                }
                if (message.relay != null && message.hasOwnProperty("relay")) {
                    var error = $root.protos.opts.RelayOptions.verify(message.relay);
                    if (error)
                        return "relay." + error;
                }
                if (message.tunnel != null && message.hasOwnProperty("tunnel")) {
                    var error = $root.protos.opts.TunnelOptions.verify(message.tunnel);
                    if (error)
                        return "tunnel." + error;
                }
                if (message.streamdal != null && message.hasOwnProperty("streamdal")) {
                    var error = $root.protos.opts.StreamdalOptions.verify(message.streamdal);
                    if (error)
                        return "streamdal." + error;
                }
                if (message.server != null && message.hasOwnProperty("server")) {
                    var error = $root.protos.opts.ServerOptions.verify(message.server);
                    if (error)
                        return "server." + error;
                }
                if (message.manage != null && message.hasOwnProperty("manage")) {
                    var error = $root.protos.opts.ManageOptions.verify(message.manage);
                    if (error)
                        return "manage." + error;
                }
                return null;
            };

            /**
             * Creates a CLIOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.CLIOptions} CLIOptions
             */
            CLIOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.CLIOptions)
                    return object;
                var message = new $root.protos.opts.CLIOptions();
                if (object.global != null) {
                    if (typeof object.global !== "object")
                        throw TypeError(".protos.opts.CLIOptions.global: object expected");
                    message.global = $root.protos.opts.GlobalCLIOptions.fromObject(object.global);
                }
                if (object.read != null) {
                    if (typeof object.read !== "object")
                        throw TypeError(".protos.opts.CLIOptions.read: object expected");
                    message.read = $root.protos.opts.ReadOptions.fromObject(object.read);
                }
                if (object.write != null) {
                    if (typeof object.write !== "object")
                        throw TypeError(".protos.opts.CLIOptions.write: object expected");
                    message.write = $root.protos.opts.WriteOptions.fromObject(object.write);
                }
                if (object.relay != null) {
                    if (typeof object.relay !== "object")
                        throw TypeError(".protos.opts.CLIOptions.relay: object expected");
                    message.relay = $root.protos.opts.RelayOptions.fromObject(object.relay);
                }
                if (object.tunnel != null) {
                    if (typeof object.tunnel !== "object")
                        throw TypeError(".protos.opts.CLIOptions.tunnel: object expected");
                    message.tunnel = $root.protos.opts.TunnelOptions.fromObject(object.tunnel);
                }
                if (object.streamdal != null) {
                    if (typeof object.streamdal !== "object")
                        throw TypeError(".protos.opts.CLIOptions.streamdal: object expected");
                    message.streamdal = $root.protos.opts.StreamdalOptions.fromObject(object.streamdal);
                }
                if (object.server != null) {
                    if (typeof object.server !== "object")
                        throw TypeError(".protos.opts.CLIOptions.server: object expected");
                    message.server = $root.protos.opts.ServerOptions.fromObject(object.server);
                }
                if (object.manage != null) {
                    if (typeof object.manage !== "object")
                        throw TypeError(".protos.opts.CLIOptions.manage: object expected");
                    message.manage = $root.protos.opts.ManageOptions.fromObject(object.manage);
                }
                return message;
            };

            /**
             * Creates a plain object from a CLIOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {protos.opts.CLIOptions} message CLIOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CLIOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.global = null;
                    object.read = null;
                    object.write = null;
                    object.relay = null;
                    object.tunnel = null;
                    object.streamdal = null;
                    object.server = null;
                    object.manage = null;
                }
                if (message.global != null && message.hasOwnProperty("global"))
                    object.global = $root.protos.opts.GlobalCLIOptions.toObject(message.global, options);
                if (message.read != null && message.hasOwnProperty("read"))
                    object.read = $root.protos.opts.ReadOptions.toObject(message.read, options);
                if (message.write != null && message.hasOwnProperty("write"))
                    object.write = $root.protos.opts.WriteOptions.toObject(message.write, options);
                if (message.relay != null && message.hasOwnProperty("relay"))
                    object.relay = $root.protos.opts.RelayOptions.toObject(message.relay, options);
                if (message.tunnel != null && message.hasOwnProperty("tunnel"))
                    object.tunnel = $root.protos.opts.TunnelOptions.toObject(message.tunnel, options);
                if (message.streamdal != null && message.hasOwnProperty("streamdal"))
                    object.streamdal = $root.protos.opts.StreamdalOptions.toObject(message.streamdal, options);
                if (message.server != null && message.hasOwnProperty("server"))
                    object.server = $root.protos.opts.ServerOptions.toObject(message.server, options);
                if (message.manage != null && message.hasOwnProperty("manage"))
                    object.manage = $root.protos.opts.ManageOptions.toObject(message.manage, options);
                return object;
            };

            /**
             * Converts this CLIOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.CLIOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CLIOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CLIOptions;
        })();

        opts.ManageOptions = (function() {

            /**
             * Properties of a ManageOptions.
             * @memberof protos.opts
             * @interface IManageOptions
             * @property {protos.opts.IGlobalManageOptions|null} [globalOptions] ManageOptions globalOptions
             * @property {protos.opts.IGetOptions|null} [get] ManageOptions get
             * @property {protos.opts.ICreateOptions|null} [create] ManageOptions create
             * @property {protos.opts.IDeleteOptions|null} ["delete"] ManageOptions delete
             * @property {protos.opts.IStopOptions|null} [stop] ManageOptions stop
             * @property {protos.opts.IResumeOptions|null} [resume] ManageOptions resume
             */

            /**
             * Constructs a new ManageOptions.
             * @memberof protos.opts
             * @classdesc Represents a ManageOptions.
             * @implements IManageOptions
             * @constructor
             * @param {protos.opts.IManageOptions=} [properties] Properties to set
             */
            function ManageOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ManageOptions globalOptions.
             * @member {protos.opts.IGlobalManageOptions|null|undefined} globalOptions
             * @memberof protos.opts.ManageOptions
             * @instance
             */
            ManageOptions.prototype.globalOptions = null;

            /**
             * ManageOptions get.
             * @member {protos.opts.IGetOptions|null|undefined} get
             * @memberof protos.opts.ManageOptions
             * @instance
             */
            ManageOptions.prototype.get = null;

            /**
             * ManageOptions create.
             * @member {protos.opts.ICreateOptions|null|undefined} create
             * @memberof protos.opts.ManageOptions
             * @instance
             */
            ManageOptions.prototype.create = null;

            /**
             * ManageOptions delete.
             * @member {protos.opts.IDeleteOptions|null|undefined} delete
             * @memberof protos.opts.ManageOptions
             * @instance
             */
            ManageOptions.prototype["delete"] = null;

            /**
             * ManageOptions stop.
             * @member {protos.opts.IStopOptions|null|undefined} stop
             * @memberof protos.opts.ManageOptions
             * @instance
             */
            ManageOptions.prototype.stop = null;

            /**
             * ManageOptions resume.
             * @member {protos.opts.IResumeOptions|null|undefined} resume
             * @memberof protos.opts.ManageOptions
             * @instance
             */
            ManageOptions.prototype.resume = null;

            /**
             * Creates a new ManageOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ManageOptions
             * @static
             * @param {protos.opts.IManageOptions=} [properties] Properties to set
             * @returns {protos.opts.ManageOptions} ManageOptions instance
             */
            ManageOptions.create = function create(properties) {
                return new ManageOptions(properties);
            };

            /**
             * Encodes the specified ManageOptions message. Does not implicitly {@link protos.opts.ManageOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ManageOptions
             * @static
             * @param {protos.opts.IManageOptions} message ManageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ManageOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.globalOptions != null && Object.hasOwnProperty.call(message, "globalOptions"))
                    $root.protos.opts.GlobalManageOptions.encode(message.globalOptions, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.get != null && Object.hasOwnProperty.call(message, "get"))
                    $root.protos.opts.GetOptions.encode(message.get, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.create != null && Object.hasOwnProperty.call(message, "create"))
                    $root.protos.opts.CreateOptions.encode(message.create, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message["delete"] != null && Object.hasOwnProperty.call(message, "delete"))
                    $root.protos.opts.DeleteOptions.encode(message["delete"], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.stop != null && Object.hasOwnProperty.call(message, "stop"))
                    $root.protos.opts.StopOptions.encode(message.stop, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.resume != null && Object.hasOwnProperty.call(message, "resume"))
                    $root.protos.opts.ResumeOptions.encode(message.resume, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ManageOptions message, length delimited. Does not implicitly {@link protos.opts.ManageOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ManageOptions
             * @static
             * @param {protos.opts.IManageOptions} message ManageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ManageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ManageOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ManageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ManageOptions} ManageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ManageOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ManageOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.globalOptions = $root.protos.opts.GlobalManageOptions.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.get = $root.protos.opts.GetOptions.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.create = $root.protos.opts.CreateOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message["delete"] = $root.protos.opts.DeleteOptions.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.stop = $root.protos.opts.StopOptions.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.resume = $root.protos.opts.ResumeOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ManageOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ManageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ManageOptions} ManageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ManageOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ManageOptions message.
             * @function verify
             * @memberof protos.opts.ManageOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ManageOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.globalOptions != null && message.hasOwnProperty("globalOptions")) {
                    var error = $root.protos.opts.GlobalManageOptions.verify(message.globalOptions);
                    if (error)
                        return "globalOptions." + error;
                }
                if (message.get != null && message.hasOwnProperty("get")) {
                    var error = $root.protos.opts.GetOptions.verify(message.get);
                    if (error)
                        return "get." + error;
                }
                if (message.create != null && message.hasOwnProperty("create")) {
                    var error = $root.protos.opts.CreateOptions.verify(message.create);
                    if (error)
                        return "create." + error;
                }
                if (message["delete"] != null && message.hasOwnProperty("delete")) {
                    var error = $root.protos.opts.DeleteOptions.verify(message["delete"]);
                    if (error)
                        return "delete." + error;
                }
                if (message.stop != null && message.hasOwnProperty("stop")) {
                    var error = $root.protos.opts.StopOptions.verify(message.stop);
                    if (error)
                        return "stop." + error;
                }
                if (message.resume != null && message.hasOwnProperty("resume")) {
                    var error = $root.protos.opts.ResumeOptions.verify(message.resume);
                    if (error)
                        return "resume." + error;
                }
                return null;
            };

            /**
             * Creates a ManageOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ManageOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ManageOptions} ManageOptions
             */
            ManageOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ManageOptions)
                    return object;
                var message = new $root.protos.opts.ManageOptions();
                if (object.globalOptions != null) {
                    if (typeof object.globalOptions !== "object")
                        throw TypeError(".protos.opts.ManageOptions.globalOptions: object expected");
                    message.globalOptions = $root.protos.opts.GlobalManageOptions.fromObject(object.globalOptions);
                }
                if (object.get != null) {
                    if (typeof object.get !== "object")
                        throw TypeError(".protos.opts.ManageOptions.get: object expected");
                    message.get = $root.protos.opts.GetOptions.fromObject(object.get);
                }
                if (object.create != null) {
                    if (typeof object.create !== "object")
                        throw TypeError(".protos.opts.ManageOptions.create: object expected");
                    message.create = $root.protos.opts.CreateOptions.fromObject(object.create);
                }
                if (object["delete"] != null) {
                    if (typeof object["delete"] !== "object")
                        throw TypeError(".protos.opts.ManageOptions.delete: object expected");
                    message["delete"] = $root.protos.opts.DeleteOptions.fromObject(object["delete"]);
                }
                if (object.stop != null) {
                    if (typeof object.stop !== "object")
                        throw TypeError(".protos.opts.ManageOptions.stop: object expected");
                    message.stop = $root.protos.opts.StopOptions.fromObject(object.stop);
                }
                if (object.resume != null) {
                    if (typeof object.resume !== "object")
                        throw TypeError(".protos.opts.ManageOptions.resume: object expected");
                    message.resume = $root.protos.opts.ResumeOptions.fromObject(object.resume);
                }
                return message;
            };

            /**
             * Creates a plain object from a ManageOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ManageOptions
             * @static
             * @param {protos.opts.ManageOptions} message ManageOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ManageOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.globalOptions = null;
                    object.get = null;
                    object.create = null;
                    object["delete"] = null;
                    object.stop = null;
                    object.resume = null;
                }
                if (message.globalOptions != null && message.hasOwnProperty("globalOptions"))
                    object.globalOptions = $root.protos.opts.GlobalManageOptions.toObject(message.globalOptions, options);
                if (message.get != null && message.hasOwnProperty("get"))
                    object.get = $root.protos.opts.GetOptions.toObject(message.get, options);
                if (message.create != null && message.hasOwnProperty("create"))
                    object.create = $root.protos.opts.CreateOptions.toObject(message.create, options);
                if (message["delete"] != null && message.hasOwnProperty("delete"))
                    object["delete"] = $root.protos.opts.DeleteOptions.toObject(message["delete"], options);
                if (message.stop != null && message.hasOwnProperty("stop"))
                    object.stop = $root.protos.opts.StopOptions.toObject(message.stop, options);
                if (message.resume != null && message.hasOwnProperty("resume"))
                    object.resume = $root.protos.opts.ResumeOptions.toObject(message.resume, options);
                return object;
            };

            /**
             * Converts this ManageOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ManageOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ManageOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ManageOptions;
        })();

        opts.GlobalManageOptions = (function() {

            /**
             * Properties of a GlobalManageOptions.
             * @memberof protos.opts
             * @interface IGlobalManageOptions
             * @property {string|null} [manageAddress] GlobalManageOptions manageAddress
             * @property {string|null} [manageToken] GlobalManageOptions manageToken
             * @property {number|Long|null} [manageTimeoutSeconds] GlobalManageOptions manageTimeoutSeconds
             * @property {boolean|null} [manageUseTls] GlobalManageOptions manageUseTls
             * @property {boolean|null} [manageInsecureTls] GlobalManageOptions manageInsecureTls
             * @property {string|null} [manageTlsCaFile] GlobalManageOptions manageTlsCaFile
             * @property {string|null} [manageTlsCertFile] GlobalManageOptions manageTlsCertFile
             * @property {string|null} [manageTlsKeyFile] GlobalManageOptions manageTlsKeyFile
             * @property {boolean|null} [disablePretty] GlobalManageOptions disablePretty
             */

            /**
             * Constructs a new GlobalManageOptions.
             * @memberof protos.opts
             * @classdesc Represents a GlobalManageOptions.
             * @implements IGlobalManageOptions
             * @constructor
             * @param {protos.opts.IGlobalManageOptions=} [properties] Properties to set
             */
            function GlobalManageOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GlobalManageOptions manageAddress.
             * @member {string} manageAddress
             * @memberof protos.opts.GlobalManageOptions
             * @instance
             */
            GlobalManageOptions.prototype.manageAddress = "";

            /**
             * GlobalManageOptions manageToken.
             * @member {string} manageToken
             * @memberof protos.opts.GlobalManageOptions
             * @instance
             */
            GlobalManageOptions.prototype.manageToken = "";

            /**
             * GlobalManageOptions manageTimeoutSeconds.
             * @member {number|Long} manageTimeoutSeconds
             * @memberof protos.opts.GlobalManageOptions
             * @instance
             */
            GlobalManageOptions.prototype.manageTimeoutSeconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * GlobalManageOptions manageUseTls.
             * @member {boolean} manageUseTls
             * @memberof protos.opts.GlobalManageOptions
             * @instance
             */
            GlobalManageOptions.prototype.manageUseTls = false;

            /**
             * GlobalManageOptions manageInsecureTls.
             * @member {boolean} manageInsecureTls
             * @memberof protos.opts.GlobalManageOptions
             * @instance
             */
            GlobalManageOptions.prototype.manageInsecureTls = false;

            /**
             * GlobalManageOptions manageTlsCaFile.
             * @member {string} manageTlsCaFile
             * @memberof protos.opts.GlobalManageOptions
             * @instance
             */
            GlobalManageOptions.prototype.manageTlsCaFile = "";

            /**
             * GlobalManageOptions manageTlsCertFile.
             * @member {string} manageTlsCertFile
             * @memberof protos.opts.GlobalManageOptions
             * @instance
             */
            GlobalManageOptions.prototype.manageTlsCertFile = "";

            /**
             * GlobalManageOptions manageTlsKeyFile.
             * @member {string} manageTlsKeyFile
             * @memberof protos.opts.GlobalManageOptions
             * @instance
             */
            GlobalManageOptions.prototype.manageTlsKeyFile = "";

            /**
             * GlobalManageOptions disablePretty.
             * @member {boolean} disablePretty
             * @memberof protos.opts.GlobalManageOptions
             * @instance
             */
            GlobalManageOptions.prototype.disablePretty = false;

            /**
             * Creates a new GlobalManageOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.GlobalManageOptions
             * @static
             * @param {protos.opts.IGlobalManageOptions=} [properties] Properties to set
             * @returns {protos.opts.GlobalManageOptions} GlobalManageOptions instance
             */
            GlobalManageOptions.create = function create(properties) {
                return new GlobalManageOptions(properties);
            };

            /**
             * Encodes the specified GlobalManageOptions message. Does not implicitly {@link protos.opts.GlobalManageOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.GlobalManageOptions
             * @static
             * @param {protos.opts.IGlobalManageOptions} message GlobalManageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlobalManageOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.manageAddress != null && Object.hasOwnProperty.call(message, "manageAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.manageAddress);
                if (message.manageToken != null && Object.hasOwnProperty.call(message, "manageToken"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.manageToken);
                if (message.manageTimeoutSeconds != null && Object.hasOwnProperty.call(message, "manageTimeoutSeconds"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.manageTimeoutSeconds);
                if (message.manageUseTls != null && Object.hasOwnProperty.call(message, "manageUseTls"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.manageUseTls);
                if (message.manageInsecureTls != null && Object.hasOwnProperty.call(message, "manageInsecureTls"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.manageInsecureTls);
                if (message.manageTlsCaFile != null && Object.hasOwnProperty.call(message, "manageTlsCaFile"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.manageTlsCaFile);
                if (message.manageTlsCertFile != null && Object.hasOwnProperty.call(message, "manageTlsCertFile"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.manageTlsCertFile);
                if (message.manageTlsKeyFile != null && Object.hasOwnProperty.call(message, "manageTlsKeyFile"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.manageTlsKeyFile);
                if (message.disablePretty != null && Object.hasOwnProperty.call(message, "disablePretty"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.disablePretty);
                return writer;
            };

            /**
             * Encodes the specified GlobalManageOptions message, length delimited. Does not implicitly {@link protos.opts.GlobalManageOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.GlobalManageOptions
             * @static
             * @param {protos.opts.IGlobalManageOptions} message GlobalManageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlobalManageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GlobalManageOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.GlobalManageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.GlobalManageOptions} GlobalManageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlobalManageOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.GlobalManageOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.manageAddress = reader.string();
                        break;
                    case 2:
                        message.manageToken = reader.string();
                        break;
                    case 3:
                        message.manageTimeoutSeconds = reader.int64();
                        break;
                    case 4:
                        message.manageUseTls = reader.bool();
                        break;
                    case 5:
                        message.manageInsecureTls = reader.bool();
                        break;
                    case 6:
                        message.manageTlsCaFile = reader.string();
                        break;
                    case 7:
                        message.manageTlsCertFile = reader.string();
                        break;
                    case 8:
                        message.manageTlsKeyFile = reader.string();
                        break;
                    case 9:
                        message.disablePretty = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GlobalManageOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.GlobalManageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.GlobalManageOptions} GlobalManageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlobalManageOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GlobalManageOptions message.
             * @function verify
             * @memberof protos.opts.GlobalManageOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GlobalManageOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.manageAddress != null && message.hasOwnProperty("manageAddress"))
                    if (!$util.isString(message.manageAddress))
                        return "manageAddress: string expected";
                if (message.manageToken != null && message.hasOwnProperty("manageToken"))
                    if (!$util.isString(message.manageToken))
                        return "manageToken: string expected";
                if (message.manageTimeoutSeconds != null && message.hasOwnProperty("manageTimeoutSeconds"))
                    if (!$util.isInteger(message.manageTimeoutSeconds) && !(message.manageTimeoutSeconds && $util.isInteger(message.manageTimeoutSeconds.low) && $util.isInteger(message.manageTimeoutSeconds.high)))
                        return "manageTimeoutSeconds: integer|Long expected";
                if (message.manageUseTls != null && message.hasOwnProperty("manageUseTls"))
                    if (typeof message.manageUseTls !== "boolean")
                        return "manageUseTls: boolean expected";
                if (message.manageInsecureTls != null && message.hasOwnProperty("manageInsecureTls"))
                    if (typeof message.manageInsecureTls !== "boolean")
                        return "manageInsecureTls: boolean expected";
                if (message.manageTlsCaFile != null && message.hasOwnProperty("manageTlsCaFile"))
                    if (!$util.isString(message.manageTlsCaFile))
                        return "manageTlsCaFile: string expected";
                if (message.manageTlsCertFile != null && message.hasOwnProperty("manageTlsCertFile"))
                    if (!$util.isString(message.manageTlsCertFile))
                        return "manageTlsCertFile: string expected";
                if (message.manageTlsKeyFile != null && message.hasOwnProperty("manageTlsKeyFile"))
                    if (!$util.isString(message.manageTlsKeyFile))
                        return "manageTlsKeyFile: string expected";
                if (message.disablePretty != null && message.hasOwnProperty("disablePretty"))
                    if (typeof message.disablePretty !== "boolean")
                        return "disablePretty: boolean expected";
                return null;
            };

            /**
             * Creates a GlobalManageOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.GlobalManageOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.GlobalManageOptions} GlobalManageOptions
             */
            GlobalManageOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.GlobalManageOptions)
                    return object;
                var message = new $root.protos.opts.GlobalManageOptions();
                if (object.manageAddress != null)
                    message.manageAddress = String(object.manageAddress);
                if (object.manageToken != null)
                    message.manageToken = String(object.manageToken);
                if (object.manageTimeoutSeconds != null)
                    if ($util.Long)
                        (message.manageTimeoutSeconds = $util.Long.fromValue(object.manageTimeoutSeconds)).unsigned = false;
                    else if (typeof object.manageTimeoutSeconds === "string")
                        message.manageTimeoutSeconds = parseInt(object.manageTimeoutSeconds, 10);
                    else if (typeof object.manageTimeoutSeconds === "number")
                        message.manageTimeoutSeconds = object.manageTimeoutSeconds;
                    else if (typeof object.manageTimeoutSeconds === "object")
                        message.manageTimeoutSeconds = new $util.LongBits(object.manageTimeoutSeconds.low >>> 0, object.manageTimeoutSeconds.high >>> 0).toNumber();
                if (object.manageUseTls != null)
                    message.manageUseTls = Boolean(object.manageUseTls);
                if (object.manageInsecureTls != null)
                    message.manageInsecureTls = Boolean(object.manageInsecureTls);
                if (object.manageTlsCaFile != null)
                    message.manageTlsCaFile = String(object.manageTlsCaFile);
                if (object.manageTlsCertFile != null)
                    message.manageTlsCertFile = String(object.manageTlsCertFile);
                if (object.manageTlsKeyFile != null)
                    message.manageTlsKeyFile = String(object.manageTlsKeyFile);
                if (object.disablePretty != null)
                    message.disablePretty = Boolean(object.disablePretty);
                return message;
            };

            /**
             * Creates a plain object from a GlobalManageOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.GlobalManageOptions
             * @static
             * @param {protos.opts.GlobalManageOptions} message GlobalManageOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GlobalManageOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.manageAddress = "";
                    object.manageToken = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.manageTimeoutSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.manageTimeoutSeconds = options.longs === String ? "0" : 0;
                    object.manageUseTls = false;
                    object.manageInsecureTls = false;
                    object.manageTlsCaFile = "";
                    object.manageTlsCertFile = "";
                    object.manageTlsKeyFile = "";
                    object.disablePretty = false;
                }
                if (message.manageAddress != null && message.hasOwnProperty("manageAddress"))
                    object.manageAddress = message.manageAddress;
                if (message.manageToken != null && message.hasOwnProperty("manageToken"))
                    object.manageToken = message.manageToken;
                if (message.manageTimeoutSeconds != null && message.hasOwnProperty("manageTimeoutSeconds"))
                    if (typeof message.manageTimeoutSeconds === "number")
                        object.manageTimeoutSeconds = options.longs === String ? String(message.manageTimeoutSeconds) : message.manageTimeoutSeconds;
                    else
                        object.manageTimeoutSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.manageTimeoutSeconds) : options.longs === Number ? new $util.LongBits(message.manageTimeoutSeconds.low >>> 0, message.manageTimeoutSeconds.high >>> 0).toNumber() : message.manageTimeoutSeconds;
                if (message.manageUseTls != null && message.hasOwnProperty("manageUseTls"))
                    object.manageUseTls = message.manageUseTls;
                if (message.manageInsecureTls != null && message.hasOwnProperty("manageInsecureTls"))
                    object.manageInsecureTls = message.manageInsecureTls;
                if (message.manageTlsCaFile != null && message.hasOwnProperty("manageTlsCaFile"))
                    object.manageTlsCaFile = message.manageTlsCaFile;
                if (message.manageTlsCertFile != null && message.hasOwnProperty("manageTlsCertFile"))
                    object.manageTlsCertFile = message.manageTlsCertFile;
                if (message.manageTlsKeyFile != null && message.hasOwnProperty("manageTlsKeyFile"))
                    object.manageTlsKeyFile = message.manageTlsKeyFile;
                if (message.disablePretty != null && message.hasOwnProperty("disablePretty"))
                    object.disablePretty = message.disablePretty;
                return object;
            };

            /**
             * Converts this GlobalManageOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.GlobalManageOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GlobalManageOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GlobalManageOptions;
        })();

        opts.GetOptions = (function() {

            /**
             * Properties of a GetOptions.
             * @memberof protos.opts
             * @interface IGetOptions
             * @property {protos.opts.IGetConnectionOptions|null} [connection] GetOptions connection
             * @property {protos.opts.IGetRelayOptions|null} [relay] GetOptions relay
             * @property {protos.opts.IGetTunnelOptions|null} [tunnel] GetOptions tunnel
             */

            /**
             * Constructs a new GetOptions.
             * @memberof protos.opts
             * @classdesc Represents a GetOptions.
             * @implements IGetOptions
             * @constructor
             * @param {protos.opts.IGetOptions=} [properties] Properties to set
             */
            function GetOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetOptions connection.
             * @member {protos.opts.IGetConnectionOptions|null|undefined} connection
             * @memberof protos.opts.GetOptions
             * @instance
             */
            GetOptions.prototype.connection = null;

            /**
             * GetOptions relay.
             * @member {protos.opts.IGetRelayOptions|null|undefined} relay
             * @memberof protos.opts.GetOptions
             * @instance
             */
            GetOptions.prototype.relay = null;

            /**
             * GetOptions tunnel.
             * @member {protos.opts.IGetTunnelOptions|null|undefined} tunnel
             * @memberof protos.opts.GetOptions
             * @instance
             */
            GetOptions.prototype.tunnel = null;

            /**
             * Creates a new GetOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.GetOptions
             * @static
             * @param {protos.opts.IGetOptions=} [properties] Properties to set
             * @returns {protos.opts.GetOptions} GetOptions instance
             */
            GetOptions.create = function create(properties) {
                return new GetOptions(properties);
            };

            /**
             * Encodes the specified GetOptions message. Does not implicitly {@link protos.opts.GetOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.GetOptions
             * @static
             * @param {protos.opts.IGetOptions} message GetOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.connection != null && Object.hasOwnProperty.call(message, "connection"))
                    $root.protos.opts.GetConnectionOptions.encode(message.connection, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.relay != null && Object.hasOwnProperty.call(message, "relay"))
                    $root.protos.opts.GetRelayOptions.encode(message.relay, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.tunnel != null && Object.hasOwnProperty.call(message, "tunnel"))
                    $root.protos.opts.GetTunnelOptions.encode(message.tunnel, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetOptions message, length delimited. Does not implicitly {@link protos.opts.GetOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.GetOptions
             * @static
             * @param {protos.opts.IGetOptions} message GetOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.GetOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.GetOptions} GetOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.GetOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.connection = $root.protos.opts.GetConnectionOptions.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.relay = $root.protos.opts.GetRelayOptions.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.tunnel = $root.protos.opts.GetTunnelOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.GetOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.GetOptions} GetOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetOptions message.
             * @function verify
             * @memberof protos.opts.GetOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.connection != null && message.hasOwnProperty("connection")) {
                    var error = $root.protos.opts.GetConnectionOptions.verify(message.connection);
                    if (error)
                        return "connection." + error;
                }
                if (message.relay != null && message.hasOwnProperty("relay")) {
                    var error = $root.protos.opts.GetRelayOptions.verify(message.relay);
                    if (error)
                        return "relay." + error;
                }
                if (message.tunnel != null && message.hasOwnProperty("tunnel")) {
                    var error = $root.protos.opts.GetTunnelOptions.verify(message.tunnel);
                    if (error)
                        return "tunnel." + error;
                }
                return null;
            };

            /**
             * Creates a GetOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.GetOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.GetOptions} GetOptions
             */
            GetOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.GetOptions)
                    return object;
                var message = new $root.protos.opts.GetOptions();
                if (object.connection != null) {
                    if (typeof object.connection !== "object")
                        throw TypeError(".protos.opts.GetOptions.connection: object expected");
                    message.connection = $root.protos.opts.GetConnectionOptions.fromObject(object.connection);
                }
                if (object.relay != null) {
                    if (typeof object.relay !== "object")
                        throw TypeError(".protos.opts.GetOptions.relay: object expected");
                    message.relay = $root.protos.opts.GetRelayOptions.fromObject(object.relay);
                }
                if (object.tunnel != null) {
                    if (typeof object.tunnel !== "object")
                        throw TypeError(".protos.opts.GetOptions.tunnel: object expected");
                    message.tunnel = $root.protos.opts.GetTunnelOptions.fromObject(object.tunnel);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.GetOptions
             * @static
             * @param {protos.opts.GetOptions} message GetOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.connection = null;
                    object.relay = null;
                    object.tunnel = null;
                }
                if (message.connection != null && message.hasOwnProperty("connection"))
                    object.connection = $root.protos.opts.GetConnectionOptions.toObject(message.connection, options);
                if (message.relay != null && message.hasOwnProperty("relay"))
                    object.relay = $root.protos.opts.GetRelayOptions.toObject(message.relay, options);
                if (message.tunnel != null && message.hasOwnProperty("tunnel"))
                    object.tunnel = $root.protos.opts.GetTunnelOptions.toObject(message.tunnel, options);
                return object;
            };

            /**
             * Converts this GetOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.GetOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetOptions;
        })();

        opts.CreateOptions = (function() {

            /**
             * Properties of a CreateOptions.
             * @memberof protos.opts
             * @interface ICreateOptions
             * @property {protos.opts.ICreateConnectionOptions|null} [connection] CreateOptions connection
             * @property {protos.opts.ICreateRelayOptions|null} [relay] CreateOptions relay
             * @property {protos.opts.ICreateTunnelOptions|null} [tunnel] CreateOptions tunnel
             */

            /**
             * Constructs a new CreateOptions.
             * @memberof protos.opts
             * @classdesc Represents a CreateOptions.
             * @implements ICreateOptions
             * @constructor
             * @param {protos.opts.ICreateOptions=} [properties] Properties to set
             */
            function CreateOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateOptions connection.
             * @member {protos.opts.ICreateConnectionOptions|null|undefined} connection
             * @memberof protos.opts.CreateOptions
             * @instance
             */
            CreateOptions.prototype.connection = null;

            /**
             * CreateOptions relay.
             * @member {protos.opts.ICreateRelayOptions|null|undefined} relay
             * @memberof protos.opts.CreateOptions
             * @instance
             */
            CreateOptions.prototype.relay = null;

            /**
             * CreateOptions tunnel.
             * @member {protos.opts.ICreateTunnelOptions|null|undefined} tunnel
             * @memberof protos.opts.CreateOptions
             * @instance
             */
            CreateOptions.prototype.tunnel = null;

            /**
             * Creates a new CreateOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.CreateOptions
             * @static
             * @param {protos.opts.ICreateOptions=} [properties] Properties to set
             * @returns {protos.opts.CreateOptions} CreateOptions instance
             */
            CreateOptions.create = function create(properties) {
                return new CreateOptions(properties);
            };

            /**
             * Encodes the specified CreateOptions message. Does not implicitly {@link protos.opts.CreateOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.CreateOptions
             * @static
             * @param {protos.opts.ICreateOptions} message CreateOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.connection != null && Object.hasOwnProperty.call(message, "connection"))
                    $root.protos.opts.CreateConnectionOptions.encode(message.connection, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.relay != null && Object.hasOwnProperty.call(message, "relay"))
                    $root.protos.opts.CreateRelayOptions.encode(message.relay, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.tunnel != null && Object.hasOwnProperty.call(message, "tunnel"))
                    $root.protos.opts.CreateTunnelOptions.encode(message.tunnel, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CreateOptions message, length delimited. Does not implicitly {@link protos.opts.CreateOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.CreateOptions
             * @static
             * @param {protos.opts.ICreateOptions} message CreateOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.CreateOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.CreateOptions} CreateOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.CreateOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.connection = $root.protos.opts.CreateConnectionOptions.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.relay = $root.protos.opts.CreateRelayOptions.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.tunnel = $root.protos.opts.CreateTunnelOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.CreateOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.CreateOptions} CreateOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateOptions message.
             * @function verify
             * @memberof protos.opts.CreateOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.connection != null && message.hasOwnProperty("connection")) {
                    var error = $root.protos.opts.CreateConnectionOptions.verify(message.connection);
                    if (error)
                        return "connection." + error;
                }
                if (message.relay != null && message.hasOwnProperty("relay")) {
                    var error = $root.protos.opts.CreateRelayOptions.verify(message.relay);
                    if (error)
                        return "relay." + error;
                }
                if (message.tunnel != null && message.hasOwnProperty("tunnel")) {
                    var error = $root.protos.opts.CreateTunnelOptions.verify(message.tunnel);
                    if (error)
                        return "tunnel." + error;
                }
                return null;
            };

            /**
             * Creates a CreateOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.CreateOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.CreateOptions} CreateOptions
             */
            CreateOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.CreateOptions)
                    return object;
                var message = new $root.protos.opts.CreateOptions();
                if (object.connection != null) {
                    if (typeof object.connection !== "object")
                        throw TypeError(".protos.opts.CreateOptions.connection: object expected");
                    message.connection = $root.protos.opts.CreateConnectionOptions.fromObject(object.connection);
                }
                if (object.relay != null) {
                    if (typeof object.relay !== "object")
                        throw TypeError(".protos.opts.CreateOptions.relay: object expected");
                    message.relay = $root.protos.opts.CreateRelayOptions.fromObject(object.relay);
                }
                if (object.tunnel != null) {
                    if (typeof object.tunnel !== "object")
                        throw TypeError(".protos.opts.CreateOptions.tunnel: object expected");
                    message.tunnel = $root.protos.opts.CreateTunnelOptions.fromObject(object.tunnel);
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.CreateOptions
             * @static
             * @param {protos.opts.CreateOptions} message CreateOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.connection = null;
                    object.relay = null;
                    object.tunnel = null;
                }
                if (message.connection != null && message.hasOwnProperty("connection"))
                    object.connection = $root.protos.opts.CreateConnectionOptions.toObject(message.connection, options);
                if (message.relay != null && message.hasOwnProperty("relay"))
                    object.relay = $root.protos.opts.CreateRelayOptions.toObject(message.relay, options);
                if (message.tunnel != null && message.hasOwnProperty("tunnel"))
                    object.tunnel = $root.protos.opts.CreateTunnelOptions.toObject(message.tunnel, options);
                return object;
            };

            /**
             * Converts this CreateOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.CreateOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateOptions;
        })();

        opts.DeleteOptions = (function() {

            /**
             * Properties of a DeleteOptions.
             * @memberof protos.opts
             * @interface IDeleteOptions
             * @property {protos.opts.IDeleteConnectionOptions|null} [connection] DeleteOptions connection
             * @property {protos.opts.IDeleteRelayOptions|null} [relay] DeleteOptions relay
             * @property {protos.opts.IDeleteTunnelOptions|null} [tunnel] DeleteOptions tunnel
             */

            /**
             * Constructs a new DeleteOptions.
             * @memberof protos.opts
             * @classdesc Represents a DeleteOptions.
             * @implements IDeleteOptions
             * @constructor
             * @param {protos.opts.IDeleteOptions=} [properties] Properties to set
             */
            function DeleteOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteOptions connection.
             * @member {protos.opts.IDeleteConnectionOptions|null|undefined} connection
             * @memberof protos.opts.DeleteOptions
             * @instance
             */
            DeleteOptions.prototype.connection = null;

            /**
             * DeleteOptions relay.
             * @member {protos.opts.IDeleteRelayOptions|null|undefined} relay
             * @memberof protos.opts.DeleteOptions
             * @instance
             */
            DeleteOptions.prototype.relay = null;

            /**
             * DeleteOptions tunnel.
             * @member {protos.opts.IDeleteTunnelOptions|null|undefined} tunnel
             * @memberof protos.opts.DeleteOptions
             * @instance
             */
            DeleteOptions.prototype.tunnel = null;

            /**
             * Creates a new DeleteOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DeleteOptions
             * @static
             * @param {protos.opts.IDeleteOptions=} [properties] Properties to set
             * @returns {protos.opts.DeleteOptions} DeleteOptions instance
             */
            DeleteOptions.create = function create(properties) {
                return new DeleteOptions(properties);
            };

            /**
             * Encodes the specified DeleteOptions message. Does not implicitly {@link protos.opts.DeleteOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DeleteOptions
             * @static
             * @param {protos.opts.IDeleteOptions} message DeleteOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.connection != null && Object.hasOwnProperty.call(message, "connection"))
                    $root.protos.opts.DeleteConnectionOptions.encode(message.connection, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.relay != null && Object.hasOwnProperty.call(message, "relay"))
                    $root.protos.opts.DeleteRelayOptions.encode(message.relay, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.tunnel != null && Object.hasOwnProperty.call(message, "tunnel"))
                    $root.protos.opts.DeleteTunnelOptions.encode(message.tunnel, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DeleteOptions message, length delimited. Does not implicitly {@link protos.opts.DeleteOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DeleteOptions
             * @static
             * @param {protos.opts.IDeleteOptions} message DeleteOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DeleteOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DeleteOptions} DeleteOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DeleteOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.connection = $root.protos.opts.DeleteConnectionOptions.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.relay = $root.protos.opts.DeleteRelayOptions.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.tunnel = $root.protos.opts.DeleteTunnelOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DeleteOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DeleteOptions} DeleteOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteOptions message.
             * @function verify
             * @memberof protos.opts.DeleteOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.connection != null && message.hasOwnProperty("connection")) {
                    var error = $root.protos.opts.DeleteConnectionOptions.verify(message.connection);
                    if (error)
                        return "connection." + error;
                }
                if (message.relay != null && message.hasOwnProperty("relay")) {
                    var error = $root.protos.opts.DeleteRelayOptions.verify(message.relay);
                    if (error)
                        return "relay." + error;
                }
                if (message.tunnel != null && message.hasOwnProperty("tunnel")) {
                    var error = $root.protos.opts.DeleteTunnelOptions.verify(message.tunnel);
                    if (error)
                        return "tunnel." + error;
                }
                return null;
            };

            /**
             * Creates a DeleteOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DeleteOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DeleteOptions} DeleteOptions
             */
            DeleteOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DeleteOptions)
                    return object;
                var message = new $root.protos.opts.DeleteOptions();
                if (object.connection != null) {
                    if (typeof object.connection !== "object")
                        throw TypeError(".protos.opts.DeleteOptions.connection: object expected");
                    message.connection = $root.protos.opts.DeleteConnectionOptions.fromObject(object.connection);
                }
                if (object.relay != null) {
                    if (typeof object.relay !== "object")
                        throw TypeError(".protos.opts.DeleteOptions.relay: object expected");
                    message.relay = $root.protos.opts.DeleteRelayOptions.fromObject(object.relay);
                }
                if (object.tunnel != null) {
                    if (typeof object.tunnel !== "object")
                        throw TypeError(".protos.opts.DeleteOptions.tunnel: object expected");
                    message.tunnel = $root.protos.opts.DeleteTunnelOptions.fromObject(object.tunnel);
                }
                return message;
            };

            /**
             * Creates a plain object from a DeleteOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DeleteOptions
             * @static
             * @param {protos.opts.DeleteOptions} message DeleteOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.connection = null;
                    object.relay = null;
                    object.tunnel = null;
                }
                if (message.connection != null && message.hasOwnProperty("connection"))
                    object.connection = $root.protos.opts.DeleteConnectionOptions.toObject(message.connection, options);
                if (message.relay != null && message.hasOwnProperty("relay"))
                    object.relay = $root.protos.opts.DeleteRelayOptions.toObject(message.relay, options);
                if (message.tunnel != null && message.hasOwnProperty("tunnel"))
                    object.tunnel = $root.protos.opts.DeleteTunnelOptions.toObject(message.tunnel, options);
                return object;
            };

            /**
             * Converts this DeleteOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DeleteOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DeleteOptions;
        })();

        opts.StopOptions = (function() {

            /**
             * Properties of a StopOptions.
             * @memberof protos.opts
             * @interface IStopOptions
             * @property {protos.opts.IStopRelayOptions|null} [relay] StopOptions relay
             * @property {protos.opts.IStopTunnelOptions|null} [tunnel] StopOptions tunnel
             */

            /**
             * Constructs a new StopOptions.
             * @memberof protos.opts
             * @classdesc Represents a StopOptions.
             * @implements IStopOptions
             * @constructor
             * @param {protos.opts.IStopOptions=} [properties] Properties to set
             */
            function StopOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StopOptions relay.
             * @member {protos.opts.IStopRelayOptions|null|undefined} relay
             * @memberof protos.opts.StopOptions
             * @instance
             */
            StopOptions.prototype.relay = null;

            /**
             * StopOptions tunnel.
             * @member {protos.opts.IStopTunnelOptions|null|undefined} tunnel
             * @memberof protos.opts.StopOptions
             * @instance
             */
            StopOptions.prototype.tunnel = null;

            /**
             * Creates a new StopOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.StopOptions
             * @static
             * @param {protos.opts.IStopOptions=} [properties] Properties to set
             * @returns {protos.opts.StopOptions} StopOptions instance
             */
            StopOptions.create = function create(properties) {
                return new StopOptions(properties);
            };

            /**
             * Encodes the specified StopOptions message. Does not implicitly {@link protos.opts.StopOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.StopOptions
             * @static
             * @param {protos.opts.IStopOptions} message StopOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StopOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.relay != null && Object.hasOwnProperty.call(message, "relay"))
                    $root.protos.opts.StopRelayOptions.encode(message.relay, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.tunnel != null && Object.hasOwnProperty.call(message, "tunnel"))
                    $root.protos.opts.StopTunnelOptions.encode(message.tunnel, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified StopOptions message, length delimited. Does not implicitly {@link protos.opts.StopOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.StopOptions
             * @static
             * @param {protos.opts.IStopOptions} message StopOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StopOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StopOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.StopOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.StopOptions} StopOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StopOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.StopOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.relay = $root.protos.opts.StopRelayOptions.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.tunnel = $root.protos.opts.StopTunnelOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StopOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.StopOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.StopOptions} StopOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StopOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StopOptions message.
             * @function verify
             * @memberof protos.opts.StopOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StopOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.relay != null && message.hasOwnProperty("relay")) {
                    var error = $root.protos.opts.StopRelayOptions.verify(message.relay);
                    if (error)
                        return "relay." + error;
                }
                if (message.tunnel != null && message.hasOwnProperty("tunnel")) {
                    var error = $root.protos.opts.StopTunnelOptions.verify(message.tunnel);
                    if (error)
                        return "tunnel." + error;
                }
                return null;
            };

            /**
             * Creates a StopOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.StopOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.StopOptions} StopOptions
             */
            StopOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.StopOptions)
                    return object;
                var message = new $root.protos.opts.StopOptions();
                if (object.relay != null) {
                    if (typeof object.relay !== "object")
                        throw TypeError(".protos.opts.StopOptions.relay: object expected");
                    message.relay = $root.protos.opts.StopRelayOptions.fromObject(object.relay);
                }
                if (object.tunnel != null) {
                    if (typeof object.tunnel !== "object")
                        throw TypeError(".protos.opts.StopOptions.tunnel: object expected");
                    message.tunnel = $root.protos.opts.StopTunnelOptions.fromObject(object.tunnel);
                }
                return message;
            };

            /**
             * Creates a plain object from a StopOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.StopOptions
             * @static
             * @param {protos.opts.StopOptions} message StopOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StopOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.relay = null;
                    object.tunnel = null;
                }
                if (message.relay != null && message.hasOwnProperty("relay"))
                    object.relay = $root.protos.opts.StopRelayOptions.toObject(message.relay, options);
                if (message.tunnel != null && message.hasOwnProperty("tunnel"))
                    object.tunnel = $root.protos.opts.StopTunnelOptions.toObject(message.tunnel, options);
                return object;
            };

            /**
             * Converts this StopOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.StopOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StopOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StopOptions;
        })();

        opts.ResumeOptions = (function() {

            /**
             * Properties of a ResumeOptions.
             * @memberof protos.opts
             * @interface IResumeOptions
             * @property {protos.opts.IResumeRelayOptions|null} [relay] ResumeOptions relay
             * @property {protos.opts.IResumeTunnelOptions|null} [tunnel] ResumeOptions tunnel
             */

            /**
             * Constructs a new ResumeOptions.
             * @memberof protos.opts
             * @classdesc Represents a ResumeOptions.
             * @implements IResumeOptions
             * @constructor
             * @param {protos.opts.IResumeOptions=} [properties] Properties to set
             */
            function ResumeOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ResumeOptions relay.
             * @member {protos.opts.IResumeRelayOptions|null|undefined} relay
             * @memberof protos.opts.ResumeOptions
             * @instance
             */
            ResumeOptions.prototype.relay = null;

            /**
             * ResumeOptions tunnel.
             * @member {protos.opts.IResumeTunnelOptions|null|undefined} tunnel
             * @memberof protos.opts.ResumeOptions
             * @instance
             */
            ResumeOptions.prototype.tunnel = null;

            /**
             * Creates a new ResumeOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ResumeOptions
             * @static
             * @param {protos.opts.IResumeOptions=} [properties] Properties to set
             * @returns {protos.opts.ResumeOptions} ResumeOptions instance
             */
            ResumeOptions.create = function create(properties) {
                return new ResumeOptions(properties);
            };

            /**
             * Encodes the specified ResumeOptions message. Does not implicitly {@link protos.opts.ResumeOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ResumeOptions
             * @static
             * @param {protos.opts.IResumeOptions} message ResumeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResumeOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.relay != null && Object.hasOwnProperty.call(message, "relay"))
                    $root.protos.opts.ResumeRelayOptions.encode(message.relay, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.tunnel != null && Object.hasOwnProperty.call(message, "tunnel"))
                    $root.protos.opts.ResumeTunnelOptions.encode(message.tunnel, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ResumeOptions message, length delimited. Does not implicitly {@link protos.opts.ResumeOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ResumeOptions
             * @static
             * @param {protos.opts.IResumeOptions} message ResumeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResumeOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ResumeOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ResumeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ResumeOptions} ResumeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResumeOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ResumeOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.relay = $root.protos.opts.ResumeRelayOptions.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.tunnel = $root.protos.opts.ResumeTunnelOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ResumeOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ResumeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ResumeOptions} ResumeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResumeOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ResumeOptions message.
             * @function verify
             * @memberof protos.opts.ResumeOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ResumeOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.relay != null && message.hasOwnProperty("relay")) {
                    var error = $root.protos.opts.ResumeRelayOptions.verify(message.relay);
                    if (error)
                        return "relay." + error;
                }
                if (message.tunnel != null && message.hasOwnProperty("tunnel")) {
                    var error = $root.protos.opts.ResumeTunnelOptions.verify(message.tunnel);
                    if (error)
                        return "tunnel." + error;
                }
                return null;
            };

            /**
             * Creates a ResumeOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ResumeOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ResumeOptions} ResumeOptions
             */
            ResumeOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ResumeOptions)
                    return object;
                var message = new $root.protos.opts.ResumeOptions();
                if (object.relay != null) {
                    if (typeof object.relay !== "object")
                        throw TypeError(".protos.opts.ResumeOptions.relay: object expected");
                    message.relay = $root.protos.opts.ResumeRelayOptions.fromObject(object.relay);
                }
                if (object.tunnel != null) {
                    if (typeof object.tunnel !== "object")
                        throw TypeError(".protos.opts.ResumeOptions.tunnel: object expected");
                    message.tunnel = $root.protos.opts.ResumeTunnelOptions.fromObject(object.tunnel);
                }
                return message;
            };

            /**
             * Creates a plain object from a ResumeOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ResumeOptions
             * @static
             * @param {protos.opts.ResumeOptions} message ResumeOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ResumeOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.relay = null;
                    object.tunnel = null;
                }
                if (message.relay != null && message.hasOwnProperty("relay"))
                    object.relay = $root.protos.opts.ResumeRelayOptions.toObject(message.relay, options);
                if (message.tunnel != null && message.hasOwnProperty("tunnel"))
                    object.tunnel = $root.protos.opts.ResumeTunnelOptions.toObject(message.tunnel, options);
                return object;
            };

            /**
             * Converts this ResumeOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ResumeOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ResumeOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ResumeOptions;
        })();

        opts.GetConnectionOptions = (function() {

            /**
             * Properties of a GetConnectionOptions.
             * @memberof protos.opts
             * @interface IGetConnectionOptions
             * @property {string|null} [id] GetConnectionOptions id
             */

            /**
             * Constructs a new GetConnectionOptions.
             * @memberof protos.opts
             * @classdesc Represents a GetConnectionOptions.
             * @implements IGetConnectionOptions
             * @constructor
             * @param {protos.opts.IGetConnectionOptions=} [properties] Properties to set
             */
            function GetConnectionOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetConnectionOptions id.
             * @member {string} id
             * @memberof protos.opts.GetConnectionOptions
             * @instance
             */
            GetConnectionOptions.prototype.id = "";

            /**
             * Creates a new GetConnectionOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.GetConnectionOptions
             * @static
             * @param {protos.opts.IGetConnectionOptions=} [properties] Properties to set
             * @returns {protos.opts.GetConnectionOptions} GetConnectionOptions instance
             */
            GetConnectionOptions.create = function create(properties) {
                return new GetConnectionOptions(properties);
            };

            /**
             * Encodes the specified GetConnectionOptions message. Does not implicitly {@link protos.opts.GetConnectionOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.GetConnectionOptions
             * @static
             * @param {protos.opts.IGetConnectionOptions} message GetConnectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetConnectionOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified GetConnectionOptions message, length delimited. Does not implicitly {@link protos.opts.GetConnectionOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.GetConnectionOptions
             * @static
             * @param {protos.opts.IGetConnectionOptions} message GetConnectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetConnectionOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetConnectionOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.GetConnectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.GetConnectionOptions} GetConnectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetConnectionOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.GetConnectionOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetConnectionOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.GetConnectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.GetConnectionOptions} GetConnectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetConnectionOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetConnectionOptions message.
             * @function verify
             * @memberof protos.opts.GetConnectionOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetConnectionOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a GetConnectionOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.GetConnectionOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.GetConnectionOptions} GetConnectionOptions
             */
            GetConnectionOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.GetConnectionOptions)
                    return object;
                var message = new $root.protos.opts.GetConnectionOptions();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a GetConnectionOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.GetConnectionOptions
             * @static
             * @param {protos.opts.GetConnectionOptions} message GetConnectionOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetConnectionOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this GetConnectionOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.GetConnectionOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetConnectionOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetConnectionOptions;
        })();

        opts.CreateConnectionOptions = (function() {

            /**
             * Properties of a CreateConnectionOptions.
             * @memberof protos.opts
             * @interface ICreateConnectionOptions
             * @property {string|null} [name] CreateConnectionOptions name
             * @property {string|null} [notes] CreateConnectionOptions notes
             * @property {protos.args.IKafkaConn|null} [kafka] CreateConnectionOptions kafka
             * @property {protos.args.IActiveMQConn|null} [activeMq] CreateConnectionOptions activeMq
             * @property {protos.args.IAWSSQSConn|null} [awsSqs] CreateConnectionOptions awsSqs
             * @property {protos.args.IAWSSNSConn|null} [awsSns] CreateConnectionOptions awsSns
             * @property {protos.args.IMongoConn|null} [mongo] CreateConnectionOptions mongo
             * @property {protos.args.INatsConn|null} [nats] CreateConnectionOptions nats
             * @property {protos.args.INatsStreamingConn|null} [natsStreaming] CreateConnectionOptions natsStreaming
             * @property {protos.args.INSQConn|null} [nsq] CreateConnectionOptions nsq
             * @property {protos.args.IPostgresConn|null} [postgres] CreateConnectionOptions postgres
             * @property {protos.args.IPulsarConn|null} [pulsar] CreateConnectionOptions pulsar
             * @property {protos.args.IRabbitConn|null} [rabbit] CreateConnectionOptions rabbit
             * @property {protos.args.IRabbitStreamsConn|null} [rabbitStreams] CreateConnectionOptions rabbitStreams
             * @property {protos.args.IRedisPubSubConn|null} [redisPubsub] CreateConnectionOptions redisPubsub
             * @property {protos.args.IRedisStreamsConn|null} [redisStreams] CreateConnectionOptions redisStreams
             * @property {protos.args.IAzureEventHubConn|null} [azureEventHub] CreateConnectionOptions azureEventHub
             * @property {protos.args.IAzureServiceBusConn|null} [azureServiceBus] CreateConnectionOptions azureServiceBus
             * @property {protos.args.IMQTTConn|null} [mqtt] CreateConnectionOptions mqtt
             * @property {protos.args.IKubeMQQueueConn|null} [kubemqQueue] CreateConnectionOptions kubemqQueue
             * @property {protos.args.IGCPPubSubConn|null} [gcpPubsub] CreateConnectionOptions gcpPubsub
             * @property {protos.args.INatsJetstreamConn|null} [natsJetstream] CreateConnectionOptions natsJetstream
             * @property {protos.args.IAWSKinesisConn|null} [awsKinesis] CreateConnectionOptions awsKinesis
             */

            /**
             * Constructs a new CreateConnectionOptions.
             * @memberof protos.opts
             * @classdesc Represents a CreateConnectionOptions.
             * @implements ICreateConnectionOptions
             * @constructor
             * @param {protos.opts.ICreateConnectionOptions=} [properties] Properties to set
             */
            function CreateConnectionOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateConnectionOptions name.
             * @member {string} name
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.name = "";

            /**
             * CreateConnectionOptions notes.
             * @member {string} notes
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.notes = "";

            /**
             * CreateConnectionOptions kafka.
             * @member {protos.args.IKafkaConn|null|undefined} kafka
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.kafka = null;

            /**
             * CreateConnectionOptions activeMq.
             * @member {protos.args.IActiveMQConn|null|undefined} activeMq
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.activeMq = null;

            /**
             * CreateConnectionOptions awsSqs.
             * @member {protos.args.IAWSSQSConn|null|undefined} awsSqs
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.awsSqs = null;

            /**
             * CreateConnectionOptions awsSns.
             * @member {protos.args.IAWSSNSConn|null|undefined} awsSns
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.awsSns = null;

            /**
             * CreateConnectionOptions mongo.
             * @member {protos.args.IMongoConn|null|undefined} mongo
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.mongo = null;

            /**
             * CreateConnectionOptions nats.
             * @member {protos.args.INatsConn|null|undefined} nats
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.nats = null;

            /**
             * CreateConnectionOptions natsStreaming.
             * @member {protos.args.INatsStreamingConn|null|undefined} natsStreaming
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.natsStreaming = null;

            /**
             * CreateConnectionOptions nsq.
             * @member {protos.args.INSQConn|null|undefined} nsq
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.nsq = null;

            /**
             * CreateConnectionOptions postgres.
             * @member {protos.args.IPostgresConn|null|undefined} postgres
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.postgres = null;

            /**
             * CreateConnectionOptions pulsar.
             * @member {protos.args.IPulsarConn|null|undefined} pulsar
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.pulsar = null;

            /**
             * CreateConnectionOptions rabbit.
             * @member {protos.args.IRabbitConn|null|undefined} rabbit
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.rabbit = null;

            /**
             * CreateConnectionOptions rabbitStreams.
             * @member {protos.args.IRabbitStreamsConn|null|undefined} rabbitStreams
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.rabbitStreams = null;

            /**
             * CreateConnectionOptions redisPubsub.
             * @member {protos.args.IRedisPubSubConn|null|undefined} redisPubsub
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.redisPubsub = null;

            /**
             * CreateConnectionOptions redisStreams.
             * @member {protos.args.IRedisStreamsConn|null|undefined} redisStreams
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.redisStreams = null;

            /**
             * CreateConnectionOptions azureEventHub.
             * @member {protos.args.IAzureEventHubConn|null|undefined} azureEventHub
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.azureEventHub = null;

            /**
             * CreateConnectionOptions azureServiceBus.
             * @member {protos.args.IAzureServiceBusConn|null|undefined} azureServiceBus
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.azureServiceBus = null;

            /**
             * CreateConnectionOptions mqtt.
             * @member {protos.args.IMQTTConn|null|undefined} mqtt
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.mqtt = null;

            /**
             * CreateConnectionOptions kubemqQueue.
             * @member {protos.args.IKubeMQQueueConn|null|undefined} kubemqQueue
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.kubemqQueue = null;

            /**
             * CreateConnectionOptions gcpPubsub.
             * @member {protos.args.IGCPPubSubConn|null|undefined} gcpPubsub
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.gcpPubsub = null;

            /**
             * CreateConnectionOptions natsJetstream.
             * @member {protos.args.INatsJetstreamConn|null|undefined} natsJetstream
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.natsJetstream = null;

            /**
             * CreateConnectionOptions awsKinesis.
             * @member {protos.args.IAWSKinesisConn|null|undefined} awsKinesis
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             */
            CreateConnectionOptions.prototype.awsKinesis = null;

            /**
             * Creates a new CreateConnectionOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.CreateConnectionOptions
             * @static
             * @param {protos.opts.ICreateConnectionOptions=} [properties] Properties to set
             * @returns {protos.opts.CreateConnectionOptions} CreateConnectionOptions instance
             */
            CreateConnectionOptions.create = function create(properties) {
                return new CreateConnectionOptions(properties);
            };

            /**
             * Encodes the specified CreateConnectionOptions message. Does not implicitly {@link protos.opts.CreateConnectionOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.CreateConnectionOptions
             * @static
             * @param {protos.opts.ICreateConnectionOptions} message CreateConnectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateConnectionOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.notes);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.args.KafkaConn.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.activeMq != null && Object.hasOwnProperty.call(message, "activeMq"))
                    $root.protos.args.ActiveMQConn.encode(message.activeMq, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.awsSqs != null && Object.hasOwnProperty.call(message, "awsSqs"))
                    $root.protos.args.AWSSQSConn.encode(message.awsSqs, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.awsSns != null && Object.hasOwnProperty.call(message, "awsSns"))
                    $root.protos.args.AWSSNSConn.encode(message.awsSns, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.mongo != null && Object.hasOwnProperty.call(message, "mongo"))
                    $root.protos.args.MongoConn.encode(message.mongo, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.args.NatsConn.encode(message.nats, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.args.NatsStreamingConn.encode(message.natsStreaming, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.args.NSQConn.encode(message.nsq, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.postgres != null && Object.hasOwnProperty.call(message, "postgres"))
                    $root.protos.args.PostgresConn.encode(message.postgres, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.pulsar != null && Object.hasOwnProperty.call(message, "pulsar"))
                    $root.protos.args.PulsarConn.encode(message.pulsar, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.args.RabbitConn.encode(message.rabbit, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
                if (message.rabbitStreams != null && Object.hasOwnProperty.call(message, "rabbitStreams"))
                    $root.protos.args.RabbitStreamsConn.encode(message.rabbitStreams, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.args.RedisPubSubConn.encode(message.redisPubsub, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.args.RedisStreamsConn.encode(message.redisStreams, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.azureEventHub != null && Object.hasOwnProperty.call(message, "azureEventHub"))
                    $root.protos.args.AzureEventHubConn.encode(message.azureEventHub, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.args.AzureServiceBusConn.encode(message.azureServiceBus, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.args.MQTTConn.encode(message.mqtt, writer.uint32(/* id 116, wireType 2 =*/930).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.args.KubeMQQueueConn.encode(message.kubemqQueue, writer.uint32(/* id 117, wireType 2 =*/938).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.args.GCPPubSubConn.encode(message.gcpPubsub, writer.uint32(/* id 118, wireType 2 =*/946).fork()).ldelim();
                if (message.natsJetstream != null && Object.hasOwnProperty.call(message, "natsJetstream"))
                    $root.protos.args.NatsJetstreamConn.encode(message.natsJetstream, writer.uint32(/* id 119, wireType 2 =*/954).fork()).ldelim();
                if (message.awsKinesis != null && Object.hasOwnProperty.call(message, "awsKinesis"))
                    $root.protos.args.AWSKinesisConn.encode(message.awsKinesis, writer.uint32(/* id 120, wireType 2 =*/962).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CreateConnectionOptions message, length delimited. Does not implicitly {@link protos.opts.CreateConnectionOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.CreateConnectionOptions
             * @static
             * @param {protos.opts.ICreateConnectionOptions} message CreateConnectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateConnectionOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateConnectionOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.CreateConnectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.CreateConnectionOptions} CreateConnectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateConnectionOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.CreateConnectionOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.notes = reader.string();
                        break;
                    case 100:
                        message.kafka = $root.protos.args.KafkaConn.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.activeMq = $root.protos.args.ActiveMQConn.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.awsSqs = $root.protos.args.AWSSQSConn.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.awsSns = $root.protos.args.AWSSNSConn.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.mongo = $root.protos.args.MongoConn.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.nats = $root.protos.args.NatsConn.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.natsStreaming = $root.protos.args.NatsStreamingConn.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.nsq = $root.protos.args.NSQConn.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.postgres = $root.protos.args.PostgresConn.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.pulsar = $root.protos.args.PulsarConn.decode(reader, reader.uint32());
                        break;
                    case 110:
                        message.rabbit = $root.protos.args.RabbitConn.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.rabbitStreams = $root.protos.args.RabbitStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.redisPubsub = $root.protos.args.RedisPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.redisStreams = $root.protos.args.RedisStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.azureEventHub = $root.protos.args.AzureEventHubConn.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.azureServiceBus = $root.protos.args.AzureServiceBusConn.decode(reader, reader.uint32());
                        break;
                    case 116:
                        message.mqtt = $root.protos.args.MQTTConn.decode(reader, reader.uint32());
                        break;
                    case 117:
                        message.kubemqQueue = $root.protos.args.KubeMQQueueConn.decode(reader, reader.uint32());
                        break;
                    case 118:
                        message.gcpPubsub = $root.protos.args.GCPPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 119:
                        message.natsJetstream = $root.protos.args.NatsJetstreamConn.decode(reader, reader.uint32());
                        break;
                    case 120:
                        message.awsKinesis = $root.protos.args.AWSKinesisConn.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateConnectionOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.CreateConnectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.CreateConnectionOptions} CreateConnectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateConnectionOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateConnectionOptions message.
             * @function verify
             * @memberof protos.opts.CreateConnectionOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateConnectionOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.notes != null && message.hasOwnProperty("notes"))
                    if (!$util.isString(message.notes))
                        return "notes: string expected";
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    var error = $root.protos.args.KafkaConn.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.activeMq != null && message.hasOwnProperty("activeMq")) {
                    var error = $root.protos.args.ActiveMQConn.verify(message.activeMq);
                    if (error)
                        return "activeMq." + error;
                }
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs")) {
                    var error = $root.protos.args.AWSSQSConn.verify(message.awsSqs);
                    if (error)
                        return "awsSqs." + error;
                }
                if (message.awsSns != null && message.hasOwnProperty("awsSns")) {
                    var error = $root.protos.args.AWSSNSConn.verify(message.awsSns);
                    if (error)
                        return "awsSns." + error;
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    var error = $root.protos.args.MongoConn.verify(message.mongo);
                    if (error)
                        return "mongo." + error;
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    var error = $root.protos.args.NatsConn.verify(message.nats);
                    if (error)
                        return "nats." + error;
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    var error = $root.protos.args.NatsStreamingConn.verify(message.natsStreaming);
                    if (error)
                        return "natsStreaming." + error;
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    var error = $root.protos.args.NSQConn.verify(message.nsq);
                    if (error)
                        return "nsq." + error;
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    var error = $root.protos.args.PostgresConn.verify(message.postgres);
                    if (error)
                        return "postgres." + error;
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    var error = $root.protos.args.PulsarConn.verify(message.pulsar);
                    if (error)
                        return "pulsar." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    var error = $root.protos.args.RabbitConn.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    var error = $root.protos.args.RabbitStreamsConn.verify(message.rabbitStreams);
                    if (error)
                        return "rabbitStreams." + error;
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    var error = $root.protos.args.RedisPubSubConn.verify(message.redisPubsub);
                    if (error)
                        return "redisPubsub." + error;
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    var error = $root.protos.args.RedisStreamsConn.verify(message.redisStreams);
                    if (error)
                        return "redisStreams." + error;
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    var error = $root.protos.args.AzureEventHubConn.verify(message.azureEventHub);
                    if (error)
                        return "azureEventHub." + error;
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    var error = $root.protos.args.AzureServiceBusConn.verify(message.azureServiceBus);
                    if (error)
                        return "azureServiceBus." + error;
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    var error = $root.protos.args.MQTTConn.verify(message.mqtt);
                    if (error)
                        return "mqtt." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    var error = $root.protos.args.KubeMQQueueConn.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    var error = $root.protos.args.GCPPubSubConn.verify(message.gcpPubsub);
                    if (error)
                        return "gcpPubsub." + error;
                }
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream")) {
                    var error = $root.protos.args.NatsJetstreamConn.verify(message.natsJetstream);
                    if (error)
                        return "natsJetstream." + error;
                }
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis")) {
                    var error = $root.protos.args.AWSKinesisConn.verify(message.awsKinesis);
                    if (error)
                        return "awsKinesis." + error;
                }
                return null;
            };

            /**
             * Creates a CreateConnectionOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.CreateConnectionOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.CreateConnectionOptions} CreateConnectionOptions
             */
            CreateConnectionOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.CreateConnectionOptions)
                    return object;
                var message = new $root.protos.opts.CreateConnectionOptions();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.notes != null)
                    message.notes = String(object.notes);
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.CreateConnectionOptions.kafka: object expected");
                    message.kafka = $root.protos.args.KafkaConn.fromObject(object.kafka);
                }
                if (object.activeMq != null) {
                    if (typeof object.activeMq !== "object")
                        throw TypeError(".protos.opts.CreateConnectionOptions.activeMq: object expected");
                    message.activeMq = $root.protos.args.ActiveMQConn.fromObject(object.activeMq);
                }
                if (object.awsSqs != null) {
                    if (typeof object.awsSqs !== "object")
                        throw TypeError(".protos.opts.CreateConnectionOptions.awsSqs: object expected");
                    message.awsSqs = $root.protos.args.AWSSQSConn.fromObject(object.awsSqs);
                }
                if (object.awsSns != null) {
                    if (typeof object.awsSns !== "object")
                        throw TypeError(".protos.opts.CreateConnectionOptions.awsSns: object expected");
                    message.awsSns = $root.protos.args.AWSSNSConn.fromObject(object.awsSns);
                }
                if (object.mongo != null) {
                    if (typeof object.mongo !== "object")
                        throw TypeError(".protos.opts.CreateConnectionOptions.mongo: object expected");
                    message.mongo = $root.protos.args.MongoConn.fromObject(object.mongo);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.opts.CreateConnectionOptions.nats: object expected");
                    message.nats = $root.protos.args.NatsConn.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.opts.CreateConnectionOptions.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.args.NatsStreamingConn.fromObject(object.natsStreaming);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.CreateConnectionOptions.nsq: object expected");
                    message.nsq = $root.protos.args.NSQConn.fromObject(object.nsq);
                }
                if (object.postgres != null) {
                    if (typeof object.postgres !== "object")
                        throw TypeError(".protos.opts.CreateConnectionOptions.postgres: object expected");
                    message.postgres = $root.protos.args.PostgresConn.fromObject(object.postgres);
                }
                if (object.pulsar != null) {
                    if (typeof object.pulsar !== "object")
                        throw TypeError(".protos.opts.CreateConnectionOptions.pulsar: object expected");
                    message.pulsar = $root.protos.args.PulsarConn.fromObject(object.pulsar);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.CreateConnectionOptions.rabbit: object expected");
                    message.rabbit = $root.protos.args.RabbitConn.fromObject(object.rabbit);
                }
                if (object.rabbitStreams != null) {
                    if (typeof object.rabbitStreams !== "object")
                        throw TypeError(".protos.opts.CreateConnectionOptions.rabbitStreams: object expected");
                    message.rabbitStreams = $root.protos.args.RabbitStreamsConn.fromObject(object.rabbitStreams);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.CreateConnectionOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.args.RedisPubSubConn.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.CreateConnectionOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.args.RedisStreamsConn.fromObject(object.redisStreams);
                }
                if (object.azureEventHub != null) {
                    if (typeof object.azureEventHub !== "object")
                        throw TypeError(".protos.opts.CreateConnectionOptions.azureEventHub: object expected");
                    message.azureEventHub = $root.protos.args.AzureEventHubConn.fromObject(object.azureEventHub);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.CreateConnectionOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.args.AzureServiceBusConn.fromObject(object.azureServiceBus);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.CreateConnectionOptions.mqtt: object expected");
                    message.mqtt = $root.protos.args.MQTTConn.fromObject(object.mqtt);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.CreateConnectionOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.args.KubeMQQueueConn.fromObject(object.kubemqQueue);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.CreateConnectionOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.args.GCPPubSubConn.fromObject(object.gcpPubsub);
                }
                if (object.natsJetstream != null) {
                    if (typeof object.natsJetstream !== "object")
                        throw TypeError(".protos.opts.CreateConnectionOptions.natsJetstream: object expected");
                    message.natsJetstream = $root.protos.args.NatsJetstreamConn.fromObject(object.natsJetstream);
                }
                if (object.awsKinesis != null) {
                    if (typeof object.awsKinesis !== "object")
                        throw TypeError(".protos.opts.CreateConnectionOptions.awsKinesis: object expected");
                    message.awsKinesis = $root.protos.args.AWSKinesisConn.fromObject(object.awsKinesis);
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateConnectionOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.CreateConnectionOptions
             * @static
             * @param {protos.opts.CreateConnectionOptions} message CreateConnectionOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateConnectionOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.notes = "";
                    object.kafka = null;
                    object.activeMq = null;
                    object.awsSqs = null;
                    object.awsSns = null;
                    object.mongo = null;
                    object.nats = null;
                    object.natsStreaming = null;
                    object.nsq = null;
                    object.postgres = null;
                    object.pulsar = null;
                    object.rabbit = null;
                    object.rabbitStreams = null;
                    object.redisPubsub = null;
                    object.redisStreams = null;
                    object.azureEventHub = null;
                    object.azureServiceBus = null;
                    object.mqtt = null;
                    object.kubemqQueue = null;
                    object.gcpPubsub = null;
                    object.natsJetstream = null;
                    object.awsKinesis = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.notes != null && message.hasOwnProperty("notes"))
                    object.notes = message.notes;
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.args.KafkaConn.toObject(message.kafka, options);
                if (message.activeMq != null && message.hasOwnProperty("activeMq"))
                    object.activeMq = $root.protos.args.ActiveMQConn.toObject(message.activeMq, options);
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs"))
                    object.awsSqs = $root.protos.args.AWSSQSConn.toObject(message.awsSqs, options);
                if (message.awsSns != null && message.hasOwnProperty("awsSns"))
                    object.awsSns = $root.protos.args.AWSSNSConn.toObject(message.awsSns, options);
                if (message.mongo != null && message.hasOwnProperty("mongo"))
                    object.mongo = $root.protos.args.MongoConn.toObject(message.mongo, options);
                if (message.nats != null && message.hasOwnProperty("nats"))
                    object.nats = $root.protos.args.NatsConn.toObject(message.nats, options);
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming"))
                    object.natsStreaming = $root.protos.args.NatsStreamingConn.toObject(message.natsStreaming, options);
                if (message.nsq != null && message.hasOwnProperty("nsq"))
                    object.nsq = $root.protos.args.NSQConn.toObject(message.nsq, options);
                if (message.postgres != null && message.hasOwnProperty("postgres"))
                    object.postgres = $root.protos.args.PostgresConn.toObject(message.postgres, options);
                if (message.pulsar != null && message.hasOwnProperty("pulsar"))
                    object.pulsar = $root.protos.args.PulsarConn.toObject(message.pulsar, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.args.RabbitConn.toObject(message.rabbit, options);
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams"))
                    object.rabbitStreams = $root.protos.args.RabbitStreamsConn.toObject(message.rabbitStreams, options);
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub"))
                    object.redisPubsub = $root.protos.args.RedisPubSubConn.toObject(message.redisPubsub, options);
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams"))
                    object.redisStreams = $root.protos.args.RedisStreamsConn.toObject(message.redisStreams, options);
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub"))
                    object.azureEventHub = $root.protos.args.AzureEventHubConn.toObject(message.azureEventHub, options);
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus"))
                    object.azureServiceBus = $root.protos.args.AzureServiceBusConn.toObject(message.azureServiceBus, options);
                if (message.mqtt != null && message.hasOwnProperty("mqtt"))
                    object.mqtt = $root.protos.args.MQTTConn.toObject(message.mqtt, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.args.KubeMQQueueConn.toObject(message.kubemqQueue, options);
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub"))
                    object.gcpPubsub = $root.protos.args.GCPPubSubConn.toObject(message.gcpPubsub, options);
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream"))
                    object.natsJetstream = $root.protos.args.NatsJetstreamConn.toObject(message.natsJetstream, options);
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis"))
                    object.awsKinesis = $root.protos.args.AWSKinesisConn.toObject(message.awsKinesis, options);
                return object;
            };

            /**
             * Converts this CreateConnectionOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.CreateConnectionOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateConnectionOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateConnectionOptions;
        })();

        opts.DeleteConnectionOptions = (function() {

            /**
             * Properties of a DeleteConnectionOptions.
             * @memberof protos.opts
             * @interface IDeleteConnectionOptions
             * @property {string|null} [id] DeleteConnectionOptions id
             */

            /**
             * Constructs a new DeleteConnectionOptions.
             * @memberof protos.opts
             * @classdesc Represents a DeleteConnectionOptions.
             * @implements IDeleteConnectionOptions
             * @constructor
             * @param {protos.opts.IDeleteConnectionOptions=} [properties] Properties to set
             */
            function DeleteConnectionOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteConnectionOptions id.
             * @member {string} id
             * @memberof protos.opts.DeleteConnectionOptions
             * @instance
             */
            DeleteConnectionOptions.prototype.id = "";

            /**
             * Creates a new DeleteConnectionOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DeleteConnectionOptions
             * @static
             * @param {protos.opts.IDeleteConnectionOptions=} [properties] Properties to set
             * @returns {protos.opts.DeleteConnectionOptions} DeleteConnectionOptions instance
             */
            DeleteConnectionOptions.create = function create(properties) {
                return new DeleteConnectionOptions(properties);
            };

            /**
             * Encodes the specified DeleteConnectionOptions message. Does not implicitly {@link protos.opts.DeleteConnectionOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DeleteConnectionOptions
             * @static
             * @param {protos.opts.IDeleteConnectionOptions} message DeleteConnectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteConnectionOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified DeleteConnectionOptions message, length delimited. Does not implicitly {@link protos.opts.DeleteConnectionOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DeleteConnectionOptions
             * @static
             * @param {protos.opts.IDeleteConnectionOptions} message DeleteConnectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteConnectionOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteConnectionOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DeleteConnectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DeleteConnectionOptions} DeleteConnectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteConnectionOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DeleteConnectionOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteConnectionOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DeleteConnectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DeleteConnectionOptions} DeleteConnectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteConnectionOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteConnectionOptions message.
             * @function verify
             * @memberof protos.opts.DeleteConnectionOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteConnectionOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a DeleteConnectionOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DeleteConnectionOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DeleteConnectionOptions} DeleteConnectionOptions
             */
            DeleteConnectionOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DeleteConnectionOptions)
                    return object;
                var message = new $root.protos.opts.DeleteConnectionOptions();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a DeleteConnectionOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DeleteConnectionOptions
             * @static
             * @param {protos.opts.DeleteConnectionOptions} message DeleteConnectionOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteConnectionOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this DeleteConnectionOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DeleteConnectionOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteConnectionOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DeleteConnectionOptions;
        })();

        opts.GetRelayOptions = (function() {

            /**
             * Properties of a GetRelayOptions.
             * @memberof protos.opts
             * @interface IGetRelayOptions
             * @property {string|null} [id] GetRelayOptions id
             */

            /**
             * Constructs a new GetRelayOptions.
             * @memberof protos.opts
             * @classdesc Represents a GetRelayOptions.
             * @implements IGetRelayOptions
             * @constructor
             * @param {protos.opts.IGetRelayOptions=} [properties] Properties to set
             */
            function GetRelayOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetRelayOptions id.
             * @member {string} id
             * @memberof protos.opts.GetRelayOptions
             * @instance
             */
            GetRelayOptions.prototype.id = "";

            /**
             * Creates a new GetRelayOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.GetRelayOptions
             * @static
             * @param {protos.opts.IGetRelayOptions=} [properties] Properties to set
             * @returns {protos.opts.GetRelayOptions} GetRelayOptions instance
             */
            GetRelayOptions.create = function create(properties) {
                return new GetRelayOptions(properties);
            };

            /**
             * Encodes the specified GetRelayOptions message. Does not implicitly {@link protos.opts.GetRelayOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.GetRelayOptions
             * @static
             * @param {protos.opts.IGetRelayOptions} message GetRelayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRelayOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified GetRelayOptions message, length delimited. Does not implicitly {@link protos.opts.GetRelayOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.GetRelayOptions
             * @static
             * @param {protos.opts.IGetRelayOptions} message GetRelayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRelayOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRelayOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.GetRelayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.GetRelayOptions} GetRelayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRelayOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.GetRelayOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetRelayOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.GetRelayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.GetRelayOptions} GetRelayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRelayOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRelayOptions message.
             * @function verify
             * @memberof protos.opts.GetRelayOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRelayOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a GetRelayOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.GetRelayOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.GetRelayOptions} GetRelayOptions
             */
            GetRelayOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.GetRelayOptions)
                    return object;
                var message = new $root.protos.opts.GetRelayOptions();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a GetRelayOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.GetRelayOptions
             * @static
             * @param {protos.opts.GetRelayOptions} message GetRelayOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetRelayOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this GetRelayOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.GetRelayOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetRelayOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetRelayOptions;
        })();

        opts.CreateRelayOptions = (function() {

            /**
             * Properties of a CreateRelayOptions.
             * @memberof protos.opts
             * @interface ICreateRelayOptions
             * @property {string|null} [connectionId] CreateRelayOptions connectionId
             * @property {string|null} [collectionToken] CreateRelayOptions collectionToken
             * @property {number|null} [batchSize] CreateRelayOptions batchSize
             * @property {number|null} [batchMaxRetry] CreateRelayOptions batchMaxRetry
             * @property {number|null} [numWorkers] CreateRelayOptions numWorkers
             * @property {string|null} [streamdalGrpcAddress] CreateRelayOptions streamdalGrpcAddress
             * @property {boolean|null} [streamdalGrpcDisableTls] CreateRelayOptions streamdalGrpcDisableTls
             * @property {number|null} [streamdalGrpcTimeoutSeconds] CreateRelayOptions streamdalGrpcTimeoutSeconds
             * @property {boolean|null} [deadLetter] CreateRelayOptions deadLetter
             * @property {protos.args.IKafkaRelayArgs|null} [kafka] CreateRelayOptions kafka
             * @property {protos.args.IAWSSQSRelayArgs|null} [awsSqs] CreateRelayOptions awsSqs
             * @property {protos.args.IMongoReadArgs|null} [mongo] CreateRelayOptions mongo
             * @property {protos.args.INSQReadArgs|null} [nsq] CreateRelayOptions nsq
             * @property {protos.args.IRabbitReadArgs|null} [rabbit] CreateRelayOptions rabbit
             * @property {protos.args.IMQTTReadArgs|null} [mqtt] CreateRelayOptions mqtt
             * @property {protos.args.IAzureServiceBusReadArgs|null} [azureServiceBus] CreateRelayOptions azureServiceBus
             * @property {protos.args.IGCPPubSubReadArgs|null} [gcpPubsub] CreateRelayOptions gcpPubsub
             * @property {protos.args.IKubeMQQueueReadArgs|null} [kubemqQueue] CreateRelayOptions kubemqQueue
             * @property {protos.args.IRedisPubSubReadArgs|null} [redisPubsub] CreateRelayOptions redisPubsub
             * @property {protos.args.IRedisStreamsReadArgs|null} [redisStreams] CreateRelayOptions redisStreams
             * @property {protos.args.IPostgresReadArgs|null} [postgres] CreateRelayOptions postgres
             * @property {protos.args.INatsReadArgs|null} [nats] CreateRelayOptions nats
             * @property {protos.args.INatsStreamingReadArgs|null} [natsStreaming] CreateRelayOptions natsStreaming
             * @property {protos.args.INatsJetstreamReadArgs|null} [natsJetstream] CreateRelayOptions natsJetstream
             */

            /**
             * Constructs a new CreateRelayOptions.
             * @memberof protos.opts
             * @classdesc Represents a CreateRelayOptions.
             * @implements ICreateRelayOptions
             * @constructor
             * @param {protos.opts.ICreateRelayOptions=} [properties] Properties to set
             */
            function CreateRelayOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateRelayOptions connectionId.
             * @member {string} connectionId
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.connectionId = "";

            /**
             * CreateRelayOptions collectionToken.
             * @member {string} collectionToken
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.collectionToken = "";

            /**
             * CreateRelayOptions batchSize.
             * @member {number} batchSize
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.batchSize = 0;

            /**
             * CreateRelayOptions batchMaxRetry.
             * @member {number} batchMaxRetry
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.batchMaxRetry = 0;

            /**
             * CreateRelayOptions numWorkers.
             * @member {number} numWorkers
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.numWorkers = 0;

            /**
             * CreateRelayOptions streamdalGrpcAddress.
             * @member {string} streamdalGrpcAddress
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.streamdalGrpcAddress = "";

            /**
             * CreateRelayOptions streamdalGrpcDisableTls.
             * @member {boolean} streamdalGrpcDisableTls
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.streamdalGrpcDisableTls = false;

            /**
             * CreateRelayOptions streamdalGrpcTimeoutSeconds.
             * @member {number} streamdalGrpcTimeoutSeconds
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.streamdalGrpcTimeoutSeconds = 0;

            /**
             * CreateRelayOptions deadLetter.
             * @member {boolean} deadLetter
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.deadLetter = false;

            /**
             * CreateRelayOptions kafka.
             * @member {protos.args.IKafkaRelayArgs|null|undefined} kafka
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.kafka = null;

            /**
             * CreateRelayOptions awsSqs.
             * @member {protos.args.IAWSSQSRelayArgs|null|undefined} awsSqs
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.awsSqs = null;

            /**
             * CreateRelayOptions mongo.
             * @member {protos.args.IMongoReadArgs|null|undefined} mongo
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.mongo = null;

            /**
             * CreateRelayOptions nsq.
             * @member {protos.args.INSQReadArgs|null|undefined} nsq
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.nsq = null;

            /**
             * CreateRelayOptions rabbit.
             * @member {protos.args.IRabbitReadArgs|null|undefined} rabbit
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.rabbit = null;

            /**
             * CreateRelayOptions mqtt.
             * @member {protos.args.IMQTTReadArgs|null|undefined} mqtt
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.mqtt = null;

            /**
             * CreateRelayOptions azureServiceBus.
             * @member {protos.args.IAzureServiceBusReadArgs|null|undefined} azureServiceBus
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.azureServiceBus = null;

            /**
             * CreateRelayOptions gcpPubsub.
             * @member {protos.args.IGCPPubSubReadArgs|null|undefined} gcpPubsub
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.gcpPubsub = null;

            /**
             * CreateRelayOptions kubemqQueue.
             * @member {protos.args.IKubeMQQueueReadArgs|null|undefined} kubemqQueue
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.kubemqQueue = null;

            /**
             * CreateRelayOptions redisPubsub.
             * @member {protos.args.IRedisPubSubReadArgs|null|undefined} redisPubsub
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.redisPubsub = null;

            /**
             * CreateRelayOptions redisStreams.
             * @member {protos.args.IRedisStreamsReadArgs|null|undefined} redisStreams
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.redisStreams = null;

            /**
             * CreateRelayOptions postgres.
             * @member {protos.args.IPostgresReadArgs|null|undefined} postgres
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.postgres = null;

            /**
             * CreateRelayOptions nats.
             * @member {protos.args.INatsReadArgs|null|undefined} nats
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.nats = null;

            /**
             * CreateRelayOptions natsStreaming.
             * @member {protos.args.INatsStreamingReadArgs|null|undefined} natsStreaming
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.natsStreaming = null;

            /**
             * CreateRelayOptions natsJetstream.
             * @member {protos.args.INatsJetstreamReadArgs|null|undefined} natsJetstream
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             */
            CreateRelayOptions.prototype.natsJetstream = null;

            /**
             * Creates a new CreateRelayOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.CreateRelayOptions
             * @static
             * @param {protos.opts.ICreateRelayOptions=} [properties] Properties to set
             * @returns {protos.opts.CreateRelayOptions} CreateRelayOptions instance
             */
            CreateRelayOptions.create = function create(properties) {
                return new CreateRelayOptions(properties);
            };

            /**
             * Encodes the specified CreateRelayOptions message. Does not implicitly {@link protos.opts.CreateRelayOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.CreateRelayOptions
             * @static
             * @param {protos.opts.ICreateRelayOptions} message CreateRelayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateRelayOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
                if (message.collectionToken != null && Object.hasOwnProperty.call(message, "collectionToken"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.collectionToken);
                if (message.batchSize != null && Object.hasOwnProperty.call(message, "batchSize"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.batchSize);
                if (message.batchMaxRetry != null && Object.hasOwnProperty.call(message, "batchMaxRetry"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.batchMaxRetry);
                if (message.numWorkers != null && Object.hasOwnProperty.call(message, "numWorkers"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.numWorkers);
                if (message.streamdalGrpcAddress != null && Object.hasOwnProperty.call(message, "streamdalGrpcAddress"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.streamdalGrpcAddress);
                if (message.streamdalGrpcDisableTls != null && Object.hasOwnProperty.call(message, "streamdalGrpcDisableTls"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.streamdalGrpcDisableTls);
                if (message.streamdalGrpcTimeoutSeconds != null && Object.hasOwnProperty.call(message, "streamdalGrpcTimeoutSeconds"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.streamdalGrpcTimeoutSeconds);
                if (message.deadLetter != null && Object.hasOwnProperty.call(message, "deadLetter"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.deadLetter);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.args.KafkaRelayArgs.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.awsSqs != null && Object.hasOwnProperty.call(message, "awsSqs"))
                    $root.protos.args.AWSSQSRelayArgs.encode(message.awsSqs, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.mongo != null && Object.hasOwnProperty.call(message, "mongo"))
                    $root.protos.args.MongoReadArgs.encode(message.mongo, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.args.NSQReadArgs.encode(message.nsq, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.args.RabbitReadArgs.encode(message.rabbit, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.args.MQTTReadArgs.encode(message.mqtt, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.args.AzureServiceBusReadArgs.encode(message.azureServiceBus, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.args.GCPPubSubReadArgs.encode(message.gcpPubsub, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.args.KubeMQQueueReadArgs.encode(message.kubemqQueue, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.args.RedisPubSubReadArgs.encode(message.redisPubsub, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.args.RedisStreamsReadArgs.encode(message.redisStreams, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.postgres != null && Object.hasOwnProperty.call(message, "postgres"))
                    $root.protos.args.PostgresReadArgs.encode(message.postgres, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.args.NatsReadArgs.encode(message.nats, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.args.NatsStreamingReadArgs.encode(message.natsStreaming, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.natsJetstream != null && Object.hasOwnProperty.call(message, "natsJetstream"))
                    $root.protos.args.NatsJetstreamReadArgs.encode(message.natsJetstream, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CreateRelayOptions message, length delimited. Does not implicitly {@link protos.opts.CreateRelayOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.CreateRelayOptions
             * @static
             * @param {protos.opts.ICreateRelayOptions} message CreateRelayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateRelayOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateRelayOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.CreateRelayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.CreateRelayOptions} CreateRelayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateRelayOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.CreateRelayOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.connectionId = reader.string();
                        break;
                    case 2:
                        message.collectionToken = reader.string();
                        break;
                    case 3:
                        message.batchSize = reader.int32();
                        break;
                    case 4:
                        message.batchMaxRetry = reader.int32();
                        break;
                    case 5:
                        message.numWorkers = reader.int32();
                        break;
                    case 6:
                        message.streamdalGrpcAddress = reader.string();
                        break;
                    case 7:
                        message.streamdalGrpcDisableTls = reader.bool();
                        break;
                    case 8:
                        message.streamdalGrpcTimeoutSeconds = reader.int32();
                        break;
                    case 9:
                        message.deadLetter = reader.bool();
                        break;
                    case 100:
                        message.kafka = $root.protos.args.KafkaRelayArgs.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.awsSqs = $root.protos.args.AWSSQSRelayArgs.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.mongo = $root.protos.args.MongoReadArgs.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.nsq = $root.protos.args.NSQReadArgs.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.rabbit = $root.protos.args.RabbitReadArgs.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.mqtt = $root.protos.args.MQTTReadArgs.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.azureServiceBus = $root.protos.args.AzureServiceBusReadArgs.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.gcpPubsub = $root.protos.args.GCPPubSubReadArgs.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.kubemqQueue = $root.protos.args.KubeMQQueueReadArgs.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.redisPubsub = $root.protos.args.RedisPubSubReadArgs.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.redisStreams = $root.protos.args.RedisStreamsReadArgs.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.postgres = $root.protos.args.PostgresReadArgs.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.nats = $root.protos.args.NatsReadArgs.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.natsStreaming = $root.protos.args.NatsStreamingReadArgs.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.natsJetstream = $root.protos.args.NatsJetstreamReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateRelayOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.CreateRelayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.CreateRelayOptions} CreateRelayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateRelayOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateRelayOptions message.
             * @function verify
             * @memberof protos.opts.CreateRelayOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateRelayOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    if (!$util.isString(message.connectionId))
                        return "connectionId: string expected";
                if (message.collectionToken != null && message.hasOwnProperty("collectionToken"))
                    if (!$util.isString(message.collectionToken))
                        return "collectionToken: string expected";
                if (message.batchSize != null && message.hasOwnProperty("batchSize"))
                    if (!$util.isInteger(message.batchSize))
                        return "batchSize: integer expected";
                if (message.batchMaxRetry != null && message.hasOwnProperty("batchMaxRetry"))
                    if (!$util.isInteger(message.batchMaxRetry))
                        return "batchMaxRetry: integer expected";
                if (message.numWorkers != null && message.hasOwnProperty("numWorkers"))
                    if (!$util.isInteger(message.numWorkers))
                        return "numWorkers: integer expected";
                if (message.streamdalGrpcAddress != null && message.hasOwnProperty("streamdalGrpcAddress"))
                    if (!$util.isString(message.streamdalGrpcAddress))
                        return "streamdalGrpcAddress: string expected";
                if (message.streamdalGrpcDisableTls != null && message.hasOwnProperty("streamdalGrpcDisableTls"))
                    if (typeof message.streamdalGrpcDisableTls !== "boolean")
                        return "streamdalGrpcDisableTls: boolean expected";
                if (message.streamdalGrpcTimeoutSeconds != null && message.hasOwnProperty("streamdalGrpcTimeoutSeconds"))
                    if (!$util.isInteger(message.streamdalGrpcTimeoutSeconds))
                        return "streamdalGrpcTimeoutSeconds: integer expected";
                if (message.deadLetter != null && message.hasOwnProperty("deadLetter"))
                    if (typeof message.deadLetter !== "boolean")
                        return "deadLetter: boolean expected";
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    var error = $root.protos.args.KafkaRelayArgs.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs")) {
                    var error = $root.protos.args.AWSSQSRelayArgs.verify(message.awsSqs);
                    if (error)
                        return "awsSqs." + error;
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    var error = $root.protos.args.MongoReadArgs.verify(message.mongo);
                    if (error)
                        return "mongo." + error;
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    var error = $root.protos.args.NSQReadArgs.verify(message.nsq);
                    if (error)
                        return "nsq." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    var error = $root.protos.args.RabbitReadArgs.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    var error = $root.protos.args.MQTTReadArgs.verify(message.mqtt);
                    if (error)
                        return "mqtt." + error;
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    var error = $root.protos.args.AzureServiceBusReadArgs.verify(message.azureServiceBus);
                    if (error)
                        return "azureServiceBus." + error;
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    var error = $root.protos.args.GCPPubSubReadArgs.verify(message.gcpPubsub);
                    if (error)
                        return "gcpPubsub." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    var error = $root.protos.args.KubeMQQueueReadArgs.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    var error = $root.protos.args.RedisPubSubReadArgs.verify(message.redisPubsub);
                    if (error)
                        return "redisPubsub." + error;
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    var error = $root.protos.args.RedisStreamsReadArgs.verify(message.redisStreams);
                    if (error)
                        return "redisStreams." + error;
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    var error = $root.protos.args.PostgresReadArgs.verify(message.postgres);
                    if (error)
                        return "postgres." + error;
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    var error = $root.protos.args.NatsReadArgs.verify(message.nats);
                    if (error)
                        return "nats." + error;
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    var error = $root.protos.args.NatsStreamingReadArgs.verify(message.natsStreaming);
                    if (error)
                        return "natsStreaming." + error;
                }
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream")) {
                    var error = $root.protos.args.NatsJetstreamReadArgs.verify(message.natsJetstream);
                    if (error)
                        return "natsJetstream." + error;
                }
                return null;
            };

            /**
             * Creates a CreateRelayOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.CreateRelayOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.CreateRelayOptions} CreateRelayOptions
             */
            CreateRelayOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.CreateRelayOptions)
                    return object;
                var message = new $root.protos.opts.CreateRelayOptions();
                if (object.connectionId != null)
                    message.connectionId = String(object.connectionId);
                if (object.collectionToken != null)
                    message.collectionToken = String(object.collectionToken);
                if (object.batchSize != null)
                    message.batchSize = object.batchSize | 0;
                if (object.batchMaxRetry != null)
                    message.batchMaxRetry = object.batchMaxRetry | 0;
                if (object.numWorkers != null)
                    message.numWorkers = object.numWorkers | 0;
                if (object.streamdalGrpcAddress != null)
                    message.streamdalGrpcAddress = String(object.streamdalGrpcAddress);
                if (object.streamdalGrpcDisableTls != null)
                    message.streamdalGrpcDisableTls = Boolean(object.streamdalGrpcDisableTls);
                if (object.streamdalGrpcTimeoutSeconds != null)
                    message.streamdalGrpcTimeoutSeconds = object.streamdalGrpcTimeoutSeconds | 0;
                if (object.deadLetter != null)
                    message.deadLetter = Boolean(object.deadLetter);
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.CreateRelayOptions.kafka: object expected");
                    message.kafka = $root.protos.args.KafkaRelayArgs.fromObject(object.kafka);
                }
                if (object.awsSqs != null) {
                    if (typeof object.awsSqs !== "object")
                        throw TypeError(".protos.opts.CreateRelayOptions.awsSqs: object expected");
                    message.awsSqs = $root.protos.args.AWSSQSRelayArgs.fromObject(object.awsSqs);
                }
                if (object.mongo != null) {
                    if (typeof object.mongo !== "object")
                        throw TypeError(".protos.opts.CreateRelayOptions.mongo: object expected");
                    message.mongo = $root.protos.args.MongoReadArgs.fromObject(object.mongo);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.CreateRelayOptions.nsq: object expected");
                    message.nsq = $root.protos.args.NSQReadArgs.fromObject(object.nsq);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.CreateRelayOptions.rabbit: object expected");
                    message.rabbit = $root.protos.args.RabbitReadArgs.fromObject(object.rabbit);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.CreateRelayOptions.mqtt: object expected");
                    message.mqtt = $root.protos.args.MQTTReadArgs.fromObject(object.mqtt);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.CreateRelayOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.args.AzureServiceBusReadArgs.fromObject(object.azureServiceBus);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.CreateRelayOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.args.GCPPubSubReadArgs.fromObject(object.gcpPubsub);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.CreateRelayOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.args.KubeMQQueueReadArgs.fromObject(object.kubemqQueue);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.CreateRelayOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.args.RedisPubSubReadArgs.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.CreateRelayOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.args.RedisStreamsReadArgs.fromObject(object.redisStreams);
                }
                if (object.postgres != null) {
                    if (typeof object.postgres !== "object")
                        throw TypeError(".protos.opts.CreateRelayOptions.postgres: object expected");
                    message.postgres = $root.protos.args.PostgresReadArgs.fromObject(object.postgres);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.opts.CreateRelayOptions.nats: object expected");
                    message.nats = $root.protos.args.NatsReadArgs.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.opts.CreateRelayOptions.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.args.NatsStreamingReadArgs.fromObject(object.natsStreaming);
                }
                if (object.natsJetstream != null) {
                    if (typeof object.natsJetstream !== "object")
                        throw TypeError(".protos.opts.CreateRelayOptions.natsJetstream: object expected");
                    message.natsJetstream = $root.protos.args.NatsJetstreamReadArgs.fromObject(object.natsJetstream);
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateRelayOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.CreateRelayOptions
             * @static
             * @param {protos.opts.CreateRelayOptions} message CreateRelayOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateRelayOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.connectionId = "";
                    object.collectionToken = "";
                    object.batchSize = 0;
                    object.batchMaxRetry = 0;
                    object.numWorkers = 0;
                    object.streamdalGrpcAddress = "";
                    object.streamdalGrpcDisableTls = false;
                    object.streamdalGrpcTimeoutSeconds = 0;
                    object.deadLetter = false;
                    object.kafka = null;
                    object.awsSqs = null;
                    object.mongo = null;
                    object.nsq = null;
                    object.rabbit = null;
                    object.mqtt = null;
                    object.azureServiceBus = null;
                    object.gcpPubsub = null;
                    object.kubemqQueue = null;
                    object.redisPubsub = null;
                    object.redisStreams = null;
                    object.postgres = null;
                    object.nats = null;
                    object.natsStreaming = null;
                    object.natsJetstream = null;
                }
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    object.connectionId = message.connectionId;
                if (message.collectionToken != null && message.hasOwnProperty("collectionToken"))
                    object.collectionToken = message.collectionToken;
                if (message.batchSize != null && message.hasOwnProperty("batchSize"))
                    object.batchSize = message.batchSize;
                if (message.batchMaxRetry != null && message.hasOwnProperty("batchMaxRetry"))
                    object.batchMaxRetry = message.batchMaxRetry;
                if (message.numWorkers != null && message.hasOwnProperty("numWorkers"))
                    object.numWorkers = message.numWorkers;
                if (message.streamdalGrpcAddress != null && message.hasOwnProperty("streamdalGrpcAddress"))
                    object.streamdalGrpcAddress = message.streamdalGrpcAddress;
                if (message.streamdalGrpcDisableTls != null && message.hasOwnProperty("streamdalGrpcDisableTls"))
                    object.streamdalGrpcDisableTls = message.streamdalGrpcDisableTls;
                if (message.streamdalGrpcTimeoutSeconds != null && message.hasOwnProperty("streamdalGrpcTimeoutSeconds"))
                    object.streamdalGrpcTimeoutSeconds = message.streamdalGrpcTimeoutSeconds;
                if (message.deadLetter != null && message.hasOwnProperty("deadLetter"))
                    object.deadLetter = message.deadLetter;
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.args.KafkaRelayArgs.toObject(message.kafka, options);
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs"))
                    object.awsSqs = $root.protos.args.AWSSQSRelayArgs.toObject(message.awsSqs, options);
                if (message.mongo != null && message.hasOwnProperty("mongo"))
                    object.mongo = $root.protos.args.MongoReadArgs.toObject(message.mongo, options);
                if (message.nsq != null && message.hasOwnProperty("nsq"))
                    object.nsq = $root.protos.args.NSQReadArgs.toObject(message.nsq, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.args.RabbitReadArgs.toObject(message.rabbit, options);
                if (message.mqtt != null && message.hasOwnProperty("mqtt"))
                    object.mqtt = $root.protos.args.MQTTReadArgs.toObject(message.mqtt, options);
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus"))
                    object.azureServiceBus = $root.protos.args.AzureServiceBusReadArgs.toObject(message.azureServiceBus, options);
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub"))
                    object.gcpPubsub = $root.protos.args.GCPPubSubReadArgs.toObject(message.gcpPubsub, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.args.KubeMQQueueReadArgs.toObject(message.kubemqQueue, options);
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub"))
                    object.redisPubsub = $root.protos.args.RedisPubSubReadArgs.toObject(message.redisPubsub, options);
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams"))
                    object.redisStreams = $root.protos.args.RedisStreamsReadArgs.toObject(message.redisStreams, options);
                if (message.postgres != null && message.hasOwnProperty("postgres"))
                    object.postgres = $root.protos.args.PostgresReadArgs.toObject(message.postgres, options);
                if (message.nats != null && message.hasOwnProperty("nats"))
                    object.nats = $root.protos.args.NatsReadArgs.toObject(message.nats, options);
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming"))
                    object.natsStreaming = $root.protos.args.NatsStreamingReadArgs.toObject(message.natsStreaming, options);
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream"))
                    object.natsJetstream = $root.protos.args.NatsJetstreamReadArgs.toObject(message.natsJetstream, options);
                return object;
            };

            /**
             * Converts this CreateRelayOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.CreateRelayOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateRelayOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateRelayOptions;
        })();

        opts.DeleteRelayOptions = (function() {

            /**
             * Properties of a DeleteRelayOptions.
             * @memberof protos.opts
             * @interface IDeleteRelayOptions
             * @property {string|null} [id] DeleteRelayOptions id
             */

            /**
             * Constructs a new DeleteRelayOptions.
             * @memberof protos.opts
             * @classdesc Represents a DeleteRelayOptions.
             * @implements IDeleteRelayOptions
             * @constructor
             * @param {protos.opts.IDeleteRelayOptions=} [properties] Properties to set
             */
            function DeleteRelayOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteRelayOptions id.
             * @member {string} id
             * @memberof protos.opts.DeleteRelayOptions
             * @instance
             */
            DeleteRelayOptions.prototype.id = "";

            /**
             * Creates a new DeleteRelayOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DeleteRelayOptions
             * @static
             * @param {protos.opts.IDeleteRelayOptions=} [properties] Properties to set
             * @returns {protos.opts.DeleteRelayOptions} DeleteRelayOptions instance
             */
            DeleteRelayOptions.create = function create(properties) {
                return new DeleteRelayOptions(properties);
            };

            /**
             * Encodes the specified DeleteRelayOptions message. Does not implicitly {@link protos.opts.DeleteRelayOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DeleteRelayOptions
             * @static
             * @param {protos.opts.IDeleteRelayOptions} message DeleteRelayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteRelayOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified DeleteRelayOptions message, length delimited. Does not implicitly {@link protos.opts.DeleteRelayOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DeleteRelayOptions
             * @static
             * @param {protos.opts.IDeleteRelayOptions} message DeleteRelayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteRelayOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteRelayOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DeleteRelayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DeleteRelayOptions} DeleteRelayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteRelayOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DeleteRelayOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteRelayOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DeleteRelayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DeleteRelayOptions} DeleteRelayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteRelayOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteRelayOptions message.
             * @function verify
             * @memberof protos.opts.DeleteRelayOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteRelayOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a DeleteRelayOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DeleteRelayOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DeleteRelayOptions} DeleteRelayOptions
             */
            DeleteRelayOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DeleteRelayOptions)
                    return object;
                var message = new $root.protos.opts.DeleteRelayOptions();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a DeleteRelayOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DeleteRelayOptions
             * @static
             * @param {protos.opts.DeleteRelayOptions} message DeleteRelayOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteRelayOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this DeleteRelayOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DeleteRelayOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteRelayOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DeleteRelayOptions;
        })();

        opts.StopRelayOptions = (function() {

            /**
             * Properties of a StopRelayOptions.
             * @memberof protos.opts
             * @interface IStopRelayOptions
             * @property {string|null} [id] StopRelayOptions id
             */

            /**
             * Constructs a new StopRelayOptions.
             * @memberof protos.opts
             * @classdesc Represents a StopRelayOptions.
             * @implements IStopRelayOptions
             * @constructor
             * @param {protos.opts.IStopRelayOptions=} [properties] Properties to set
             */
            function StopRelayOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StopRelayOptions id.
             * @member {string} id
             * @memberof protos.opts.StopRelayOptions
             * @instance
             */
            StopRelayOptions.prototype.id = "";

            /**
             * Creates a new StopRelayOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.StopRelayOptions
             * @static
             * @param {protos.opts.IStopRelayOptions=} [properties] Properties to set
             * @returns {protos.opts.StopRelayOptions} StopRelayOptions instance
             */
            StopRelayOptions.create = function create(properties) {
                return new StopRelayOptions(properties);
            };

            /**
             * Encodes the specified StopRelayOptions message. Does not implicitly {@link protos.opts.StopRelayOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.StopRelayOptions
             * @static
             * @param {protos.opts.IStopRelayOptions} message StopRelayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StopRelayOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified StopRelayOptions message, length delimited. Does not implicitly {@link protos.opts.StopRelayOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.StopRelayOptions
             * @static
             * @param {protos.opts.IStopRelayOptions} message StopRelayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StopRelayOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StopRelayOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.StopRelayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.StopRelayOptions} StopRelayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StopRelayOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.StopRelayOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StopRelayOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.StopRelayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.StopRelayOptions} StopRelayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StopRelayOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StopRelayOptions message.
             * @function verify
             * @memberof protos.opts.StopRelayOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StopRelayOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a StopRelayOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.StopRelayOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.StopRelayOptions} StopRelayOptions
             */
            StopRelayOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.StopRelayOptions)
                    return object;
                var message = new $root.protos.opts.StopRelayOptions();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a StopRelayOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.StopRelayOptions
             * @static
             * @param {protos.opts.StopRelayOptions} message StopRelayOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StopRelayOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this StopRelayOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.StopRelayOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StopRelayOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StopRelayOptions;
        })();

        opts.ResumeRelayOptions = (function() {

            /**
             * Properties of a ResumeRelayOptions.
             * @memberof protos.opts
             * @interface IResumeRelayOptions
             * @property {string|null} [id] ResumeRelayOptions id
             */

            /**
             * Constructs a new ResumeRelayOptions.
             * @memberof protos.opts
             * @classdesc Represents a ResumeRelayOptions.
             * @implements IResumeRelayOptions
             * @constructor
             * @param {protos.opts.IResumeRelayOptions=} [properties] Properties to set
             */
            function ResumeRelayOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ResumeRelayOptions id.
             * @member {string} id
             * @memberof protos.opts.ResumeRelayOptions
             * @instance
             */
            ResumeRelayOptions.prototype.id = "";

            /**
             * Creates a new ResumeRelayOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ResumeRelayOptions
             * @static
             * @param {protos.opts.IResumeRelayOptions=} [properties] Properties to set
             * @returns {protos.opts.ResumeRelayOptions} ResumeRelayOptions instance
             */
            ResumeRelayOptions.create = function create(properties) {
                return new ResumeRelayOptions(properties);
            };

            /**
             * Encodes the specified ResumeRelayOptions message. Does not implicitly {@link protos.opts.ResumeRelayOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ResumeRelayOptions
             * @static
             * @param {protos.opts.IResumeRelayOptions} message ResumeRelayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResumeRelayOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified ResumeRelayOptions message, length delimited. Does not implicitly {@link protos.opts.ResumeRelayOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ResumeRelayOptions
             * @static
             * @param {protos.opts.IResumeRelayOptions} message ResumeRelayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResumeRelayOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ResumeRelayOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ResumeRelayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ResumeRelayOptions} ResumeRelayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResumeRelayOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ResumeRelayOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ResumeRelayOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ResumeRelayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ResumeRelayOptions} ResumeRelayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResumeRelayOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ResumeRelayOptions message.
             * @function verify
             * @memberof protos.opts.ResumeRelayOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ResumeRelayOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a ResumeRelayOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ResumeRelayOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ResumeRelayOptions} ResumeRelayOptions
             */
            ResumeRelayOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ResumeRelayOptions)
                    return object;
                var message = new $root.protos.opts.ResumeRelayOptions();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a ResumeRelayOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ResumeRelayOptions
             * @static
             * @param {protos.opts.ResumeRelayOptions} message ResumeRelayOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ResumeRelayOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this ResumeRelayOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ResumeRelayOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ResumeRelayOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ResumeRelayOptions;
        })();

        opts.GetTunnelOptions = (function() {

            /**
             * Properties of a GetTunnelOptions.
             * @memberof protos.opts
             * @interface IGetTunnelOptions
             * @property {string|null} [id] GetTunnelOptions id
             */

            /**
             * Constructs a new GetTunnelOptions.
             * @memberof protos.opts
             * @classdesc Represents a GetTunnelOptions.
             * @implements IGetTunnelOptions
             * @constructor
             * @param {protos.opts.IGetTunnelOptions=} [properties] Properties to set
             */
            function GetTunnelOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetTunnelOptions id.
             * @member {string} id
             * @memberof protos.opts.GetTunnelOptions
             * @instance
             */
            GetTunnelOptions.prototype.id = "";

            /**
             * Creates a new GetTunnelOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.GetTunnelOptions
             * @static
             * @param {protos.opts.IGetTunnelOptions=} [properties] Properties to set
             * @returns {protos.opts.GetTunnelOptions} GetTunnelOptions instance
             */
            GetTunnelOptions.create = function create(properties) {
                return new GetTunnelOptions(properties);
            };

            /**
             * Encodes the specified GetTunnelOptions message. Does not implicitly {@link protos.opts.GetTunnelOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.GetTunnelOptions
             * @static
             * @param {protos.opts.IGetTunnelOptions} message GetTunnelOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetTunnelOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified GetTunnelOptions message, length delimited. Does not implicitly {@link protos.opts.GetTunnelOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.GetTunnelOptions
             * @static
             * @param {protos.opts.IGetTunnelOptions} message GetTunnelOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetTunnelOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetTunnelOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.GetTunnelOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.GetTunnelOptions} GetTunnelOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetTunnelOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.GetTunnelOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetTunnelOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.GetTunnelOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.GetTunnelOptions} GetTunnelOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetTunnelOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetTunnelOptions message.
             * @function verify
             * @memberof protos.opts.GetTunnelOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetTunnelOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a GetTunnelOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.GetTunnelOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.GetTunnelOptions} GetTunnelOptions
             */
            GetTunnelOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.GetTunnelOptions)
                    return object;
                var message = new $root.protos.opts.GetTunnelOptions();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a GetTunnelOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.GetTunnelOptions
             * @static
             * @param {protos.opts.GetTunnelOptions} message GetTunnelOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetTunnelOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this GetTunnelOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.GetTunnelOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetTunnelOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetTunnelOptions;
        })();

        opts.CreateTunnelOptions = (function() {

            /**
             * Properties of a CreateTunnelOptions.
             * @memberof protos.opts
             * @interface ICreateTunnelOptions
             * @property {string|null} [connectionId] CreateTunnelOptions connectionId
             * @property {string|null} [tunnelToken] CreateTunnelOptions tunnelToken
             * @property {string|null} [name] CreateTunnelOptions name
             * @property {string|null} [notes] CreateTunnelOptions notes
             * @property {string|null} [_tunnelAddress] CreateTunnelOptions _tunnelAddress
             * @property {number|null} [_tunnelTimeoutSeconds] CreateTunnelOptions _tunnelTimeoutSeconds
             * @property {boolean|null} [_tunnelInsecure] CreateTunnelOptions _tunnelInsecure
             * @property {protos.args.IKafkaWriteArgs|null} [kafka] CreateTunnelOptions kafka
             * @property {protos.args.IActiveMQWriteArgs|null} [activemq] CreateTunnelOptions activemq
             * @property {protos.args.IAWSSQSWriteArgs|null} [awsSqs] CreateTunnelOptions awsSqs
             * @property {protos.args.IAWSSNSWriteArgs|null} [awsSns] CreateTunnelOptions awsSns
             * @property {protos.args.INatsWriteArgs|null} [nats] CreateTunnelOptions nats
             * @property {protos.args.INatsStreamingWriteArgs|null} [natsStreaming] CreateTunnelOptions natsStreaming
             * @property {protos.args.INSQWriteArgs|null} [nsq] CreateTunnelOptions nsq
             * @property {protos.args.IRabbitWriteArgs|null} [rabbit] CreateTunnelOptions rabbit
             * @property {protos.args.IMQTTWriteArgs|null} [mqtt] CreateTunnelOptions mqtt
             * @property {protos.args.IAzureServiceBusWriteArgs|null} [azureServiceBus] CreateTunnelOptions azureServiceBus
             * @property {protos.args.IAzureEventHubWriteArgs|null} [azureEventHub] CreateTunnelOptions azureEventHub
             * @property {protos.args.IGCPPubSubWriteArgs|null} [gcpPubsub] CreateTunnelOptions gcpPubsub
             * @property {protos.args.IKubeMQQueueWriteArgs|null} [kubemqQueue] CreateTunnelOptions kubemqQueue
             * @property {protos.args.IRedisPubSubWriteArgs|null} [redisPubsub] CreateTunnelOptions redisPubsub
             * @property {protos.args.IRedisStreamsWriteArgs|null} [redisStreams] CreateTunnelOptions redisStreams
             * @property {protos.args.IPulsarWriteArgs|null} [pulsar] CreateTunnelOptions pulsar
             * @property {protos.args.IRabbitStreamsWriteArgs|null} [rabbitStreams] CreateTunnelOptions rabbitStreams
             * @property {protos.args.INatsJetstreamWriteArgs|null} [natsJetstream] CreateTunnelOptions natsJetstream
             * @property {protos.args.IAWSKinesisWriteArgs|null} [awsKinesis] CreateTunnelOptions awsKinesis
             * @property {protos.args.IMemphisWriteArgs|null} [memphis] CreateTunnelOptions memphis
             */

            /**
             * Constructs a new CreateTunnelOptions.
             * @memberof protos.opts
             * @classdesc Represents a CreateTunnelOptions.
             * @implements ICreateTunnelOptions
             * @constructor
             * @param {protos.opts.ICreateTunnelOptions=} [properties] Properties to set
             */
            function CreateTunnelOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateTunnelOptions connectionId.
             * @member {string} connectionId
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.connectionId = "";

            /**
             * CreateTunnelOptions tunnelToken.
             * @member {string} tunnelToken
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.tunnelToken = "";

            /**
             * CreateTunnelOptions name.
             * @member {string} name
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.name = "";

            /**
             * CreateTunnelOptions notes.
             * @member {string} notes
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.notes = "";

            /**
             * CreateTunnelOptions _tunnelAddress.
             * @member {string} _tunnelAddress
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype._tunnelAddress = "";

            /**
             * CreateTunnelOptions _tunnelTimeoutSeconds.
             * @member {number} _tunnelTimeoutSeconds
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype._tunnelTimeoutSeconds = 0;

            /**
             * CreateTunnelOptions _tunnelInsecure.
             * @member {boolean} _tunnelInsecure
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype._tunnelInsecure = false;

            /**
             * CreateTunnelOptions kafka.
             * @member {protos.args.IKafkaWriteArgs|null|undefined} kafka
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.kafka = null;

            /**
             * CreateTunnelOptions activemq.
             * @member {protos.args.IActiveMQWriteArgs|null|undefined} activemq
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.activemq = null;

            /**
             * CreateTunnelOptions awsSqs.
             * @member {protos.args.IAWSSQSWriteArgs|null|undefined} awsSqs
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.awsSqs = null;

            /**
             * CreateTunnelOptions awsSns.
             * @member {protos.args.IAWSSNSWriteArgs|null|undefined} awsSns
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.awsSns = null;

            /**
             * CreateTunnelOptions nats.
             * @member {protos.args.INatsWriteArgs|null|undefined} nats
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.nats = null;

            /**
             * CreateTunnelOptions natsStreaming.
             * @member {protos.args.INatsStreamingWriteArgs|null|undefined} natsStreaming
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.natsStreaming = null;

            /**
             * CreateTunnelOptions nsq.
             * @member {protos.args.INSQWriteArgs|null|undefined} nsq
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.nsq = null;

            /**
             * CreateTunnelOptions rabbit.
             * @member {protos.args.IRabbitWriteArgs|null|undefined} rabbit
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.rabbit = null;

            /**
             * CreateTunnelOptions mqtt.
             * @member {protos.args.IMQTTWriteArgs|null|undefined} mqtt
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.mqtt = null;

            /**
             * CreateTunnelOptions azureServiceBus.
             * @member {protos.args.IAzureServiceBusWriteArgs|null|undefined} azureServiceBus
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.azureServiceBus = null;

            /**
             * CreateTunnelOptions azureEventHub.
             * @member {protos.args.IAzureEventHubWriteArgs|null|undefined} azureEventHub
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.azureEventHub = null;

            /**
             * CreateTunnelOptions gcpPubsub.
             * @member {protos.args.IGCPPubSubWriteArgs|null|undefined} gcpPubsub
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.gcpPubsub = null;

            /**
             * CreateTunnelOptions kubemqQueue.
             * @member {protos.args.IKubeMQQueueWriteArgs|null|undefined} kubemqQueue
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.kubemqQueue = null;

            /**
             * CreateTunnelOptions redisPubsub.
             * @member {protos.args.IRedisPubSubWriteArgs|null|undefined} redisPubsub
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.redisPubsub = null;

            /**
             * CreateTunnelOptions redisStreams.
             * @member {protos.args.IRedisStreamsWriteArgs|null|undefined} redisStreams
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.redisStreams = null;

            /**
             * CreateTunnelOptions pulsar.
             * @member {protos.args.IPulsarWriteArgs|null|undefined} pulsar
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.pulsar = null;

            /**
             * CreateTunnelOptions rabbitStreams.
             * @member {protos.args.IRabbitStreamsWriteArgs|null|undefined} rabbitStreams
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.rabbitStreams = null;

            /**
             * CreateTunnelOptions natsJetstream.
             * @member {protos.args.INatsJetstreamWriteArgs|null|undefined} natsJetstream
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.natsJetstream = null;

            /**
             * CreateTunnelOptions awsKinesis.
             * @member {protos.args.IAWSKinesisWriteArgs|null|undefined} awsKinesis
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.awsKinesis = null;

            /**
             * CreateTunnelOptions memphis.
             * @member {protos.args.IMemphisWriteArgs|null|undefined} memphis
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             */
            CreateTunnelOptions.prototype.memphis = null;

            /**
             * Creates a new CreateTunnelOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.CreateTunnelOptions
             * @static
             * @param {protos.opts.ICreateTunnelOptions=} [properties] Properties to set
             * @returns {protos.opts.CreateTunnelOptions} CreateTunnelOptions instance
             */
            CreateTunnelOptions.create = function create(properties) {
                return new CreateTunnelOptions(properties);
            };

            /**
             * Encodes the specified CreateTunnelOptions message. Does not implicitly {@link protos.opts.CreateTunnelOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.CreateTunnelOptions
             * @static
             * @param {protos.opts.ICreateTunnelOptions} message CreateTunnelOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateTunnelOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
                if (message.tunnelToken != null && Object.hasOwnProperty.call(message, "tunnelToken"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.tunnelToken);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
                if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.notes);
                if (message._tunnelAddress != null && Object.hasOwnProperty.call(message, "_tunnelAddress"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message._tunnelAddress);
                if (message._tunnelTimeoutSeconds != null && Object.hasOwnProperty.call(message, "_tunnelTimeoutSeconds"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message._tunnelTimeoutSeconds);
                if (message._tunnelInsecure != null && Object.hasOwnProperty.call(message, "_tunnelInsecure"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message._tunnelInsecure);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.args.KafkaWriteArgs.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.activemq != null && Object.hasOwnProperty.call(message, "activemq"))
                    $root.protos.args.ActiveMQWriteArgs.encode(message.activemq, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.awsSqs != null && Object.hasOwnProperty.call(message, "awsSqs"))
                    $root.protos.args.AWSSQSWriteArgs.encode(message.awsSqs, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.awsSns != null && Object.hasOwnProperty.call(message, "awsSns"))
                    $root.protos.args.AWSSNSWriteArgs.encode(message.awsSns, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.args.NatsWriteArgs.encode(message.nats, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.args.NatsStreamingWriteArgs.encode(message.natsStreaming, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.args.NSQWriteArgs.encode(message.nsq, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.args.RabbitWriteArgs.encode(message.rabbit, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.args.MQTTWriteArgs.encode(message.mqtt, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.args.AzureServiceBusWriteArgs.encode(message.azureServiceBus, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.azureEventHub != null && Object.hasOwnProperty.call(message, "azureEventHub"))
                    $root.protos.args.AzureEventHubWriteArgs.encode(message.azureEventHub, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.args.GCPPubSubWriteArgs.encode(message.gcpPubsub, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.args.KubeMQQueueWriteArgs.encode(message.kubemqQueue, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.args.RedisPubSubWriteArgs.encode(message.redisPubsub, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.args.RedisStreamsWriteArgs.encode(message.redisStreams, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.pulsar != null && Object.hasOwnProperty.call(message, "pulsar"))
                    $root.protos.args.PulsarWriteArgs.encode(message.pulsar, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                if (message.rabbitStreams != null && Object.hasOwnProperty.call(message, "rabbitStreams"))
                    $root.protos.args.RabbitStreamsWriteArgs.encode(message.rabbitStreams, writer.uint32(/* id 116, wireType 2 =*/930).fork()).ldelim();
                if (message.natsJetstream != null && Object.hasOwnProperty.call(message, "natsJetstream"))
                    $root.protos.args.NatsJetstreamWriteArgs.encode(message.natsJetstream, writer.uint32(/* id 117, wireType 2 =*/938).fork()).ldelim();
                if (message.awsKinesis != null && Object.hasOwnProperty.call(message, "awsKinesis"))
                    $root.protos.args.AWSKinesisWriteArgs.encode(message.awsKinesis, writer.uint32(/* id 118, wireType 2 =*/946).fork()).ldelim();
                if (message.memphis != null && Object.hasOwnProperty.call(message, "memphis"))
                    $root.protos.args.MemphisWriteArgs.encode(message.memphis, writer.uint32(/* id 119, wireType 2 =*/954).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CreateTunnelOptions message, length delimited. Does not implicitly {@link protos.opts.CreateTunnelOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.CreateTunnelOptions
             * @static
             * @param {protos.opts.ICreateTunnelOptions} message CreateTunnelOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateTunnelOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateTunnelOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.CreateTunnelOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.CreateTunnelOptions} CreateTunnelOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateTunnelOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.CreateTunnelOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.connectionId = reader.string();
                        break;
                    case 3:
                        message.tunnelToken = reader.string();
                        break;
                    case 4:
                        message.name = reader.string();
                        break;
                    case 5:
                        message.notes = reader.string();
                        break;
                    case 6:
                        message._tunnelAddress = reader.string();
                        break;
                    case 7:
                        message._tunnelTimeoutSeconds = reader.uint32();
                        break;
                    case 8:
                        message._tunnelInsecure = reader.bool();
                        break;
                    case 100:
                        message.kafka = $root.protos.args.KafkaWriteArgs.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.activemq = $root.protos.args.ActiveMQWriteArgs.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.awsSqs = $root.protos.args.AWSSQSWriteArgs.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.awsSns = $root.protos.args.AWSSNSWriteArgs.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.nats = $root.protos.args.NatsWriteArgs.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.natsStreaming = $root.protos.args.NatsStreamingWriteArgs.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.nsq = $root.protos.args.NSQWriteArgs.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.rabbit = $root.protos.args.RabbitWriteArgs.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.mqtt = $root.protos.args.MQTTWriteArgs.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.azureServiceBus = $root.protos.args.AzureServiceBusWriteArgs.decode(reader, reader.uint32());
                        break;
                    case 110:
                        message.azureEventHub = $root.protos.args.AzureEventHubWriteArgs.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.gcpPubsub = $root.protos.args.GCPPubSubWriteArgs.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.kubemqQueue = $root.protos.args.KubeMQQueueWriteArgs.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.redisPubsub = $root.protos.args.RedisPubSubWriteArgs.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.redisStreams = $root.protos.args.RedisStreamsWriteArgs.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.pulsar = $root.protos.args.PulsarWriteArgs.decode(reader, reader.uint32());
                        break;
                    case 116:
                        message.rabbitStreams = $root.protos.args.RabbitStreamsWriteArgs.decode(reader, reader.uint32());
                        break;
                    case 117:
                        message.natsJetstream = $root.protos.args.NatsJetstreamWriteArgs.decode(reader, reader.uint32());
                        break;
                    case 118:
                        message.awsKinesis = $root.protos.args.AWSKinesisWriteArgs.decode(reader, reader.uint32());
                        break;
                    case 119:
                        message.memphis = $root.protos.args.MemphisWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateTunnelOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.CreateTunnelOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.CreateTunnelOptions} CreateTunnelOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateTunnelOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateTunnelOptions message.
             * @function verify
             * @memberof protos.opts.CreateTunnelOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateTunnelOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    if (!$util.isString(message.connectionId))
                        return "connectionId: string expected";
                if (message.tunnelToken != null && message.hasOwnProperty("tunnelToken"))
                    if (!$util.isString(message.tunnelToken))
                        return "tunnelToken: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.notes != null && message.hasOwnProperty("notes"))
                    if (!$util.isString(message.notes))
                        return "notes: string expected";
                if (message._tunnelAddress != null && message.hasOwnProperty("_tunnelAddress"))
                    if (!$util.isString(message._tunnelAddress))
                        return "_tunnelAddress: string expected";
                if (message._tunnelTimeoutSeconds != null && message.hasOwnProperty("_tunnelTimeoutSeconds"))
                    if (!$util.isInteger(message._tunnelTimeoutSeconds))
                        return "_tunnelTimeoutSeconds: integer expected";
                if (message._tunnelInsecure != null && message.hasOwnProperty("_tunnelInsecure"))
                    if (typeof message._tunnelInsecure !== "boolean")
                        return "_tunnelInsecure: boolean expected";
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    var error = $root.protos.args.KafkaWriteArgs.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.activemq != null && message.hasOwnProperty("activemq")) {
                    var error = $root.protos.args.ActiveMQWriteArgs.verify(message.activemq);
                    if (error)
                        return "activemq." + error;
                }
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs")) {
                    var error = $root.protos.args.AWSSQSWriteArgs.verify(message.awsSqs);
                    if (error)
                        return "awsSqs." + error;
                }
                if (message.awsSns != null && message.hasOwnProperty("awsSns")) {
                    var error = $root.protos.args.AWSSNSWriteArgs.verify(message.awsSns);
                    if (error)
                        return "awsSns." + error;
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    var error = $root.protos.args.NatsWriteArgs.verify(message.nats);
                    if (error)
                        return "nats." + error;
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    var error = $root.protos.args.NatsStreamingWriteArgs.verify(message.natsStreaming);
                    if (error)
                        return "natsStreaming." + error;
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    var error = $root.protos.args.NSQWriteArgs.verify(message.nsq);
                    if (error)
                        return "nsq." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    var error = $root.protos.args.RabbitWriteArgs.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    var error = $root.protos.args.MQTTWriteArgs.verify(message.mqtt);
                    if (error)
                        return "mqtt." + error;
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    var error = $root.protos.args.AzureServiceBusWriteArgs.verify(message.azureServiceBus);
                    if (error)
                        return "azureServiceBus." + error;
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    var error = $root.protos.args.AzureEventHubWriteArgs.verify(message.azureEventHub);
                    if (error)
                        return "azureEventHub." + error;
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    var error = $root.protos.args.GCPPubSubWriteArgs.verify(message.gcpPubsub);
                    if (error)
                        return "gcpPubsub." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    var error = $root.protos.args.KubeMQQueueWriteArgs.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    var error = $root.protos.args.RedisPubSubWriteArgs.verify(message.redisPubsub);
                    if (error)
                        return "redisPubsub." + error;
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    var error = $root.protos.args.RedisStreamsWriteArgs.verify(message.redisStreams);
                    if (error)
                        return "redisStreams." + error;
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    var error = $root.protos.args.PulsarWriteArgs.verify(message.pulsar);
                    if (error)
                        return "pulsar." + error;
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    var error = $root.protos.args.RabbitStreamsWriteArgs.verify(message.rabbitStreams);
                    if (error)
                        return "rabbitStreams." + error;
                }
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream")) {
                    var error = $root.protos.args.NatsJetstreamWriteArgs.verify(message.natsJetstream);
                    if (error)
                        return "natsJetstream." + error;
                }
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis")) {
                    var error = $root.protos.args.AWSKinesisWriteArgs.verify(message.awsKinesis);
                    if (error)
                        return "awsKinesis." + error;
                }
                if (message.memphis != null && message.hasOwnProperty("memphis")) {
                    var error = $root.protos.args.MemphisWriteArgs.verify(message.memphis);
                    if (error)
                        return "memphis." + error;
                }
                return null;
            };

            /**
             * Creates a CreateTunnelOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.CreateTunnelOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.CreateTunnelOptions} CreateTunnelOptions
             */
            CreateTunnelOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.CreateTunnelOptions)
                    return object;
                var message = new $root.protos.opts.CreateTunnelOptions();
                if (object.connectionId != null)
                    message.connectionId = String(object.connectionId);
                if (object.tunnelToken != null)
                    message.tunnelToken = String(object.tunnelToken);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.notes != null)
                    message.notes = String(object.notes);
                if (object._tunnelAddress != null)
                    message._tunnelAddress = String(object._tunnelAddress);
                if (object._tunnelTimeoutSeconds != null)
                    message._tunnelTimeoutSeconds = object._tunnelTimeoutSeconds >>> 0;
                if (object._tunnelInsecure != null)
                    message._tunnelInsecure = Boolean(object._tunnelInsecure);
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.CreateTunnelOptions.kafka: object expected");
                    message.kafka = $root.protos.args.KafkaWriteArgs.fromObject(object.kafka);
                }
                if (object.activemq != null) {
                    if (typeof object.activemq !== "object")
                        throw TypeError(".protos.opts.CreateTunnelOptions.activemq: object expected");
                    message.activemq = $root.protos.args.ActiveMQWriteArgs.fromObject(object.activemq);
                }
                if (object.awsSqs != null) {
                    if (typeof object.awsSqs !== "object")
                        throw TypeError(".protos.opts.CreateTunnelOptions.awsSqs: object expected");
                    message.awsSqs = $root.protos.args.AWSSQSWriteArgs.fromObject(object.awsSqs);
                }
                if (object.awsSns != null) {
                    if (typeof object.awsSns !== "object")
                        throw TypeError(".protos.opts.CreateTunnelOptions.awsSns: object expected");
                    message.awsSns = $root.protos.args.AWSSNSWriteArgs.fromObject(object.awsSns);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.opts.CreateTunnelOptions.nats: object expected");
                    message.nats = $root.protos.args.NatsWriteArgs.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.opts.CreateTunnelOptions.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.args.NatsStreamingWriteArgs.fromObject(object.natsStreaming);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.CreateTunnelOptions.nsq: object expected");
                    message.nsq = $root.protos.args.NSQWriteArgs.fromObject(object.nsq);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.CreateTunnelOptions.rabbit: object expected");
                    message.rabbit = $root.protos.args.RabbitWriteArgs.fromObject(object.rabbit);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.CreateTunnelOptions.mqtt: object expected");
                    message.mqtt = $root.protos.args.MQTTWriteArgs.fromObject(object.mqtt);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.CreateTunnelOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.args.AzureServiceBusWriteArgs.fromObject(object.azureServiceBus);
                }
                if (object.azureEventHub != null) {
                    if (typeof object.azureEventHub !== "object")
                        throw TypeError(".protos.opts.CreateTunnelOptions.azureEventHub: object expected");
                    message.azureEventHub = $root.protos.args.AzureEventHubWriteArgs.fromObject(object.azureEventHub);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.CreateTunnelOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.args.GCPPubSubWriteArgs.fromObject(object.gcpPubsub);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.CreateTunnelOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.args.KubeMQQueueWriteArgs.fromObject(object.kubemqQueue);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.CreateTunnelOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.args.RedisPubSubWriteArgs.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.CreateTunnelOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.args.RedisStreamsWriteArgs.fromObject(object.redisStreams);
                }
                if (object.pulsar != null) {
                    if (typeof object.pulsar !== "object")
                        throw TypeError(".protos.opts.CreateTunnelOptions.pulsar: object expected");
                    message.pulsar = $root.protos.args.PulsarWriteArgs.fromObject(object.pulsar);
                }
                if (object.rabbitStreams != null) {
                    if (typeof object.rabbitStreams !== "object")
                        throw TypeError(".protos.opts.CreateTunnelOptions.rabbitStreams: object expected");
                    message.rabbitStreams = $root.protos.args.RabbitStreamsWriteArgs.fromObject(object.rabbitStreams);
                }
                if (object.natsJetstream != null) {
                    if (typeof object.natsJetstream !== "object")
                        throw TypeError(".protos.opts.CreateTunnelOptions.natsJetstream: object expected");
                    message.natsJetstream = $root.protos.args.NatsJetstreamWriteArgs.fromObject(object.natsJetstream);
                }
                if (object.awsKinesis != null) {
                    if (typeof object.awsKinesis !== "object")
                        throw TypeError(".protos.opts.CreateTunnelOptions.awsKinesis: object expected");
                    message.awsKinesis = $root.protos.args.AWSKinesisWriteArgs.fromObject(object.awsKinesis);
                }
                if (object.memphis != null) {
                    if (typeof object.memphis !== "object")
                        throw TypeError(".protos.opts.CreateTunnelOptions.memphis: object expected");
                    message.memphis = $root.protos.args.MemphisWriteArgs.fromObject(object.memphis);
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateTunnelOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.CreateTunnelOptions
             * @static
             * @param {protos.opts.CreateTunnelOptions} message CreateTunnelOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateTunnelOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.connectionId = "";
                    object.tunnelToken = "";
                    object.name = "";
                    object.notes = "";
                    object._tunnelAddress = "";
                    object._tunnelTimeoutSeconds = 0;
                    object._tunnelInsecure = false;
                    object.kafka = null;
                    object.activemq = null;
                    object.awsSqs = null;
                    object.awsSns = null;
                    object.nats = null;
                    object.natsStreaming = null;
                    object.nsq = null;
                    object.rabbit = null;
                    object.mqtt = null;
                    object.azureServiceBus = null;
                    object.azureEventHub = null;
                    object.gcpPubsub = null;
                    object.kubemqQueue = null;
                    object.redisPubsub = null;
                    object.redisStreams = null;
                    object.pulsar = null;
                    object.rabbitStreams = null;
                    object.natsJetstream = null;
                    object.awsKinesis = null;
                    object.memphis = null;
                }
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    object.connectionId = message.connectionId;
                if (message.tunnelToken != null && message.hasOwnProperty("tunnelToken"))
                    object.tunnelToken = message.tunnelToken;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.notes != null && message.hasOwnProperty("notes"))
                    object.notes = message.notes;
                if (message._tunnelAddress != null && message.hasOwnProperty("_tunnelAddress"))
                    object._tunnelAddress = message._tunnelAddress;
                if (message._tunnelTimeoutSeconds != null && message.hasOwnProperty("_tunnelTimeoutSeconds"))
                    object._tunnelTimeoutSeconds = message._tunnelTimeoutSeconds;
                if (message._tunnelInsecure != null && message.hasOwnProperty("_tunnelInsecure"))
                    object._tunnelInsecure = message._tunnelInsecure;
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.args.KafkaWriteArgs.toObject(message.kafka, options);
                if (message.activemq != null && message.hasOwnProperty("activemq"))
                    object.activemq = $root.protos.args.ActiveMQWriteArgs.toObject(message.activemq, options);
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs"))
                    object.awsSqs = $root.protos.args.AWSSQSWriteArgs.toObject(message.awsSqs, options);
                if (message.awsSns != null && message.hasOwnProperty("awsSns"))
                    object.awsSns = $root.protos.args.AWSSNSWriteArgs.toObject(message.awsSns, options);
                if (message.nats != null && message.hasOwnProperty("nats"))
                    object.nats = $root.protos.args.NatsWriteArgs.toObject(message.nats, options);
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming"))
                    object.natsStreaming = $root.protos.args.NatsStreamingWriteArgs.toObject(message.natsStreaming, options);
                if (message.nsq != null && message.hasOwnProperty("nsq"))
                    object.nsq = $root.protos.args.NSQWriteArgs.toObject(message.nsq, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.args.RabbitWriteArgs.toObject(message.rabbit, options);
                if (message.mqtt != null && message.hasOwnProperty("mqtt"))
                    object.mqtt = $root.protos.args.MQTTWriteArgs.toObject(message.mqtt, options);
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus"))
                    object.azureServiceBus = $root.protos.args.AzureServiceBusWriteArgs.toObject(message.azureServiceBus, options);
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub"))
                    object.azureEventHub = $root.protos.args.AzureEventHubWriteArgs.toObject(message.azureEventHub, options);
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub"))
                    object.gcpPubsub = $root.protos.args.GCPPubSubWriteArgs.toObject(message.gcpPubsub, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.args.KubeMQQueueWriteArgs.toObject(message.kubemqQueue, options);
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub"))
                    object.redisPubsub = $root.protos.args.RedisPubSubWriteArgs.toObject(message.redisPubsub, options);
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams"))
                    object.redisStreams = $root.protos.args.RedisStreamsWriteArgs.toObject(message.redisStreams, options);
                if (message.pulsar != null && message.hasOwnProperty("pulsar"))
                    object.pulsar = $root.protos.args.PulsarWriteArgs.toObject(message.pulsar, options);
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams"))
                    object.rabbitStreams = $root.protos.args.RabbitStreamsWriteArgs.toObject(message.rabbitStreams, options);
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream"))
                    object.natsJetstream = $root.protos.args.NatsJetstreamWriteArgs.toObject(message.natsJetstream, options);
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis"))
                    object.awsKinesis = $root.protos.args.AWSKinesisWriteArgs.toObject(message.awsKinesis, options);
                if (message.memphis != null && message.hasOwnProperty("memphis"))
                    object.memphis = $root.protos.args.MemphisWriteArgs.toObject(message.memphis, options);
                return object;
            };

            /**
             * Converts this CreateTunnelOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.CreateTunnelOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateTunnelOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateTunnelOptions;
        })();

        opts.DeleteTunnelOptions = (function() {

            /**
             * Properties of a DeleteTunnelOptions.
             * @memberof protos.opts
             * @interface IDeleteTunnelOptions
             * @property {string|null} [id] DeleteTunnelOptions id
             */

            /**
             * Constructs a new DeleteTunnelOptions.
             * @memberof protos.opts
             * @classdesc Represents a DeleteTunnelOptions.
             * @implements IDeleteTunnelOptions
             * @constructor
             * @param {protos.opts.IDeleteTunnelOptions=} [properties] Properties to set
             */
            function DeleteTunnelOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteTunnelOptions id.
             * @member {string} id
             * @memberof protos.opts.DeleteTunnelOptions
             * @instance
             */
            DeleteTunnelOptions.prototype.id = "";

            /**
             * Creates a new DeleteTunnelOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DeleteTunnelOptions
             * @static
             * @param {protos.opts.IDeleteTunnelOptions=} [properties] Properties to set
             * @returns {protos.opts.DeleteTunnelOptions} DeleteTunnelOptions instance
             */
            DeleteTunnelOptions.create = function create(properties) {
                return new DeleteTunnelOptions(properties);
            };

            /**
             * Encodes the specified DeleteTunnelOptions message. Does not implicitly {@link protos.opts.DeleteTunnelOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DeleteTunnelOptions
             * @static
             * @param {protos.opts.IDeleteTunnelOptions} message DeleteTunnelOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteTunnelOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified DeleteTunnelOptions message, length delimited. Does not implicitly {@link protos.opts.DeleteTunnelOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DeleteTunnelOptions
             * @static
             * @param {protos.opts.IDeleteTunnelOptions} message DeleteTunnelOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteTunnelOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteTunnelOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DeleteTunnelOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DeleteTunnelOptions} DeleteTunnelOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteTunnelOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DeleteTunnelOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteTunnelOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DeleteTunnelOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DeleteTunnelOptions} DeleteTunnelOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteTunnelOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteTunnelOptions message.
             * @function verify
             * @memberof protos.opts.DeleteTunnelOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteTunnelOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a DeleteTunnelOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DeleteTunnelOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DeleteTunnelOptions} DeleteTunnelOptions
             */
            DeleteTunnelOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DeleteTunnelOptions)
                    return object;
                var message = new $root.protos.opts.DeleteTunnelOptions();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a DeleteTunnelOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DeleteTunnelOptions
             * @static
             * @param {protos.opts.DeleteTunnelOptions} message DeleteTunnelOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteTunnelOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this DeleteTunnelOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DeleteTunnelOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteTunnelOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DeleteTunnelOptions;
        })();

        opts.StopTunnelOptions = (function() {

            /**
             * Properties of a StopTunnelOptions.
             * @memberof protos.opts
             * @interface IStopTunnelOptions
             * @property {string|null} [id] StopTunnelOptions id
             */

            /**
             * Constructs a new StopTunnelOptions.
             * @memberof protos.opts
             * @classdesc Represents a StopTunnelOptions.
             * @implements IStopTunnelOptions
             * @constructor
             * @param {protos.opts.IStopTunnelOptions=} [properties] Properties to set
             */
            function StopTunnelOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StopTunnelOptions id.
             * @member {string} id
             * @memberof protos.opts.StopTunnelOptions
             * @instance
             */
            StopTunnelOptions.prototype.id = "";

            /**
             * Creates a new StopTunnelOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.StopTunnelOptions
             * @static
             * @param {protos.opts.IStopTunnelOptions=} [properties] Properties to set
             * @returns {protos.opts.StopTunnelOptions} StopTunnelOptions instance
             */
            StopTunnelOptions.create = function create(properties) {
                return new StopTunnelOptions(properties);
            };

            /**
             * Encodes the specified StopTunnelOptions message. Does not implicitly {@link protos.opts.StopTunnelOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.StopTunnelOptions
             * @static
             * @param {protos.opts.IStopTunnelOptions} message StopTunnelOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StopTunnelOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified StopTunnelOptions message, length delimited. Does not implicitly {@link protos.opts.StopTunnelOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.StopTunnelOptions
             * @static
             * @param {protos.opts.IStopTunnelOptions} message StopTunnelOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StopTunnelOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StopTunnelOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.StopTunnelOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.StopTunnelOptions} StopTunnelOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StopTunnelOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.StopTunnelOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StopTunnelOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.StopTunnelOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.StopTunnelOptions} StopTunnelOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StopTunnelOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StopTunnelOptions message.
             * @function verify
             * @memberof protos.opts.StopTunnelOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StopTunnelOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a StopTunnelOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.StopTunnelOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.StopTunnelOptions} StopTunnelOptions
             */
            StopTunnelOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.StopTunnelOptions)
                    return object;
                var message = new $root.protos.opts.StopTunnelOptions();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a StopTunnelOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.StopTunnelOptions
             * @static
             * @param {protos.opts.StopTunnelOptions} message StopTunnelOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StopTunnelOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this StopTunnelOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.StopTunnelOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StopTunnelOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StopTunnelOptions;
        })();

        opts.ResumeTunnelOptions = (function() {

            /**
             * Properties of a ResumeTunnelOptions.
             * @memberof protos.opts
             * @interface IResumeTunnelOptions
             * @property {string|null} [id] ResumeTunnelOptions id
             */

            /**
             * Constructs a new ResumeTunnelOptions.
             * @memberof protos.opts
             * @classdesc Represents a ResumeTunnelOptions.
             * @implements IResumeTunnelOptions
             * @constructor
             * @param {protos.opts.IResumeTunnelOptions=} [properties] Properties to set
             */
            function ResumeTunnelOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ResumeTunnelOptions id.
             * @member {string} id
             * @memberof protos.opts.ResumeTunnelOptions
             * @instance
             */
            ResumeTunnelOptions.prototype.id = "";

            /**
             * Creates a new ResumeTunnelOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ResumeTunnelOptions
             * @static
             * @param {protos.opts.IResumeTunnelOptions=} [properties] Properties to set
             * @returns {protos.opts.ResumeTunnelOptions} ResumeTunnelOptions instance
             */
            ResumeTunnelOptions.create = function create(properties) {
                return new ResumeTunnelOptions(properties);
            };

            /**
             * Encodes the specified ResumeTunnelOptions message. Does not implicitly {@link protos.opts.ResumeTunnelOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ResumeTunnelOptions
             * @static
             * @param {protos.opts.IResumeTunnelOptions} message ResumeTunnelOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResumeTunnelOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified ResumeTunnelOptions message, length delimited. Does not implicitly {@link protos.opts.ResumeTunnelOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ResumeTunnelOptions
             * @static
             * @param {protos.opts.IResumeTunnelOptions} message ResumeTunnelOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResumeTunnelOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ResumeTunnelOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ResumeTunnelOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ResumeTunnelOptions} ResumeTunnelOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResumeTunnelOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ResumeTunnelOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ResumeTunnelOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ResumeTunnelOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ResumeTunnelOptions} ResumeTunnelOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResumeTunnelOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ResumeTunnelOptions message.
             * @function verify
             * @memberof protos.opts.ResumeTunnelOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ResumeTunnelOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a ResumeTunnelOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ResumeTunnelOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ResumeTunnelOptions} ResumeTunnelOptions
             */
            ResumeTunnelOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ResumeTunnelOptions)
                    return object;
                var message = new $root.protos.opts.ResumeTunnelOptions();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a ResumeTunnelOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ResumeTunnelOptions
             * @static
             * @param {protos.opts.ResumeTunnelOptions} message ResumeTunnelOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ResumeTunnelOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this ResumeTunnelOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ResumeTunnelOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ResumeTunnelOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ResumeTunnelOptions;
        })();

        /**
         * ConvertOption enum.
         * @name protos.opts.ConvertOption
         * @enum {number}
         * @property {number} CONVERT_OPTION_UNSET=0 CONVERT_OPTION_UNSET value
         * @property {number} CONVERT_OPTION_BASE64=1 CONVERT_OPTION_BASE64 value
         * @property {number} CONVERT_OPTION_GZIP=2 CONVERT_OPTION_GZIP value
         */
        opts.ConvertOption = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CONVERT_OPTION_UNSET"] = 0;
            values[valuesById[1] = "CONVERT_OPTION_BASE64"] = 1;
            values[valuesById[2] = "CONVERT_OPTION_GZIP"] = 2;
            return values;
        })();

        opts.ReadCLIOptions = (function() {

            /**
             * Properties of a ReadCLIOptions.
             * @memberof protos.opts
             * @interface IReadCLIOptions
             * @property {boolean|null} [verboseOutput] ReadCLIOptions verboseOutput
             * @property {boolean|null} [pretty] ReadCLIOptions pretty
             * @property {boolean|null} [json] ReadCLIOptions json
             */

            /**
             * Constructs a new ReadCLIOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadCLIOptions.
             * @implements IReadCLIOptions
             * @constructor
             * @param {protos.opts.IReadCLIOptions=} [properties] Properties to set
             */
            function ReadCLIOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadCLIOptions verboseOutput.
             * @member {boolean} verboseOutput
             * @memberof protos.opts.ReadCLIOptions
             * @instance
             */
            ReadCLIOptions.prototype.verboseOutput = false;

            /**
             * ReadCLIOptions pretty.
             * @member {boolean} pretty
             * @memberof protos.opts.ReadCLIOptions
             * @instance
             */
            ReadCLIOptions.prototype.pretty = false;

            /**
             * ReadCLIOptions json.
             * @member {boolean} json
             * @memberof protos.opts.ReadCLIOptions
             * @instance
             */
            ReadCLIOptions.prototype.json = false;

            /**
             * Creates a new ReadCLIOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {protos.opts.IReadCLIOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadCLIOptions} ReadCLIOptions instance
             */
            ReadCLIOptions.create = function create(properties) {
                return new ReadCLIOptions(properties);
            };

            /**
             * Encodes the specified ReadCLIOptions message. Does not implicitly {@link protos.opts.ReadCLIOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {protos.opts.IReadCLIOptions} message ReadCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadCLIOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.verboseOutput != null && Object.hasOwnProperty.call(message, "verboseOutput"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.verboseOutput);
                if (message.pretty != null && Object.hasOwnProperty.call(message, "pretty"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.pretty);
                if (message.json != null && Object.hasOwnProperty.call(message, "json"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.json);
                return writer;
            };

            /**
             * Encodes the specified ReadCLIOptions message, length delimited. Does not implicitly {@link protos.opts.ReadCLIOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {protos.opts.IReadCLIOptions} message ReadCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadCLIOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadCLIOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadCLIOptions} ReadCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadCLIOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadCLIOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.verboseOutput = reader.bool();
                        break;
                    case 2:
                        message.pretty = reader.bool();
                        break;
                    case 3:
                        message.json = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadCLIOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadCLIOptions} ReadCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadCLIOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadCLIOptions message.
             * @function verify
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadCLIOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.verboseOutput != null && message.hasOwnProperty("verboseOutput"))
                    if (typeof message.verboseOutput !== "boolean")
                        return "verboseOutput: boolean expected";
                if (message.pretty != null && message.hasOwnProperty("pretty"))
                    if (typeof message.pretty !== "boolean")
                        return "pretty: boolean expected";
                if (message.json != null && message.hasOwnProperty("json"))
                    if (typeof message.json !== "boolean")
                        return "json: boolean expected";
                return null;
            };

            /**
             * Creates a ReadCLIOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadCLIOptions} ReadCLIOptions
             */
            ReadCLIOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadCLIOptions)
                    return object;
                var message = new $root.protos.opts.ReadCLIOptions();
                if (object.verboseOutput != null)
                    message.verboseOutput = Boolean(object.verboseOutput);
                if (object.pretty != null)
                    message.pretty = Boolean(object.pretty);
                if (object.json != null)
                    message.json = Boolean(object.json);
                return message;
            };

            /**
             * Creates a plain object from a ReadCLIOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {protos.opts.ReadCLIOptions} message ReadCLIOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadCLIOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.verboseOutput = false;
                    object.pretty = false;
                    object.json = false;
                }
                if (message.verboseOutput != null && message.hasOwnProperty("verboseOutput"))
                    object.verboseOutput = message.verboseOutput;
                if (message.pretty != null && message.hasOwnProperty("pretty"))
                    object.pretty = message.pretty;
                if (message.json != null && message.hasOwnProperty("json"))
                    object.json = message.json;
                return object;
            };

            /**
             * Converts this ReadCLIOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadCLIOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadCLIOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadCLIOptions;
        })();

        opts.ReadSampleOptions = (function() {

            /**
             * Properties of a ReadSampleOptions.
             * @memberof protos.opts
             * @interface IReadSampleOptions
             * @property {number|null} [sampleRate] ReadSampleOptions sampleRate
             * @property {number|null} [sampleIntervalSeconds] ReadSampleOptions sampleIntervalSeconds
             */

            /**
             * Constructs a new ReadSampleOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadSampleOptions.
             * @implements IReadSampleOptions
             * @constructor
             * @param {protos.opts.IReadSampleOptions=} [properties] Properties to set
             */
            function ReadSampleOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadSampleOptions sampleRate.
             * @member {number} sampleRate
             * @memberof protos.opts.ReadSampleOptions
             * @instance
             */
            ReadSampleOptions.prototype.sampleRate = 0;

            /**
             * ReadSampleOptions sampleIntervalSeconds.
             * @member {number} sampleIntervalSeconds
             * @memberof protos.opts.ReadSampleOptions
             * @instance
             */
            ReadSampleOptions.prototype.sampleIntervalSeconds = 0;

            /**
             * Creates a new ReadSampleOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {protos.opts.IReadSampleOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadSampleOptions} ReadSampleOptions instance
             */
            ReadSampleOptions.create = function create(properties) {
                return new ReadSampleOptions(properties);
            };

            /**
             * Encodes the specified ReadSampleOptions message. Does not implicitly {@link protos.opts.ReadSampleOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {protos.opts.IReadSampleOptions} message ReadSampleOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadSampleOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sampleRate != null && Object.hasOwnProperty.call(message, "sampleRate"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.sampleRate);
                if (message.sampleIntervalSeconds != null && Object.hasOwnProperty.call(message, "sampleIntervalSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.sampleIntervalSeconds);
                return writer;
            };

            /**
             * Encodes the specified ReadSampleOptions message, length delimited. Does not implicitly {@link protos.opts.ReadSampleOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {protos.opts.IReadSampleOptions} message ReadSampleOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadSampleOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadSampleOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadSampleOptions} ReadSampleOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadSampleOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadSampleOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sampleRate = reader.uint32();
                        break;
                    case 2:
                        message.sampleIntervalSeconds = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadSampleOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadSampleOptions} ReadSampleOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadSampleOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadSampleOptions message.
             * @function verify
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadSampleOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sampleRate != null && message.hasOwnProperty("sampleRate"))
                    if (!$util.isInteger(message.sampleRate))
                        return "sampleRate: integer expected";
                if (message.sampleIntervalSeconds != null && message.hasOwnProperty("sampleIntervalSeconds"))
                    if (!$util.isInteger(message.sampleIntervalSeconds))
                        return "sampleIntervalSeconds: integer expected";
                return null;
            };

            /**
             * Creates a ReadSampleOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadSampleOptions} ReadSampleOptions
             */
            ReadSampleOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadSampleOptions)
                    return object;
                var message = new $root.protos.opts.ReadSampleOptions();
                if (object.sampleRate != null)
                    message.sampleRate = object.sampleRate >>> 0;
                if (object.sampleIntervalSeconds != null)
                    message.sampleIntervalSeconds = object.sampleIntervalSeconds >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a ReadSampleOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {protos.opts.ReadSampleOptions} message ReadSampleOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadSampleOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sampleRate = 0;
                    object.sampleIntervalSeconds = 0;
                }
                if (message.sampleRate != null && message.hasOwnProperty("sampleRate"))
                    object.sampleRate = message.sampleRate;
                if (message.sampleIntervalSeconds != null && message.hasOwnProperty("sampleIntervalSeconds"))
                    object.sampleIntervalSeconds = message.sampleIntervalSeconds;
                return object;
            };

            /**
             * Converts this ReadSampleOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadSampleOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadSampleOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadSampleOptions;
        })();

        opts.ReadFilterOptions = (function() {

            /**
             * Properties of a ReadFilterOptions.
             * @memberof protos.opts
             * @interface IReadFilterOptions
             * @property {string|null} [query] ReadFilterOptions query
             */

            /**
             * Constructs a new ReadFilterOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadFilterOptions.
             * @implements IReadFilterOptions
             * @constructor
             * @param {protos.opts.IReadFilterOptions=} [properties] Properties to set
             */
            function ReadFilterOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadFilterOptions query.
             * @member {string} query
             * @memberof protos.opts.ReadFilterOptions
             * @instance
             */
            ReadFilterOptions.prototype.query = "";

            /**
             * Creates a new ReadFilterOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {protos.opts.IReadFilterOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadFilterOptions} ReadFilterOptions instance
             */
            ReadFilterOptions.create = function create(properties) {
                return new ReadFilterOptions(properties);
            };

            /**
             * Encodes the specified ReadFilterOptions message. Does not implicitly {@link protos.opts.ReadFilterOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {protos.opts.IReadFilterOptions} message ReadFilterOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadFilterOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.query);
                return writer;
            };

            /**
             * Encodes the specified ReadFilterOptions message, length delimited. Does not implicitly {@link protos.opts.ReadFilterOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {protos.opts.IReadFilterOptions} message ReadFilterOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadFilterOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadFilterOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadFilterOptions} ReadFilterOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadFilterOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadFilterOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.query = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadFilterOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadFilterOptions} ReadFilterOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadFilterOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadFilterOptions message.
             * @function verify
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadFilterOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.query != null && message.hasOwnProperty("query"))
                    if (!$util.isString(message.query))
                        return "query: string expected";
                return null;
            };

            /**
             * Creates a ReadFilterOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadFilterOptions} ReadFilterOptions
             */
            ReadFilterOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadFilterOptions)
                    return object;
                var message = new $root.protos.opts.ReadFilterOptions();
                if (object.query != null)
                    message.query = String(object.query);
                return message;
            };

            /**
             * Creates a plain object from a ReadFilterOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {protos.opts.ReadFilterOptions} message ReadFilterOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadFilterOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.query = "";
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = message.query;
                return object;
            };

            /**
             * Converts this ReadFilterOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadFilterOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadFilterOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadFilterOptions;
        })();

        opts.ReadOptions = (function() {

            /**
             * Properties of a ReadOptions.
             * @memberof protos.opts
             * @interface IReadOptions
             * @property {string|null} [name] ReadOptions name
             * @property {string|null} [connectionId] ReadOptions connectionId
             * @property {boolean|null} [continuous] ReadOptions continuous
             * @property {protos.opts.IReadSampleOptions|null} [sampleOptions] ReadOptions sampleOptions
             * @property {protos.encoding.IDecodeOptions|null} [decodeOptions] ReadOptions decodeOptions
             * @property {protos.opts.ConvertOption|null} [convertOutput] ReadOptions convertOutput
             * @property {protos.opts.IReadFilterOptions|null} [filter] ReadOptions filter
             * @property {protos.opts.IInferSchemaOptions|null} [inferSchemaOptions] ReadOptions inferSchemaOptions
             * @property {string|null} [_id] ReadOptions _id
             * @property {boolean|null} [_active] ReadOptions _active
             * @property {protos.opts.IReadCLIOptions|null} [_cliOptions] ReadOptions _cliOptions
             * @property {protos.opts.IReadGroupKafkaOptions|null} [kafka] ReadOptions kafka
             * @property {protos.opts.IReadGroupActiveMQOptions|null} [activemq] ReadOptions activemq
             * @property {protos.opts.IReadGroupAWSSQSOptions|null} [awsSqs] ReadOptions awsSqs
             * @property {protos.opts.IReadGroupMongoOptions|null} [mongo] ReadOptions mongo
             * @property {protos.opts.IReadGroupNatsOptions|null} [nats] ReadOptions nats
             * @property {protos.opts.IReadGroupNatsStreamingOptions|null} [natsStreaming] ReadOptions natsStreaming
             * @property {protos.opts.IReadGroupNSQOptions|null} [nsq] ReadOptions nsq
             * @property {protos.opts.IReadGroupPulsarOptions|null} [pulsar] ReadOptions pulsar
             * @property {protos.opts.IReadGroupRabbitOptions|null} [rabbit] ReadOptions rabbit
             * @property {protos.opts.IReadGroupRabbitStreamsOptions|null} [rabbitStreams] ReadOptions rabbitStreams
             * @property {protos.opts.IReadGroupMQTTOptions|null} [mqtt] ReadOptions mqtt
             * @property {protos.opts.IReadGroupAzureServiceBusOptions|null} [azureServiceBus] ReadOptions azureServiceBus
             * @property {protos.opts.IReadGroupAzureEventHubOptions|null} [azureEventHub] ReadOptions azureEventHub
             * @property {protos.opts.IReadGroupGCPPubSubOptions|null} [gcpPubsub] ReadOptions gcpPubsub
             * @property {protos.opts.IReadGroupKubeMQQueueOptions|null} [kubemqQueue] ReadOptions kubemqQueue
             * @property {protos.opts.IReadGroupRedisPubSubOptions|null} [redisPubsub] ReadOptions redisPubsub
             * @property {protos.opts.IReadGroupRedisStreamsOptions|null} [redisStreams] ReadOptions redisStreams
             * @property {protos.opts.IReadGroupPostgresOptions|null} [postgres] ReadOptions postgres
             * @property {protos.opts.IReadGroupNatsJetstreamOptions|null} [natsJetstream] ReadOptions natsJetstream
             * @property {protos.opts.IReadGroupAWSKinesisOptions|null} [awsKinesis] ReadOptions awsKinesis
             * @property {protos.opts.IReadGroupMemphisOptions|null} [memphis] ReadOptions memphis
             */

            /**
             * Constructs a new ReadOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadOptions.
             * @implements IReadOptions
             * @constructor
             * @param {protos.opts.IReadOptions=} [properties] Properties to set
             */
            function ReadOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadOptions name.
             * @member {string} name
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.name = "";

            /**
             * ReadOptions connectionId.
             * @member {string} connectionId
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.connectionId = "";

            /**
             * ReadOptions continuous.
             * @member {boolean} continuous
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.continuous = false;

            /**
             * ReadOptions sampleOptions.
             * @member {protos.opts.IReadSampleOptions|null|undefined} sampleOptions
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.sampleOptions = null;

            /**
             * ReadOptions decodeOptions.
             * @member {protos.encoding.IDecodeOptions|null|undefined} decodeOptions
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.decodeOptions = null;

            /**
             * ReadOptions convertOutput.
             * @member {protos.opts.ConvertOption} convertOutput
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.convertOutput = 0;

            /**
             * ReadOptions filter.
             * @member {protos.opts.IReadFilterOptions|null|undefined} filter
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.filter = null;

            /**
             * ReadOptions inferSchemaOptions.
             * @member {protos.opts.IInferSchemaOptions|null|undefined} inferSchemaOptions
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.inferSchemaOptions = null;

            /**
             * ReadOptions _id.
             * @member {string} _id
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype._id = "";

            /**
             * ReadOptions _active.
             * @member {boolean} _active
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype._active = false;

            /**
             * ReadOptions _cliOptions.
             * @member {protos.opts.IReadCLIOptions|null|undefined} _cliOptions
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype._cliOptions = null;

            /**
             * ReadOptions kafka.
             * @member {protos.opts.IReadGroupKafkaOptions|null|undefined} kafka
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.kafka = null;

            /**
             * ReadOptions activemq.
             * @member {protos.opts.IReadGroupActiveMQOptions|null|undefined} activemq
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.activemq = null;

            /**
             * ReadOptions awsSqs.
             * @member {protos.opts.IReadGroupAWSSQSOptions|null|undefined} awsSqs
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.awsSqs = null;

            /**
             * ReadOptions mongo.
             * @member {protos.opts.IReadGroupMongoOptions|null|undefined} mongo
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.mongo = null;

            /**
             * ReadOptions nats.
             * @member {protos.opts.IReadGroupNatsOptions|null|undefined} nats
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.nats = null;

            /**
             * ReadOptions natsStreaming.
             * @member {protos.opts.IReadGroupNatsStreamingOptions|null|undefined} natsStreaming
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.natsStreaming = null;

            /**
             * ReadOptions nsq.
             * @member {protos.opts.IReadGroupNSQOptions|null|undefined} nsq
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.nsq = null;

            /**
             * ReadOptions pulsar.
             * @member {protos.opts.IReadGroupPulsarOptions|null|undefined} pulsar
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.pulsar = null;

            /**
             * ReadOptions rabbit.
             * @member {protos.opts.IReadGroupRabbitOptions|null|undefined} rabbit
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.rabbit = null;

            /**
             * ReadOptions rabbitStreams.
             * @member {protos.opts.IReadGroupRabbitStreamsOptions|null|undefined} rabbitStreams
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.rabbitStreams = null;

            /**
             * ReadOptions mqtt.
             * @member {protos.opts.IReadGroupMQTTOptions|null|undefined} mqtt
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.mqtt = null;

            /**
             * ReadOptions azureServiceBus.
             * @member {protos.opts.IReadGroupAzureServiceBusOptions|null|undefined} azureServiceBus
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.azureServiceBus = null;

            /**
             * ReadOptions azureEventHub.
             * @member {protos.opts.IReadGroupAzureEventHubOptions|null|undefined} azureEventHub
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.azureEventHub = null;

            /**
             * ReadOptions gcpPubsub.
             * @member {protos.opts.IReadGroupGCPPubSubOptions|null|undefined} gcpPubsub
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.gcpPubsub = null;

            /**
             * ReadOptions kubemqQueue.
             * @member {protos.opts.IReadGroupKubeMQQueueOptions|null|undefined} kubemqQueue
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.kubemqQueue = null;

            /**
             * ReadOptions redisPubsub.
             * @member {protos.opts.IReadGroupRedisPubSubOptions|null|undefined} redisPubsub
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.redisPubsub = null;

            /**
             * ReadOptions redisStreams.
             * @member {protos.opts.IReadGroupRedisStreamsOptions|null|undefined} redisStreams
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.redisStreams = null;

            /**
             * ReadOptions postgres.
             * @member {protos.opts.IReadGroupPostgresOptions|null|undefined} postgres
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.postgres = null;

            /**
             * ReadOptions natsJetstream.
             * @member {protos.opts.IReadGroupNatsJetstreamOptions|null|undefined} natsJetstream
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.natsJetstream = null;

            /**
             * ReadOptions awsKinesis.
             * @member {protos.opts.IReadGroupAWSKinesisOptions|null|undefined} awsKinesis
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.awsKinesis = null;

            /**
             * ReadOptions memphis.
             * @member {protos.opts.IReadGroupMemphisOptions|null|undefined} memphis
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.memphis = null;

            /**
             * Creates a new ReadOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {protos.opts.IReadOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadOptions} ReadOptions instance
             */
            ReadOptions.create = function create(properties) {
                return new ReadOptions(properties);
            };

            /**
             * Encodes the specified ReadOptions message. Does not implicitly {@link protos.opts.ReadOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {protos.opts.IReadOptions} message ReadOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.connectionId);
                if (message.continuous != null && Object.hasOwnProperty.call(message, "continuous"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.continuous);
                if (message.sampleOptions != null && Object.hasOwnProperty.call(message, "sampleOptions"))
                    $root.protos.opts.ReadSampleOptions.encode(message.sampleOptions, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.decodeOptions != null && Object.hasOwnProperty.call(message, "decodeOptions"))
                    $root.protos.encoding.DecodeOptions.encode(message.decodeOptions, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.convertOutput != null && Object.hasOwnProperty.call(message, "convertOutput"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.convertOutput);
                if (message.filter != null && Object.hasOwnProperty.call(message, "filter"))
                    $root.protos.opts.ReadFilterOptions.encode(message.filter, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.inferSchemaOptions != null && Object.hasOwnProperty.call(message, "inferSchemaOptions"))
                    $root.protos.opts.InferSchemaOptions.encode(message.inferSchemaOptions, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.opts.ReadGroupKafkaOptions.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.activemq != null && Object.hasOwnProperty.call(message, "activemq"))
                    $root.protos.opts.ReadGroupActiveMQOptions.encode(message.activemq, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.awsSqs != null && Object.hasOwnProperty.call(message, "awsSqs"))
                    $root.protos.opts.ReadGroupAWSSQSOptions.encode(message.awsSqs, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.mongo != null && Object.hasOwnProperty.call(message, "mongo"))
                    $root.protos.opts.ReadGroupMongoOptions.encode(message.mongo, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.opts.ReadGroupNatsOptions.encode(message.nats, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.opts.ReadGroupNatsStreamingOptions.encode(message.natsStreaming, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.opts.ReadGroupNSQOptions.encode(message.nsq, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.pulsar != null && Object.hasOwnProperty.call(message, "pulsar"))
                    $root.protos.opts.ReadGroupPulsarOptions.encode(message.pulsar, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.opts.ReadGroupRabbitOptions.encode(message.rabbit, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.rabbitStreams != null && Object.hasOwnProperty.call(message, "rabbitStreams"))
                    $root.protos.opts.ReadGroupRabbitStreamsOptions.encode(message.rabbitStreams, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.opts.ReadGroupMQTTOptions.encode(message.mqtt, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.opts.ReadGroupAzureServiceBusOptions.encode(message.azureServiceBus, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.azureEventHub != null && Object.hasOwnProperty.call(message, "azureEventHub"))
                    $root.protos.opts.ReadGroupAzureEventHubOptions.encode(message.azureEventHub, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.opts.ReadGroupGCPPubSubOptions.encode(message.gcpPubsub, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.opts.ReadGroupKubeMQQueueOptions.encode(message.kubemqQueue, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.opts.ReadGroupRedisPubSubOptions.encode(message.redisPubsub, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.opts.ReadGroupRedisStreamsOptions.encode(message.redisStreams, writer.uint32(/* id 116, wireType 2 =*/930).fork()).ldelim();
                if (message.postgres != null && Object.hasOwnProperty.call(message, "postgres"))
                    $root.protos.opts.ReadGroupPostgresOptions.encode(message.postgres, writer.uint32(/* id 117, wireType 2 =*/938).fork()).ldelim();
                if (message.natsJetstream != null && Object.hasOwnProperty.call(message, "natsJetstream"))
                    $root.protos.opts.ReadGroupNatsJetstreamOptions.encode(message.natsJetstream, writer.uint32(/* id 118, wireType 2 =*/946).fork()).ldelim();
                if (message.awsKinesis != null && Object.hasOwnProperty.call(message, "awsKinesis"))
                    $root.protos.opts.ReadGroupAWSKinesisOptions.encode(message.awsKinesis, writer.uint32(/* id 119, wireType 2 =*/954).fork()).ldelim();
                if (message.memphis != null && Object.hasOwnProperty.call(message, "memphis"))
                    $root.protos.opts.ReadGroupMemphisOptions.encode(message.memphis, writer.uint32(/* id 120, wireType 2 =*/962).fork()).ldelim();
                if (message._id != null && Object.hasOwnProperty.call(message, "_id"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._id);
                if (message._active != null && Object.hasOwnProperty.call(message, "_active"))
                    writer.uint32(/* id 1001, wireType 0 =*/8008).bool(message._active);
                if (message._cliOptions != null && Object.hasOwnProperty.call(message, "_cliOptions"))
                    $root.protos.opts.ReadCLIOptions.encode(message._cliOptions, writer.uint32(/* id 1002, wireType 2 =*/8018).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadOptions message, length delimited. Does not implicitly {@link protos.opts.ReadOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {protos.opts.IReadOptions} message ReadOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadOptions} ReadOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.connectionId = reader.string();
                        break;
                    case 3:
                        message.continuous = reader.bool();
                        break;
                    case 4:
                        message.sampleOptions = $root.protos.opts.ReadSampleOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.decodeOptions = $root.protos.encoding.DecodeOptions.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.convertOutput = reader.int32();
                        break;
                    case 7:
                        message.filter = $root.protos.opts.ReadFilterOptions.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.inferSchemaOptions = $root.protos.opts.InferSchemaOptions.decode(reader, reader.uint32());
                        break;
                    case 1000:
                        message._id = reader.string();
                        break;
                    case 1001:
                        message._active = reader.bool();
                        break;
                    case 1002:
                        message._cliOptions = $root.protos.opts.ReadCLIOptions.decode(reader, reader.uint32());
                        break;
                    case 100:
                        message.kafka = $root.protos.opts.ReadGroupKafkaOptions.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.activemq = $root.protos.opts.ReadGroupActiveMQOptions.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.awsSqs = $root.protos.opts.ReadGroupAWSSQSOptions.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.mongo = $root.protos.opts.ReadGroupMongoOptions.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.nats = $root.protos.opts.ReadGroupNatsOptions.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.natsStreaming = $root.protos.opts.ReadGroupNatsStreamingOptions.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.nsq = $root.protos.opts.ReadGroupNSQOptions.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.pulsar = $root.protos.opts.ReadGroupPulsarOptions.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.rabbit = $root.protos.opts.ReadGroupRabbitOptions.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.rabbitStreams = $root.protos.opts.ReadGroupRabbitStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 110:
                        message.mqtt = $root.protos.opts.ReadGroupMQTTOptions.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.azureServiceBus = $root.protos.opts.ReadGroupAzureServiceBusOptions.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.azureEventHub = $root.protos.opts.ReadGroupAzureEventHubOptions.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.gcpPubsub = $root.protos.opts.ReadGroupGCPPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.kubemqQueue = $root.protos.opts.ReadGroupKubeMQQueueOptions.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.redisPubsub = $root.protos.opts.ReadGroupRedisPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 116:
                        message.redisStreams = $root.protos.opts.ReadGroupRedisStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 117:
                        message.postgres = $root.protos.opts.ReadGroupPostgresOptions.decode(reader, reader.uint32());
                        break;
                    case 118:
                        message.natsJetstream = $root.protos.opts.ReadGroupNatsJetstreamOptions.decode(reader, reader.uint32());
                        break;
                    case 119:
                        message.awsKinesis = $root.protos.opts.ReadGroupAWSKinesisOptions.decode(reader, reader.uint32());
                        break;
                    case 120:
                        message.memphis = $root.protos.opts.ReadGroupMemphisOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadOptions} ReadOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadOptions message.
             * @function verify
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    if (!$util.isString(message.connectionId))
                        return "connectionId: string expected";
                if (message.continuous != null && message.hasOwnProperty("continuous"))
                    if (typeof message.continuous !== "boolean")
                        return "continuous: boolean expected";
                if (message.sampleOptions != null && message.hasOwnProperty("sampleOptions")) {
                    var error = $root.protos.opts.ReadSampleOptions.verify(message.sampleOptions);
                    if (error)
                        return "sampleOptions." + error;
                }
                if (message.decodeOptions != null && message.hasOwnProperty("decodeOptions")) {
                    var error = $root.protos.encoding.DecodeOptions.verify(message.decodeOptions);
                    if (error)
                        return "decodeOptions." + error;
                }
                if (message.convertOutput != null && message.hasOwnProperty("convertOutput"))
                    switch (message.convertOutput) {
                    default:
                        return "convertOutput: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.filter != null && message.hasOwnProperty("filter")) {
                    var error = $root.protos.opts.ReadFilterOptions.verify(message.filter);
                    if (error)
                        return "filter." + error;
                }
                if (message.inferSchemaOptions != null && message.hasOwnProperty("inferSchemaOptions")) {
                    var error = $root.protos.opts.InferSchemaOptions.verify(message.inferSchemaOptions);
                    if (error)
                        return "inferSchemaOptions." + error;
                }
                if (message._id != null && message.hasOwnProperty("_id"))
                    if (!$util.isString(message._id))
                        return "_id: string expected";
                if (message._active != null && message.hasOwnProperty("_active"))
                    if (typeof message._active !== "boolean")
                        return "_active: boolean expected";
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions")) {
                    var error = $root.protos.opts.ReadCLIOptions.verify(message._cliOptions);
                    if (error)
                        return "_cliOptions." + error;
                }
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    var error = $root.protos.opts.ReadGroupKafkaOptions.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.activemq != null && message.hasOwnProperty("activemq")) {
                    var error = $root.protos.opts.ReadGroupActiveMQOptions.verify(message.activemq);
                    if (error)
                        return "activemq." + error;
                }
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs")) {
                    var error = $root.protos.opts.ReadGroupAWSSQSOptions.verify(message.awsSqs);
                    if (error)
                        return "awsSqs." + error;
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    var error = $root.protos.opts.ReadGroupMongoOptions.verify(message.mongo);
                    if (error)
                        return "mongo." + error;
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    var error = $root.protos.opts.ReadGroupNatsOptions.verify(message.nats);
                    if (error)
                        return "nats." + error;
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    var error = $root.protos.opts.ReadGroupNatsStreamingOptions.verify(message.natsStreaming);
                    if (error)
                        return "natsStreaming." + error;
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    var error = $root.protos.opts.ReadGroupNSQOptions.verify(message.nsq);
                    if (error)
                        return "nsq." + error;
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    var error = $root.protos.opts.ReadGroupPulsarOptions.verify(message.pulsar);
                    if (error)
                        return "pulsar." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    var error = $root.protos.opts.ReadGroupRabbitOptions.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    var error = $root.protos.opts.ReadGroupRabbitStreamsOptions.verify(message.rabbitStreams);
                    if (error)
                        return "rabbitStreams." + error;
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    var error = $root.protos.opts.ReadGroupMQTTOptions.verify(message.mqtt);
                    if (error)
                        return "mqtt." + error;
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    var error = $root.protos.opts.ReadGroupAzureServiceBusOptions.verify(message.azureServiceBus);
                    if (error)
                        return "azureServiceBus." + error;
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    var error = $root.protos.opts.ReadGroupAzureEventHubOptions.verify(message.azureEventHub);
                    if (error)
                        return "azureEventHub." + error;
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    var error = $root.protos.opts.ReadGroupGCPPubSubOptions.verify(message.gcpPubsub);
                    if (error)
                        return "gcpPubsub." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    var error = $root.protos.opts.ReadGroupKubeMQQueueOptions.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    var error = $root.protos.opts.ReadGroupRedisPubSubOptions.verify(message.redisPubsub);
                    if (error)
                        return "redisPubsub." + error;
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    var error = $root.protos.opts.ReadGroupRedisStreamsOptions.verify(message.redisStreams);
                    if (error)
                        return "redisStreams." + error;
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    var error = $root.protos.opts.ReadGroupPostgresOptions.verify(message.postgres);
                    if (error)
                        return "postgres." + error;
                }
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream")) {
                    var error = $root.protos.opts.ReadGroupNatsJetstreamOptions.verify(message.natsJetstream);
                    if (error)
                        return "natsJetstream." + error;
                }
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis")) {
                    var error = $root.protos.opts.ReadGroupAWSKinesisOptions.verify(message.awsKinesis);
                    if (error)
                        return "awsKinesis." + error;
                }
                if (message.memphis != null && message.hasOwnProperty("memphis")) {
                    var error = $root.protos.opts.ReadGroupMemphisOptions.verify(message.memphis);
                    if (error)
                        return "memphis." + error;
                }
                return null;
            };

            /**
             * Creates a ReadOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadOptions} ReadOptions
             */
            ReadOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadOptions)
                    return object;
                var message = new $root.protos.opts.ReadOptions();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.connectionId != null)
                    message.connectionId = String(object.connectionId);
                if (object.continuous != null)
                    message.continuous = Boolean(object.continuous);
                if (object.sampleOptions != null) {
                    if (typeof object.sampleOptions !== "object")
                        throw TypeError(".protos.opts.ReadOptions.sampleOptions: object expected");
                    message.sampleOptions = $root.protos.opts.ReadSampleOptions.fromObject(object.sampleOptions);
                }
                if (object.decodeOptions != null) {
                    if (typeof object.decodeOptions !== "object")
                        throw TypeError(".protos.opts.ReadOptions.decodeOptions: object expected");
                    message.decodeOptions = $root.protos.encoding.DecodeOptions.fromObject(object.decodeOptions);
                }
                switch (object.convertOutput) {
                case "CONVERT_OPTION_UNSET":
                case 0:
                    message.convertOutput = 0;
                    break;
                case "CONVERT_OPTION_BASE64":
                case 1:
                    message.convertOutput = 1;
                    break;
                case "CONVERT_OPTION_GZIP":
                case 2:
                    message.convertOutput = 2;
                    break;
                }
                if (object.filter != null) {
                    if (typeof object.filter !== "object")
                        throw TypeError(".protos.opts.ReadOptions.filter: object expected");
                    message.filter = $root.protos.opts.ReadFilterOptions.fromObject(object.filter);
                }
                if (object.inferSchemaOptions != null) {
                    if (typeof object.inferSchemaOptions !== "object")
                        throw TypeError(".protos.opts.ReadOptions.inferSchemaOptions: object expected");
                    message.inferSchemaOptions = $root.protos.opts.InferSchemaOptions.fromObject(object.inferSchemaOptions);
                }
                if (object._id != null)
                    message._id = String(object._id);
                if (object._active != null)
                    message._active = Boolean(object._active);
                if (object._cliOptions != null) {
                    if (typeof object._cliOptions !== "object")
                        throw TypeError(".protos.opts.ReadOptions._cliOptions: object expected");
                    message._cliOptions = $root.protos.opts.ReadCLIOptions.fromObject(object._cliOptions);
                }
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.ReadOptions.kafka: object expected");
                    message.kafka = $root.protos.opts.ReadGroupKafkaOptions.fromObject(object.kafka);
                }
                if (object.activemq != null) {
                    if (typeof object.activemq !== "object")
                        throw TypeError(".protos.opts.ReadOptions.activemq: object expected");
                    message.activemq = $root.protos.opts.ReadGroupActiveMQOptions.fromObject(object.activemq);
                }
                if (object.awsSqs != null) {
                    if (typeof object.awsSqs !== "object")
                        throw TypeError(".protos.opts.ReadOptions.awsSqs: object expected");
                    message.awsSqs = $root.protos.opts.ReadGroupAWSSQSOptions.fromObject(object.awsSqs);
                }
                if (object.mongo != null) {
                    if (typeof object.mongo !== "object")
                        throw TypeError(".protos.opts.ReadOptions.mongo: object expected");
                    message.mongo = $root.protos.opts.ReadGroupMongoOptions.fromObject(object.mongo);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.opts.ReadOptions.nats: object expected");
                    message.nats = $root.protos.opts.ReadGroupNatsOptions.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.opts.ReadOptions.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.opts.ReadGroupNatsStreamingOptions.fromObject(object.natsStreaming);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.ReadOptions.nsq: object expected");
                    message.nsq = $root.protos.opts.ReadGroupNSQOptions.fromObject(object.nsq);
                }
                if (object.pulsar != null) {
                    if (typeof object.pulsar !== "object")
                        throw TypeError(".protos.opts.ReadOptions.pulsar: object expected");
                    message.pulsar = $root.protos.opts.ReadGroupPulsarOptions.fromObject(object.pulsar);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.ReadOptions.rabbit: object expected");
                    message.rabbit = $root.protos.opts.ReadGroupRabbitOptions.fromObject(object.rabbit);
                }
                if (object.rabbitStreams != null) {
                    if (typeof object.rabbitStreams !== "object")
                        throw TypeError(".protos.opts.ReadOptions.rabbitStreams: object expected");
                    message.rabbitStreams = $root.protos.opts.ReadGroupRabbitStreamsOptions.fromObject(object.rabbitStreams);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.ReadOptions.mqtt: object expected");
                    message.mqtt = $root.protos.opts.ReadGroupMQTTOptions.fromObject(object.mqtt);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.ReadOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.opts.ReadGroupAzureServiceBusOptions.fromObject(object.azureServiceBus);
                }
                if (object.azureEventHub != null) {
                    if (typeof object.azureEventHub !== "object")
                        throw TypeError(".protos.opts.ReadOptions.azureEventHub: object expected");
                    message.azureEventHub = $root.protos.opts.ReadGroupAzureEventHubOptions.fromObject(object.azureEventHub);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.ReadOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.opts.ReadGroupGCPPubSubOptions.fromObject(object.gcpPubsub);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.ReadOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.opts.ReadGroupKubeMQQueueOptions.fromObject(object.kubemqQueue);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.ReadOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.opts.ReadGroupRedisPubSubOptions.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.ReadOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.opts.ReadGroupRedisStreamsOptions.fromObject(object.redisStreams);
                }
                if (object.postgres != null) {
                    if (typeof object.postgres !== "object")
                        throw TypeError(".protos.opts.ReadOptions.postgres: object expected");
                    message.postgres = $root.protos.opts.ReadGroupPostgresOptions.fromObject(object.postgres);
                }
                if (object.natsJetstream != null) {
                    if (typeof object.natsJetstream !== "object")
                        throw TypeError(".protos.opts.ReadOptions.natsJetstream: object expected");
                    message.natsJetstream = $root.protos.opts.ReadGroupNatsJetstreamOptions.fromObject(object.natsJetstream);
                }
                if (object.awsKinesis != null) {
                    if (typeof object.awsKinesis !== "object")
                        throw TypeError(".protos.opts.ReadOptions.awsKinesis: object expected");
                    message.awsKinesis = $root.protos.opts.ReadGroupAWSKinesisOptions.fromObject(object.awsKinesis);
                }
                if (object.memphis != null) {
                    if (typeof object.memphis !== "object")
                        throw TypeError(".protos.opts.ReadOptions.memphis: object expected");
                    message.memphis = $root.protos.opts.ReadGroupMemphisOptions.fromObject(object.memphis);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {protos.opts.ReadOptions} message ReadOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.connectionId = "";
                    object.continuous = false;
                    object.sampleOptions = null;
                    object.decodeOptions = null;
                    object.convertOutput = options.enums === String ? "CONVERT_OPTION_UNSET" : 0;
                    object.filter = null;
                    object.inferSchemaOptions = null;
                    object.kafka = null;
                    object.activemq = null;
                    object.awsSqs = null;
                    object.mongo = null;
                    object.nats = null;
                    object.natsStreaming = null;
                    object.nsq = null;
                    object.pulsar = null;
                    object.rabbit = null;
                    object.rabbitStreams = null;
                    object.mqtt = null;
                    object.azureServiceBus = null;
                    object.azureEventHub = null;
                    object.gcpPubsub = null;
                    object.kubemqQueue = null;
                    object.redisPubsub = null;
                    object.redisStreams = null;
                    object.postgres = null;
                    object.natsJetstream = null;
                    object.awsKinesis = null;
                    object.memphis = null;
                    object._id = "";
                    object._active = false;
                    object._cliOptions = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    object.connectionId = message.connectionId;
                if (message.continuous != null && message.hasOwnProperty("continuous"))
                    object.continuous = message.continuous;
                if (message.sampleOptions != null && message.hasOwnProperty("sampleOptions"))
                    object.sampleOptions = $root.protos.opts.ReadSampleOptions.toObject(message.sampleOptions, options);
                if (message.decodeOptions != null && message.hasOwnProperty("decodeOptions"))
                    object.decodeOptions = $root.protos.encoding.DecodeOptions.toObject(message.decodeOptions, options);
                if (message.convertOutput != null && message.hasOwnProperty("convertOutput"))
                    object.convertOutput = options.enums === String ? $root.protos.opts.ConvertOption[message.convertOutput] : message.convertOutput;
                if (message.filter != null && message.hasOwnProperty("filter"))
                    object.filter = $root.protos.opts.ReadFilterOptions.toObject(message.filter, options);
                if (message.inferSchemaOptions != null && message.hasOwnProperty("inferSchemaOptions"))
                    object.inferSchemaOptions = $root.protos.opts.InferSchemaOptions.toObject(message.inferSchemaOptions, options);
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.opts.ReadGroupKafkaOptions.toObject(message.kafka, options);
                if (message.activemq != null && message.hasOwnProperty("activemq"))
                    object.activemq = $root.protos.opts.ReadGroupActiveMQOptions.toObject(message.activemq, options);
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs"))
                    object.awsSqs = $root.protos.opts.ReadGroupAWSSQSOptions.toObject(message.awsSqs, options);
                if (message.mongo != null && message.hasOwnProperty("mongo"))
                    object.mongo = $root.protos.opts.ReadGroupMongoOptions.toObject(message.mongo, options);
                if (message.nats != null && message.hasOwnProperty("nats"))
                    object.nats = $root.protos.opts.ReadGroupNatsOptions.toObject(message.nats, options);
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming"))
                    object.natsStreaming = $root.protos.opts.ReadGroupNatsStreamingOptions.toObject(message.natsStreaming, options);
                if (message.nsq != null && message.hasOwnProperty("nsq"))
                    object.nsq = $root.protos.opts.ReadGroupNSQOptions.toObject(message.nsq, options);
                if (message.pulsar != null && message.hasOwnProperty("pulsar"))
                    object.pulsar = $root.protos.opts.ReadGroupPulsarOptions.toObject(message.pulsar, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.opts.ReadGroupRabbitOptions.toObject(message.rabbit, options);
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams"))
                    object.rabbitStreams = $root.protos.opts.ReadGroupRabbitStreamsOptions.toObject(message.rabbitStreams, options);
                if (message.mqtt != null && message.hasOwnProperty("mqtt"))
                    object.mqtt = $root.protos.opts.ReadGroupMQTTOptions.toObject(message.mqtt, options);
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus"))
                    object.azureServiceBus = $root.protos.opts.ReadGroupAzureServiceBusOptions.toObject(message.azureServiceBus, options);
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub"))
                    object.azureEventHub = $root.protos.opts.ReadGroupAzureEventHubOptions.toObject(message.azureEventHub, options);
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub"))
                    object.gcpPubsub = $root.protos.opts.ReadGroupGCPPubSubOptions.toObject(message.gcpPubsub, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.opts.ReadGroupKubeMQQueueOptions.toObject(message.kubemqQueue, options);
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub"))
                    object.redisPubsub = $root.protos.opts.ReadGroupRedisPubSubOptions.toObject(message.redisPubsub, options);
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams"))
                    object.redisStreams = $root.protos.opts.ReadGroupRedisStreamsOptions.toObject(message.redisStreams, options);
                if (message.postgres != null && message.hasOwnProperty("postgres"))
                    object.postgres = $root.protos.opts.ReadGroupPostgresOptions.toObject(message.postgres, options);
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream"))
                    object.natsJetstream = $root.protos.opts.ReadGroupNatsJetstreamOptions.toObject(message.natsJetstream, options);
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis"))
                    object.awsKinesis = $root.protos.opts.ReadGroupAWSKinesisOptions.toObject(message.awsKinesis, options);
                if (message.memphis != null && message.hasOwnProperty("memphis"))
                    object.memphis = $root.protos.opts.ReadGroupMemphisOptions.toObject(message.memphis, options);
                if (message._id != null && message.hasOwnProperty("_id"))
                    object._id = message._id;
                if (message._active != null && message.hasOwnProperty("_active"))
                    object._active = message._active;
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions"))
                    object._cliOptions = $root.protos.opts.ReadCLIOptions.toObject(message._cliOptions, options);
                return object;
            };

            /**
             * Converts this ReadOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadOptions;
        })();

        opts.ReadGroupKafkaOptions = (function() {

            /**
             * Properties of a ReadGroupKafkaOptions.
             * @memberof protos.opts
             * @interface IReadGroupKafkaOptions
             * @property {protos.args.IKafkaConn|null} [_conn] ReadGroupKafkaOptions _conn
             * @property {protos.args.IKafkaReadArgs|null} [args] ReadGroupKafkaOptions args
             */

            /**
             * Constructs a new ReadGroupKafkaOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupKafkaOptions.
             * @implements IReadGroupKafkaOptions
             * @constructor
             * @param {protos.opts.IReadGroupKafkaOptions=} [properties] Properties to set
             */
            function ReadGroupKafkaOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupKafkaOptions _conn.
             * @member {protos.args.IKafkaConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @instance
             */
            ReadGroupKafkaOptions.prototype._conn = null;

            /**
             * ReadGroupKafkaOptions args.
             * @member {protos.args.IKafkaReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @instance
             */
            ReadGroupKafkaOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupKafkaOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {protos.opts.IReadGroupKafkaOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupKafkaOptions} ReadGroupKafkaOptions instance
             */
            ReadGroupKafkaOptions.create = function create(properties) {
                return new ReadGroupKafkaOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupKafkaOptions message. Does not implicitly {@link protos.opts.ReadGroupKafkaOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {protos.opts.IReadGroupKafkaOptions} message ReadGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupKafkaOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KafkaConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KafkaReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupKafkaOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupKafkaOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {protos.opts.IReadGroupKafkaOptions} message ReadGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupKafkaOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupKafkaOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupKafkaOptions} ReadGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupKafkaOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupKafkaOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KafkaConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KafkaReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupKafkaOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupKafkaOptions} ReadGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupKafkaOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupKafkaOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupKafkaOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KafkaConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KafkaReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupKafkaOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupKafkaOptions} ReadGroupKafkaOptions
             */
            ReadGroupKafkaOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupKafkaOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupKafkaOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupKafkaOptions._conn: object expected");
                    message._conn = $root.protos.args.KafkaConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupKafkaOptions.args: object expected");
                    message.args = $root.protos.args.KafkaReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupKafkaOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {protos.opts.ReadGroupKafkaOptions} message ReadGroupKafkaOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupKafkaOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KafkaConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KafkaReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupKafkaOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupKafkaOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupKafkaOptions;
        })();

        opts.ReadGroupActiveMQOptions = (function() {

            /**
             * Properties of a ReadGroupActiveMQOptions.
             * @memberof protos.opts
             * @interface IReadGroupActiveMQOptions
             * @property {protos.args.IActiveMQConn|null} [_conn] ReadGroupActiveMQOptions _conn
             * @property {protos.args.IActiveMQReadArgs|null} [args] ReadGroupActiveMQOptions args
             */

            /**
             * Constructs a new ReadGroupActiveMQOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupActiveMQOptions.
             * @implements IReadGroupActiveMQOptions
             * @constructor
             * @param {protos.opts.IReadGroupActiveMQOptions=} [properties] Properties to set
             */
            function ReadGroupActiveMQOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupActiveMQOptions _conn.
             * @member {protos.args.IActiveMQConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @instance
             */
            ReadGroupActiveMQOptions.prototype._conn = null;

            /**
             * ReadGroupActiveMQOptions args.
             * @member {protos.args.IActiveMQReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @instance
             */
            ReadGroupActiveMQOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupActiveMQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {protos.opts.IReadGroupActiveMQOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupActiveMQOptions} ReadGroupActiveMQOptions instance
             */
            ReadGroupActiveMQOptions.create = function create(properties) {
                return new ReadGroupActiveMQOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupActiveMQOptions message. Does not implicitly {@link protos.opts.ReadGroupActiveMQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {protos.opts.IReadGroupActiveMQOptions} message ReadGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupActiveMQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.ActiveMQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.ActiveMQReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupActiveMQOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupActiveMQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {protos.opts.IReadGroupActiveMQOptions} message ReadGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupActiveMQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupActiveMQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupActiveMQOptions} ReadGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupActiveMQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupActiveMQOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.ActiveMQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.ActiveMQReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupActiveMQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupActiveMQOptions} ReadGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupActiveMQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupActiveMQOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupActiveMQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.ActiveMQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.ActiveMQReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupActiveMQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupActiveMQOptions} ReadGroupActiveMQOptions
             */
            ReadGroupActiveMQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupActiveMQOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupActiveMQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupActiveMQOptions._conn: object expected");
                    message._conn = $root.protos.args.ActiveMQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupActiveMQOptions.args: object expected");
                    message.args = $root.protos.args.ActiveMQReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupActiveMQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {protos.opts.ReadGroupActiveMQOptions} message ReadGroupActiveMQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupActiveMQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.ActiveMQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.ActiveMQReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupActiveMQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupActiveMQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupActiveMQOptions;
        })();

        opts.ReadGroupAWSSQSOptions = (function() {

            /**
             * Properties of a ReadGroupAWSSQSOptions.
             * @memberof protos.opts
             * @interface IReadGroupAWSSQSOptions
             * @property {protos.args.IAWSSQSConn|null} [_conn] ReadGroupAWSSQSOptions _conn
             * @property {protos.args.IAWSSQSReadArgs|null} [args] ReadGroupAWSSQSOptions args
             */

            /**
             * Constructs a new ReadGroupAWSSQSOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupAWSSQSOptions.
             * @implements IReadGroupAWSSQSOptions
             * @constructor
             * @param {protos.opts.IReadGroupAWSSQSOptions=} [properties] Properties to set
             */
            function ReadGroupAWSSQSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupAWSSQSOptions _conn.
             * @member {protos.args.IAWSSQSConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @instance
             */
            ReadGroupAWSSQSOptions.prototype._conn = null;

            /**
             * ReadGroupAWSSQSOptions args.
             * @member {protos.args.IAWSSQSReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @instance
             */
            ReadGroupAWSSQSOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupAWSSQSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IReadGroupAWSSQSOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupAWSSQSOptions} ReadGroupAWSSQSOptions instance
             */
            ReadGroupAWSSQSOptions.create = function create(properties) {
                return new ReadGroupAWSSQSOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupAWSSQSOptions message. Does not implicitly {@link protos.opts.ReadGroupAWSSQSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IReadGroupAWSSQSOptions} message ReadGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAWSSQSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSQSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSQSReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupAWSSQSOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupAWSSQSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IReadGroupAWSSQSOptions} message ReadGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAWSSQSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupAWSSQSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupAWSSQSOptions} ReadGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAWSSQSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupAWSSQSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSQSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSQSReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupAWSSQSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupAWSSQSOptions} ReadGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAWSSQSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupAWSSQSOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupAWSSQSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSSQSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSSQSReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupAWSSQSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupAWSSQSOptions} ReadGroupAWSSQSOptions
             */
            ReadGroupAWSSQSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupAWSSQSOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupAWSSQSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupAWSSQSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSQSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupAWSSQSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSQSReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupAWSSQSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {protos.opts.ReadGroupAWSSQSOptions} message ReadGroupAWSSQSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupAWSSQSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSQSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSQSReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupAWSSQSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupAWSSQSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupAWSSQSOptions;
        })();

        opts.ReadGroupMongoOptions = (function() {

            /**
             * Properties of a ReadGroupMongoOptions.
             * @memberof protos.opts
             * @interface IReadGroupMongoOptions
             * @property {protos.args.IMongoConn|null} [_conn] ReadGroupMongoOptions _conn
             * @property {protos.args.IMongoReadArgs|null} [args] ReadGroupMongoOptions args
             */

            /**
             * Constructs a new ReadGroupMongoOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupMongoOptions.
             * @implements IReadGroupMongoOptions
             * @constructor
             * @param {protos.opts.IReadGroupMongoOptions=} [properties] Properties to set
             */
            function ReadGroupMongoOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupMongoOptions _conn.
             * @member {protos.args.IMongoConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupMongoOptions
             * @instance
             */
            ReadGroupMongoOptions.prototype._conn = null;

            /**
             * ReadGroupMongoOptions args.
             * @member {protos.args.IMongoReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupMongoOptions
             * @instance
             */
            ReadGroupMongoOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupMongoOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {protos.opts.IReadGroupMongoOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupMongoOptions} ReadGroupMongoOptions instance
             */
            ReadGroupMongoOptions.create = function create(properties) {
                return new ReadGroupMongoOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupMongoOptions message. Does not implicitly {@link protos.opts.ReadGroupMongoOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {protos.opts.IReadGroupMongoOptions} message ReadGroupMongoOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupMongoOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MongoConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MongoReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupMongoOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupMongoOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {protos.opts.IReadGroupMongoOptions} message ReadGroupMongoOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupMongoOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupMongoOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupMongoOptions} ReadGroupMongoOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupMongoOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupMongoOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MongoConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MongoReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupMongoOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupMongoOptions} ReadGroupMongoOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupMongoOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupMongoOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupMongoOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.MongoConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.MongoReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupMongoOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupMongoOptions} ReadGroupMongoOptions
             */
            ReadGroupMongoOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupMongoOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupMongoOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupMongoOptions._conn: object expected");
                    message._conn = $root.protos.args.MongoConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupMongoOptions.args: object expected");
                    message.args = $root.protos.args.MongoReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupMongoOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {protos.opts.ReadGroupMongoOptions} message ReadGroupMongoOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupMongoOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MongoConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MongoReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupMongoOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupMongoOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupMongoOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupMongoOptions;
        })();

        opts.ReadGroupNatsOptions = (function() {

            /**
             * Properties of a ReadGroupNatsOptions.
             * @memberof protos.opts
             * @interface IReadGroupNatsOptions
             * @property {protos.args.INatsConn|null} [_conn] ReadGroupNatsOptions _conn
             * @property {protos.args.INatsReadArgs|null} [args] ReadGroupNatsOptions args
             */

            /**
             * Constructs a new ReadGroupNatsOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupNatsOptions.
             * @implements IReadGroupNatsOptions
             * @constructor
             * @param {protos.opts.IReadGroupNatsOptions=} [properties] Properties to set
             */
            function ReadGroupNatsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupNatsOptions _conn.
             * @member {protos.args.INatsConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupNatsOptions
             * @instance
             */
            ReadGroupNatsOptions.prototype._conn = null;

            /**
             * ReadGroupNatsOptions args.
             * @member {protos.args.INatsReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupNatsOptions
             * @instance
             */
            ReadGroupNatsOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupNatsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {protos.opts.IReadGroupNatsOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupNatsOptions} ReadGroupNatsOptions instance
             */
            ReadGroupNatsOptions.create = function create(properties) {
                return new ReadGroupNatsOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupNatsOptions message. Does not implicitly {@link protos.opts.ReadGroupNatsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {protos.opts.IReadGroupNatsOptions} message ReadGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNatsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupNatsOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupNatsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {protos.opts.IReadGroupNatsOptions} message ReadGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNatsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupNatsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupNatsOptions} ReadGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNatsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupNatsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupNatsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupNatsOptions} ReadGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNatsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupNatsOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupNatsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupNatsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupNatsOptions} ReadGroupNatsOptions
             */
            ReadGroupNatsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupNatsOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupNatsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupNatsOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupNatsOptions.args: object expected");
                    message.args = $root.protos.args.NatsReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupNatsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {protos.opts.ReadGroupNatsOptions} message ReadGroupNatsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupNatsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupNatsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupNatsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupNatsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupNatsOptions;
        })();

        opts.ReadGroupNatsStreamingOptions = (function() {

            /**
             * Properties of a ReadGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @interface IReadGroupNatsStreamingOptions
             * @property {protos.args.INatsStreamingConn|null} [_conn] ReadGroupNatsStreamingOptions _conn
             * @property {protos.args.INatsStreamingReadArgs|null} [args] ReadGroupNatsStreamingOptions args
             */

            /**
             * Constructs a new ReadGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupNatsStreamingOptions.
             * @implements IReadGroupNatsStreamingOptions
             * @constructor
             * @param {protos.opts.IReadGroupNatsStreamingOptions=} [properties] Properties to set
             */
            function ReadGroupNatsStreamingOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupNatsStreamingOptions _conn.
             * @member {protos.args.INatsStreamingConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @instance
             */
            ReadGroupNatsStreamingOptions.prototype._conn = null;

            /**
             * ReadGroupNatsStreamingOptions args.
             * @member {protos.args.INatsStreamingReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @instance
             */
            ReadGroupNatsStreamingOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupNatsStreamingOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IReadGroupNatsStreamingOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupNatsStreamingOptions} ReadGroupNatsStreamingOptions instance
             */
            ReadGroupNatsStreamingOptions.create = function create(properties) {
                return new ReadGroupNatsStreamingOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupNatsStreamingOptions message. Does not implicitly {@link protos.opts.ReadGroupNatsStreamingOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IReadGroupNatsStreamingOptions} message ReadGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNatsStreamingOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsStreamingConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsStreamingReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupNatsStreamingOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupNatsStreamingOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IReadGroupNatsStreamingOptions} message ReadGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNatsStreamingOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupNatsStreamingOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupNatsStreamingOptions} ReadGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNatsStreamingOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupNatsStreamingOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsStreamingConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsStreamingReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupNatsStreamingOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupNatsStreamingOptions} ReadGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNatsStreamingOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupNatsStreamingOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupNatsStreamingOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsStreamingConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsStreamingReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupNatsStreamingOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupNatsStreamingOptions} ReadGroupNatsStreamingOptions
             */
            ReadGroupNatsStreamingOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupNatsStreamingOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupNatsStreamingOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupNatsStreamingOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsStreamingConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupNatsStreamingOptions.args: object expected");
                    message.args = $root.protos.args.NatsStreamingReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupNatsStreamingOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.ReadGroupNatsStreamingOptions} message ReadGroupNatsStreamingOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupNatsStreamingOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsStreamingConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsStreamingReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupNatsStreamingOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupNatsStreamingOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupNatsStreamingOptions;
        })();

        opts.ReadGroupNatsJetstreamOptions = (function() {

            /**
             * Properties of a ReadGroupNatsJetstreamOptions.
             * @memberof protos.opts
             * @interface IReadGroupNatsJetstreamOptions
             * @property {protos.args.INatsJetstreamConn|null} [_conn] ReadGroupNatsJetstreamOptions _conn
             * @property {protos.args.INatsJetstreamReadArgs|null} [args] ReadGroupNatsJetstreamOptions args
             */

            /**
             * Constructs a new ReadGroupNatsJetstreamOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupNatsJetstreamOptions.
             * @implements IReadGroupNatsJetstreamOptions
             * @constructor
             * @param {protos.opts.IReadGroupNatsJetstreamOptions=} [properties] Properties to set
             */
            function ReadGroupNatsJetstreamOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupNatsJetstreamOptions _conn.
             * @member {protos.args.INatsJetstreamConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @instance
             */
            ReadGroupNatsJetstreamOptions.prototype._conn = null;

            /**
             * ReadGroupNatsJetstreamOptions args.
             * @member {protos.args.INatsJetstreamReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @instance
             */
            ReadGroupNatsJetstreamOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupNatsJetstreamOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.IReadGroupNatsJetstreamOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupNatsJetstreamOptions} ReadGroupNatsJetstreamOptions instance
             */
            ReadGroupNatsJetstreamOptions.create = function create(properties) {
                return new ReadGroupNatsJetstreamOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupNatsJetstreamOptions message. Does not implicitly {@link protos.opts.ReadGroupNatsJetstreamOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.IReadGroupNatsJetstreamOptions} message ReadGroupNatsJetstreamOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNatsJetstreamOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsJetstreamConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsJetstreamReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupNatsJetstreamOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupNatsJetstreamOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.IReadGroupNatsJetstreamOptions} message ReadGroupNatsJetstreamOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNatsJetstreamOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupNatsJetstreamOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupNatsJetstreamOptions} ReadGroupNatsJetstreamOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNatsJetstreamOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupNatsJetstreamOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsJetstreamConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsJetstreamReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupNatsJetstreamOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupNatsJetstreamOptions} ReadGroupNatsJetstreamOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNatsJetstreamOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupNatsJetstreamOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupNatsJetstreamOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsJetstreamConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsJetstreamReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupNatsJetstreamOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupNatsJetstreamOptions} ReadGroupNatsJetstreamOptions
             */
            ReadGroupNatsJetstreamOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupNatsJetstreamOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupNatsJetstreamOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupNatsJetstreamOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsJetstreamConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupNatsJetstreamOptions.args: object expected");
                    message.args = $root.protos.args.NatsJetstreamReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupNatsJetstreamOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.ReadGroupNatsJetstreamOptions} message ReadGroupNatsJetstreamOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupNatsJetstreamOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsJetstreamConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsJetstreamReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupNatsJetstreamOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupNatsJetstreamOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupNatsJetstreamOptions;
        })();

        opts.ReadGroupNSQOptions = (function() {

            /**
             * Properties of a ReadGroupNSQOptions.
             * @memberof protos.opts
             * @interface IReadGroupNSQOptions
             * @property {protos.args.INSQConn|null} [_conn] ReadGroupNSQOptions _conn
             * @property {protos.args.INSQReadArgs|null} [args] ReadGroupNSQOptions args
             */

            /**
             * Constructs a new ReadGroupNSQOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupNSQOptions.
             * @implements IReadGroupNSQOptions
             * @constructor
             * @param {protos.opts.IReadGroupNSQOptions=} [properties] Properties to set
             */
            function ReadGroupNSQOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupNSQOptions _conn.
             * @member {protos.args.INSQConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupNSQOptions
             * @instance
             */
            ReadGroupNSQOptions.prototype._conn = null;

            /**
             * ReadGroupNSQOptions args.
             * @member {protos.args.INSQReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupNSQOptions
             * @instance
             */
            ReadGroupNSQOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupNSQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {protos.opts.IReadGroupNSQOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupNSQOptions} ReadGroupNSQOptions instance
             */
            ReadGroupNSQOptions.create = function create(properties) {
                return new ReadGroupNSQOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupNSQOptions message. Does not implicitly {@link protos.opts.ReadGroupNSQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {protos.opts.IReadGroupNSQOptions} message ReadGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNSQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NSQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NSQReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupNSQOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupNSQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {protos.opts.IReadGroupNSQOptions} message ReadGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNSQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupNSQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupNSQOptions} ReadGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNSQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupNSQOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NSQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NSQReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupNSQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupNSQOptions} ReadGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNSQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupNSQOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupNSQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NSQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NSQReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupNSQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupNSQOptions} ReadGroupNSQOptions
             */
            ReadGroupNSQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupNSQOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupNSQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupNSQOptions._conn: object expected");
                    message._conn = $root.protos.args.NSQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupNSQOptions.args: object expected");
                    message.args = $root.protos.args.NSQReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupNSQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {protos.opts.ReadGroupNSQOptions} message ReadGroupNSQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupNSQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NSQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NSQReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupNSQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupNSQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupNSQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupNSQOptions;
        })();

        opts.ReadGroupPostgresOptions = (function() {

            /**
             * Properties of a ReadGroupPostgresOptions.
             * @memberof protos.opts
             * @interface IReadGroupPostgresOptions
             * @property {protos.args.IPostgresConn|null} [_conn] ReadGroupPostgresOptions _conn
             * @property {protos.args.IPostgresReadArgs|null} [args] ReadGroupPostgresOptions args
             */

            /**
             * Constructs a new ReadGroupPostgresOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupPostgresOptions.
             * @implements IReadGroupPostgresOptions
             * @constructor
             * @param {protos.opts.IReadGroupPostgresOptions=} [properties] Properties to set
             */
            function ReadGroupPostgresOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupPostgresOptions _conn.
             * @member {protos.args.IPostgresConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @instance
             */
            ReadGroupPostgresOptions.prototype._conn = null;

            /**
             * ReadGroupPostgresOptions args.
             * @member {protos.args.IPostgresReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @instance
             */
            ReadGroupPostgresOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupPostgresOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {protos.opts.IReadGroupPostgresOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupPostgresOptions} ReadGroupPostgresOptions instance
             */
            ReadGroupPostgresOptions.create = function create(properties) {
                return new ReadGroupPostgresOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupPostgresOptions message. Does not implicitly {@link protos.opts.ReadGroupPostgresOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {protos.opts.IReadGroupPostgresOptions} message ReadGroupPostgresOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupPostgresOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.PostgresConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.PostgresReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupPostgresOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupPostgresOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {protos.opts.IReadGroupPostgresOptions} message ReadGroupPostgresOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupPostgresOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupPostgresOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupPostgresOptions} ReadGroupPostgresOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupPostgresOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupPostgresOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.PostgresConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.PostgresReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupPostgresOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupPostgresOptions} ReadGroupPostgresOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupPostgresOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupPostgresOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupPostgresOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.PostgresConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.PostgresReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupPostgresOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupPostgresOptions} ReadGroupPostgresOptions
             */
            ReadGroupPostgresOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupPostgresOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupPostgresOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupPostgresOptions._conn: object expected");
                    message._conn = $root.protos.args.PostgresConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupPostgresOptions.args: object expected");
                    message.args = $root.protos.args.PostgresReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupPostgresOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {protos.opts.ReadGroupPostgresOptions} message ReadGroupPostgresOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupPostgresOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.PostgresConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.PostgresReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupPostgresOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupPostgresOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupPostgresOptions;
        })();

        opts.ReadGroupPulsarOptions = (function() {

            /**
             * Properties of a ReadGroupPulsarOptions.
             * @memberof protos.opts
             * @interface IReadGroupPulsarOptions
             * @property {protos.args.IPulsarConn|null} [_conn] ReadGroupPulsarOptions _conn
             * @property {protos.args.IPulsarReadArgs|null} [args] ReadGroupPulsarOptions args
             */

            /**
             * Constructs a new ReadGroupPulsarOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupPulsarOptions.
             * @implements IReadGroupPulsarOptions
             * @constructor
             * @param {protos.opts.IReadGroupPulsarOptions=} [properties] Properties to set
             */
            function ReadGroupPulsarOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupPulsarOptions _conn.
             * @member {protos.args.IPulsarConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @instance
             */
            ReadGroupPulsarOptions.prototype._conn = null;

            /**
             * ReadGroupPulsarOptions args.
             * @member {protos.args.IPulsarReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @instance
             */
            ReadGroupPulsarOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupPulsarOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {protos.opts.IReadGroupPulsarOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupPulsarOptions} ReadGroupPulsarOptions instance
             */
            ReadGroupPulsarOptions.create = function create(properties) {
                return new ReadGroupPulsarOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupPulsarOptions message. Does not implicitly {@link protos.opts.ReadGroupPulsarOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {protos.opts.IReadGroupPulsarOptions} message ReadGroupPulsarOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupPulsarOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.PulsarConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.PulsarReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupPulsarOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupPulsarOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {protos.opts.IReadGroupPulsarOptions} message ReadGroupPulsarOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupPulsarOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupPulsarOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupPulsarOptions} ReadGroupPulsarOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupPulsarOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupPulsarOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.PulsarConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.PulsarReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupPulsarOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupPulsarOptions} ReadGroupPulsarOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupPulsarOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupPulsarOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupPulsarOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.PulsarConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.PulsarReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupPulsarOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupPulsarOptions} ReadGroupPulsarOptions
             */
            ReadGroupPulsarOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupPulsarOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupPulsarOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupPulsarOptions._conn: object expected");
                    message._conn = $root.protos.args.PulsarConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupPulsarOptions.args: object expected");
                    message.args = $root.protos.args.PulsarReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupPulsarOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {protos.opts.ReadGroupPulsarOptions} message ReadGroupPulsarOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupPulsarOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.PulsarConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.PulsarReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupPulsarOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupPulsarOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupPulsarOptions;
        })();

        opts.ReadGroupRabbitOptions = (function() {

            /**
             * Properties of a ReadGroupRabbitOptions.
             * @memberof protos.opts
             * @interface IReadGroupRabbitOptions
             * @property {protos.args.IRabbitConn|null} [_conn] ReadGroupRabbitOptions _conn
             * @property {protos.args.IRabbitReadArgs|null} [args] ReadGroupRabbitOptions args
             */

            /**
             * Constructs a new ReadGroupRabbitOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupRabbitOptions.
             * @implements IReadGroupRabbitOptions
             * @constructor
             * @param {protos.opts.IReadGroupRabbitOptions=} [properties] Properties to set
             */
            function ReadGroupRabbitOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupRabbitOptions _conn.
             * @member {protos.args.IRabbitConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @instance
             */
            ReadGroupRabbitOptions.prototype._conn = null;

            /**
             * ReadGroupRabbitOptions args.
             * @member {protos.args.IRabbitReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @instance
             */
            ReadGroupRabbitOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupRabbitOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupRabbitOptions} ReadGroupRabbitOptions instance
             */
            ReadGroupRabbitOptions.create = function create(properties) {
                return new ReadGroupRabbitOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupRabbitOptions message. Does not implicitly {@link protos.opts.ReadGroupRabbitOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitOptions} message ReadGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRabbitOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupRabbitOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupRabbitOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitOptions} message ReadGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRabbitOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupRabbitOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupRabbitOptions} ReadGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRabbitOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupRabbitOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupRabbitOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupRabbitOptions} ReadGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRabbitOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupRabbitOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupRabbitOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RabbitConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RabbitReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupRabbitOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupRabbitOptions} ReadGroupRabbitOptions
             */
            ReadGroupRabbitOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupRabbitOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupRabbitOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupRabbitOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupRabbitOptions.args: object expected");
                    message.args = $root.protos.args.RabbitReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupRabbitOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {protos.opts.ReadGroupRabbitOptions} message ReadGroupRabbitOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupRabbitOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupRabbitOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupRabbitOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupRabbitOptions;
        })();

        opts.ReadGroupRabbitStreamsOptions = (function() {

            /**
             * Properties of a ReadGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @interface IReadGroupRabbitStreamsOptions
             * @property {protos.args.IRabbitStreamsConn|null} [_conn] ReadGroupRabbitStreamsOptions _conn
             * @property {protos.args.IRabbitStreamsReadArgs|null} [args] ReadGroupRabbitStreamsOptions args
             */

            /**
             * Constructs a new ReadGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupRabbitStreamsOptions.
             * @implements IReadGroupRabbitStreamsOptions
             * @constructor
             * @param {protos.opts.IReadGroupRabbitStreamsOptions=} [properties] Properties to set
             */
            function ReadGroupRabbitStreamsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupRabbitStreamsOptions _conn.
             * @member {protos.args.IRabbitStreamsConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @instance
             */
            ReadGroupRabbitStreamsOptions.prototype._conn = null;

            /**
             * ReadGroupRabbitStreamsOptions args.
             * @member {protos.args.IRabbitStreamsReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @instance
             */
            ReadGroupRabbitStreamsOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupRabbitStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupRabbitStreamsOptions} ReadGroupRabbitStreamsOptions instance
             */
            ReadGroupRabbitStreamsOptions.create = function create(properties) {
                return new ReadGroupRabbitStreamsOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupRabbitStreamsOptions message. Does not implicitly {@link protos.opts.ReadGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitStreamsOptions} message ReadGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRabbitStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitStreamsReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupRabbitStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitStreamsOptions} message ReadGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRabbitStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupRabbitStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupRabbitStreamsOptions} ReadGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRabbitStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupRabbitStreamsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitStreamsReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupRabbitStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupRabbitStreamsOptions} ReadGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRabbitStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupRabbitStreamsOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupRabbitStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RabbitStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RabbitStreamsReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupRabbitStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupRabbitStreamsOptions} ReadGroupRabbitStreamsOptions
             */
            ReadGroupRabbitStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupRabbitStreamsOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupRabbitStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupRabbitStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupRabbitStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RabbitStreamsReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupRabbitStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.ReadGroupRabbitStreamsOptions} message ReadGroupRabbitStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupRabbitStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitStreamsReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupRabbitStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupRabbitStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupRabbitStreamsOptions;
        })();

        opts.ReadGroupRedisPubSubOptions = (function() {

            /**
             * Properties of a ReadGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @interface IReadGroupRedisPubSubOptions
             * @property {protos.args.IRedisPubSubConn|null} [_conn] ReadGroupRedisPubSubOptions _conn
             * @property {protos.args.IRedisPubSubReadArgs|null} [args] ReadGroupRedisPubSubOptions args
             */

            /**
             * Constructs a new ReadGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupRedisPubSubOptions.
             * @implements IReadGroupRedisPubSubOptions
             * @constructor
             * @param {protos.opts.IReadGroupRedisPubSubOptions=} [properties] Properties to set
             */
            function ReadGroupRedisPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupRedisPubSubOptions _conn.
             * @member {protos.args.IRedisPubSubConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @instance
             */
            ReadGroupRedisPubSubOptions.prototype._conn = null;

            /**
             * ReadGroupRedisPubSubOptions args.
             * @member {protos.args.IRedisPubSubReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @instance
             */
            ReadGroupRedisPubSubOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupRedisPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupRedisPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupRedisPubSubOptions} ReadGroupRedisPubSubOptions instance
             */
            ReadGroupRedisPubSubOptions.create = function create(properties) {
                return new ReadGroupRedisPubSubOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupRedisPubSubOptions message. Does not implicitly {@link protos.opts.ReadGroupRedisPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupRedisPubSubOptions} message ReadGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRedisPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisPubSubReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupRedisPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupRedisPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupRedisPubSubOptions} message ReadGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRedisPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupRedisPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupRedisPubSubOptions} ReadGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRedisPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupRedisPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisPubSubReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupRedisPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupRedisPubSubOptions} ReadGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRedisPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupRedisPubSubOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupRedisPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisPubSubReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupRedisPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupRedisPubSubOptions} ReadGroupRedisPubSubOptions
             */
            ReadGroupRedisPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupRedisPubSubOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupRedisPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupRedisPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupRedisPubSubOptions.args: object expected");
                    message.args = $root.protos.args.RedisPubSubReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupRedisPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.ReadGroupRedisPubSubOptions} message ReadGroupRedisPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupRedisPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisPubSubReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupRedisPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupRedisPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupRedisPubSubOptions;
        })();

        opts.ReadGroupRedisStreamsOptions = (function() {

            /**
             * Properties of a ReadGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @interface IReadGroupRedisStreamsOptions
             * @property {protos.args.IRedisStreamsConn|null} [_conn] ReadGroupRedisStreamsOptions _conn
             * @property {protos.args.IRedisStreamsReadArgs|null} [args] ReadGroupRedisStreamsOptions args
             */

            /**
             * Constructs a new ReadGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupRedisStreamsOptions.
             * @implements IReadGroupRedisStreamsOptions
             * @constructor
             * @param {protos.opts.IReadGroupRedisStreamsOptions=} [properties] Properties to set
             */
            function ReadGroupRedisStreamsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupRedisStreamsOptions _conn.
             * @member {protos.args.IRedisStreamsConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @instance
             */
            ReadGroupRedisStreamsOptions.prototype._conn = null;

            /**
             * ReadGroupRedisStreamsOptions args.
             * @member {protos.args.IRedisStreamsReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @instance
             */
            ReadGroupRedisStreamsOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupRedisStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRedisStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupRedisStreamsOptions} ReadGroupRedisStreamsOptions instance
             */
            ReadGroupRedisStreamsOptions.create = function create(properties) {
                return new ReadGroupRedisStreamsOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupRedisStreamsOptions message. Does not implicitly {@link protos.opts.ReadGroupRedisStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRedisStreamsOptions} message ReadGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRedisStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisStreamsReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupRedisStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupRedisStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRedisStreamsOptions} message ReadGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRedisStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupRedisStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupRedisStreamsOptions} ReadGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRedisStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupRedisStreamsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisStreamsReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupRedisStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupRedisStreamsOptions} ReadGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRedisStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupRedisStreamsOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupRedisStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisStreamsReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupRedisStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupRedisStreamsOptions} ReadGroupRedisStreamsOptions
             */
            ReadGroupRedisStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupRedisStreamsOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupRedisStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupRedisStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupRedisStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RedisStreamsReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupRedisStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.ReadGroupRedisStreamsOptions} message ReadGroupRedisStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupRedisStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisStreamsReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupRedisStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupRedisStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupRedisStreamsOptions;
        })();

        opts.ReadGroupAzureEventHubOptions = (function() {

            /**
             * Properties of a ReadGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @interface IReadGroupAzureEventHubOptions
             * @property {protos.args.IAzureEventHubConn|null} [_conn] ReadGroupAzureEventHubOptions _conn
             * @property {protos.args.IAzureEventHubReadArgs|null} [args] ReadGroupAzureEventHubOptions args
             */

            /**
             * Constructs a new ReadGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupAzureEventHubOptions.
             * @implements IReadGroupAzureEventHubOptions
             * @constructor
             * @param {protos.opts.IReadGroupAzureEventHubOptions=} [properties] Properties to set
             */
            function ReadGroupAzureEventHubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupAzureEventHubOptions _conn.
             * @member {protos.args.IAzureEventHubConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @instance
             */
            ReadGroupAzureEventHubOptions.prototype._conn = null;

            /**
             * ReadGroupAzureEventHubOptions args.
             * @member {protos.args.IAzureEventHubReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @instance
             */
            ReadGroupAzureEventHubOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupAzureEventHubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IReadGroupAzureEventHubOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupAzureEventHubOptions} ReadGroupAzureEventHubOptions instance
             */
            ReadGroupAzureEventHubOptions.create = function create(properties) {
                return new ReadGroupAzureEventHubOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupAzureEventHubOptions message. Does not implicitly {@link protos.opts.ReadGroupAzureEventHubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IReadGroupAzureEventHubOptions} message ReadGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAzureEventHubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureEventHubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureEventHubReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupAzureEventHubOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupAzureEventHubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IReadGroupAzureEventHubOptions} message ReadGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAzureEventHubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupAzureEventHubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupAzureEventHubOptions} ReadGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAzureEventHubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupAzureEventHubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureEventHubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureEventHubReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupAzureEventHubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupAzureEventHubOptions} ReadGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAzureEventHubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupAzureEventHubOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupAzureEventHubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AzureEventHubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AzureEventHubReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupAzureEventHubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupAzureEventHubOptions} ReadGroupAzureEventHubOptions
             */
            ReadGroupAzureEventHubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupAzureEventHubOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupAzureEventHubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupAzureEventHubOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureEventHubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupAzureEventHubOptions.args: object expected");
                    message.args = $root.protos.args.AzureEventHubReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupAzureEventHubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.ReadGroupAzureEventHubOptions} message ReadGroupAzureEventHubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupAzureEventHubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureEventHubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureEventHubReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupAzureEventHubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupAzureEventHubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupAzureEventHubOptions;
        })();

        opts.ReadGroupAzureServiceBusOptions = (function() {

            /**
             * Properties of a ReadGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @interface IReadGroupAzureServiceBusOptions
             * @property {protos.args.IAzureServiceBusConn|null} [_conn] ReadGroupAzureServiceBusOptions _conn
             * @property {protos.args.IAzureServiceBusReadArgs|null} [args] ReadGroupAzureServiceBusOptions args
             */

            /**
             * Constructs a new ReadGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupAzureServiceBusOptions.
             * @implements IReadGroupAzureServiceBusOptions
             * @constructor
             * @param {protos.opts.IReadGroupAzureServiceBusOptions=} [properties] Properties to set
             */
            function ReadGroupAzureServiceBusOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupAzureServiceBusOptions _conn.
             * @member {protos.args.IAzureServiceBusConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @instance
             */
            ReadGroupAzureServiceBusOptions.prototype._conn = null;

            /**
             * ReadGroupAzureServiceBusOptions args.
             * @member {protos.args.IAzureServiceBusReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @instance
             */
            ReadGroupAzureServiceBusOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupAzureServiceBusOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IReadGroupAzureServiceBusOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupAzureServiceBusOptions} ReadGroupAzureServiceBusOptions instance
             */
            ReadGroupAzureServiceBusOptions.create = function create(properties) {
                return new ReadGroupAzureServiceBusOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupAzureServiceBusOptions message. Does not implicitly {@link protos.opts.ReadGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IReadGroupAzureServiceBusOptions} message ReadGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAzureServiceBusOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureServiceBusConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureServiceBusReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupAzureServiceBusOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IReadGroupAzureServiceBusOptions} message ReadGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAzureServiceBusOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupAzureServiceBusOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupAzureServiceBusOptions} ReadGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAzureServiceBusOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupAzureServiceBusOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureServiceBusConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureServiceBusReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupAzureServiceBusOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupAzureServiceBusOptions} ReadGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAzureServiceBusOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupAzureServiceBusOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupAzureServiceBusOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AzureServiceBusConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AzureServiceBusReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupAzureServiceBusOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupAzureServiceBusOptions} ReadGroupAzureServiceBusOptions
             */
            ReadGroupAzureServiceBusOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupAzureServiceBusOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupAzureServiceBusOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupAzureServiceBusOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureServiceBusConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupAzureServiceBusOptions.args: object expected");
                    message.args = $root.protos.args.AzureServiceBusReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupAzureServiceBusOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.ReadGroupAzureServiceBusOptions} message ReadGroupAzureServiceBusOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupAzureServiceBusOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureServiceBusConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureServiceBusReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupAzureServiceBusOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupAzureServiceBusOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupAzureServiceBusOptions;
        })();

        opts.ReadGroupMQTTOptions = (function() {

            /**
             * Properties of a ReadGroupMQTTOptions.
             * @memberof protos.opts
             * @interface IReadGroupMQTTOptions
             * @property {protos.args.IMQTTConn|null} [_conn] ReadGroupMQTTOptions _conn
             * @property {protos.args.IMQTTReadArgs|null} [args] ReadGroupMQTTOptions args
             */

            /**
             * Constructs a new ReadGroupMQTTOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupMQTTOptions.
             * @implements IReadGroupMQTTOptions
             * @constructor
             * @param {protos.opts.IReadGroupMQTTOptions=} [properties] Properties to set
             */
            function ReadGroupMQTTOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupMQTTOptions _conn.
             * @member {protos.args.IMQTTConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @instance
             */
            ReadGroupMQTTOptions.prototype._conn = null;

            /**
             * ReadGroupMQTTOptions args.
             * @member {protos.args.IMQTTReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @instance
             */
            ReadGroupMQTTOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupMQTTOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {protos.opts.IReadGroupMQTTOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupMQTTOptions} ReadGroupMQTTOptions instance
             */
            ReadGroupMQTTOptions.create = function create(properties) {
                return new ReadGroupMQTTOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupMQTTOptions message. Does not implicitly {@link protos.opts.ReadGroupMQTTOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {protos.opts.IReadGroupMQTTOptions} message ReadGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupMQTTOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MQTTConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MQTTReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupMQTTOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupMQTTOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {protos.opts.IReadGroupMQTTOptions} message ReadGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupMQTTOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupMQTTOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupMQTTOptions} ReadGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupMQTTOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupMQTTOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MQTTConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MQTTReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupMQTTOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupMQTTOptions} ReadGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupMQTTOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupMQTTOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupMQTTOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.MQTTConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.MQTTReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupMQTTOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupMQTTOptions} ReadGroupMQTTOptions
             */
            ReadGroupMQTTOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupMQTTOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupMQTTOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupMQTTOptions._conn: object expected");
                    message._conn = $root.protos.args.MQTTConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupMQTTOptions.args: object expected");
                    message.args = $root.protos.args.MQTTReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupMQTTOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {protos.opts.ReadGroupMQTTOptions} message ReadGroupMQTTOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupMQTTOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MQTTConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MQTTReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupMQTTOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupMQTTOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupMQTTOptions;
        })();

        opts.ReadGroupGCPPubSubOptions = (function() {

            /**
             * Properties of a ReadGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @interface IReadGroupGCPPubSubOptions
             * @property {protos.args.IGCPPubSubConn|null} [_conn] ReadGroupGCPPubSubOptions _conn
             * @property {protos.args.IGCPPubSubReadArgs|null} [args] ReadGroupGCPPubSubOptions args
             */

            /**
             * Constructs a new ReadGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupGCPPubSubOptions.
             * @implements IReadGroupGCPPubSubOptions
             * @constructor
             * @param {protos.opts.IReadGroupGCPPubSubOptions=} [properties] Properties to set
             */
            function ReadGroupGCPPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupGCPPubSubOptions _conn.
             * @member {protos.args.IGCPPubSubConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @instance
             */
            ReadGroupGCPPubSubOptions.prototype._conn = null;

            /**
             * ReadGroupGCPPubSubOptions args.
             * @member {protos.args.IGCPPubSubReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @instance
             */
            ReadGroupGCPPubSubOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupGCPPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupGCPPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupGCPPubSubOptions} ReadGroupGCPPubSubOptions instance
             */
            ReadGroupGCPPubSubOptions.create = function create(properties) {
                return new ReadGroupGCPPubSubOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupGCPPubSubOptions message. Does not implicitly {@link protos.opts.ReadGroupGCPPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupGCPPubSubOptions} message ReadGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupGCPPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.GCPPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.GCPPubSubReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupGCPPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupGCPPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupGCPPubSubOptions} message ReadGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupGCPPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupGCPPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupGCPPubSubOptions} ReadGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupGCPPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupGCPPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.GCPPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.GCPPubSubReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupGCPPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupGCPPubSubOptions} ReadGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupGCPPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupGCPPubSubOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupGCPPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.GCPPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.GCPPubSubReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupGCPPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupGCPPubSubOptions} ReadGroupGCPPubSubOptions
             */
            ReadGroupGCPPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupGCPPubSubOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupGCPPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupGCPPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.GCPPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupGCPPubSubOptions.args: object expected");
                    message.args = $root.protos.args.GCPPubSubReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupGCPPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.ReadGroupGCPPubSubOptions} message ReadGroupGCPPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupGCPPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.GCPPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.GCPPubSubReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupGCPPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupGCPPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupGCPPubSubOptions;
        })();

        opts.ReadGroupKubeMQQueueOptions = (function() {

            /**
             * Properties of a ReadGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @interface IReadGroupKubeMQQueueOptions
             * @property {protos.args.IKubeMQQueueConn|null} [_conn] ReadGroupKubeMQQueueOptions _conn
             * @property {protos.args.IKubeMQQueueReadArgs|null} [args] ReadGroupKubeMQQueueOptions args
             */

            /**
             * Constructs a new ReadGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupKubeMQQueueOptions.
             * @implements IReadGroupKubeMQQueueOptions
             * @constructor
             * @param {protos.opts.IReadGroupKubeMQQueueOptions=} [properties] Properties to set
             */
            function ReadGroupKubeMQQueueOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupKubeMQQueueOptions _conn.
             * @member {protos.args.IKubeMQQueueConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @instance
             */
            ReadGroupKubeMQQueueOptions.prototype._conn = null;

            /**
             * ReadGroupKubeMQQueueOptions args.
             * @member {protos.args.IKubeMQQueueReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @instance
             */
            ReadGroupKubeMQQueueOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupKubeMQQueueOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IReadGroupKubeMQQueueOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupKubeMQQueueOptions} ReadGroupKubeMQQueueOptions instance
             */
            ReadGroupKubeMQQueueOptions.create = function create(properties) {
                return new ReadGroupKubeMQQueueOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupKubeMQQueueOptions message. Does not implicitly {@link protos.opts.ReadGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IReadGroupKubeMQQueueOptions} message ReadGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupKubeMQQueueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KubeMQQueueConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KubeMQQueueReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupKubeMQQueueOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IReadGroupKubeMQQueueOptions} message ReadGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupKubeMQQueueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupKubeMQQueueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupKubeMQQueueOptions} ReadGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupKubeMQQueueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupKubeMQQueueOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KubeMQQueueConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KubeMQQueueReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupKubeMQQueueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupKubeMQQueueOptions} ReadGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupKubeMQQueueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupKubeMQQueueOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupKubeMQQueueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KubeMQQueueConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KubeMQQueueReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupKubeMQQueueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupKubeMQQueueOptions} ReadGroupKubeMQQueueOptions
             */
            ReadGroupKubeMQQueueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupKubeMQQueueOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupKubeMQQueueOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupKubeMQQueueOptions._conn: object expected");
                    message._conn = $root.protos.args.KubeMQQueueConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupKubeMQQueueOptions.args: object expected");
                    message.args = $root.protos.args.KubeMQQueueReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupKubeMQQueueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.ReadGroupKubeMQQueueOptions} message ReadGroupKubeMQQueueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupKubeMQQueueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KubeMQQueueConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KubeMQQueueReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupKubeMQQueueOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupKubeMQQueueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupKubeMQQueueOptions;
        })();

        opts.ReadGroupAWSKinesisOptions = (function() {

            /**
             * Properties of a ReadGroupAWSKinesisOptions.
             * @memberof protos.opts
             * @interface IReadGroupAWSKinesisOptions
             * @property {protos.args.IAWSKinesisConn|null} [_conn] ReadGroupAWSKinesisOptions _conn
             * @property {protos.args.IAWSKinesisReadArgs|null} [args] ReadGroupAWSKinesisOptions args
             */

            /**
             * Constructs a new ReadGroupAWSKinesisOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupAWSKinesisOptions.
             * @implements IReadGroupAWSKinesisOptions
             * @constructor
             * @param {protos.opts.IReadGroupAWSKinesisOptions=} [properties] Properties to set
             */
            function ReadGroupAWSKinesisOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupAWSKinesisOptions _conn.
             * @member {protos.args.IAWSKinesisConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @instance
             */
            ReadGroupAWSKinesisOptions.prototype._conn = null;

            /**
             * ReadGroupAWSKinesisOptions args.
             * @member {protos.args.IAWSKinesisReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @instance
             */
            ReadGroupAWSKinesisOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupAWSKinesisOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.IReadGroupAWSKinesisOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupAWSKinesisOptions} ReadGroupAWSKinesisOptions instance
             */
            ReadGroupAWSKinesisOptions.create = function create(properties) {
                return new ReadGroupAWSKinesisOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupAWSKinesisOptions message. Does not implicitly {@link protos.opts.ReadGroupAWSKinesisOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.IReadGroupAWSKinesisOptions} message ReadGroupAWSKinesisOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAWSKinesisOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSKinesisConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSKinesisReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupAWSKinesisOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupAWSKinesisOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.IReadGroupAWSKinesisOptions} message ReadGroupAWSKinesisOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAWSKinesisOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupAWSKinesisOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupAWSKinesisOptions} ReadGroupAWSKinesisOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAWSKinesisOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupAWSKinesisOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSKinesisConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSKinesisReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupAWSKinesisOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupAWSKinesisOptions} ReadGroupAWSKinesisOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAWSKinesisOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupAWSKinesisOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupAWSKinesisOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSKinesisConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSKinesisReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupAWSKinesisOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupAWSKinesisOptions} ReadGroupAWSKinesisOptions
             */
            ReadGroupAWSKinesisOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupAWSKinesisOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupAWSKinesisOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupAWSKinesisOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSKinesisConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupAWSKinesisOptions.args: object expected");
                    message.args = $root.protos.args.AWSKinesisReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupAWSKinesisOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.ReadGroupAWSKinesisOptions} message ReadGroupAWSKinesisOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupAWSKinesisOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSKinesisConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSKinesisReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupAWSKinesisOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupAWSKinesisOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupAWSKinesisOptions;
        })();

        opts.ReadGroupMemphisOptions = (function() {

            /**
             * Properties of a ReadGroupMemphisOptions.
             * @memberof protos.opts
             * @interface IReadGroupMemphisOptions
             * @property {protos.args.IMemphisConn|null} [_conn] ReadGroupMemphisOptions _conn
             * @property {protos.args.IMemphisReadArgs|null} [args] ReadGroupMemphisOptions args
             */

            /**
             * Constructs a new ReadGroupMemphisOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupMemphisOptions.
             * @implements IReadGroupMemphisOptions
             * @constructor
             * @param {protos.opts.IReadGroupMemphisOptions=} [properties] Properties to set
             */
            function ReadGroupMemphisOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupMemphisOptions _conn.
             * @member {protos.args.IMemphisConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupMemphisOptions
             * @instance
             */
            ReadGroupMemphisOptions.prototype._conn = null;

            /**
             * ReadGroupMemphisOptions args.
             * @member {protos.args.IMemphisReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupMemphisOptions
             * @instance
             */
            ReadGroupMemphisOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupMemphisOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupMemphisOptions
             * @static
             * @param {protos.opts.IReadGroupMemphisOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupMemphisOptions} ReadGroupMemphisOptions instance
             */
            ReadGroupMemphisOptions.create = function create(properties) {
                return new ReadGroupMemphisOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupMemphisOptions message. Does not implicitly {@link protos.opts.ReadGroupMemphisOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupMemphisOptions
             * @static
             * @param {protos.opts.IReadGroupMemphisOptions} message ReadGroupMemphisOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupMemphisOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MemphisConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MemphisReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupMemphisOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupMemphisOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupMemphisOptions
             * @static
             * @param {protos.opts.IReadGroupMemphisOptions} message ReadGroupMemphisOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupMemphisOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupMemphisOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupMemphisOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupMemphisOptions} ReadGroupMemphisOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupMemphisOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupMemphisOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MemphisConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MemphisReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupMemphisOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupMemphisOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupMemphisOptions} ReadGroupMemphisOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupMemphisOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupMemphisOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupMemphisOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupMemphisOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.MemphisConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.MemphisReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupMemphisOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupMemphisOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupMemphisOptions} ReadGroupMemphisOptions
             */
            ReadGroupMemphisOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupMemphisOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupMemphisOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupMemphisOptions._conn: object expected");
                    message._conn = $root.protos.args.MemphisConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupMemphisOptions.args: object expected");
                    message.args = $root.protos.args.MemphisReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupMemphisOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupMemphisOptions
             * @static
             * @param {protos.opts.ReadGroupMemphisOptions} message ReadGroupMemphisOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupMemphisOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MemphisConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MemphisReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupMemphisOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupMemphisOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupMemphisOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupMemphisOptions;
        })();

        opts.InferSchemaOptions = (function() {

            /**
             * Properties of an InferSchemaOptions.
             * @memberof protos.opts
             * @interface IInferSchemaOptions
             * @property {protos.opts.InferSchemaOptions.Type|null} [type] InferSchemaOptions type
             * @property {string|null} [schemaId] InferSchemaOptions schemaId
             */

            /**
             * Constructs a new InferSchemaOptions.
             * @memberof protos.opts
             * @classdesc Represents an InferSchemaOptions.
             * @implements IInferSchemaOptions
             * @constructor
             * @param {protos.opts.IInferSchemaOptions=} [properties] Properties to set
             */
            function InferSchemaOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InferSchemaOptions type.
             * @member {protos.opts.InferSchemaOptions.Type} type
             * @memberof protos.opts.InferSchemaOptions
             * @instance
             */
            InferSchemaOptions.prototype.type = 0;

            /**
             * InferSchemaOptions schemaId.
             * @member {string} schemaId
             * @memberof protos.opts.InferSchemaOptions
             * @instance
             */
            InferSchemaOptions.prototype.schemaId = "";

            /**
             * Creates a new InferSchemaOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {protos.opts.IInferSchemaOptions=} [properties] Properties to set
             * @returns {protos.opts.InferSchemaOptions} InferSchemaOptions instance
             */
            InferSchemaOptions.create = function create(properties) {
                return new InferSchemaOptions(properties);
            };

            /**
             * Encodes the specified InferSchemaOptions message. Does not implicitly {@link protos.opts.InferSchemaOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {protos.opts.IInferSchemaOptions} message InferSchemaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InferSchemaOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.schemaId != null && Object.hasOwnProperty.call(message, "schemaId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.schemaId);
                return writer;
            };

            /**
             * Encodes the specified InferSchemaOptions message, length delimited. Does not implicitly {@link protos.opts.InferSchemaOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {protos.opts.IInferSchemaOptions} message InferSchemaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InferSchemaOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InferSchemaOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.InferSchemaOptions} InferSchemaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InferSchemaOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.InferSchemaOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.schemaId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InferSchemaOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.InferSchemaOptions} InferSchemaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InferSchemaOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InferSchemaOptions message.
             * @function verify
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InferSchemaOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    if (!$util.isString(message.schemaId))
                        return "schemaId: string expected";
                return null;
            };

            /**
             * Creates an InferSchemaOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.InferSchemaOptions} InferSchemaOptions
             */
            InferSchemaOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.InferSchemaOptions)
                    return object;
                var message = new $root.protos.opts.InferSchemaOptions();
                switch (object.type) {
                case "UNSET":
                case 0:
                    message.type = 0;
                    break;
                case "JSONSCHEMA":
                case 1:
                    message.type = 1;
                    break;
                }
                if (object.schemaId != null)
                    message.schemaId = String(object.schemaId);
                return message;
            };

            /**
             * Creates a plain object from an InferSchemaOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {protos.opts.InferSchemaOptions} message InferSchemaOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InferSchemaOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNSET" : 0;
                    object.schemaId = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.protos.opts.InferSchemaOptions.Type[message.type] : message.type;
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    object.schemaId = message.schemaId;
                return object;
            };

            /**
             * Converts this InferSchemaOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.InferSchemaOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InferSchemaOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name protos.opts.InferSchemaOptions.Type
             * @enum {number}
             * @property {number} UNSET=0 UNSET value
             * @property {number} JSONSCHEMA=1 JSONSCHEMA value
             */
            InferSchemaOptions.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSET"] = 0;
                values[valuesById[1] = "JSONSCHEMA"] = 1;
                return values;
            })();

            return InferSchemaOptions;
        })();

        /**
         * StreamdalOutputType enum.
         * @name protos.opts.StreamdalOutputType
         * @enum {number}
         * @property {number} TABLE=0 TABLE value
         * @property {number} JSON=1 JSON value
         */
        opts.StreamdalOutputType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "TABLE"] = 0;
            values[valuesById[1] = "JSON"] = 1;
            return values;
        })();

        /**
         * StreamdalReplayType enum.
         * @name protos.opts.StreamdalReplayType
         * @enum {number}
         * @property {number} SINGLE=0 SINGLE value
         * @property {number} CONTINUOUS=1 CONTINUOUS value
         */
        opts.StreamdalReplayType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SINGLE"] = 0;
            values[valuesById[1] = "CONTINUOUS"] = 1;
            return values;
        })();

        opts.StreamdalOptions = (function() {

            /**
             * Properties of a StreamdalOptions.
             * @memberof protos.opts
             * @interface IStreamdalOptions
             * @property {protos.opts.StreamdalOutputType|null} [outputType] StreamdalOptions outputType
             * @property {string|null} [apiUrl] StreamdalOptions apiUrl
             * @property {protos.opts.IStreamdalLoginOptions|null} [login] StreamdalOptions login
             * @property {protos.opts.IStreamdalLogoutOptions|null} [logout] StreamdalOptions logout
             * @property {protos.opts.IStreamdalListOptions|null} [list] StreamdalOptions list
             * @property {protos.opts.IStreamdalCreateOptions|null} [create] StreamdalOptions create
             * @property {protos.opts.IStreamdalSearchOptions|null} [search] StreamdalOptions search
             * @property {protos.opts.IStreamdalArchiveOptions|null} [archive] StreamdalOptions archive
             */

            /**
             * Constructs a new StreamdalOptions.
             * @memberof protos.opts
             * @classdesc Represents a StreamdalOptions.
             * @implements IStreamdalOptions
             * @constructor
             * @param {protos.opts.IStreamdalOptions=} [properties] Properties to set
             */
            function StreamdalOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StreamdalOptions outputType.
             * @member {protos.opts.StreamdalOutputType} outputType
             * @memberof protos.opts.StreamdalOptions
             * @instance
             */
            StreamdalOptions.prototype.outputType = 0;

            /**
             * StreamdalOptions apiUrl.
             * @member {string} apiUrl
             * @memberof protos.opts.StreamdalOptions
             * @instance
             */
            StreamdalOptions.prototype.apiUrl = "";

            /**
             * StreamdalOptions login.
             * @member {protos.opts.IStreamdalLoginOptions|null|undefined} login
             * @memberof protos.opts.StreamdalOptions
             * @instance
             */
            StreamdalOptions.prototype.login = null;

            /**
             * StreamdalOptions logout.
             * @member {protos.opts.IStreamdalLogoutOptions|null|undefined} logout
             * @memberof protos.opts.StreamdalOptions
             * @instance
             */
            StreamdalOptions.prototype.logout = null;

            /**
             * StreamdalOptions list.
             * @member {protos.opts.IStreamdalListOptions|null|undefined} list
             * @memberof protos.opts.StreamdalOptions
             * @instance
             */
            StreamdalOptions.prototype.list = null;

            /**
             * StreamdalOptions create.
             * @member {protos.opts.IStreamdalCreateOptions|null|undefined} create
             * @memberof protos.opts.StreamdalOptions
             * @instance
             */
            StreamdalOptions.prototype.create = null;

            /**
             * StreamdalOptions search.
             * @member {protos.opts.IStreamdalSearchOptions|null|undefined} search
             * @memberof protos.opts.StreamdalOptions
             * @instance
             */
            StreamdalOptions.prototype.search = null;

            /**
             * StreamdalOptions archive.
             * @member {protos.opts.IStreamdalArchiveOptions|null|undefined} archive
             * @memberof protos.opts.StreamdalOptions
             * @instance
             */
            StreamdalOptions.prototype.archive = null;

            /**
             * Creates a new StreamdalOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.StreamdalOptions
             * @static
             * @param {protos.opts.IStreamdalOptions=} [properties] Properties to set
             * @returns {protos.opts.StreamdalOptions} StreamdalOptions instance
             */
            StreamdalOptions.create = function create(properties) {
                return new StreamdalOptions(properties);
            };

            /**
             * Encodes the specified StreamdalOptions message. Does not implicitly {@link protos.opts.StreamdalOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.StreamdalOptions
             * @static
             * @param {protos.opts.IStreamdalOptions} message StreamdalOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.outputType != null && Object.hasOwnProperty.call(message, "outputType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.outputType);
                if (message.apiUrl != null && Object.hasOwnProperty.call(message, "apiUrl"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.apiUrl);
                if (message.login != null && Object.hasOwnProperty.call(message, "login"))
                    $root.protos.opts.StreamdalLoginOptions.encode(message.login, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.logout != null && Object.hasOwnProperty.call(message, "logout"))
                    $root.protos.opts.StreamdalLogoutOptions.encode(message.logout, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.list != null && Object.hasOwnProperty.call(message, "list"))
                    $root.protos.opts.StreamdalListOptions.encode(message.list, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.create != null && Object.hasOwnProperty.call(message, "create"))
                    $root.protos.opts.StreamdalCreateOptions.encode(message.create, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.search != null && Object.hasOwnProperty.call(message, "search"))
                    $root.protos.opts.StreamdalSearchOptions.encode(message.search, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.archive != null && Object.hasOwnProperty.call(message, "archive"))
                    $root.protos.opts.StreamdalArchiveOptions.encode(message.archive, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified StreamdalOptions message, length delimited. Does not implicitly {@link protos.opts.StreamdalOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.StreamdalOptions
             * @static
             * @param {protos.opts.IStreamdalOptions} message StreamdalOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StreamdalOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.StreamdalOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.StreamdalOptions} StreamdalOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.StreamdalOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.outputType = reader.int32();
                        break;
                    case 2:
                        message.apiUrl = reader.string();
                        break;
                    case 3:
                        message.login = $root.protos.opts.StreamdalLoginOptions.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.logout = $root.protos.opts.StreamdalLogoutOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.list = $root.protos.opts.StreamdalListOptions.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.create = $root.protos.opts.StreamdalCreateOptions.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.search = $root.protos.opts.StreamdalSearchOptions.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.archive = $root.protos.opts.StreamdalArchiveOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StreamdalOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.StreamdalOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.StreamdalOptions} StreamdalOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StreamdalOptions message.
             * @function verify
             * @memberof protos.opts.StreamdalOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StreamdalOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    switch (message.outputType) {
                    default:
                        return "outputType: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.apiUrl != null && message.hasOwnProperty("apiUrl"))
                    if (!$util.isString(message.apiUrl))
                        return "apiUrl: string expected";
                if (message.login != null && message.hasOwnProperty("login")) {
                    var error = $root.protos.opts.StreamdalLoginOptions.verify(message.login);
                    if (error)
                        return "login." + error;
                }
                if (message.logout != null && message.hasOwnProperty("logout")) {
                    var error = $root.protos.opts.StreamdalLogoutOptions.verify(message.logout);
                    if (error)
                        return "logout." + error;
                }
                if (message.list != null && message.hasOwnProperty("list")) {
                    var error = $root.protos.opts.StreamdalListOptions.verify(message.list);
                    if (error)
                        return "list." + error;
                }
                if (message.create != null && message.hasOwnProperty("create")) {
                    var error = $root.protos.opts.StreamdalCreateOptions.verify(message.create);
                    if (error)
                        return "create." + error;
                }
                if (message.search != null && message.hasOwnProperty("search")) {
                    var error = $root.protos.opts.StreamdalSearchOptions.verify(message.search);
                    if (error)
                        return "search." + error;
                }
                if (message.archive != null && message.hasOwnProperty("archive")) {
                    var error = $root.protos.opts.StreamdalArchiveOptions.verify(message.archive);
                    if (error)
                        return "archive." + error;
                }
                return null;
            };

            /**
             * Creates a StreamdalOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.StreamdalOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.StreamdalOptions} StreamdalOptions
             */
            StreamdalOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.StreamdalOptions)
                    return object;
                var message = new $root.protos.opts.StreamdalOptions();
                switch (object.outputType) {
                case "TABLE":
                case 0:
                    message.outputType = 0;
                    break;
                case "JSON":
                case 1:
                    message.outputType = 1;
                    break;
                }
                if (object.apiUrl != null)
                    message.apiUrl = String(object.apiUrl);
                if (object.login != null) {
                    if (typeof object.login !== "object")
                        throw TypeError(".protos.opts.StreamdalOptions.login: object expected");
                    message.login = $root.protos.opts.StreamdalLoginOptions.fromObject(object.login);
                }
                if (object.logout != null) {
                    if (typeof object.logout !== "object")
                        throw TypeError(".protos.opts.StreamdalOptions.logout: object expected");
                    message.logout = $root.protos.opts.StreamdalLogoutOptions.fromObject(object.logout);
                }
                if (object.list != null) {
                    if (typeof object.list !== "object")
                        throw TypeError(".protos.opts.StreamdalOptions.list: object expected");
                    message.list = $root.protos.opts.StreamdalListOptions.fromObject(object.list);
                }
                if (object.create != null) {
                    if (typeof object.create !== "object")
                        throw TypeError(".protos.opts.StreamdalOptions.create: object expected");
                    message.create = $root.protos.opts.StreamdalCreateOptions.fromObject(object.create);
                }
                if (object.search != null) {
                    if (typeof object.search !== "object")
                        throw TypeError(".protos.opts.StreamdalOptions.search: object expected");
                    message.search = $root.protos.opts.StreamdalSearchOptions.fromObject(object.search);
                }
                if (object.archive != null) {
                    if (typeof object.archive !== "object")
                        throw TypeError(".protos.opts.StreamdalOptions.archive: object expected");
                    message.archive = $root.protos.opts.StreamdalArchiveOptions.fromObject(object.archive);
                }
                return message;
            };

            /**
             * Creates a plain object from a StreamdalOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.StreamdalOptions
             * @static
             * @param {protos.opts.StreamdalOptions} message StreamdalOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StreamdalOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.outputType = options.enums === String ? "TABLE" : 0;
                    object.apiUrl = "";
                    object.login = null;
                    object.logout = null;
                    object.list = null;
                    object.create = null;
                    object.search = null;
                    object.archive = null;
                }
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    object.outputType = options.enums === String ? $root.protos.opts.StreamdalOutputType[message.outputType] : message.outputType;
                if (message.apiUrl != null && message.hasOwnProperty("apiUrl"))
                    object.apiUrl = message.apiUrl;
                if (message.login != null && message.hasOwnProperty("login"))
                    object.login = $root.protos.opts.StreamdalLoginOptions.toObject(message.login, options);
                if (message.logout != null && message.hasOwnProperty("logout"))
                    object.logout = $root.protos.opts.StreamdalLogoutOptions.toObject(message.logout, options);
                if (message.list != null && message.hasOwnProperty("list"))
                    object.list = $root.protos.opts.StreamdalListOptions.toObject(message.list, options);
                if (message.create != null && message.hasOwnProperty("create"))
                    object.create = $root.protos.opts.StreamdalCreateOptions.toObject(message.create, options);
                if (message.search != null && message.hasOwnProperty("search"))
                    object.search = $root.protos.opts.StreamdalSearchOptions.toObject(message.search, options);
                if (message.archive != null && message.hasOwnProperty("archive"))
                    object.archive = $root.protos.opts.StreamdalArchiveOptions.toObject(message.archive, options);
                return object;
            };

            /**
             * Converts this StreamdalOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.StreamdalOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StreamdalOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StreamdalOptions;
        })();

        opts.StreamdalLoginOptions = (function() {

            /**
             * Properties of a StreamdalLoginOptions.
             * @memberof protos.opts
             * @interface IStreamdalLoginOptions
             */

            /**
             * Constructs a new StreamdalLoginOptions.
             * @memberof protos.opts
             * @classdesc Represents a StreamdalLoginOptions.
             * @implements IStreamdalLoginOptions
             * @constructor
             * @param {protos.opts.IStreamdalLoginOptions=} [properties] Properties to set
             */
            function StreamdalLoginOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new StreamdalLoginOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.StreamdalLoginOptions
             * @static
             * @param {protos.opts.IStreamdalLoginOptions=} [properties] Properties to set
             * @returns {protos.opts.StreamdalLoginOptions} StreamdalLoginOptions instance
             */
            StreamdalLoginOptions.create = function create(properties) {
                return new StreamdalLoginOptions(properties);
            };

            /**
             * Encodes the specified StreamdalLoginOptions message. Does not implicitly {@link protos.opts.StreamdalLoginOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.StreamdalLoginOptions
             * @static
             * @param {protos.opts.IStreamdalLoginOptions} message StreamdalLoginOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalLoginOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified StreamdalLoginOptions message, length delimited. Does not implicitly {@link protos.opts.StreamdalLoginOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.StreamdalLoginOptions
             * @static
             * @param {protos.opts.IStreamdalLoginOptions} message StreamdalLoginOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalLoginOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StreamdalLoginOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.StreamdalLoginOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.StreamdalLoginOptions} StreamdalLoginOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalLoginOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.StreamdalLoginOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StreamdalLoginOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.StreamdalLoginOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.StreamdalLoginOptions} StreamdalLoginOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalLoginOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StreamdalLoginOptions message.
             * @function verify
             * @memberof protos.opts.StreamdalLoginOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StreamdalLoginOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a StreamdalLoginOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.StreamdalLoginOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.StreamdalLoginOptions} StreamdalLoginOptions
             */
            StreamdalLoginOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.StreamdalLoginOptions)
                    return object;
                return new $root.protos.opts.StreamdalLoginOptions();
            };

            /**
             * Creates a plain object from a StreamdalLoginOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.StreamdalLoginOptions
             * @static
             * @param {protos.opts.StreamdalLoginOptions} message StreamdalLoginOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StreamdalLoginOptions.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this StreamdalLoginOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.StreamdalLoginOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StreamdalLoginOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StreamdalLoginOptions;
        })();

        opts.StreamdalLogoutOptions = (function() {

            /**
             * Properties of a StreamdalLogoutOptions.
             * @memberof protos.opts
             * @interface IStreamdalLogoutOptions
             */

            /**
             * Constructs a new StreamdalLogoutOptions.
             * @memberof protos.opts
             * @classdesc Represents a StreamdalLogoutOptions.
             * @implements IStreamdalLogoutOptions
             * @constructor
             * @param {protos.opts.IStreamdalLogoutOptions=} [properties] Properties to set
             */
            function StreamdalLogoutOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new StreamdalLogoutOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.StreamdalLogoutOptions
             * @static
             * @param {protos.opts.IStreamdalLogoutOptions=} [properties] Properties to set
             * @returns {protos.opts.StreamdalLogoutOptions} StreamdalLogoutOptions instance
             */
            StreamdalLogoutOptions.create = function create(properties) {
                return new StreamdalLogoutOptions(properties);
            };

            /**
             * Encodes the specified StreamdalLogoutOptions message. Does not implicitly {@link protos.opts.StreamdalLogoutOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.StreamdalLogoutOptions
             * @static
             * @param {protos.opts.IStreamdalLogoutOptions} message StreamdalLogoutOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalLogoutOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified StreamdalLogoutOptions message, length delimited. Does not implicitly {@link protos.opts.StreamdalLogoutOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.StreamdalLogoutOptions
             * @static
             * @param {protos.opts.IStreamdalLogoutOptions} message StreamdalLogoutOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalLogoutOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StreamdalLogoutOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.StreamdalLogoutOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.StreamdalLogoutOptions} StreamdalLogoutOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalLogoutOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.StreamdalLogoutOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StreamdalLogoutOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.StreamdalLogoutOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.StreamdalLogoutOptions} StreamdalLogoutOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalLogoutOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StreamdalLogoutOptions message.
             * @function verify
             * @memberof protos.opts.StreamdalLogoutOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StreamdalLogoutOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a StreamdalLogoutOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.StreamdalLogoutOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.StreamdalLogoutOptions} StreamdalLogoutOptions
             */
            StreamdalLogoutOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.StreamdalLogoutOptions)
                    return object;
                return new $root.protos.opts.StreamdalLogoutOptions();
            };

            /**
             * Creates a plain object from a StreamdalLogoutOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.StreamdalLogoutOptions
             * @static
             * @param {protos.opts.StreamdalLogoutOptions} message StreamdalLogoutOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StreamdalLogoutOptions.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this StreamdalLogoutOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.StreamdalLogoutOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StreamdalLogoutOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StreamdalLogoutOptions;
        })();

        opts.StreamdalListCollectionOptions = (function() {

            /**
             * Properties of a StreamdalListCollectionOptions.
             * @memberof protos.opts
             * @interface IStreamdalListCollectionOptions
             */

            /**
             * Constructs a new StreamdalListCollectionOptions.
             * @memberof protos.opts
             * @classdesc Represents a StreamdalListCollectionOptions.
             * @implements IStreamdalListCollectionOptions
             * @constructor
             * @param {protos.opts.IStreamdalListCollectionOptions=} [properties] Properties to set
             */
            function StreamdalListCollectionOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new StreamdalListCollectionOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.StreamdalListCollectionOptions
             * @static
             * @param {protos.opts.IStreamdalListCollectionOptions=} [properties] Properties to set
             * @returns {protos.opts.StreamdalListCollectionOptions} StreamdalListCollectionOptions instance
             */
            StreamdalListCollectionOptions.create = function create(properties) {
                return new StreamdalListCollectionOptions(properties);
            };

            /**
             * Encodes the specified StreamdalListCollectionOptions message. Does not implicitly {@link protos.opts.StreamdalListCollectionOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.StreamdalListCollectionOptions
             * @static
             * @param {protos.opts.IStreamdalListCollectionOptions} message StreamdalListCollectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalListCollectionOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified StreamdalListCollectionOptions message, length delimited. Does not implicitly {@link protos.opts.StreamdalListCollectionOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.StreamdalListCollectionOptions
             * @static
             * @param {protos.opts.IStreamdalListCollectionOptions} message StreamdalListCollectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalListCollectionOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StreamdalListCollectionOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.StreamdalListCollectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.StreamdalListCollectionOptions} StreamdalListCollectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalListCollectionOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.StreamdalListCollectionOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StreamdalListCollectionOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.StreamdalListCollectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.StreamdalListCollectionOptions} StreamdalListCollectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalListCollectionOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StreamdalListCollectionOptions message.
             * @function verify
             * @memberof protos.opts.StreamdalListCollectionOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StreamdalListCollectionOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a StreamdalListCollectionOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.StreamdalListCollectionOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.StreamdalListCollectionOptions} StreamdalListCollectionOptions
             */
            StreamdalListCollectionOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.StreamdalListCollectionOptions)
                    return object;
                return new $root.protos.opts.StreamdalListCollectionOptions();
            };

            /**
             * Creates a plain object from a StreamdalListCollectionOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.StreamdalListCollectionOptions
             * @static
             * @param {protos.opts.StreamdalListCollectionOptions} message StreamdalListCollectionOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StreamdalListCollectionOptions.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this StreamdalListCollectionOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.StreamdalListCollectionOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StreamdalListCollectionOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StreamdalListCollectionOptions;
        })();

        opts.StreamdalListDestinationOptions = (function() {

            /**
             * Properties of a StreamdalListDestinationOptions.
             * @memberof protos.opts
             * @interface IStreamdalListDestinationOptions
             */

            /**
             * Constructs a new StreamdalListDestinationOptions.
             * @memberof protos.opts
             * @classdesc Represents a StreamdalListDestinationOptions.
             * @implements IStreamdalListDestinationOptions
             * @constructor
             * @param {protos.opts.IStreamdalListDestinationOptions=} [properties] Properties to set
             */
            function StreamdalListDestinationOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new StreamdalListDestinationOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.StreamdalListDestinationOptions
             * @static
             * @param {protos.opts.IStreamdalListDestinationOptions=} [properties] Properties to set
             * @returns {protos.opts.StreamdalListDestinationOptions} StreamdalListDestinationOptions instance
             */
            StreamdalListDestinationOptions.create = function create(properties) {
                return new StreamdalListDestinationOptions(properties);
            };

            /**
             * Encodes the specified StreamdalListDestinationOptions message. Does not implicitly {@link protos.opts.StreamdalListDestinationOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.StreamdalListDestinationOptions
             * @static
             * @param {protos.opts.IStreamdalListDestinationOptions} message StreamdalListDestinationOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalListDestinationOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified StreamdalListDestinationOptions message, length delimited. Does not implicitly {@link protos.opts.StreamdalListDestinationOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.StreamdalListDestinationOptions
             * @static
             * @param {protos.opts.IStreamdalListDestinationOptions} message StreamdalListDestinationOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalListDestinationOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StreamdalListDestinationOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.StreamdalListDestinationOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.StreamdalListDestinationOptions} StreamdalListDestinationOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalListDestinationOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.StreamdalListDestinationOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StreamdalListDestinationOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.StreamdalListDestinationOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.StreamdalListDestinationOptions} StreamdalListDestinationOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalListDestinationOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StreamdalListDestinationOptions message.
             * @function verify
             * @memberof protos.opts.StreamdalListDestinationOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StreamdalListDestinationOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a StreamdalListDestinationOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.StreamdalListDestinationOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.StreamdalListDestinationOptions} StreamdalListDestinationOptions
             */
            StreamdalListDestinationOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.StreamdalListDestinationOptions)
                    return object;
                return new $root.protos.opts.StreamdalListDestinationOptions();
            };

            /**
             * Creates a plain object from a StreamdalListDestinationOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.StreamdalListDestinationOptions
             * @static
             * @param {protos.opts.StreamdalListDestinationOptions} message StreamdalListDestinationOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StreamdalListDestinationOptions.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this StreamdalListDestinationOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.StreamdalListDestinationOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StreamdalListDestinationOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StreamdalListDestinationOptions;
        })();

        opts.StreamdalListSchemaOptions = (function() {

            /**
             * Properties of a StreamdalListSchemaOptions.
             * @memberof protos.opts
             * @interface IStreamdalListSchemaOptions
             */

            /**
             * Constructs a new StreamdalListSchemaOptions.
             * @memberof protos.opts
             * @classdesc Represents a StreamdalListSchemaOptions.
             * @implements IStreamdalListSchemaOptions
             * @constructor
             * @param {protos.opts.IStreamdalListSchemaOptions=} [properties] Properties to set
             */
            function StreamdalListSchemaOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new StreamdalListSchemaOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.StreamdalListSchemaOptions
             * @static
             * @param {protos.opts.IStreamdalListSchemaOptions=} [properties] Properties to set
             * @returns {protos.opts.StreamdalListSchemaOptions} StreamdalListSchemaOptions instance
             */
            StreamdalListSchemaOptions.create = function create(properties) {
                return new StreamdalListSchemaOptions(properties);
            };

            /**
             * Encodes the specified StreamdalListSchemaOptions message. Does not implicitly {@link protos.opts.StreamdalListSchemaOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.StreamdalListSchemaOptions
             * @static
             * @param {protos.opts.IStreamdalListSchemaOptions} message StreamdalListSchemaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalListSchemaOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified StreamdalListSchemaOptions message, length delimited. Does not implicitly {@link protos.opts.StreamdalListSchemaOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.StreamdalListSchemaOptions
             * @static
             * @param {protos.opts.IStreamdalListSchemaOptions} message StreamdalListSchemaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalListSchemaOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StreamdalListSchemaOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.StreamdalListSchemaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.StreamdalListSchemaOptions} StreamdalListSchemaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalListSchemaOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.StreamdalListSchemaOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StreamdalListSchemaOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.StreamdalListSchemaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.StreamdalListSchemaOptions} StreamdalListSchemaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalListSchemaOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StreamdalListSchemaOptions message.
             * @function verify
             * @memberof protos.opts.StreamdalListSchemaOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StreamdalListSchemaOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a StreamdalListSchemaOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.StreamdalListSchemaOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.StreamdalListSchemaOptions} StreamdalListSchemaOptions
             */
            StreamdalListSchemaOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.StreamdalListSchemaOptions)
                    return object;
                return new $root.protos.opts.StreamdalListSchemaOptions();
            };

            /**
             * Creates a plain object from a StreamdalListSchemaOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.StreamdalListSchemaOptions
             * @static
             * @param {protos.opts.StreamdalListSchemaOptions} message StreamdalListSchemaOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StreamdalListSchemaOptions.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this StreamdalListSchemaOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.StreamdalListSchemaOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StreamdalListSchemaOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StreamdalListSchemaOptions;
        })();

        opts.StreamdalListReplayOptions = (function() {

            /**
             * Properties of a StreamdalListReplayOptions.
             * @memberof protos.opts
             * @interface IStreamdalListReplayOptions
             */

            /**
             * Constructs a new StreamdalListReplayOptions.
             * @memberof protos.opts
             * @classdesc Represents a StreamdalListReplayOptions.
             * @implements IStreamdalListReplayOptions
             * @constructor
             * @param {protos.opts.IStreamdalListReplayOptions=} [properties] Properties to set
             */
            function StreamdalListReplayOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new StreamdalListReplayOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.StreamdalListReplayOptions
             * @static
             * @param {protos.opts.IStreamdalListReplayOptions=} [properties] Properties to set
             * @returns {protos.opts.StreamdalListReplayOptions} StreamdalListReplayOptions instance
             */
            StreamdalListReplayOptions.create = function create(properties) {
                return new StreamdalListReplayOptions(properties);
            };

            /**
             * Encodes the specified StreamdalListReplayOptions message. Does not implicitly {@link protos.opts.StreamdalListReplayOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.StreamdalListReplayOptions
             * @static
             * @param {protos.opts.IStreamdalListReplayOptions} message StreamdalListReplayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalListReplayOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified StreamdalListReplayOptions message, length delimited. Does not implicitly {@link protos.opts.StreamdalListReplayOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.StreamdalListReplayOptions
             * @static
             * @param {protos.opts.IStreamdalListReplayOptions} message StreamdalListReplayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalListReplayOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StreamdalListReplayOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.StreamdalListReplayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.StreamdalListReplayOptions} StreamdalListReplayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalListReplayOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.StreamdalListReplayOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StreamdalListReplayOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.StreamdalListReplayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.StreamdalListReplayOptions} StreamdalListReplayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalListReplayOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StreamdalListReplayOptions message.
             * @function verify
             * @memberof protos.opts.StreamdalListReplayOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StreamdalListReplayOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a StreamdalListReplayOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.StreamdalListReplayOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.StreamdalListReplayOptions} StreamdalListReplayOptions
             */
            StreamdalListReplayOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.StreamdalListReplayOptions)
                    return object;
                return new $root.protos.opts.StreamdalListReplayOptions();
            };

            /**
             * Creates a plain object from a StreamdalListReplayOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.StreamdalListReplayOptions
             * @static
             * @param {protos.opts.StreamdalListReplayOptions} message StreamdalListReplayOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StreamdalListReplayOptions.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this StreamdalListReplayOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.StreamdalListReplayOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StreamdalListReplayOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StreamdalListReplayOptions;
        })();

        opts.StreamdalArchiveOptions = (function() {

            /**
             * Properties of a StreamdalArchiveOptions.
             * @memberof protos.opts
             * @interface IStreamdalArchiveOptions
             * @property {protos.opts.IStreamdalArchiveReplayOptions|null} [replay] StreamdalArchiveOptions replay
             */

            /**
             * Constructs a new StreamdalArchiveOptions.
             * @memberof protos.opts
             * @classdesc Represents a StreamdalArchiveOptions.
             * @implements IStreamdalArchiveOptions
             * @constructor
             * @param {protos.opts.IStreamdalArchiveOptions=} [properties] Properties to set
             */
            function StreamdalArchiveOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StreamdalArchiveOptions replay.
             * @member {protos.opts.IStreamdalArchiveReplayOptions|null|undefined} replay
             * @memberof protos.opts.StreamdalArchiveOptions
             * @instance
             */
            StreamdalArchiveOptions.prototype.replay = null;

            /**
             * Creates a new StreamdalArchiveOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.StreamdalArchiveOptions
             * @static
             * @param {protos.opts.IStreamdalArchiveOptions=} [properties] Properties to set
             * @returns {protos.opts.StreamdalArchiveOptions} StreamdalArchiveOptions instance
             */
            StreamdalArchiveOptions.create = function create(properties) {
                return new StreamdalArchiveOptions(properties);
            };

            /**
             * Encodes the specified StreamdalArchiveOptions message. Does not implicitly {@link protos.opts.StreamdalArchiveOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.StreamdalArchiveOptions
             * @static
             * @param {protos.opts.IStreamdalArchiveOptions} message StreamdalArchiveOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalArchiveOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.replay != null && Object.hasOwnProperty.call(message, "replay"))
                    $root.protos.opts.StreamdalArchiveReplayOptions.encode(message.replay, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified StreamdalArchiveOptions message, length delimited. Does not implicitly {@link protos.opts.StreamdalArchiveOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.StreamdalArchiveOptions
             * @static
             * @param {protos.opts.IStreamdalArchiveOptions} message StreamdalArchiveOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalArchiveOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StreamdalArchiveOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.StreamdalArchiveOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.StreamdalArchiveOptions} StreamdalArchiveOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalArchiveOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.StreamdalArchiveOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.replay = $root.protos.opts.StreamdalArchiveReplayOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StreamdalArchiveOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.StreamdalArchiveOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.StreamdalArchiveOptions} StreamdalArchiveOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalArchiveOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StreamdalArchiveOptions message.
             * @function verify
             * @memberof protos.opts.StreamdalArchiveOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StreamdalArchiveOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.replay != null && message.hasOwnProperty("replay")) {
                    var error = $root.protos.opts.StreamdalArchiveReplayOptions.verify(message.replay);
                    if (error)
                        return "replay." + error;
                }
                return null;
            };

            /**
             * Creates a StreamdalArchiveOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.StreamdalArchiveOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.StreamdalArchiveOptions} StreamdalArchiveOptions
             */
            StreamdalArchiveOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.StreamdalArchiveOptions)
                    return object;
                var message = new $root.protos.opts.StreamdalArchiveOptions();
                if (object.replay != null) {
                    if (typeof object.replay !== "object")
                        throw TypeError(".protos.opts.StreamdalArchiveOptions.replay: object expected");
                    message.replay = $root.protos.opts.StreamdalArchiveReplayOptions.fromObject(object.replay);
                }
                return message;
            };

            /**
             * Creates a plain object from a StreamdalArchiveOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.StreamdalArchiveOptions
             * @static
             * @param {protos.opts.StreamdalArchiveOptions} message StreamdalArchiveOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StreamdalArchiveOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.replay = null;
                if (message.replay != null && message.hasOwnProperty("replay"))
                    object.replay = $root.protos.opts.StreamdalArchiveReplayOptions.toObject(message.replay, options);
                return object;
            };

            /**
             * Converts this StreamdalArchiveOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.StreamdalArchiveOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StreamdalArchiveOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StreamdalArchiveOptions;
        })();

        opts.StreamdalArchiveReplayOptions = (function() {

            /**
             * Properties of a StreamdalArchiveReplayOptions.
             * @memberof protos.opts
             * @interface IStreamdalArchiveReplayOptions
             * @property {string|null} [replayId] StreamdalArchiveReplayOptions replayId
             */

            /**
             * Constructs a new StreamdalArchiveReplayOptions.
             * @memberof protos.opts
             * @classdesc Represents a StreamdalArchiveReplayOptions.
             * @implements IStreamdalArchiveReplayOptions
             * @constructor
             * @param {protos.opts.IStreamdalArchiveReplayOptions=} [properties] Properties to set
             */
            function StreamdalArchiveReplayOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StreamdalArchiveReplayOptions replayId.
             * @member {string} replayId
             * @memberof protos.opts.StreamdalArchiveReplayOptions
             * @instance
             */
            StreamdalArchiveReplayOptions.prototype.replayId = "";

            /**
             * Creates a new StreamdalArchiveReplayOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.StreamdalArchiveReplayOptions
             * @static
             * @param {protos.opts.IStreamdalArchiveReplayOptions=} [properties] Properties to set
             * @returns {protos.opts.StreamdalArchiveReplayOptions} StreamdalArchiveReplayOptions instance
             */
            StreamdalArchiveReplayOptions.create = function create(properties) {
                return new StreamdalArchiveReplayOptions(properties);
            };

            /**
             * Encodes the specified StreamdalArchiveReplayOptions message. Does not implicitly {@link protos.opts.StreamdalArchiveReplayOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.StreamdalArchiveReplayOptions
             * @static
             * @param {protos.opts.IStreamdalArchiveReplayOptions} message StreamdalArchiveReplayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalArchiveReplayOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.replayId != null && Object.hasOwnProperty.call(message, "replayId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.replayId);
                return writer;
            };

            /**
             * Encodes the specified StreamdalArchiveReplayOptions message, length delimited. Does not implicitly {@link protos.opts.StreamdalArchiveReplayOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.StreamdalArchiveReplayOptions
             * @static
             * @param {protos.opts.IStreamdalArchiveReplayOptions} message StreamdalArchiveReplayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalArchiveReplayOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StreamdalArchiveReplayOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.StreamdalArchiveReplayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.StreamdalArchiveReplayOptions} StreamdalArchiveReplayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalArchiveReplayOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.StreamdalArchiveReplayOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.replayId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StreamdalArchiveReplayOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.StreamdalArchiveReplayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.StreamdalArchiveReplayOptions} StreamdalArchiveReplayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalArchiveReplayOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StreamdalArchiveReplayOptions message.
             * @function verify
             * @memberof protos.opts.StreamdalArchiveReplayOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StreamdalArchiveReplayOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.replayId != null && message.hasOwnProperty("replayId"))
                    if (!$util.isString(message.replayId))
                        return "replayId: string expected";
                return null;
            };

            /**
             * Creates a StreamdalArchiveReplayOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.StreamdalArchiveReplayOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.StreamdalArchiveReplayOptions} StreamdalArchiveReplayOptions
             */
            StreamdalArchiveReplayOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.StreamdalArchiveReplayOptions)
                    return object;
                var message = new $root.protos.opts.StreamdalArchiveReplayOptions();
                if (object.replayId != null)
                    message.replayId = String(object.replayId);
                return message;
            };

            /**
             * Creates a plain object from a StreamdalArchiveReplayOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.StreamdalArchiveReplayOptions
             * @static
             * @param {protos.opts.StreamdalArchiveReplayOptions} message StreamdalArchiveReplayOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StreamdalArchiveReplayOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.replayId = "";
                if (message.replayId != null && message.hasOwnProperty("replayId"))
                    object.replayId = message.replayId;
                return object;
            };

            /**
             * Converts this StreamdalArchiveReplayOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.StreamdalArchiveReplayOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StreamdalArchiveReplayOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StreamdalArchiveReplayOptions;
        })();

        opts.StreamdalListOptions = (function() {

            /**
             * Properties of a StreamdalListOptions.
             * @memberof protos.opts
             * @interface IStreamdalListOptions
             * @property {protos.opts.IStreamdalListCollectionOptions|null} [collection] StreamdalListOptions collection
             * @property {protos.opts.IStreamdalListDestinationOptions|null} [destination] StreamdalListOptions destination
             * @property {protos.opts.IStreamdalListReplayOptions|null} [replay] StreamdalListOptions replay
             * @property {protos.opts.IStreamdalListSchemaOptions|null} [schema] StreamdalListOptions schema
             */

            /**
             * Constructs a new StreamdalListOptions.
             * @memberof protos.opts
             * @classdesc Represents a StreamdalListOptions.
             * @implements IStreamdalListOptions
             * @constructor
             * @param {protos.opts.IStreamdalListOptions=} [properties] Properties to set
             */
            function StreamdalListOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StreamdalListOptions collection.
             * @member {protos.opts.IStreamdalListCollectionOptions|null|undefined} collection
             * @memberof protos.opts.StreamdalListOptions
             * @instance
             */
            StreamdalListOptions.prototype.collection = null;

            /**
             * StreamdalListOptions destination.
             * @member {protos.opts.IStreamdalListDestinationOptions|null|undefined} destination
             * @memberof protos.opts.StreamdalListOptions
             * @instance
             */
            StreamdalListOptions.prototype.destination = null;

            /**
             * StreamdalListOptions replay.
             * @member {protos.opts.IStreamdalListReplayOptions|null|undefined} replay
             * @memberof protos.opts.StreamdalListOptions
             * @instance
             */
            StreamdalListOptions.prototype.replay = null;

            /**
             * StreamdalListOptions schema.
             * @member {protos.opts.IStreamdalListSchemaOptions|null|undefined} schema
             * @memberof protos.opts.StreamdalListOptions
             * @instance
             */
            StreamdalListOptions.prototype.schema = null;

            /**
             * Creates a new StreamdalListOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.StreamdalListOptions
             * @static
             * @param {protos.opts.IStreamdalListOptions=} [properties] Properties to set
             * @returns {protos.opts.StreamdalListOptions} StreamdalListOptions instance
             */
            StreamdalListOptions.create = function create(properties) {
                return new StreamdalListOptions(properties);
            };

            /**
             * Encodes the specified StreamdalListOptions message. Does not implicitly {@link protos.opts.StreamdalListOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.StreamdalListOptions
             * @static
             * @param {protos.opts.IStreamdalListOptions} message StreamdalListOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalListOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    $root.protos.opts.StreamdalListCollectionOptions.encode(message.collection, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                    $root.protos.opts.StreamdalListDestinationOptions.encode(message.destination, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.replay != null && Object.hasOwnProperty.call(message, "replay"))
                    $root.protos.opts.StreamdalListReplayOptions.encode(message.replay, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                    $root.protos.opts.StreamdalListSchemaOptions.encode(message.schema, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified StreamdalListOptions message, length delimited. Does not implicitly {@link protos.opts.StreamdalListOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.StreamdalListOptions
             * @static
             * @param {protos.opts.IStreamdalListOptions} message StreamdalListOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalListOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StreamdalListOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.StreamdalListOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.StreamdalListOptions} StreamdalListOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalListOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.StreamdalListOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collection = $root.protos.opts.StreamdalListCollectionOptions.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.destination = $root.protos.opts.StreamdalListDestinationOptions.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.replay = $root.protos.opts.StreamdalListReplayOptions.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.schema = $root.protos.opts.StreamdalListSchemaOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StreamdalListOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.StreamdalListOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.StreamdalListOptions} StreamdalListOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalListOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StreamdalListOptions message.
             * @function verify
             * @memberof protos.opts.StreamdalListOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StreamdalListOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collection != null && message.hasOwnProperty("collection")) {
                    var error = $root.protos.opts.StreamdalListCollectionOptions.verify(message.collection);
                    if (error)
                        return "collection." + error;
                }
                if (message.destination != null && message.hasOwnProperty("destination")) {
                    var error = $root.protos.opts.StreamdalListDestinationOptions.verify(message.destination);
                    if (error)
                        return "destination." + error;
                }
                if (message.replay != null && message.hasOwnProperty("replay")) {
                    var error = $root.protos.opts.StreamdalListReplayOptions.verify(message.replay);
                    if (error)
                        return "replay." + error;
                }
                if (message.schema != null && message.hasOwnProperty("schema")) {
                    var error = $root.protos.opts.StreamdalListSchemaOptions.verify(message.schema);
                    if (error)
                        return "schema." + error;
                }
                return null;
            };

            /**
             * Creates a StreamdalListOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.StreamdalListOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.StreamdalListOptions} StreamdalListOptions
             */
            StreamdalListOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.StreamdalListOptions)
                    return object;
                var message = new $root.protos.opts.StreamdalListOptions();
                if (object.collection != null) {
                    if (typeof object.collection !== "object")
                        throw TypeError(".protos.opts.StreamdalListOptions.collection: object expected");
                    message.collection = $root.protos.opts.StreamdalListCollectionOptions.fromObject(object.collection);
                }
                if (object.destination != null) {
                    if (typeof object.destination !== "object")
                        throw TypeError(".protos.opts.StreamdalListOptions.destination: object expected");
                    message.destination = $root.protos.opts.StreamdalListDestinationOptions.fromObject(object.destination);
                }
                if (object.replay != null) {
                    if (typeof object.replay !== "object")
                        throw TypeError(".protos.opts.StreamdalListOptions.replay: object expected");
                    message.replay = $root.protos.opts.StreamdalListReplayOptions.fromObject(object.replay);
                }
                if (object.schema != null) {
                    if (typeof object.schema !== "object")
                        throw TypeError(".protos.opts.StreamdalListOptions.schema: object expected");
                    message.schema = $root.protos.opts.StreamdalListSchemaOptions.fromObject(object.schema);
                }
                return message;
            };

            /**
             * Creates a plain object from a StreamdalListOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.StreamdalListOptions
             * @static
             * @param {protos.opts.StreamdalListOptions} message StreamdalListOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StreamdalListOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.collection = null;
                    object.destination = null;
                    object.replay = null;
                    object.schema = null;
                }
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = $root.protos.opts.StreamdalListCollectionOptions.toObject(message.collection, options);
                if (message.destination != null && message.hasOwnProperty("destination"))
                    object.destination = $root.protos.opts.StreamdalListDestinationOptions.toObject(message.destination, options);
                if (message.replay != null && message.hasOwnProperty("replay"))
                    object.replay = $root.protos.opts.StreamdalListReplayOptions.toObject(message.replay, options);
                if (message.schema != null && message.hasOwnProperty("schema"))
                    object.schema = $root.protos.opts.StreamdalListSchemaOptions.toObject(message.schema, options);
                return object;
            };

            /**
             * Converts this StreamdalListOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.StreamdalListOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StreamdalListOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StreamdalListOptions;
        })();

        opts.StreamdalCreateOptions = (function() {

            /**
             * Properties of a StreamdalCreateOptions.
             * @memberof protos.opts
             * @interface IStreamdalCreateOptions
             * @property {protos.opts.IStreamdalCreateCollectionOptions|null} [collection] StreamdalCreateOptions collection
             * @property {protos.opts.IStreamdalCreateReplayOptions|null} [replay] StreamdalCreateOptions replay
             * @property {protos.opts.IStreamdalCreateDestinationOptions|null} [destination] StreamdalCreateOptions destination
             */

            /**
             * Constructs a new StreamdalCreateOptions.
             * @memberof protos.opts
             * @classdesc Represents a StreamdalCreateOptions.
             * @implements IStreamdalCreateOptions
             * @constructor
             * @param {protos.opts.IStreamdalCreateOptions=} [properties] Properties to set
             */
            function StreamdalCreateOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StreamdalCreateOptions collection.
             * @member {protos.opts.IStreamdalCreateCollectionOptions|null|undefined} collection
             * @memberof protos.opts.StreamdalCreateOptions
             * @instance
             */
            StreamdalCreateOptions.prototype.collection = null;

            /**
             * StreamdalCreateOptions replay.
             * @member {protos.opts.IStreamdalCreateReplayOptions|null|undefined} replay
             * @memberof protos.opts.StreamdalCreateOptions
             * @instance
             */
            StreamdalCreateOptions.prototype.replay = null;

            /**
             * StreamdalCreateOptions destination.
             * @member {protos.opts.IStreamdalCreateDestinationOptions|null|undefined} destination
             * @memberof protos.opts.StreamdalCreateOptions
             * @instance
             */
            StreamdalCreateOptions.prototype.destination = null;

            /**
             * Creates a new StreamdalCreateOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.StreamdalCreateOptions
             * @static
             * @param {protos.opts.IStreamdalCreateOptions=} [properties] Properties to set
             * @returns {protos.opts.StreamdalCreateOptions} StreamdalCreateOptions instance
             */
            StreamdalCreateOptions.create = function create(properties) {
                return new StreamdalCreateOptions(properties);
            };

            /**
             * Encodes the specified StreamdalCreateOptions message. Does not implicitly {@link protos.opts.StreamdalCreateOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.StreamdalCreateOptions
             * @static
             * @param {protos.opts.IStreamdalCreateOptions} message StreamdalCreateOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalCreateOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    $root.protos.opts.StreamdalCreateCollectionOptions.encode(message.collection, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.replay != null && Object.hasOwnProperty.call(message, "replay"))
                    $root.protos.opts.StreamdalCreateReplayOptions.encode(message.replay, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                    $root.protos.opts.StreamdalCreateDestinationOptions.encode(message.destination, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified StreamdalCreateOptions message, length delimited. Does not implicitly {@link protos.opts.StreamdalCreateOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.StreamdalCreateOptions
             * @static
             * @param {protos.opts.IStreamdalCreateOptions} message StreamdalCreateOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalCreateOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StreamdalCreateOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.StreamdalCreateOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.StreamdalCreateOptions} StreamdalCreateOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalCreateOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.StreamdalCreateOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collection = $root.protos.opts.StreamdalCreateCollectionOptions.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.replay = $root.protos.opts.StreamdalCreateReplayOptions.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.destination = $root.protos.opts.StreamdalCreateDestinationOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StreamdalCreateOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.StreamdalCreateOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.StreamdalCreateOptions} StreamdalCreateOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalCreateOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StreamdalCreateOptions message.
             * @function verify
             * @memberof protos.opts.StreamdalCreateOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StreamdalCreateOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collection != null && message.hasOwnProperty("collection")) {
                    var error = $root.protos.opts.StreamdalCreateCollectionOptions.verify(message.collection);
                    if (error)
                        return "collection." + error;
                }
                if (message.replay != null && message.hasOwnProperty("replay")) {
                    var error = $root.protos.opts.StreamdalCreateReplayOptions.verify(message.replay);
                    if (error)
                        return "replay." + error;
                }
                if (message.destination != null && message.hasOwnProperty("destination")) {
                    var error = $root.protos.opts.StreamdalCreateDestinationOptions.verify(message.destination);
                    if (error)
                        return "destination." + error;
                }
                return null;
            };

            /**
             * Creates a StreamdalCreateOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.StreamdalCreateOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.StreamdalCreateOptions} StreamdalCreateOptions
             */
            StreamdalCreateOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.StreamdalCreateOptions)
                    return object;
                var message = new $root.protos.opts.StreamdalCreateOptions();
                if (object.collection != null) {
                    if (typeof object.collection !== "object")
                        throw TypeError(".protos.opts.StreamdalCreateOptions.collection: object expected");
                    message.collection = $root.protos.opts.StreamdalCreateCollectionOptions.fromObject(object.collection);
                }
                if (object.replay != null) {
                    if (typeof object.replay !== "object")
                        throw TypeError(".protos.opts.StreamdalCreateOptions.replay: object expected");
                    message.replay = $root.protos.opts.StreamdalCreateReplayOptions.fromObject(object.replay);
                }
                if (object.destination != null) {
                    if (typeof object.destination !== "object")
                        throw TypeError(".protos.opts.StreamdalCreateOptions.destination: object expected");
                    message.destination = $root.protos.opts.StreamdalCreateDestinationOptions.fromObject(object.destination);
                }
                return message;
            };

            /**
             * Creates a plain object from a StreamdalCreateOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.StreamdalCreateOptions
             * @static
             * @param {protos.opts.StreamdalCreateOptions} message StreamdalCreateOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StreamdalCreateOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.collection = null;
                    object.replay = null;
                    object.destination = null;
                }
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = $root.protos.opts.StreamdalCreateCollectionOptions.toObject(message.collection, options);
                if (message.replay != null && message.hasOwnProperty("replay"))
                    object.replay = $root.protos.opts.StreamdalCreateReplayOptions.toObject(message.replay, options);
                if (message.destination != null && message.hasOwnProperty("destination"))
                    object.destination = $root.protos.opts.StreamdalCreateDestinationOptions.toObject(message.destination, options);
                return object;
            };

            /**
             * Converts this StreamdalCreateOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.StreamdalCreateOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StreamdalCreateOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StreamdalCreateOptions;
        })();

        opts.StreamdalSearchOptions = (function() {

            /**
             * Properties of a StreamdalSearchOptions.
             * @memberof protos.opts
             * @interface IStreamdalSearchOptions
             * @property {string|null} [query] StreamdalSearchOptions query
             * @property {string|null} [collectionId] StreamdalSearchOptions collectionId
             * @property {number|null} [page] StreamdalSearchOptions page
             */

            /**
             * Constructs a new StreamdalSearchOptions.
             * @memberof protos.opts
             * @classdesc Represents a StreamdalSearchOptions.
             * @implements IStreamdalSearchOptions
             * @constructor
             * @param {protos.opts.IStreamdalSearchOptions=} [properties] Properties to set
             */
            function StreamdalSearchOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StreamdalSearchOptions query.
             * @member {string} query
             * @memberof protos.opts.StreamdalSearchOptions
             * @instance
             */
            StreamdalSearchOptions.prototype.query = "";

            /**
             * StreamdalSearchOptions collectionId.
             * @member {string} collectionId
             * @memberof protos.opts.StreamdalSearchOptions
             * @instance
             */
            StreamdalSearchOptions.prototype.collectionId = "";

            /**
             * StreamdalSearchOptions page.
             * @member {number} page
             * @memberof protos.opts.StreamdalSearchOptions
             * @instance
             */
            StreamdalSearchOptions.prototype.page = 0;

            /**
             * Creates a new StreamdalSearchOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.StreamdalSearchOptions
             * @static
             * @param {protos.opts.IStreamdalSearchOptions=} [properties] Properties to set
             * @returns {protos.opts.StreamdalSearchOptions} StreamdalSearchOptions instance
             */
            StreamdalSearchOptions.create = function create(properties) {
                return new StreamdalSearchOptions(properties);
            };

            /**
             * Encodes the specified StreamdalSearchOptions message. Does not implicitly {@link protos.opts.StreamdalSearchOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.StreamdalSearchOptions
             * @static
             * @param {protos.opts.IStreamdalSearchOptions} message StreamdalSearchOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalSearchOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.query);
                if (message.collectionId != null && Object.hasOwnProperty.call(message, "collectionId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.collectionId);
                if (message.page != null && Object.hasOwnProperty.call(message, "page"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.page);
                return writer;
            };

            /**
             * Encodes the specified StreamdalSearchOptions message, length delimited. Does not implicitly {@link protos.opts.StreamdalSearchOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.StreamdalSearchOptions
             * @static
             * @param {protos.opts.IStreamdalSearchOptions} message StreamdalSearchOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalSearchOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StreamdalSearchOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.StreamdalSearchOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.StreamdalSearchOptions} StreamdalSearchOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalSearchOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.StreamdalSearchOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.query = reader.string();
                        break;
                    case 2:
                        message.collectionId = reader.string();
                        break;
                    case 3:
                        message.page = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StreamdalSearchOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.StreamdalSearchOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.StreamdalSearchOptions} StreamdalSearchOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalSearchOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StreamdalSearchOptions message.
             * @function verify
             * @memberof protos.opts.StreamdalSearchOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StreamdalSearchOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.query != null && message.hasOwnProperty("query"))
                    if (!$util.isString(message.query))
                        return "query: string expected";
                if (message.collectionId != null && message.hasOwnProperty("collectionId"))
                    if (!$util.isString(message.collectionId))
                        return "collectionId: string expected";
                if (message.page != null && message.hasOwnProperty("page"))
                    if (!$util.isInteger(message.page))
                        return "page: integer expected";
                return null;
            };

            /**
             * Creates a StreamdalSearchOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.StreamdalSearchOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.StreamdalSearchOptions} StreamdalSearchOptions
             */
            StreamdalSearchOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.StreamdalSearchOptions)
                    return object;
                var message = new $root.protos.opts.StreamdalSearchOptions();
                if (object.query != null)
                    message.query = String(object.query);
                if (object.collectionId != null)
                    message.collectionId = String(object.collectionId);
                if (object.page != null)
                    message.page = object.page | 0;
                return message;
            };

            /**
             * Creates a plain object from a StreamdalSearchOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.StreamdalSearchOptions
             * @static
             * @param {protos.opts.StreamdalSearchOptions} message StreamdalSearchOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StreamdalSearchOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.query = "";
                    object.collectionId = "";
                    object.page = 0;
                }
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = message.query;
                if (message.collectionId != null && message.hasOwnProperty("collectionId"))
                    object.collectionId = message.collectionId;
                if (message.page != null && message.hasOwnProperty("page"))
                    object.page = message.page;
                return object;
            };

            /**
             * Converts this StreamdalSearchOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.StreamdalSearchOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StreamdalSearchOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StreamdalSearchOptions;
        })();

        opts.StreamdalCreateCollectionOptions = (function() {

            /**
             * Properties of a StreamdalCreateCollectionOptions.
             * @memberof protos.opts
             * @interface IStreamdalCreateCollectionOptions
             * @property {string|null} [name] StreamdalCreateCollectionOptions name
             * @property {string|null} [schemaId] StreamdalCreateCollectionOptions schemaId
             * @property {string|null} [notes] StreamdalCreateCollectionOptions notes
             * @property {string|null} [envelopeType] StreamdalCreateCollectionOptions envelopeType
             * @property {string|null} [envelopeRootMessage] StreamdalCreateCollectionOptions envelopeRootMessage
             * @property {string|null} [payloadFieldMessage] StreamdalCreateCollectionOptions payloadFieldMessage
             * @property {string|null} [payloadFieldId] StreamdalCreateCollectionOptions payloadFieldId
             */

            /**
             * Constructs a new StreamdalCreateCollectionOptions.
             * @memberof protos.opts
             * @classdesc Represents a StreamdalCreateCollectionOptions.
             * @implements IStreamdalCreateCollectionOptions
             * @constructor
             * @param {protos.opts.IStreamdalCreateCollectionOptions=} [properties] Properties to set
             */
            function StreamdalCreateCollectionOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StreamdalCreateCollectionOptions name.
             * @member {string} name
             * @memberof protos.opts.StreamdalCreateCollectionOptions
             * @instance
             */
            StreamdalCreateCollectionOptions.prototype.name = "";

            /**
             * StreamdalCreateCollectionOptions schemaId.
             * @member {string} schemaId
             * @memberof protos.opts.StreamdalCreateCollectionOptions
             * @instance
             */
            StreamdalCreateCollectionOptions.prototype.schemaId = "";

            /**
             * StreamdalCreateCollectionOptions notes.
             * @member {string} notes
             * @memberof protos.opts.StreamdalCreateCollectionOptions
             * @instance
             */
            StreamdalCreateCollectionOptions.prototype.notes = "";

            /**
             * StreamdalCreateCollectionOptions envelopeType.
             * @member {string} envelopeType
             * @memberof protos.opts.StreamdalCreateCollectionOptions
             * @instance
             */
            StreamdalCreateCollectionOptions.prototype.envelopeType = "";

            /**
             * StreamdalCreateCollectionOptions envelopeRootMessage.
             * @member {string} envelopeRootMessage
             * @memberof protos.opts.StreamdalCreateCollectionOptions
             * @instance
             */
            StreamdalCreateCollectionOptions.prototype.envelopeRootMessage = "";

            /**
             * StreamdalCreateCollectionOptions payloadFieldMessage.
             * @member {string} payloadFieldMessage
             * @memberof protos.opts.StreamdalCreateCollectionOptions
             * @instance
             */
            StreamdalCreateCollectionOptions.prototype.payloadFieldMessage = "";

            /**
             * StreamdalCreateCollectionOptions payloadFieldId.
             * @member {string} payloadFieldId
             * @memberof protos.opts.StreamdalCreateCollectionOptions
             * @instance
             */
            StreamdalCreateCollectionOptions.prototype.payloadFieldId = "";

            /**
             * Creates a new StreamdalCreateCollectionOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.StreamdalCreateCollectionOptions
             * @static
             * @param {protos.opts.IStreamdalCreateCollectionOptions=} [properties] Properties to set
             * @returns {protos.opts.StreamdalCreateCollectionOptions} StreamdalCreateCollectionOptions instance
             */
            StreamdalCreateCollectionOptions.create = function create(properties) {
                return new StreamdalCreateCollectionOptions(properties);
            };

            /**
             * Encodes the specified StreamdalCreateCollectionOptions message. Does not implicitly {@link protos.opts.StreamdalCreateCollectionOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.StreamdalCreateCollectionOptions
             * @static
             * @param {protos.opts.IStreamdalCreateCollectionOptions} message StreamdalCreateCollectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalCreateCollectionOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.schemaId != null && Object.hasOwnProperty.call(message, "schemaId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.schemaId);
                if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.notes);
                if (message.envelopeType != null && Object.hasOwnProperty.call(message, "envelopeType"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.envelopeType);
                if (message.envelopeRootMessage != null && Object.hasOwnProperty.call(message, "envelopeRootMessage"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.envelopeRootMessage);
                if (message.payloadFieldMessage != null && Object.hasOwnProperty.call(message, "payloadFieldMessage"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.payloadFieldMessage);
                if (message.payloadFieldId != null && Object.hasOwnProperty.call(message, "payloadFieldId"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.payloadFieldId);
                return writer;
            };

            /**
             * Encodes the specified StreamdalCreateCollectionOptions message, length delimited. Does not implicitly {@link protos.opts.StreamdalCreateCollectionOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.StreamdalCreateCollectionOptions
             * @static
             * @param {protos.opts.IStreamdalCreateCollectionOptions} message StreamdalCreateCollectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalCreateCollectionOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StreamdalCreateCollectionOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.StreamdalCreateCollectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.StreamdalCreateCollectionOptions} StreamdalCreateCollectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalCreateCollectionOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.StreamdalCreateCollectionOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.schemaId = reader.string();
                        break;
                    case 3:
                        message.notes = reader.string();
                        break;
                    case 4:
                        message.envelopeType = reader.string();
                        break;
                    case 5:
                        message.envelopeRootMessage = reader.string();
                        break;
                    case 6:
                        message.payloadFieldMessage = reader.string();
                        break;
                    case 7:
                        message.payloadFieldId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StreamdalCreateCollectionOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.StreamdalCreateCollectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.StreamdalCreateCollectionOptions} StreamdalCreateCollectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalCreateCollectionOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StreamdalCreateCollectionOptions message.
             * @function verify
             * @memberof protos.opts.StreamdalCreateCollectionOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StreamdalCreateCollectionOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    if (!$util.isString(message.schemaId))
                        return "schemaId: string expected";
                if (message.notes != null && message.hasOwnProperty("notes"))
                    if (!$util.isString(message.notes))
                        return "notes: string expected";
                if (message.envelopeType != null && message.hasOwnProperty("envelopeType"))
                    if (!$util.isString(message.envelopeType))
                        return "envelopeType: string expected";
                if (message.envelopeRootMessage != null && message.hasOwnProperty("envelopeRootMessage"))
                    if (!$util.isString(message.envelopeRootMessage))
                        return "envelopeRootMessage: string expected";
                if (message.payloadFieldMessage != null && message.hasOwnProperty("payloadFieldMessage"))
                    if (!$util.isString(message.payloadFieldMessage))
                        return "payloadFieldMessage: string expected";
                if (message.payloadFieldId != null && message.hasOwnProperty("payloadFieldId"))
                    if (!$util.isString(message.payloadFieldId))
                        return "payloadFieldId: string expected";
                return null;
            };

            /**
             * Creates a StreamdalCreateCollectionOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.StreamdalCreateCollectionOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.StreamdalCreateCollectionOptions} StreamdalCreateCollectionOptions
             */
            StreamdalCreateCollectionOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.StreamdalCreateCollectionOptions)
                    return object;
                var message = new $root.protos.opts.StreamdalCreateCollectionOptions();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.schemaId != null)
                    message.schemaId = String(object.schemaId);
                if (object.notes != null)
                    message.notes = String(object.notes);
                if (object.envelopeType != null)
                    message.envelopeType = String(object.envelopeType);
                if (object.envelopeRootMessage != null)
                    message.envelopeRootMessage = String(object.envelopeRootMessage);
                if (object.payloadFieldMessage != null)
                    message.payloadFieldMessage = String(object.payloadFieldMessage);
                if (object.payloadFieldId != null)
                    message.payloadFieldId = String(object.payloadFieldId);
                return message;
            };

            /**
             * Creates a plain object from a StreamdalCreateCollectionOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.StreamdalCreateCollectionOptions
             * @static
             * @param {protos.opts.StreamdalCreateCollectionOptions} message StreamdalCreateCollectionOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StreamdalCreateCollectionOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.schemaId = "";
                    object.notes = "";
                    object.envelopeType = "";
                    object.envelopeRootMessage = "";
                    object.payloadFieldMessage = "";
                    object.payloadFieldId = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    object.schemaId = message.schemaId;
                if (message.notes != null && message.hasOwnProperty("notes"))
                    object.notes = message.notes;
                if (message.envelopeType != null && message.hasOwnProperty("envelopeType"))
                    object.envelopeType = message.envelopeType;
                if (message.envelopeRootMessage != null && message.hasOwnProperty("envelopeRootMessage"))
                    object.envelopeRootMessage = message.envelopeRootMessage;
                if (message.payloadFieldMessage != null && message.hasOwnProperty("payloadFieldMessage"))
                    object.payloadFieldMessage = message.payloadFieldMessage;
                if (message.payloadFieldId != null && message.hasOwnProperty("payloadFieldId"))
                    object.payloadFieldId = message.payloadFieldId;
                return object;
            };

            /**
             * Converts this StreamdalCreateCollectionOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.StreamdalCreateCollectionOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StreamdalCreateCollectionOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StreamdalCreateCollectionOptions;
        })();

        opts.StreamdalCreateReplayOptions = (function() {

            /**
             * Properties of a StreamdalCreateReplayOptions.
             * @memberof protos.opts
             * @interface IStreamdalCreateReplayOptions
             * @property {string|null} [name] StreamdalCreateReplayOptions name
             * @property {protos.opts.StreamdalReplayType|null} [type] StreamdalCreateReplayOptions type
             * @property {string|null} [notes] StreamdalCreateReplayOptions notes
             * @property {string|null} [collectionId] StreamdalCreateReplayOptions collectionId
             * @property {string|null} [destinationId] StreamdalCreateReplayOptions destinationId
             * @property {string|null} [query] StreamdalCreateReplayOptions query
             * @property {string|null} [fromTimestamp] StreamdalCreateReplayOptions fromTimestamp
             * @property {string|null} [toTimestamp] StreamdalCreateReplayOptions toTimestamp
             */

            /**
             * Constructs a new StreamdalCreateReplayOptions.
             * @memberof protos.opts
             * @classdesc Represents a StreamdalCreateReplayOptions.
             * @implements IStreamdalCreateReplayOptions
             * @constructor
             * @param {protos.opts.IStreamdalCreateReplayOptions=} [properties] Properties to set
             */
            function StreamdalCreateReplayOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StreamdalCreateReplayOptions name.
             * @member {string} name
             * @memberof protos.opts.StreamdalCreateReplayOptions
             * @instance
             */
            StreamdalCreateReplayOptions.prototype.name = "";

            /**
             * StreamdalCreateReplayOptions type.
             * @member {protos.opts.StreamdalReplayType} type
             * @memberof protos.opts.StreamdalCreateReplayOptions
             * @instance
             */
            StreamdalCreateReplayOptions.prototype.type = 0;

            /**
             * StreamdalCreateReplayOptions notes.
             * @member {string} notes
             * @memberof protos.opts.StreamdalCreateReplayOptions
             * @instance
             */
            StreamdalCreateReplayOptions.prototype.notes = "";

            /**
             * StreamdalCreateReplayOptions collectionId.
             * @member {string} collectionId
             * @memberof protos.opts.StreamdalCreateReplayOptions
             * @instance
             */
            StreamdalCreateReplayOptions.prototype.collectionId = "";

            /**
             * StreamdalCreateReplayOptions destinationId.
             * @member {string} destinationId
             * @memberof protos.opts.StreamdalCreateReplayOptions
             * @instance
             */
            StreamdalCreateReplayOptions.prototype.destinationId = "";

            /**
             * StreamdalCreateReplayOptions query.
             * @member {string} query
             * @memberof protos.opts.StreamdalCreateReplayOptions
             * @instance
             */
            StreamdalCreateReplayOptions.prototype.query = "";

            /**
             * StreamdalCreateReplayOptions fromTimestamp.
             * @member {string} fromTimestamp
             * @memberof protos.opts.StreamdalCreateReplayOptions
             * @instance
             */
            StreamdalCreateReplayOptions.prototype.fromTimestamp = "";

            /**
             * StreamdalCreateReplayOptions toTimestamp.
             * @member {string} toTimestamp
             * @memberof protos.opts.StreamdalCreateReplayOptions
             * @instance
             */
            StreamdalCreateReplayOptions.prototype.toTimestamp = "";

            /**
             * Creates a new StreamdalCreateReplayOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.StreamdalCreateReplayOptions
             * @static
             * @param {protos.opts.IStreamdalCreateReplayOptions=} [properties] Properties to set
             * @returns {protos.opts.StreamdalCreateReplayOptions} StreamdalCreateReplayOptions instance
             */
            StreamdalCreateReplayOptions.create = function create(properties) {
                return new StreamdalCreateReplayOptions(properties);
            };

            /**
             * Encodes the specified StreamdalCreateReplayOptions message. Does not implicitly {@link protos.opts.StreamdalCreateReplayOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.StreamdalCreateReplayOptions
             * @static
             * @param {protos.opts.IStreamdalCreateReplayOptions} message StreamdalCreateReplayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalCreateReplayOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.notes);
                if (message.collectionId != null && Object.hasOwnProperty.call(message, "collectionId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.collectionId);
                if (message.destinationId != null && Object.hasOwnProperty.call(message, "destinationId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.destinationId);
                if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.query);
                if (message.fromTimestamp != null && Object.hasOwnProperty.call(message, "fromTimestamp"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.fromTimestamp);
                if (message.toTimestamp != null && Object.hasOwnProperty.call(message, "toTimestamp"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.toTimestamp);
                return writer;
            };

            /**
             * Encodes the specified StreamdalCreateReplayOptions message, length delimited. Does not implicitly {@link protos.opts.StreamdalCreateReplayOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.StreamdalCreateReplayOptions
             * @static
             * @param {protos.opts.IStreamdalCreateReplayOptions} message StreamdalCreateReplayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalCreateReplayOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StreamdalCreateReplayOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.StreamdalCreateReplayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.StreamdalCreateReplayOptions} StreamdalCreateReplayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalCreateReplayOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.StreamdalCreateReplayOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.notes = reader.string();
                        break;
                    case 4:
                        message.collectionId = reader.string();
                        break;
                    case 5:
                        message.destinationId = reader.string();
                        break;
                    case 6:
                        message.query = reader.string();
                        break;
                    case 7:
                        message.fromTimestamp = reader.string();
                        break;
                    case 8:
                        message.toTimestamp = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StreamdalCreateReplayOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.StreamdalCreateReplayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.StreamdalCreateReplayOptions} StreamdalCreateReplayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalCreateReplayOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StreamdalCreateReplayOptions message.
             * @function verify
             * @memberof protos.opts.StreamdalCreateReplayOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StreamdalCreateReplayOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.notes != null && message.hasOwnProperty("notes"))
                    if (!$util.isString(message.notes))
                        return "notes: string expected";
                if (message.collectionId != null && message.hasOwnProperty("collectionId"))
                    if (!$util.isString(message.collectionId))
                        return "collectionId: string expected";
                if (message.destinationId != null && message.hasOwnProperty("destinationId"))
                    if (!$util.isString(message.destinationId))
                        return "destinationId: string expected";
                if (message.query != null && message.hasOwnProperty("query"))
                    if (!$util.isString(message.query))
                        return "query: string expected";
                if (message.fromTimestamp != null && message.hasOwnProperty("fromTimestamp"))
                    if (!$util.isString(message.fromTimestamp))
                        return "fromTimestamp: string expected";
                if (message.toTimestamp != null && message.hasOwnProperty("toTimestamp"))
                    if (!$util.isString(message.toTimestamp))
                        return "toTimestamp: string expected";
                return null;
            };

            /**
             * Creates a StreamdalCreateReplayOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.StreamdalCreateReplayOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.StreamdalCreateReplayOptions} StreamdalCreateReplayOptions
             */
            StreamdalCreateReplayOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.StreamdalCreateReplayOptions)
                    return object;
                var message = new $root.protos.opts.StreamdalCreateReplayOptions();
                if (object.name != null)
                    message.name = String(object.name);
                switch (object.type) {
                case "SINGLE":
                case 0:
                    message.type = 0;
                    break;
                case "CONTINUOUS":
                case 1:
                    message.type = 1;
                    break;
                }
                if (object.notes != null)
                    message.notes = String(object.notes);
                if (object.collectionId != null)
                    message.collectionId = String(object.collectionId);
                if (object.destinationId != null)
                    message.destinationId = String(object.destinationId);
                if (object.query != null)
                    message.query = String(object.query);
                if (object.fromTimestamp != null)
                    message.fromTimestamp = String(object.fromTimestamp);
                if (object.toTimestamp != null)
                    message.toTimestamp = String(object.toTimestamp);
                return message;
            };

            /**
             * Creates a plain object from a StreamdalCreateReplayOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.StreamdalCreateReplayOptions
             * @static
             * @param {protos.opts.StreamdalCreateReplayOptions} message StreamdalCreateReplayOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StreamdalCreateReplayOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.type = options.enums === String ? "SINGLE" : 0;
                    object.notes = "";
                    object.collectionId = "";
                    object.destinationId = "";
                    object.query = "";
                    object.fromTimestamp = "";
                    object.toTimestamp = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.protos.opts.StreamdalReplayType[message.type] : message.type;
                if (message.notes != null && message.hasOwnProperty("notes"))
                    object.notes = message.notes;
                if (message.collectionId != null && message.hasOwnProperty("collectionId"))
                    object.collectionId = message.collectionId;
                if (message.destinationId != null && message.hasOwnProperty("destinationId"))
                    object.destinationId = message.destinationId;
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = message.query;
                if (message.fromTimestamp != null && message.hasOwnProperty("fromTimestamp"))
                    object.fromTimestamp = message.fromTimestamp;
                if (message.toTimestamp != null && message.hasOwnProperty("toTimestamp"))
                    object.toTimestamp = message.toTimestamp;
                return object;
            };

            /**
             * Converts this StreamdalCreateReplayOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.StreamdalCreateReplayOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StreamdalCreateReplayOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StreamdalCreateReplayOptions;
        })();

        opts.StreamdalCreateDestinationOptions = (function() {

            /**
             * Properties of a StreamdalCreateDestinationOptions.
             * @memberof protos.opts
             * @interface IStreamdalCreateDestinationOptions
             * @property {string|null} [name] StreamdalCreateDestinationOptions name
             * @property {string|null} [notes] StreamdalCreateDestinationOptions notes
             * @property {string|null} [_apiDestinationType] StreamdalCreateDestinationOptions _apiDestinationType
             * @property {protos.opts.IWriteGroupKafkaOptions|null} [kafka] StreamdalCreateDestinationOptions kafka
             * @property {protos.opts.IWriteGroupRabbitOptions|null} [rabbit] StreamdalCreateDestinationOptions rabbit
             * @property {protos.opts.IWriteGroupKubeMQQueueOptions|null} [kubemqQueue] StreamdalCreateDestinationOptions kubemqQueue
             * @property {protos.opts.IWriteGroupAWSSQSOptions|null} [awsSqs] StreamdalCreateDestinationOptions awsSqs
             * @property {protos.opts.IHTTPDestination|null} [http] StreamdalCreateDestinationOptions http
             */

            /**
             * Constructs a new StreamdalCreateDestinationOptions.
             * @memberof protos.opts
             * @classdesc Represents a StreamdalCreateDestinationOptions.
             * @implements IStreamdalCreateDestinationOptions
             * @constructor
             * @param {protos.opts.IStreamdalCreateDestinationOptions=} [properties] Properties to set
             */
            function StreamdalCreateDestinationOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StreamdalCreateDestinationOptions name.
             * @member {string} name
             * @memberof protos.opts.StreamdalCreateDestinationOptions
             * @instance
             */
            StreamdalCreateDestinationOptions.prototype.name = "";

            /**
             * StreamdalCreateDestinationOptions notes.
             * @member {string} notes
             * @memberof protos.opts.StreamdalCreateDestinationOptions
             * @instance
             */
            StreamdalCreateDestinationOptions.prototype.notes = "";

            /**
             * StreamdalCreateDestinationOptions _apiDestinationType.
             * @member {string} _apiDestinationType
             * @memberof protos.opts.StreamdalCreateDestinationOptions
             * @instance
             */
            StreamdalCreateDestinationOptions.prototype._apiDestinationType = "";

            /**
             * StreamdalCreateDestinationOptions kafka.
             * @member {protos.opts.IWriteGroupKafkaOptions|null|undefined} kafka
             * @memberof protos.opts.StreamdalCreateDestinationOptions
             * @instance
             */
            StreamdalCreateDestinationOptions.prototype.kafka = null;

            /**
             * StreamdalCreateDestinationOptions rabbit.
             * @member {protos.opts.IWriteGroupRabbitOptions|null|undefined} rabbit
             * @memberof protos.opts.StreamdalCreateDestinationOptions
             * @instance
             */
            StreamdalCreateDestinationOptions.prototype.rabbit = null;

            /**
             * StreamdalCreateDestinationOptions kubemqQueue.
             * @member {protos.opts.IWriteGroupKubeMQQueueOptions|null|undefined} kubemqQueue
             * @memberof protos.opts.StreamdalCreateDestinationOptions
             * @instance
             */
            StreamdalCreateDestinationOptions.prototype.kubemqQueue = null;

            /**
             * StreamdalCreateDestinationOptions awsSqs.
             * @member {protos.opts.IWriteGroupAWSSQSOptions|null|undefined} awsSqs
             * @memberof protos.opts.StreamdalCreateDestinationOptions
             * @instance
             */
            StreamdalCreateDestinationOptions.prototype.awsSqs = null;

            /**
             * StreamdalCreateDestinationOptions http.
             * @member {protos.opts.IHTTPDestination|null|undefined} http
             * @memberof protos.opts.StreamdalCreateDestinationOptions
             * @instance
             */
            StreamdalCreateDestinationOptions.prototype.http = null;

            /**
             * Creates a new StreamdalCreateDestinationOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.StreamdalCreateDestinationOptions
             * @static
             * @param {protos.opts.IStreamdalCreateDestinationOptions=} [properties] Properties to set
             * @returns {protos.opts.StreamdalCreateDestinationOptions} StreamdalCreateDestinationOptions instance
             */
            StreamdalCreateDestinationOptions.create = function create(properties) {
                return new StreamdalCreateDestinationOptions(properties);
            };

            /**
             * Encodes the specified StreamdalCreateDestinationOptions message. Does not implicitly {@link protos.opts.StreamdalCreateDestinationOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.StreamdalCreateDestinationOptions
             * @static
             * @param {protos.opts.IStreamdalCreateDestinationOptions} message StreamdalCreateDestinationOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalCreateDestinationOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.notes);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.opts.WriteGroupKafkaOptions.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.opts.WriteGroupRabbitOptions.encode(message.rabbit, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.opts.WriteGroupKubeMQQueueOptions.encode(message.kubemqQueue, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.awsSqs != null && Object.hasOwnProperty.call(message, "awsSqs"))
                    $root.protos.opts.WriteGroupAWSSQSOptions.encode(message.awsSqs, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.http != null && Object.hasOwnProperty.call(message, "http"))
                    $root.protos.opts.HTTPDestination.encode(message.http, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message._apiDestinationType != null && Object.hasOwnProperty.call(message, "_apiDestinationType"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._apiDestinationType);
                return writer;
            };

            /**
             * Encodes the specified StreamdalCreateDestinationOptions message, length delimited. Does not implicitly {@link protos.opts.StreamdalCreateDestinationOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.StreamdalCreateDestinationOptions
             * @static
             * @param {protos.opts.IStreamdalCreateDestinationOptions} message StreamdalCreateDestinationOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamdalCreateDestinationOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StreamdalCreateDestinationOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.StreamdalCreateDestinationOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.StreamdalCreateDestinationOptions} StreamdalCreateDestinationOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalCreateDestinationOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.StreamdalCreateDestinationOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.notes = reader.string();
                        break;
                    case 1000:
                        message._apiDestinationType = reader.string();
                        break;
                    case 100:
                        message.kafka = $root.protos.opts.WriteGroupKafkaOptions.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.rabbit = $root.protos.opts.WriteGroupRabbitOptions.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.awsSqs = $root.protos.opts.WriteGroupAWSSQSOptions.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.http = $root.protos.opts.HTTPDestination.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StreamdalCreateDestinationOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.StreamdalCreateDestinationOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.StreamdalCreateDestinationOptions} StreamdalCreateDestinationOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamdalCreateDestinationOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StreamdalCreateDestinationOptions message.
             * @function verify
             * @memberof protos.opts.StreamdalCreateDestinationOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StreamdalCreateDestinationOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.notes != null && message.hasOwnProperty("notes"))
                    if (!$util.isString(message.notes))
                        return "notes: string expected";
                if (message._apiDestinationType != null && message.hasOwnProperty("_apiDestinationType"))
                    if (!$util.isString(message._apiDestinationType))
                        return "_apiDestinationType: string expected";
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    var error = $root.protos.opts.WriteGroupKafkaOptions.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    var error = $root.protos.opts.WriteGroupRabbitOptions.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    var error = $root.protos.opts.WriteGroupKubeMQQueueOptions.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs")) {
                    var error = $root.protos.opts.WriteGroupAWSSQSOptions.verify(message.awsSqs);
                    if (error)
                        return "awsSqs." + error;
                }
                if (message.http != null && message.hasOwnProperty("http")) {
                    var error = $root.protos.opts.HTTPDestination.verify(message.http);
                    if (error)
                        return "http." + error;
                }
                return null;
            };

            /**
             * Creates a StreamdalCreateDestinationOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.StreamdalCreateDestinationOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.StreamdalCreateDestinationOptions} StreamdalCreateDestinationOptions
             */
            StreamdalCreateDestinationOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.StreamdalCreateDestinationOptions)
                    return object;
                var message = new $root.protos.opts.StreamdalCreateDestinationOptions();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.notes != null)
                    message.notes = String(object.notes);
                if (object._apiDestinationType != null)
                    message._apiDestinationType = String(object._apiDestinationType);
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.StreamdalCreateDestinationOptions.kafka: object expected");
                    message.kafka = $root.protos.opts.WriteGroupKafkaOptions.fromObject(object.kafka);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.StreamdalCreateDestinationOptions.rabbit: object expected");
                    message.rabbit = $root.protos.opts.WriteGroupRabbitOptions.fromObject(object.rabbit);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.StreamdalCreateDestinationOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.fromObject(object.kubemqQueue);
                }
                if (object.awsSqs != null) {
                    if (typeof object.awsSqs !== "object")
                        throw TypeError(".protos.opts.StreamdalCreateDestinationOptions.awsSqs: object expected");
                    message.awsSqs = $root.protos.opts.WriteGroupAWSSQSOptions.fromObject(object.awsSqs);
                }
                if (object.http != null) {
                    if (typeof object.http !== "object")
                        throw TypeError(".protos.opts.StreamdalCreateDestinationOptions.http: object expected");
                    message.http = $root.protos.opts.HTTPDestination.fromObject(object.http);
                }
                return message;
            };

            /**
             * Creates a plain object from a StreamdalCreateDestinationOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.StreamdalCreateDestinationOptions
             * @static
             * @param {protos.opts.StreamdalCreateDestinationOptions} message StreamdalCreateDestinationOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StreamdalCreateDestinationOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.notes = "";
                    object.kafka = null;
                    object.rabbit = null;
                    object.kubemqQueue = null;
                    object.awsSqs = null;
                    object.http = null;
                    object._apiDestinationType = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.notes != null && message.hasOwnProperty("notes"))
                    object.notes = message.notes;
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.opts.WriteGroupKafkaOptions.toObject(message.kafka, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.opts.WriteGroupRabbitOptions.toObject(message.rabbit, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.toObject(message.kubemqQueue, options);
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs"))
                    object.awsSqs = $root.protos.opts.WriteGroupAWSSQSOptions.toObject(message.awsSqs, options);
                if (message.http != null && message.hasOwnProperty("http"))
                    object.http = $root.protos.opts.HTTPDestination.toObject(message.http, options);
                if (message._apiDestinationType != null && message.hasOwnProperty("_apiDestinationType"))
                    object._apiDestinationType = message._apiDestinationType;
                return object;
            };

            /**
             * Converts this StreamdalCreateDestinationOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.StreamdalCreateDestinationOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StreamdalCreateDestinationOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StreamdalCreateDestinationOptions;
        })();

        opts.HTTPDestination = (function() {

            /**
             * Properties of a HTTPDestination.
             * @memberof protos.opts
             * @interface IHTTPDestination
             * @property {string|null} [url] HTTPDestination url
             * @property {Object.<string,string>|null} [headers] HTTPDestination headers
             */

            /**
             * Constructs a new HTTPDestination.
             * @memberof protos.opts
             * @classdesc Represents a HTTPDestination.
             * @implements IHTTPDestination
             * @constructor
             * @param {protos.opts.IHTTPDestination=} [properties] Properties to set
             */
            function HTTPDestination(properties) {
                this.headers = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HTTPDestination url.
             * @member {string} url
             * @memberof protos.opts.HTTPDestination
             * @instance
             */
            HTTPDestination.prototype.url = "";

            /**
             * HTTPDestination headers.
             * @member {Object.<string,string>} headers
             * @memberof protos.opts.HTTPDestination
             * @instance
             */
            HTTPDestination.prototype.headers = $util.emptyObject;

            /**
             * Creates a new HTTPDestination instance using the specified properties.
             * @function create
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {protos.opts.IHTTPDestination=} [properties] Properties to set
             * @returns {protos.opts.HTTPDestination} HTTPDestination instance
             */
            HTTPDestination.create = function create(properties) {
                return new HTTPDestination(properties);
            };

            /**
             * Encodes the specified HTTPDestination message. Does not implicitly {@link protos.opts.HTTPDestination.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {protos.opts.IHTTPDestination} message HTTPDestination message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HTTPDestination.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.headers != null && Object.hasOwnProperty.call(message, "headers"))
                    for (var keys = Object.keys(message.headers), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.headers[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified HTTPDestination message, length delimited. Does not implicitly {@link protos.opts.HTTPDestination.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {protos.opts.IHTTPDestination} message HTTPDestination message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HTTPDestination.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HTTPDestination message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.HTTPDestination} HTTPDestination
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HTTPDestination.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.HTTPDestination(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.url = reader.string();
                        break;
                    case 2:
                        if (message.headers === $util.emptyObject)
                            message.headers = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.headers[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HTTPDestination message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.HTTPDestination} HTTPDestination
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HTTPDestination.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HTTPDestination message.
             * @function verify
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HTTPDestination.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    if (!$util.isObject(message.headers))
                        return "headers: object expected";
                    var key = Object.keys(message.headers);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.headers[key[i]]))
                            return "headers: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a HTTPDestination message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.HTTPDestination} HTTPDestination
             */
            HTTPDestination.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.HTTPDestination)
                    return object;
                var message = new $root.protos.opts.HTTPDestination();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.headers) {
                    if (typeof object.headers !== "object")
                        throw TypeError(".protos.opts.HTTPDestination.headers: object expected");
                    message.headers = {};
                    for (var keys = Object.keys(object.headers), i = 0; i < keys.length; ++i)
                        message.headers[keys[i]] = String(object.headers[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a HTTPDestination message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {protos.opts.HTTPDestination} message HTTPDestination
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HTTPDestination.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.headers = {};
                if (options.defaults)
                    object.url = "";
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                var keys2;
                if (message.headers && (keys2 = Object.keys(message.headers)).length) {
                    object.headers = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.headers[keys2[j]] = message.headers[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this HTTPDestination to JSON.
             * @function toJSON
             * @memberof protos.opts.HTTPDestination
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HTTPDestination.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HTTPDestination;
        })();

        opts.WriteCLIOptions = (function() {

            /**
             * Properties of a WriteCLIOptions.
             * @memberof protos.opts
             * @interface IWriteCLIOptions
             * @property {string|null} [inputFile] WriteCLIOptions inputFile
             * @property {boolean|null} [inputAsJsonArray] WriteCLIOptions inputAsJsonArray
             * @property {Array.<string>|null} [inputStdin] WriteCLIOptions inputStdin
             */

            /**
             * Constructs a new WriteCLIOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteCLIOptions.
             * @implements IWriteCLIOptions
             * @constructor
             * @param {protos.opts.IWriteCLIOptions=} [properties] Properties to set
             */
            function WriteCLIOptions(properties) {
                this.inputStdin = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteCLIOptions inputFile.
             * @member {string} inputFile
             * @memberof protos.opts.WriteCLIOptions
             * @instance
             */
            WriteCLIOptions.prototype.inputFile = "";

            /**
             * WriteCLIOptions inputAsJsonArray.
             * @member {boolean} inputAsJsonArray
             * @memberof protos.opts.WriteCLIOptions
             * @instance
             */
            WriteCLIOptions.prototype.inputAsJsonArray = false;

            /**
             * WriteCLIOptions inputStdin.
             * @member {Array.<string>} inputStdin
             * @memberof protos.opts.WriteCLIOptions
             * @instance
             */
            WriteCLIOptions.prototype.inputStdin = $util.emptyArray;

            /**
             * Creates a new WriteCLIOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {protos.opts.IWriteCLIOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteCLIOptions} WriteCLIOptions instance
             */
            WriteCLIOptions.create = function create(properties) {
                return new WriteCLIOptions(properties);
            };

            /**
             * Encodes the specified WriteCLIOptions message. Does not implicitly {@link protos.opts.WriteCLIOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {protos.opts.IWriteCLIOptions} message WriteCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteCLIOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.inputFile != null && Object.hasOwnProperty.call(message, "inputFile"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.inputFile);
                if (message.inputAsJsonArray != null && Object.hasOwnProperty.call(message, "inputAsJsonArray"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.inputAsJsonArray);
                if (message.inputStdin != null && message.inputStdin.length)
                    for (var i = 0; i < message.inputStdin.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.inputStdin[i]);
                return writer;
            };

            /**
             * Encodes the specified WriteCLIOptions message, length delimited. Does not implicitly {@link protos.opts.WriteCLIOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {protos.opts.IWriteCLIOptions} message WriteCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteCLIOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteCLIOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteCLIOptions} WriteCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteCLIOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteCLIOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.inputFile = reader.string();
                        break;
                    case 2:
                        message.inputAsJsonArray = reader.bool();
                        break;
                    case 3:
                        if (!(message.inputStdin && message.inputStdin.length))
                            message.inputStdin = [];
                        message.inputStdin.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteCLIOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteCLIOptions} WriteCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteCLIOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteCLIOptions message.
             * @function verify
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteCLIOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.inputFile != null && message.hasOwnProperty("inputFile"))
                    if (!$util.isString(message.inputFile))
                        return "inputFile: string expected";
                if (message.inputAsJsonArray != null && message.hasOwnProperty("inputAsJsonArray"))
                    if (typeof message.inputAsJsonArray !== "boolean")
                        return "inputAsJsonArray: boolean expected";
                if (message.inputStdin != null && message.hasOwnProperty("inputStdin")) {
                    if (!Array.isArray(message.inputStdin))
                        return "inputStdin: array expected";
                    for (var i = 0; i < message.inputStdin.length; ++i)
                        if (!$util.isString(message.inputStdin[i]))
                            return "inputStdin: string[] expected";
                }
                return null;
            };

            /**
             * Creates a WriteCLIOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteCLIOptions} WriteCLIOptions
             */
            WriteCLIOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteCLIOptions)
                    return object;
                var message = new $root.protos.opts.WriteCLIOptions();
                if (object.inputFile != null)
                    message.inputFile = String(object.inputFile);
                if (object.inputAsJsonArray != null)
                    message.inputAsJsonArray = Boolean(object.inputAsJsonArray);
                if (object.inputStdin) {
                    if (!Array.isArray(object.inputStdin))
                        throw TypeError(".protos.opts.WriteCLIOptions.inputStdin: array expected");
                    message.inputStdin = [];
                    for (var i = 0; i < object.inputStdin.length; ++i)
                        message.inputStdin[i] = String(object.inputStdin[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteCLIOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {protos.opts.WriteCLIOptions} message WriteCLIOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteCLIOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.inputStdin = [];
                if (options.defaults) {
                    object.inputFile = "";
                    object.inputAsJsonArray = false;
                }
                if (message.inputFile != null && message.hasOwnProperty("inputFile"))
                    object.inputFile = message.inputFile;
                if (message.inputAsJsonArray != null && message.hasOwnProperty("inputAsJsonArray"))
                    object.inputAsJsonArray = message.inputAsJsonArray;
                if (message.inputStdin && message.inputStdin.length) {
                    object.inputStdin = [];
                    for (var j = 0; j < message.inputStdin.length; ++j)
                        object.inputStdin[j] = message.inputStdin[j];
                }
                return object;
            };

            /**
             * Converts this WriteCLIOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteCLIOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteCLIOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteCLIOptions;
        })();

        opts.WriteOptions = (function() {

            /**
             * Properties of a WriteOptions.
             * @memberof protos.opts
             * @interface IWriteOptions
             * @property {string|null} [connectionId] WriteOptions connectionId
             * @property {protos.records.IWriteRecord|null} [record] WriteOptions record
             * @property {protos.encoding.IEncodeOptions|null} [encodeOptions] WriteOptions encodeOptions
             * @property {protos.opts.IWriteCLIOptions|null} [_cliOptions] WriteOptions _cliOptions
             * @property {protos.opts.IWriteGroupKafkaOptions|null} [kafka] WriteOptions kafka
             * @property {protos.opts.IWriteGroupActiveMQOptions|null} [activemq] WriteOptions activemq
             * @property {protos.opts.IWriteGroupAWSSQSOptions|null} [awsSqs] WriteOptions awsSqs
             * @property {protos.opts.IWriteGroupAWSSNSOptions|null} [awsSns] WriteOptions awsSns
             * @property {protos.opts.IWriteGroupNatsOptions|null} [nats] WriteOptions nats
             * @property {protos.opts.IWriteGroupNatsStreamingOptions|null} [natsStreaming] WriteOptions natsStreaming
             * @property {protos.opts.IWriteGroupNSQOptions|null} [nsq] WriteOptions nsq
             * @property {protos.opts.IWriteGroupPulsarOptions|null} [pulsar] WriteOptions pulsar
             * @property {protos.opts.IWriteGroupRabbitOptions|null} [rabbit] WriteOptions rabbit
             * @property {protos.opts.IWriteGroupRabbitStreamsOptions|null} [rabbitStreams] WriteOptions rabbitStreams
             * @property {protos.opts.IWriteGroupMQTTOptions|null} [mqtt] WriteOptions mqtt
             * @property {protos.opts.IWriteGroupAzureServiceBusOptions|null} [azureServiceBus] WriteOptions azureServiceBus
             * @property {protos.opts.IWriteGroupAzureEventHubOptions|null} [azureEventHub] WriteOptions azureEventHub
             * @property {protos.opts.IWriteGroupGCPPubSubOptions|null} [gcpPubsub] WriteOptions gcpPubsub
             * @property {protos.opts.IWriteGroupKubeMQQueueOptions|null} [kubemqQueue] WriteOptions kubemqQueue
             * @property {protos.opts.IWriteGroupRedisPubSubOptions|null} [redisPubsub] WriteOptions redisPubsub
             * @property {protos.opts.IWriteGroupRedisStreamsOptions|null} [redisStreams] WriteOptions redisStreams
             * @property {protos.opts.IWriteGroupNatsJetstreamOptions|null} [natsJetstream] WriteOptions natsJetstream
             * @property {protos.opts.IWriteGroupAWSKinesisOptions|null} [awsKinesis] WriteOptions awsKinesis
             * @property {protos.opts.IWriteGroupMemphisOptions|null} [memphis] WriteOptions memphis
             */

            /**
             * Constructs a new WriteOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteOptions.
             * @implements IWriteOptions
             * @constructor
             * @param {protos.opts.IWriteOptions=} [properties] Properties to set
             */
            function WriteOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteOptions connectionId.
             * @member {string} connectionId
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.connectionId = "";

            /**
             * WriteOptions record.
             * @member {protos.records.IWriteRecord|null|undefined} record
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.record = null;

            /**
             * WriteOptions encodeOptions.
             * @member {protos.encoding.IEncodeOptions|null|undefined} encodeOptions
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.encodeOptions = null;

            /**
             * WriteOptions _cliOptions.
             * @member {protos.opts.IWriteCLIOptions|null|undefined} _cliOptions
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype._cliOptions = null;

            /**
             * WriteOptions kafka.
             * @member {protos.opts.IWriteGroupKafkaOptions|null|undefined} kafka
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.kafka = null;

            /**
             * WriteOptions activemq.
             * @member {protos.opts.IWriteGroupActiveMQOptions|null|undefined} activemq
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.activemq = null;

            /**
             * WriteOptions awsSqs.
             * @member {protos.opts.IWriteGroupAWSSQSOptions|null|undefined} awsSqs
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.awsSqs = null;

            /**
             * WriteOptions awsSns.
             * @member {protos.opts.IWriteGroupAWSSNSOptions|null|undefined} awsSns
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.awsSns = null;

            /**
             * WriteOptions nats.
             * @member {protos.opts.IWriteGroupNatsOptions|null|undefined} nats
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.nats = null;

            /**
             * WriteOptions natsStreaming.
             * @member {protos.opts.IWriteGroupNatsStreamingOptions|null|undefined} natsStreaming
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.natsStreaming = null;

            /**
             * WriteOptions nsq.
             * @member {protos.opts.IWriteGroupNSQOptions|null|undefined} nsq
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.nsq = null;

            /**
             * WriteOptions pulsar.
             * @member {protos.opts.IWriteGroupPulsarOptions|null|undefined} pulsar
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.pulsar = null;

            /**
             * WriteOptions rabbit.
             * @member {protos.opts.IWriteGroupRabbitOptions|null|undefined} rabbit
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.rabbit = null;

            /**
             * WriteOptions rabbitStreams.
             * @member {protos.opts.IWriteGroupRabbitStreamsOptions|null|undefined} rabbitStreams
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.rabbitStreams = null;

            /**
             * WriteOptions mqtt.
             * @member {protos.opts.IWriteGroupMQTTOptions|null|undefined} mqtt
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.mqtt = null;

            /**
             * WriteOptions azureServiceBus.
             * @member {protos.opts.IWriteGroupAzureServiceBusOptions|null|undefined} azureServiceBus
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.azureServiceBus = null;

            /**
             * WriteOptions azureEventHub.
             * @member {protos.opts.IWriteGroupAzureEventHubOptions|null|undefined} azureEventHub
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.azureEventHub = null;

            /**
             * WriteOptions gcpPubsub.
             * @member {protos.opts.IWriteGroupGCPPubSubOptions|null|undefined} gcpPubsub
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.gcpPubsub = null;

            /**
             * WriteOptions kubemqQueue.
             * @member {protos.opts.IWriteGroupKubeMQQueueOptions|null|undefined} kubemqQueue
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.kubemqQueue = null;

            /**
             * WriteOptions redisPubsub.
             * @member {protos.opts.IWriteGroupRedisPubSubOptions|null|undefined} redisPubsub
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.redisPubsub = null;

            /**
             * WriteOptions redisStreams.
             * @member {protos.opts.IWriteGroupRedisStreamsOptions|null|undefined} redisStreams
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.redisStreams = null;

            /**
             * WriteOptions natsJetstream.
             * @member {protos.opts.IWriteGroupNatsJetstreamOptions|null|undefined} natsJetstream
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.natsJetstream = null;

            /**
             * WriteOptions awsKinesis.
             * @member {protos.opts.IWriteGroupAWSKinesisOptions|null|undefined} awsKinesis
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.awsKinesis = null;

            /**
             * WriteOptions memphis.
             * @member {protos.opts.IWriteGroupMemphisOptions|null|undefined} memphis
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.memphis = null;

            /**
             * Creates a new WriteOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {protos.opts.IWriteOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteOptions} WriteOptions instance
             */
            WriteOptions.create = function create(properties) {
                return new WriteOptions(properties);
            };

            /**
             * Encodes the specified WriteOptions message. Does not implicitly {@link protos.opts.WriteOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {protos.opts.IWriteOptions} message WriteOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
                if (message.record != null && Object.hasOwnProperty.call(message, "record"))
                    $root.protos.records.WriteRecord.encode(message.record, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.encodeOptions != null && Object.hasOwnProperty.call(message, "encodeOptions"))
                    $root.protos.encoding.EncodeOptions.encode(message.encodeOptions, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.opts.WriteGroupKafkaOptions.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.activemq != null && Object.hasOwnProperty.call(message, "activemq"))
                    $root.protos.opts.WriteGroupActiveMQOptions.encode(message.activemq, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.awsSqs != null && Object.hasOwnProperty.call(message, "awsSqs"))
                    $root.protos.opts.WriteGroupAWSSQSOptions.encode(message.awsSqs, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.awsSns != null && Object.hasOwnProperty.call(message, "awsSns"))
                    $root.protos.opts.WriteGroupAWSSNSOptions.encode(message.awsSns, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.opts.WriteGroupNatsOptions.encode(message.nats, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.opts.WriteGroupNatsStreamingOptions.encode(message.natsStreaming, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.opts.WriteGroupNSQOptions.encode(message.nsq, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.pulsar != null && Object.hasOwnProperty.call(message, "pulsar"))
                    $root.protos.opts.WriteGroupPulsarOptions.encode(message.pulsar, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.opts.WriteGroupRabbitOptions.encode(message.rabbit, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.rabbitStreams != null && Object.hasOwnProperty.call(message, "rabbitStreams"))
                    $root.protos.opts.WriteGroupRabbitStreamsOptions.encode(message.rabbitStreams, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.opts.WriteGroupMQTTOptions.encode(message.mqtt, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.opts.WriteGroupAzureServiceBusOptions.encode(message.azureServiceBus, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.azureEventHub != null && Object.hasOwnProperty.call(message, "azureEventHub"))
                    $root.protos.opts.WriteGroupAzureEventHubOptions.encode(message.azureEventHub, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.opts.WriteGroupGCPPubSubOptions.encode(message.gcpPubsub, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.opts.WriteGroupKubeMQQueueOptions.encode(message.kubemqQueue, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.opts.WriteGroupRedisPubSubOptions.encode(message.redisPubsub, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.opts.WriteGroupRedisStreamsOptions.encode(message.redisStreams, writer.uint32(/* id 116, wireType 2 =*/930).fork()).ldelim();
                if (message.natsJetstream != null && Object.hasOwnProperty.call(message, "natsJetstream"))
                    $root.protos.opts.WriteGroupNatsJetstreamOptions.encode(message.natsJetstream, writer.uint32(/* id 117, wireType 2 =*/938).fork()).ldelim();
                if (message.awsKinesis != null && Object.hasOwnProperty.call(message, "awsKinesis"))
                    $root.protos.opts.WriteGroupAWSKinesisOptions.encode(message.awsKinesis, writer.uint32(/* id 118, wireType 2 =*/946).fork()).ldelim();
                if (message.memphis != null && Object.hasOwnProperty.call(message, "memphis"))
                    $root.protos.opts.WriteGroupMemphisOptions.encode(message.memphis, writer.uint32(/* id 119, wireType 2 =*/954).fork()).ldelim();
                if (message._cliOptions != null && Object.hasOwnProperty.call(message, "_cliOptions"))
                    $root.protos.opts.WriteCLIOptions.encode(message._cliOptions, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteOptions message, length delimited. Does not implicitly {@link protos.opts.WriteOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {protos.opts.IWriteOptions} message WriteOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteOptions} WriteOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.connectionId = reader.string();
                        break;
                    case 2:
                        message.record = $root.protos.records.WriteRecord.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.encodeOptions = $root.protos.encoding.EncodeOptions.decode(reader, reader.uint32());
                        break;
                    case 1000:
                        message._cliOptions = $root.protos.opts.WriteCLIOptions.decode(reader, reader.uint32());
                        break;
                    case 100:
                        message.kafka = $root.protos.opts.WriteGroupKafkaOptions.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.activemq = $root.protos.opts.WriteGroupActiveMQOptions.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.awsSqs = $root.protos.opts.WriteGroupAWSSQSOptions.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.awsSns = $root.protos.opts.WriteGroupAWSSNSOptions.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.nats = $root.protos.opts.WriteGroupNatsOptions.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.natsStreaming = $root.protos.opts.WriteGroupNatsStreamingOptions.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.nsq = $root.protos.opts.WriteGroupNSQOptions.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.pulsar = $root.protos.opts.WriteGroupPulsarOptions.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.rabbit = $root.protos.opts.WriteGroupRabbitOptions.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.rabbitStreams = $root.protos.opts.WriteGroupRabbitStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 110:
                        message.mqtt = $root.protos.opts.WriteGroupMQTTOptions.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.azureServiceBus = $root.protos.opts.WriteGroupAzureServiceBusOptions.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.azureEventHub = $root.protos.opts.WriteGroupAzureEventHubOptions.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.gcpPubsub = $root.protos.opts.WriteGroupGCPPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.redisPubsub = $root.protos.opts.WriteGroupRedisPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 116:
                        message.redisStreams = $root.protos.opts.WriteGroupRedisStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 117:
                        message.natsJetstream = $root.protos.opts.WriteGroupNatsJetstreamOptions.decode(reader, reader.uint32());
                        break;
                    case 118:
                        message.awsKinesis = $root.protos.opts.WriteGroupAWSKinesisOptions.decode(reader, reader.uint32());
                        break;
                    case 119:
                        message.memphis = $root.protos.opts.WriteGroupMemphisOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteOptions} WriteOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteOptions message.
             * @function verify
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    if (!$util.isString(message.connectionId))
                        return "connectionId: string expected";
                if (message.record != null && message.hasOwnProperty("record")) {
                    var error = $root.protos.records.WriteRecord.verify(message.record);
                    if (error)
                        return "record." + error;
                }
                if (message.encodeOptions != null && message.hasOwnProperty("encodeOptions")) {
                    var error = $root.protos.encoding.EncodeOptions.verify(message.encodeOptions);
                    if (error)
                        return "encodeOptions." + error;
                }
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions")) {
                    var error = $root.protos.opts.WriteCLIOptions.verify(message._cliOptions);
                    if (error)
                        return "_cliOptions." + error;
                }
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    var error = $root.protos.opts.WriteGroupKafkaOptions.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.activemq != null && message.hasOwnProperty("activemq")) {
                    var error = $root.protos.opts.WriteGroupActiveMQOptions.verify(message.activemq);
                    if (error)
                        return "activemq." + error;
                }
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs")) {
                    var error = $root.protos.opts.WriteGroupAWSSQSOptions.verify(message.awsSqs);
                    if (error)
                        return "awsSqs." + error;
                }
                if (message.awsSns != null && message.hasOwnProperty("awsSns")) {
                    var error = $root.protos.opts.WriteGroupAWSSNSOptions.verify(message.awsSns);
                    if (error)
                        return "awsSns." + error;
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    var error = $root.protos.opts.WriteGroupNatsOptions.verify(message.nats);
                    if (error)
                        return "nats." + error;
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    var error = $root.protos.opts.WriteGroupNatsStreamingOptions.verify(message.natsStreaming);
                    if (error)
                        return "natsStreaming." + error;
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    var error = $root.protos.opts.WriteGroupNSQOptions.verify(message.nsq);
                    if (error)
                        return "nsq." + error;
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    var error = $root.protos.opts.WriteGroupPulsarOptions.verify(message.pulsar);
                    if (error)
                        return "pulsar." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    var error = $root.protos.opts.WriteGroupRabbitOptions.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    var error = $root.protos.opts.WriteGroupRabbitStreamsOptions.verify(message.rabbitStreams);
                    if (error)
                        return "rabbitStreams." + error;
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    var error = $root.protos.opts.WriteGroupMQTTOptions.verify(message.mqtt);
                    if (error)
                        return "mqtt." + error;
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    var error = $root.protos.opts.WriteGroupAzureServiceBusOptions.verify(message.azureServiceBus);
                    if (error)
                        return "azureServiceBus." + error;
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    var error = $root.protos.opts.WriteGroupAzureEventHubOptions.verify(message.azureEventHub);
                    if (error)
                        return "azureEventHub." + error;
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    var error = $root.protos.opts.WriteGroupGCPPubSubOptions.verify(message.gcpPubsub);
                    if (error)
                        return "gcpPubsub." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    var error = $root.protos.opts.WriteGroupKubeMQQueueOptions.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    var error = $root.protos.opts.WriteGroupRedisPubSubOptions.verify(message.redisPubsub);
                    if (error)
                        return "redisPubsub." + error;
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    var error = $root.protos.opts.WriteGroupRedisStreamsOptions.verify(message.redisStreams);
                    if (error)
                        return "redisStreams." + error;
                }
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream")) {
                    var error = $root.protos.opts.WriteGroupNatsJetstreamOptions.verify(message.natsJetstream);
                    if (error)
                        return "natsJetstream." + error;
                }
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis")) {
                    var error = $root.protos.opts.WriteGroupAWSKinesisOptions.verify(message.awsKinesis);
                    if (error)
                        return "awsKinesis." + error;
                }
                if (message.memphis != null && message.hasOwnProperty("memphis")) {
                    var error = $root.protos.opts.WriteGroupMemphisOptions.verify(message.memphis);
                    if (error)
                        return "memphis." + error;
                }
                return null;
            };

            /**
             * Creates a WriteOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteOptions} WriteOptions
             */
            WriteOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteOptions)
                    return object;
                var message = new $root.protos.opts.WriteOptions();
                if (object.connectionId != null)
                    message.connectionId = String(object.connectionId);
                if (object.record != null) {
                    if (typeof object.record !== "object")
                        throw TypeError(".protos.opts.WriteOptions.record: object expected");
                    message.record = $root.protos.records.WriteRecord.fromObject(object.record);
                }
                if (object.encodeOptions != null) {
                    if (typeof object.encodeOptions !== "object")
                        throw TypeError(".protos.opts.WriteOptions.encodeOptions: object expected");
                    message.encodeOptions = $root.protos.encoding.EncodeOptions.fromObject(object.encodeOptions);
                }
                if (object._cliOptions != null) {
                    if (typeof object._cliOptions !== "object")
                        throw TypeError(".protos.opts.WriteOptions._cliOptions: object expected");
                    message._cliOptions = $root.protos.opts.WriteCLIOptions.fromObject(object._cliOptions);
                }
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.WriteOptions.kafka: object expected");
                    message.kafka = $root.protos.opts.WriteGroupKafkaOptions.fromObject(object.kafka);
                }
                if (object.activemq != null) {
                    if (typeof object.activemq !== "object")
                        throw TypeError(".protos.opts.WriteOptions.activemq: object expected");
                    message.activemq = $root.protos.opts.WriteGroupActiveMQOptions.fromObject(object.activemq);
                }
                if (object.awsSqs != null) {
                    if (typeof object.awsSqs !== "object")
                        throw TypeError(".protos.opts.WriteOptions.awsSqs: object expected");
                    message.awsSqs = $root.protos.opts.WriteGroupAWSSQSOptions.fromObject(object.awsSqs);
                }
                if (object.awsSns != null) {
                    if (typeof object.awsSns !== "object")
                        throw TypeError(".protos.opts.WriteOptions.awsSns: object expected");
                    message.awsSns = $root.protos.opts.WriteGroupAWSSNSOptions.fromObject(object.awsSns);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.opts.WriteOptions.nats: object expected");
                    message.nats = $root.protos.opts.WriteGroupNatsOptions.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.opts.WriteOptions.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.opts.WriteGroupNatsStreamingOptions.fromObject(object.natsStreaming);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.WriteOptions.nsq: object expected");
                    message.nsq = $root.protos.opts.WriteGroupNSQOptions.fromObject(object.nsq);
                }
                if (object.pulsar != null) {
                    if (typeof object.pulsar !== "object")
                        throw TypeError(".protos.opts.WriteOptions.pulsar: object expected");
                    message.pulsar = $root.protos.opts.WriteGroupPulsarOptions.fromObject(object.pulsar);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.WriteOptions.rabbit: object expected");
                    message.rabbit = $root.protos.opts.WriteGroupRabbitOptions.fromObject(object.rabbit);
                }
                if (object.rabbitStreams != null) {
                    if (typeof object.rabbitStreams !== "object")
                        throw TypeError(".protos.opts.WriteOptions.rabbitStreams: object expected");
                    message.rabbitStreams = $root.protos.opts.WriteGroupRabbitStreamsOptions.fromObject(object.rabbitStreams);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.WriteOptions.mqtt: object expected");
                    message.mqtt = $root.protos.opts.WriteGroupMQTTOptions.fromObject(object.mqtt);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.WriteOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.opts.WriteGroupAzureServiceBusOptions.fromObject(object.azureServiceBus);
                }
                if (object.azureEventHub != null) {
                    if (typeof object.azureEventHub !== "object")
                        throw TypeError(".protos.opts.WriteOptions.azureEventHub: object expected");
                    message.azureEventHub = $root.protos.opts.WriteGroupAzureEventHubOptions.fromObject(object.azureEventHub);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.WriteOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.opts.WriteGroupGCPPubSubOptions.fromObject(object.gcpPubsub);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.WriteOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.fromObject(object.kubemqQueue);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.WriteOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.opts.WriteGroupRedisPubSubOptions.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.WriteOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.opts.WriteGroupRedisStreamsOptions.fromObject(object.redisStreams);
                }
                if (object.natsJetstream != null) {
                    if (typeof object.natsJetstream !== "object")
                        throw TypeError(".protos.opts.WriteOptions.natsJetstream: object expected");
                    message.natsJetstream = $root.protos.opts.WriteGroupNatsJetstreamOptions.fromObject(object.natsJetstream);
                }
                if (object.awsKinesis != null) {
                    if (typeof object.awsKinesis !== "object")
                        throw TypeError(".protos.opts.WriteOptions.awsKinesis: object expected");
                    message.awsKinesis = $root.protos.opts.WriteGroupAWSKinesisOptions.fromObject(object.awsKinesis);
                }
                if (object.memphis != null) {
                    if (typeof object.memphis !== "object")
                        throw TypeError(".protos.opts.WriteOptions.memphis: object expected");
                    message.memphis = $root.protos.opts.WriteGroupMemphisOptions.fromObject(object.memphis);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {protos.opts.WriteOptions} message WriteOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.connectionId = "";
                    object.record = null;
                    object.encodeOptions = null;
                    object.kafka = null;
                    object.activemq = null;
                    object.awsSqs = null;
                    object.awsSns = null;
                    object.nats = null;
                    object.natsStreaming = null;
                    object.nsq = null;
                    object.pulsar = null;
                    object.rabbit = null;
                    object.rabbitStreams = null;
                    object.mqtt = null;
                    object.azureServiceBus = null;
                    object.azureEventHub = null;
                    object.gcpPubsub = null;
                    object.kubemqQueue = null;
                    object.redisPubsub = null;
                    object.redisStreams = null;
                    object.natsJetstream = null;
                    object.awsKinesis = null;
                    object.memphis = null;
                    object._cliOptions = null;
                }
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    object.connectionId = message.connectionId;
                if (message.record != null && message.hasOwnProperty("record"))
                    object.record = $root.protos.records.WriteRecord.toObject(message.record, options);
                if (message.encodeOptions != null && message.hasOwnProperty("encodeOptions"))
                    object.encodeOptions = $root.protos.encoding.EncodeOptions.toObject(message.encodeOptions, options);
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.opts.WriteGroupKafkaOptions.toObject(message.kafka, options);
                if (message.activemq != null && message.hasOwnProperty("activemq"))
                    object.activemq = $root.protos.opts.WriteGroupActiveMQOptions.toObject(message.activemq, options);
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs"))
                    object.awsSqs = $root.protos.opts.WriteGroupAWSSQSOptions.toObject(message.awsSqs, options);
                if (message.awsSns != null && message.hasOwnProperty("awsSns"))
                    object.awsSns = $root.protos.opts.WriteGroupAWSSNSOptions.toObject(message.awsSns, options);
                if (message.nats != null && message.hasOwnProperty("nats"))
                    object.nats = $root.protos.opts.WriteGroupNatsOptions.toObject(message.nats, options);
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming"))
                    object.natsStreaming = $root.protos.opts.WriteGroupNatsStreamingOptions.toObject(message.natsStreaming, options);
                if (message.nsq != null && message.hasOwnProperty("nsq"))
                    object.nsq = $root.protos.opts.WriteGroupNSQOptions.toObject(message.nsq, options);
                if (message.pulsar != null && message.hasOwnProperty("pulsar"))
                    object.pulsar = $root.protos.opts.WriteGroupPulsarOptions.toObject(message.pulsar, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.opts.WriteGroupRabbitOptions.toObject(message.rabbit, options);
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams"))
                    object.rabbitStreams = $root.protos.opts.WriteGroupRabbitStreamsOptions.toObject(message.rabbitStreams, options);
                if (message.mqtt != null && message.hasOwnProperty("mqtt"))
                    object.mqtt = $root.protos.opts.WriteGroupMQTTOptions.toObject(message.mqtt, options);
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus"))
                    object.azureServiceBus = $root.protos.opts.WriteGroupAzureServiceBusOptions.toObject(message.azureServiceBus, options);
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub"))
                    object.azureEventHub = $root.protos.opts.WriteGroupAzureEventHubOptions.toObject(message.azureEventHub, options);
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub"))
                    object.gcpPubsub = $root.protos.opts.WriteGroupGCPPubSubOptions.toObject(message.gcpPubsub, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.toObject(message.kubemqQueue, options);
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub"))
                    object.redisPubsub = $root.protos.opts.WriteGroupRedisPubSubOptions.toObject(message.redisPubsub, options);
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams"))
                    object.redisStreams = $root.protos.opts.WriteGroupRedisStreamsOptions.toObject(message.redisStreams, options);
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream"))
                    object.natsJetstream = $root.protos.opts.WriteGroupNatsJetstreamOptions.toObject(message.natsJetstream, options);
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis"))
                    object.awsKinesis = $root.protos.opts.WriteGroupAWSKinesisOptions.toObject(message.awsKinesis, options);
                if (message.memphis != null && message.hasOwnProperty("memphis"))
                    object.memphis = $root.protos.opts.WriteGroupMemphisOptions.toObject(message.memphis, options);
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions"))
                    object._cliOptions = $root.protos.opts.WriteCLIOptions.toObject(message._cliOptions, options);
                return object;
            };

            /**
             * Converts this WriteOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteOptions;
        })();

        opts.WriteGroupKafkaOptions = (function() {

            /**
             * Properties of a WriteGroupKafkaOptions.
             * @memberof protos.opts
             * @interface IWriteGroupKafkaOptions
             * @property {protos.args.IKafkaConn|null} [_conn] WriteGroupKafkaOptions _conn
             * @property {protos.args.IKafkaWriteArgs|null} [args] WriteGroupKafkaOptions args
             */

            /**
             * Constructs a new WriteGroupKafkaOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupKafkaOptions.
             * @implements IWriteGroupKafkaOptions
             * @constructor
             * @param {protos.opts.IWriteGroupKafkaOptions=} [properties] Properties to set
             */
            function WriteGroupKafkaOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupKafkaOptions _conn.
             * @member {protos.args.IKafkaConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @instance
             */
            WriteGroupKafkaOptions.prototype._conn = null;

            /**
             * WriteGroupKafkaOptions args.
             * @member {protos.args.IKafkaWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @instance
             */
            WriteGroupKafkaOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupKafkaOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {protos.opts.IWriteGroupKafkaOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupKafkaOptions} WriteGroupKafkaOptions instance
             */
            WriteGroupKafkaOptions.create = function create(properties) {
                return new WriteGroupKafkaOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupKafkaOptions message. Does not implicitly {@link protos.opts.WriteGroupKafkaOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {protos.opts.IWriteGroupKafkaOptions} message WriteGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupKafkaOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KafkaConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KafkaWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupKafkaOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupKafkaOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {protos.opts.IWriteGroupKafkaOptions} message WriteGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupKafkaOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupKafkaOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupKafkaOptions} WriteGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupKafkaOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupKafkaOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KafkaConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KafkaWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupKafkaOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupKafkaOptions} WriteGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupKafkaOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupKafkaOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupKafkaOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KafkaConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KafkaWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupKafkaOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupKafkaOptions} WriteGroupKafkaOptions
             */
            WriteGroupKafkaOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupKafkaOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupKafkaOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupKafkaOptions._conn: object expected");
                    message._conn = $root.protos.args.KafkaConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupKafkaOptions.args: object expected");
                    message.args = $root.protos.args.KafkaWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupKafkaOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {protos.opts.WriteGroupKafkaOptions} message WriteGroupKafkaOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupKafkaOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KafkaConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KafkaWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupKafkaOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupKafkaOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupKafkaOptions;
        })();

        opts.WriteGroupActiveMQOptions = (function() {

            /**
             * Properties of a WriteGroupActiveMQOptions.
             * @memberof protos.opts
             * @interface IWriteGroupActiveMQOptions
             * @property {protos.args.IActiveMQConn|null} [_conn] WriteGroupActiveMQOptions _conn
             * @property {protos.args.IActiveMQWriteArgs|null} [args] WriteGroupActiveMQOptions args
             */

            /**
             * Constructs a new WriteGroupActiveMQOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupActiveMQOptions.
             * @implements IWriteGroupActiveMQOptions
             * @constructor
             * @param {protos.opts.IWriteGroupActiveMQOptions=} [properties] Properties to set
             */
            function WriteGroupActiveMQOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupActiveMQOptions _conn.
             * @member {protos.args.IActiveMQConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @instance
             */
            WriteGroupActiveMQOptions.prototype._conn = null;

            /**
             * WriteGroupActiveMQOptions args.
             * @member {protos.args.IActiveMQWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @instance
             */
            WriteGroupActiveMQOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupActiveMQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {protos.opts.IWriteGroupActiveMQOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupActiveMQOptions} WriteGroupActiveMQOptions instance
             */
            WriteGroupActiveMQOptions.create = function create(properties) {
                return new WriteGroupActiveMQOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupActiveMQOptions message. Does not implicitly {@link protos.opts.WriteGroupActiveMQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {protos.opts.IWriteGroupActiveMQOptions} message WriteGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupActiveMQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.ActiveMQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.ActiveMQWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupActiveMQOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupActiveMQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {protos.opts.IWriteGroupActiveMQOptions} message WriteGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupActiveMQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupActiveMQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupActiveMQOptions} WriteGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupActiveMQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupActiveMQOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.ActiveMQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.ActiveMQWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupActiveMQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupActiveMQOptions} WriteGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupActiveMQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupActiveMQOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupActiveMQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.ActiveMQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.ActiveMQWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupActiveMQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupActiveMQOptions} WriteGroupActiveMQOptions
             */
            WriteGroupActiveMQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupActiveMQOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupActiveMQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupActiveMQOptions._conn: object expected");
                    message._conn = $root.protos.args.ActiveMQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupActiveMQOptions.args: object expected");
                    message.args = $root.protos.args.ActiveMQWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupActiveMQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {protos.opts.WriteGroupActiveMQOptions} message WriteGroupActiveMQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupActiveMQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.ActiveMQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.ActiveMQWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupActiveMQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupActiveMQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupActiveMQOptions;
        })();

        opts.WriteGroupAWSSQSOptions = (function() {

            /**
             * Properties of a WriteGroupAWSSQSOptions.
             * @memberof protos.opts
             * @interface IWriteGroupAWSSQSOptions
             * @property {protos.args.IAWSSQSConn|null} [_conn] WriteGroupAWSSQSOptions _conn
             * @property {protos.args.IAWSSQSWriteArgs|null} [args] WriteGroupAWSSQSOptions args
             */

            /**
             * Constructs a new WriteGroupAWSSQSOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupAWSSQSOptions.
             * @implements IWriteGroupAWSSQSOptions
             * @constructor
             * @param {protos.opts.IWriteGroupAWSSQSOptions=} [properties] Properties to set
             */
            function WriteGroupAWSSQSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupAWSSQSOptions _conn.
             * @member {protos.args.IAWSSQSConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @instance
             */
            WriteGroupAWSSQSOptions.prototype._conn = null;

            /**
             * WriteGroupAWSSQSOptions args.
             * @member {protos.args.IAWSSQSWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @instance
             */
            WriteGroupAWSSQSOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupAWSSQSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSQSOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupAWSSQSOptions} WriteGroupAWSSQSOptions instance
             */
            WriteGroupAWSSQSOptions.create = function create(properties) {
                return new WriteGroupAWSSQSOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupAWSSQSOptions message. Does not implicitly {@link protos.opts.WriteGroupAWSSQSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSQSOptions} message WriteGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAWSSQSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSQSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSQSWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupAWSSQSOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupAWSSQSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSQSOptions} message WriteGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAWSSQSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupAWSSQSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupAWSSQSOptions} WriteGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAWSSQSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupAWSSQSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSQSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSQSWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupAWSSQSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupAWSSQSOptions} WriteGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAWSSQSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupAWSSQSOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupAWSSQSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSSQSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSSQSWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupAWSSQSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupAWSSQSOptions} WriteGroupAWSSQSOptions
             */
            WriteGroupAWSSQSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupAWSSQSOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupAWSSQSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupAWSSQSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSQSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupAWSSQSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSQSWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupAWSSQSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {protos.opts.WriteGroupAWSSQSOptions} message WriteGroupAWSSQSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupAWSSQSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSQSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSQSWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupAWSSQSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupAWSSQSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupAWSSQSOptions;
        })();

        opts.WriteGroupAWSSNSOptions = (function() {

            /**
             * Properties of a WriteGroupAWSSNSOptions.
             * @memberof protos.opts
             * @interface IWriteGroupAWSSNSOptions
             * @property {protos.args.IAWSSNSConn|null} [_conn] WriteGroupAWSSNSOptions _conn
             * @property {protos.args.IAWSSNSWriteArgs|null} [args] WriteGroupAWSSNSOptions args
             */

            /**
             * Constructs a new WriteGroupAWSSNSOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupAWSSNSOptions.
             * @implements IWriteGroupAWSSNSOptions
             * @constructor
             * @param {protos.opts.IWriteGroupAWSSNSOptions=} [properties] Properties to set
             */
            function WriteGroupAWSSNSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupAWSSNSOptions _conn.
             * @member {protos.args.IAWSSNSConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @instance
             */
            WriteGroupAWSSNSOptions.prototype._conn = null;

            /**
             * WriteGroupAWSSNSOptions args.
             * @member {protos.args.IAWSSNSWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @instance
             */
            WriteGroupAWSSNSOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupAWSSNSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSNSOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupAWSSNSOptions} WriteGroupAWSSNSOptions instance
             */
            WriteGroupAWSSNSOptions.create = function create(properties) {
                return new WriteGroupAWSSNSOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupAWSSNSOptions message. Does not implicitly {@link protos.opts.WriteGroupAWSSNSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSNSOptions} message WriteGroupAWSSNSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAWSSNSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSNSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSNSWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupAWSSNSOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupAWSSNSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSNSOptions} message WriteGroupAWSSNSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAWSSNSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupAWSSNSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupAWSSNSOptions} WriteGroupAWSSNSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAWSSNSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupAWSSNSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSNSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSNSWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupAWSSNSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupAWSSNSOptions} WriteGroupAWSSNSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAWSSNSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupAWSSNSOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupAWSSNSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSSNSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSSNSWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupAWSSNSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupAWSSNSOptions} WriteGroupAWSSNSOptions
             */
            WriteGroupAWSSNSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupAWSSNSOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupAWSSNSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupAWSSNSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSNSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupAWSSNSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSNSWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupAWSSNSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {protos.opts.WriteGroupAWSSNSOptions} message WriteGroupAWSSNSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupAWSSNSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSNSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSNSWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupAWSSNSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupAWSSNSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupAWSSNSOptions;
        })();

        opts.WriteGroupNatsOptions = (function() {

            /**
             * Properties of a WriteGroupNatsOptions.
             * @memberof protos.opts
             * @interface IWriteGroupNatsOptions
             * @property {protos.args.INatsConn|null} [_conn] WriteGroupNatsOptions _conn
             * @property {protos.args.INatsWriteArgs|null} [args] WriteGroupNatsOptions args
             */

            /**
             * Constructs a new WriteGroupNatsOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupNatsOptions.
             * @implements IWriteGroupNatsOptions
             * @constructor
             * @param {protos.opts.IWriteGroupNatsOptions=} [properties] Properties to set
             */
            function WriteGroupNatsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupNatsOptions _conn.
             * @member {protos.args.INatsConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupNatsOptions
             * @instance
             */
            WriteGroupNatsOptions.prototype._conn = null;

            /**
             * WriteGroupNatsOptions args.
             * @member {protos.args.INatsWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupNatsOptions
             * @instance
             */
            WriteGroupNatsOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupNatsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupNatsOptions} WriteGroupNatsOptions instance
             */
            WriteGroupNatsOptions.create = function create(properties) {
                return new WriteGroupNatsOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupNatsOptions message. Does not implicitly {@link protos.opts.WriteGroupNatsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsOptions} message WriteGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNatsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupNatsOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupNatsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsOptions} message WriteGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNatsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupNatsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupNatsOptions} WriteGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNatsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupNatsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupNatsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupNatsOptions} WriteGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNatsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupNatsOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupNatsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupNatsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupNatsOptions} WriteGroupNatsOptions
             */
            WriteGroupNatsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupNatsOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupNatsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupNatsOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupNatsOptions.args: object expected");
                    message.args = $root.protos.args.NatsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupNatsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {protos.opts.WriteGroupNatsOptions} message WriteGroupNatsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupNatsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupNatsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupNatsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupNatsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupNatsOptions;
        })();

        opts.WriteGroupNatsJetstreamOptions = (function() {

            /**
             * Properties of a WriteGroupNatsJetstreamOptions.
             * @memberof protos.opts
             * @interface IWriteGroupNatsJetstreamOptions
             * @property {protos.args.INatsJetstreamConn|null} [_conn] WriteGroupNatsJetstreamOptions _conn
             * @property {protos.args.INatsJetstreamWriteArgs|null} [args] WriteGroupNatsJetstreamOptions args
             */

            /**
             * Constructs a new WriteGroupNatsJetstreamOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupNatsJetstreamOptions.
             * @implements IWriteGroupNatsJetstreamOptions
             * @constructor
             * @param {protos.opts.IWriteGroupNatsJetstreamOptions=} [properties] Properties to set
             */
            function WriteGroupNatsJetstreamOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupNatsJetstreamOptions _conn.
             * @member {protos.args.INatsJetstreamConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @instance
             */
            WriteGroupNatsJetstreamOptions.prototype._conn = null;

            /**
             * WriteGroupNatsJetstreamOptions args.
             * @member {protos.args.INatsJetstreamWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @instance
             */
            WriteGroupNatsJetstreamOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupNatsJetstreamOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsJetstreamOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupNatsJetstreamOptions} WriteGroupNatsJetstreamOptions instance
             */
            WriteGroupNatsJetstreamOptions.create = function create(properties) {
                return new WriteGroupNatsJetstreamOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupNatsJetstreamOptions message. Does not implicitly {@link protos.opts.WriteGroupNatsJetstreamOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsJetstreamOptions} message WriteGroupNatsJetstreamOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNatsJetstreamOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsJetstreamConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsJetstreamWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupNatsJetstreamOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupNatsJetstreamOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsJetstreamOptions} message WriteGroupNatsJetstreamOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNatsJetstreamOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupNatsJetstreamOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupNatsJetstreamOptions} WriteGroupNatsJetstreamOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNatsJetstreamOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupNatsJetstreamOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsJetstreamConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsJetstreamWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupNatsJetstreamOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupNatsJetstreamOptions} WriteGroupNatsJetstreamOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNatsJetstreamOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupNatsJetstreamOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupNatsJetstreamOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsJetstreamConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsJetstreamWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupNatsJetstreamOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupNatsJetstreamOptions} WriteGroupNatsJetstreamOptions
             */
            WriteGroupNatsJetstreamOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupNatsJetstreamOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupNatsJetstreamOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupNatsJetstreamOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsJetstreamConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupNatsJetstreamOptions.args: object expected");
                    message.args = $root.protos.args.NatsJetstreamWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupNatsJetstreamOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.WriteGroupNatsJetstreamOptions} message WriteGroupNatsJetstreamOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupNatsJetstreamOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsJetstreamConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsJetstreamWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupNatsJetstreamOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupNatsJetstreamOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupNatsJetstreamOptions;
        })();

        opts.WriteGroupNatsStreamingOptions = (function() {

            /**
             * Properties of a WriteGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @interface IWriteGroupNatsStreamingOptions
             * @property {protos.args.INatsStreamingConn|null} [_conn] WriteGroupNatsStreamingOptions _conn
             * @property {protos.args.INatsStreamingWriteArgs|null} [args] WriteGroupNatsStreamingOptions args
             */

            /**
             * Constructs a new WriteGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupNatsStreamingOptions.
             * @implements IWriteGroupNatsStreamingOptions
             * @constructor
             * @param {protos.opts.IWriteGroupNatsStreamingOptions=} [properties] Properties to set
             */
            function WriteGroupNatsStreamingOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupNatsStreamingOptions _conn.
             * @member {protos.args.INatsStreamingConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @instance
             */
            WriteGroupNatsStreamingOptions.prototype._conn = null;

            /**
             * WriteGroupNatsStreamingOptions args.
             * @member {protos.args.INatsStreamingWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @instance
             */
            WriteGroupNatsStreamingOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupNatsStreamingOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsStreamingOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupNatsStreamingOptions} WriteGroupNatsStreamingOptions instance
             */
            WriteGroupNatsStreamingOptions.create = function create(properties) {
                return new WriteGroupNatsStreamingOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupNatsStreamingOptions message. Does not implicitly {@link protos.opts.WriteGroupNatsStreamingOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsStreamingOptions} message WriteGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNatsStreamingOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsStreamingConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsStreamingWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupNatsStreamingOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupNatsStreamingOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsStreamingOptions} message WriteGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNatsStreamingOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupNatsStreamingOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupNatsStreamingOptions} WriteGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNatsStreamingOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupNatsStreamingOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsStreamingConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsStreamingWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupNatsStreamingOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupNatsStreamingOptions} WriteGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNatsStreamingOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupNatsStreamingOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupNatsStreamingOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsStreamingConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsStreamingWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupNatsStreamingOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupNatsStreamingOptions} WriteGroupNatsStreamingOptions
             */
            WriteGroupNatsStreamingOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupNatsStreamingOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupNatsStreamingOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupNatsStreamingOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsStreamingConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupNatsStreamingOptions.args: object expected");
                    message.args = $root.protos.args.NatsStreamingWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupNatsStreamingOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.WriteGroupNatsStreamingOptions} message WriteGroupNatsStreamingOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupNatsStreamingOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsStreamingConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsStreamingWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupNatsStreamingOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupNatsStreamingOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupNatsStreamingOptions;
        })();

        opts.WriteGroupNSQOptions = (function() {

            /**
             * Properties of a WriteGroupNSQOptions.
             * @memberof protos.opts
             * @interface IWriteGroupNSQOptions
             * @property {protos.args.INSQConn|null} [_conn] WriteGroupNSQOptions _conn
             * @property {protos.args.INSQWriteArgs|null} [args] WriteGroupNSQOptions args
             */

            /**
             * Constructs a new WriteGroupNSQOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupNSQOptions.
             * @implements IWriteGroupNSQOptions
             * @constructor
             * @param {protos.opts.IWriteGroupNSQOptions=} [properties] Properties to set
             */
            function WriteGroupNSQOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupNSQOptions _conn.
             * @member {protos.args.INSQConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupNSQOptions
             * @instance
             */
            WriteGroupNSQOptions.prototype._conn = null;

            /**
             * WriteGroupNSQOptions args.
             * @member {protos.args.INSQWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupNSQOptions
             * @instance
             */
            WriteGroupNSQOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupNSQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {protos.opts.IWriteGroupNSQOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupNSQOptions} WriteGroupNSQOptions instance
             */
            WriteGroupNSQOptions.create = function create(properties) {
                return new WriteGroupNSQOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupNSQOptions message. Does not implicitly {@link protos.opts.WriteGroupNSQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {protos.opts.IWriteGroupNSQOptions} message WriteGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNSQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NSQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NSQWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupNSQOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupNSQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {protos.opts.IWriteGroupNSQOptions} message WriteGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNSQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupNSQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupNSQOptions} WriteGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNSQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupNSQOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NSQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NSQWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupNSQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupNSQOptions} WriteGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNSQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupNSQOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupNSQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NSQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NSQWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupNSQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupNSQOptions} WriteGroupNSQOptions
             */
            WriteGroupNSQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupNSQOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupNSQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupNSQOptions._conn: object expected");
                    message._conn = $root.protos.args.NSQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupNSQOptions.args: object expected");
                    message.args = $root.protos.args.NSQWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupNSQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {protos.opts.WriteGroupNSQOptions} message WriteGroupNSQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupNSQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NSQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NSQWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupNSQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupNSQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupNSQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupNSQOptions;
        })();

        opts.WriteGroupPulsarOptions = (function() {

            /**
             * Properties of a WriteGroupPulsarOptions.
             * @memberof protos.opts
             * @interface IWriteGroupPulsarOptions
             * @property {protos.args.IPulsarConn|null} [_conn] WriteGroupPulsarOptions _conn
             * @property {protos.args.IPulsarWriteArgs|null} [args] WriteGroupPulsarOptions args
             */

            /**
             * Constructs a new WriteGroupPulsarOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupPulsarOptions.
             * @implements IWriteGroupPulsarOptions
             * @constructor
             * @param {protos.opts.IWriteGroupPulsarOptions=} [properties] Properties to set
             */
            function WriteGroupPulsarOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupPulsarOptions _conn.
             * @member {protos.args.IPulsarConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @instance
             */
            WriteGroupPulsarOptions.prototype._conn = null;

            /**
             * WriteGroupPulsarOptions args.
             * @member {protos.args.IPulsarWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @instance
             */
            WriteGroupPulsarOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupPulsarOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {protos.opts.IWriteGroupPulsarOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupPulsarOptions} WriteGroupPulsarOptions instance
             */
            WriteGroupPulsarOptions.create = function create(properties) {
                return new WriteGroupPulsarOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupPulsarOptions message. Does not implicitly {@link protos.opts.WriteGroupPulsarOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {protos.opts.IWriteGroupPulsarOptions} message WriteGroupPulsarOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupPulsarOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.PulsarConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.PulsarWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupPulsarOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupPulsarOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {protos.opts.IWriteGroupPulsarOptions} message WriteGroupPulsarOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupPulsarOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupPulsarOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupPulsarOptions} WriteGroupPulsarOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupPulsarOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupPulsarOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.PulsarConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.PulsarWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupPulsarOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupPulsarOptions} WriteGroupPulsarOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupPulsarOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupPulsarOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupPulsarOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.PulsarConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.PulsarWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupPulsarOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupPulsarOptions} WriteGroupPulsarOptions
             */
            WriteGroupPulsarOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupPulsarOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupPulsarOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupPulsarOptions._conn: object expected");
                    message._conn = $root.protos.args.PulsarConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupPulsarOptions.args: object expected");
                    message.args = $root.protos.args.PulsarWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupPulsarOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {protos.opts.WriteGroupPulsarOptions} message WriteGroupPulsarOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupPulsarOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.PulsarConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.PulsarWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupPulsarOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupPulsarOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupPulsarOptions;
        })();

        opts.WriteGroupRabbitOptions = (function() {

            /**
             * Properties of a WriteGroupRabbitOptions.
             * @memberof protos.opts
             * @interface IWriteGroupRabbitOptions
             * @property {protos.args.IRabbitConn|null} [_conn] WriteGroupRabbitOptions _conn
             * @property {protos.args.IRabbitWriteArgs|null} [args] WriteGroupRabbitOptions args
             */

            /**
             * Constructs a new WriteGroupRabbitOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupRabbitOptions.
             * @implements IWriteGroupRabbitOptions
             * @constructor
             * @param {protos.opts.IWriteGroupRabbitOptions=} [properties] Properties to set
             */
            function WriteGroupRabbitOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupRabbitOptions _conn.
             * @member {protos.args.IRabbitConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @instance
             */
            WriteGroupRabbitOptions.prototype._conn = null;

            /**
             * WriteGroupRabbitOptions args.
             * @member {protos.args.IRabbitWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @instance
             */
            WriteGroupRabbitOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupRabbitOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupRabbitOptions} WriteGroupRabbitOptions instance
             */
            WriteGroupRabbitOptions.create = function create(properties) {
                return new WriteGroupRabbitOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupRabbitOptions message. Does not implicitly {@link protos.opts.WriteGroupRabbitOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitOptions} message WriteGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRabbitOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupRabbitOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupRabbitOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitOptions} message WriteGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRabbitOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupRabbitOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupRabbitOptions} WriteGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRabbitOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupRabbitOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupRabbitOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupRabbitOptions} WriteGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRabbitOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupRabbitOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupRabbitOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RabbitConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RabbitWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupRabbitOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupRabbitOptions} WriteGroupRabbitOptions
             */
            WriteGroupRabbitOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupRabbitOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupRabbitOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupRabbitOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupRabbitOptions.args: object expected");
                    message.args = $root.protos.args.RabbitWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupRabbitOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {protos.opts.WriteGroupRabbitOptions} message WriteGroupRabbitOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupRabbitOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupRabbitOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupRabbitOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupRabbitOptions;
        })();

        opts.WriteGroupRabbitStreamsOptions = (function() {

            /**
             * Properties of a WriteGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @interface IWriteGroupRabbitStreamsOptions
             * @property {protos.args.IRabbitStreamsConn|null} [_conn] WriteGroupRabbitStreamsOptions _conn
             * @property {protos.args.IRabbitStreamsWriteArgs|null} [args] WriteGroupRabbitStreamsOptions args
             */

            /**
             * Constructs a new WriteGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupRabbitStreamsOptions.
             * @implements IWriteGroupRabbitStreamsOptions
             * @constructor
             * @param {protos.opts.IWriteGroupRabbitStreamsOptions=} [properties] Properties to set
             */
            function WriteGroupRabbitStreamsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupRabbitStreamsOptions _conn.
             * @member {protos.args.IRabbitStreamsConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @instance
             */
            WriteGroupRabbitStreamsOptions.prototype._conn = null;

            /**
             * WriteGroupRabbitStreamsOptions args.
             * @member {protos.args.IRabbitStreamsWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @instance
             */
            WriteGroupRabbitStreamsOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupRabbitStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupRabbitStreamsOptions} WriteGroupRabbitStreamsOptions instance
             */
            WriteGroupRabbitStreamsOptions.create = function create(properties) {
                return new WriteGroupRabbitStreamsOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupRabbitStreamsOptions message. Does not implicitly {@link protos.opts.WriteGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitStreamsOptions} message WriteGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRabbitStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitStreamsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupRabbitStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitStreamsOptions} message WriteGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRabbitStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupRabbitStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupRabbitStreamsOptions} WriteGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRabbitStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupRabbitStreamsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitStreamsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupRabbitStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupRabbitStreamsOptions} WriteGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRabbitStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupRabbitStreamsOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupRabbitStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RabbitStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RabbitStreamsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupRabbitStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupRabbitStreamsOptions} WriteGroupRabbitStreamsOptions
             */
            WriteGroupRabbitStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupRabbitStreamsOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupRabbitStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupRabbitStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupRabbitStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RabbitStreamsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupRabbitStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.WriteGroupRabbitStreamsOptions} message WriteGroupRabbitStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupRabbitStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitStreamsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupRabbitStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupRabbitStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupRabbitStreamsOptions;
        })();

        opts.WriteGroupRedisPubSubOptions = (function() {

            /**
             * Properties of a WriteGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @interface IWriteGroupRedisPubSubOptions
             * @property {protos.args.IRedisPubSubConn|null} [_conn] WriteGroupRedisPubSubOptions _conn
             * @property {protos.args.IRedisPubSubWriteArgs|null} [args] WriteGroupRedisPubSubOptions args
             */

            /**
             * Constructs a new WriteGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupRedisPubSubOptions.
             * @implements IWriteGroupRedisPubSubOptions
             * @constructor
             * @param {protos.opts.IWriteGroupRedisPubSubOptions=} [properties] Properties to set
             */
            function WriteGroupRedisPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupRedisPubSubOptions _conn.
             * @member {protos.args.IRedisPubSubConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @instance
             */
            WriteGroupRedisPubSubOptions.prototype._conn = null;

            /**
             * WriteGroupRedisPubSubOptions args.
             * @member {protos.args.IRedisPubSubWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @instance
             */
            WriteGroupRedisPubSubOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupRedisPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupRedisPubSubOptions} WriteGroupRedisPubSubOptions instance
             */
            WriteGroupRedisPubSubOptions.create = function create(properties) {
                return new WriteGroupRedisPubSubOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupRedisPubSubOptions message. Does not implicitly {@link protos.opts.WriteGroupRedisPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisPubSubOptions} message WriteGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRedisPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisPubSubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupRedisPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupRedisPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisPubSubOptions} message WriteGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRedisPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupRedisPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupRedisPubSubOptions} WriteGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRedisPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupRedisPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisPubSubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupRedisPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupRedisPubSubOptions} WriteGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRedisPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupRedisPubSubOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupRedisPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisPubSubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupRedisPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupRedisPubSubOptions} WriteGroupRedisPubSubOptions
             */
            WriteGroupRedisPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupRedisPubSubOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupRedisPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupRedisPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupRedisPubSubOptions.args: object expected");
                    message.args = $root.protos.args.RedisPubSubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupRedisPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.WriteGroupRedisPubSubOptions} message WriteGroupRedisPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupRedisPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisPubSubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupRedisPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupRedisPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupRedisPubSubOptions;
        })();

        opts.WriteGroupRedisStreamsOptions = (function() {

            /**
             * Properties of a WriteGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @interface IWriteGroupRedisStreamsOptions
             * @property {protos.args.IRedisStreamsConn|null} [_conn] WriteGroupRedisStreamsOptions _conn
             * @property {protos.args.IRedisStreamsWriteArgs|null} [args] WriteGroupRedisStreamsOptions args
             */

            /**
             * Constructs a new WriteGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupRedisStreamsOptions.
             * @implements IWriteGroupRedisStreamsOptions
             * @constructor
             * @param {protos.opts.IWriteGroupRedisStreamsOptions=} [properties] Properties to set
             */
            function WriteGroupRedisStreamsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupRedisStreamsOptions _conn.
             * @member {protos.args.IRedisStreamsConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @instance
             */
            WriteGroupRedisStreamsOptions.prototype._conn = null;

            /**
             * WriteGroupRedisStreamsOptions args.
             * @member {protos.args.IRedisStreamsWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @instance
             */
            WriteGroupRedisStreamsOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupRedisStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupRedisStreamsOptions} WriteGroupRedisStreamsOptions instance
             */
            WriteGroupRedisStreamsOptions.create = function create(properties) {
                return new WriteGroupRedisStreamsOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupRedisStreamsOptions message. Does not implicitly {@link protos.opts.WriteGroupRedisStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisStreamsOptions} message WriteGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRedisStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisStreamsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupRedisStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupRedisStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisStreamsOptions} message WriteGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRedisStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupRedisStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupRedisStreamsOptions} WriteGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRedisStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupRedisStreamsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisStreamsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupRedisStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupRedisStreamsOptions} WriteGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRedisStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupRedisStreamsOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupRedisStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisStreamsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupRedisStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupRedisStreamsOptions} WriteGroupRedisStreamsOptions
             */
            WriteGroupRedisStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupRedisStreamsOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupRedisStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupRedisStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupRedisStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RedisStreamsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupRedisStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.WriteGroupRedisStreamsOptions} message WriteGroupRedisStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupRedisStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisStreamsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupRedisStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupRedisStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupRedisStreamsOptions;
        })();

        opts.WriteGroupAzureEventHubOptions = (function() {

            /**
             * Properties of a WriteGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @interface IWriteGroupAzureEventHubOptions
             * @property {protos.args.IAzureEventHubConn|null} [_conn] WriteGroupAzureEventHubOptions _conn
             * @property {protos.args.IAzureEventHubWriteArgs|null} [args] WriteGroupAzureEventHubOptions args
             */

            /**
             * Constructs a new WriteGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupAzureEventHubOptions.
             * @implements IWriteGroupAzureEventHubOptions
             * @constructor
             * @param {protos.opts.IWriteGroupAzureEventHubOptions=} [properties] Properties to set
             */
            function WriteGroupAzureEventHubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupAzureEventHubOptions _conn.
             * @member {protos.args.IAzureEventHubConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @instance
             */
            WriteGroupAzureEventHubOptions.prototype._conn = null;

            /**
             * WriteGroupAzureEventHubOptions args.
             * @member {protos.args.IAzureEventHubWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @instance
             */
            WriteGroupAzureEventHubOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupAzureEventHubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureEventHubOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupAzureEventHubOptions} WriteGroupAzureEventHubOptions instance
             */
            WriteGroupAzureEventHubOptions.create = function create(properties) {
                return new WriteGroupAzureEventHubOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupAzureEventHubOptions message. Does not implicitly {@link protos.opts.WriteGroupAzureEventHubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureEventHubOptions} message WriteGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAzureEventHubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureEventHubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureEventHubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupAzureEventHubOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupAzureEventHubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureEventHubOptions} message WriteGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAzureEventHubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupAzureEventHubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupAzureEventHubOptions} WriteGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAzureEventHubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupAzureEventHubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureEventHubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureEventHubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupAzureEventHubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupAzureEventHubOptions} WriteGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAzureEventHubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupAzureEventHubOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupAzureEventHubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AzureEventHubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AzureEventHubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupAzureEventHubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupAzureEventHubOptions} WriteGroupAzureEventHubOptions
             */
            WriteGroupAzureEventHubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupAzureEventHubOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupAzureEventHubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupAzureEventHubOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureEventHubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupAzureEventHubOptions.args: object expected");
                    message.args = $root.protos.args.AzureEventHubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupAzureEventHubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.WriteGroupAzureEventHubOptions} message WriteGroupAzureEventHubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupAzureEventHubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureEventHubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureEventHubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupAzureEventHubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupAzureEventHubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupAzureEventHubOptions;
        })();

        opts.WriteGroupAzureServiceBusOptions = (function() {

            /**
             * Properties of a WriteGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @interface IWriteGroupAzureServiceBusOptions
             * @property {protos.args.IAzureServiceBusConn|null} [_conn] WriteGroupAzureServiceBusOptions _conn
             * @property {protos.args.IAzureServiceBusWriteArgs|null} [args] WriteGroupAzureServiceBusOptions args
             */

            /**
             * Constructs a new WriteGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupAzureServiceBusOptions.
             * @implements IWriteGroupAzureServiceBusOptions
             * @constructor
             * @param {protos.opts.IWriteGroupAzureServiceBusOptions=} [properties] Properties to set
             */
            function WriteGroupAzureServiceBusOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupAzureServiceBusOptions _conn.
             * @member {protos.args.IAzureServiceBusConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @instance
             */
            WriteGroupAzureServiceBusOptions.prototype._conn = null;

            /**
             * WriteGroupAzureServiceBusOptions args.
             * @member {protos.args.IAzureServiceBusWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @instance
             */
            WriteGroupAzureServiceBusOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupAzureServiceBusOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureServiceBusOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupAzureServiceBusOptions} WriteGroupAzureServiceBusOptions instance
             */
            WriteGroupAzureServiceBusOptions.create = function create(properties) {
                return new WriteGroupAzureServiceBusOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupAzureServiceBusOptions message. Does not implicitly {@link protos.opts.WriteGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureServiceBusOptions} message WriteGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAzureServiceBusOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureServiceBusConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureServiceBusWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupAzureServiceBusOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureServiceBusOptions} message WriteGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAzureServiceBusOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupAzureServiceBusOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupAzureServiceBusOptions} WriteGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAzureServiceBusOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupAzureServiceBusOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureServiceBusConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureServiceBusWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupAzureServiceBusOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupAzureServiceBusOptions} WriteGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAzureServiceBusOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupAzureServiceBusOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupAzureServiceBusOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AzureServiceBusConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AzureServiceBusWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupAzureServiceBusOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupAzureServiceBusOptions} WriteGroupAzureServiceBusOptions
             */
            WriteGroupAzureServiceBusOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupAzureServiceBusOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupAzureServiceBusOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupAzureServiceBusOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureServiceBusConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupAzureServiceBusOptions.args: object expected");
                    message.args = $root.protos.args.AzureServiceBusWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupAzureServiceBusOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.WriteGroupAzureServiceBusOptions} message WriteGroupAzureServiceBusOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupAzureServiceBusOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureServiceBusConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureServiceBusWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupAzureServiceBusOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupAzureServiceBusOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupAzureServiceBusOptions;
        })();

        opts.WriteGroupMQTTOptions = (function() {

            /**
             * Properties of a WriteGroupMQTTOptions.
             * @memberof protos.opts
             * @interface IWriteGroupMQTTOptions
             * @property {protos.args.IMQTTConn|null} [_conn] WriteGroupMQTTOptions _conn
             * @property {protos.args.IMQTTWriteArgs|null} [args] WriteGroupMQTTOptions args
             */

            /**
             * Constructs a new WriteGroupMQTTOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupMQTTOptions.
             * @implements IWriteGroupMQTTOptions
             * @constructor
             * @param {protos.opts.IWriteGroupMQTTOptions=} [properties] Properties to set
             */
            function WriteGroupMQTTOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupMQTTOptions _conn.
             * @member {protos.args.IMQTTConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @instance
             */
            WriteGroupMQTTOptions.prototype._conn = null;

            /**
             * WriteGroupMQTTOptions args.
             * @member {protos.args.IMQTTWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @instance
             */
            WriteGroupMQTTOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupMQTTOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {protos.opts.IWriteGroupMQTTOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupMQTTOptions} WriteGroupMQTTOptions instance
             */
            WriteGroupMQTTOptions.create = function create(properties) {
                return new WriteGroupMQTTOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupMQTTOptions message. Does not implicitly {@link protos.opts.WriteGroupMQTTOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {protos.opts.IWriteGroupMQTTOptions} message WriteGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupMQTTOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MQTTConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MQTTWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupMQTTOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupMQTTOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {protos.opts.IWriteGroupMQTTOptions} message WriteGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupMQTTOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupMQTTOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupMQTTOptions} WriteGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupMQTTOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupMQTTOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MQTTConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MQTTWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupMQTTOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupMQTTOptions} WriteGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupMQTTOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupMQTTOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupMQTTOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.MQTTConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.MQTTWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupMQTTOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupMQTTOptions} WriteGroupMQTTOptions
             */
            WriteGroupMQTTOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupMQTTOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupMQTTOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupMQTTOptions._conn: object expected");
                    message._conn = $root.protos.args.MQTTConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupMQTTOptions.args: object expected");
                    message.args = $root.protos.args.MQTTWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupMQTTOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {protos.opts.WriteGroupMQTTOptions} message WriteGroupMQTTOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupMQTTOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MQTTConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MQTTWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupMQTTOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupMQTTOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupMQTTOptions;
        })();

        opts.WriteGroupGCPPubSubOptions = (function() {

            /**
             * Properties of a WriteGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @interface IWriteGroupGCPPubSubOptions
             * @property {protos.args.IGCPPubSubConn|null} [_conn] WriteGroupGCPPubSubOptions _conn
             * @property {protos.args.IGCPPubSubWriteArgs|null} [args] WriteGroupGCPPubSubOptions args
             */

            /**
             * Constructs a new WriteGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupGCPPubSubOptions.
             * @implements IWriteGroupGCPPubSubOptions
             * @constructor
             * @param {protos.opts.IWriteGroupGCPPubSubOptions=} [properties] Properties to set
             */
            function WriteGroupGCPPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupGCPPubSubOptions _conn.
             * @member {protos.args.IGCPPubSubConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @instance
             */
            WriteGroupGCPPubSubOptions.prototype._conn = null;

            /**
             * WriteGroupGCPPubSubOptions args.
             * @member {protos.args.IGCPPubSubWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @instance
             */
            WriteGroupGCPPubSubOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupGCPPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupGCPPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupGCPPubSubOptions} WriteGroupGCPPubSubOptions instance
             */
            WriteGroupGCPPubSubOptions.create = function create(properties) {
                return new WriteGroupGCPPubSubOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupGCPPubSubOptions message. Does not implicitly {@link protos.opts.WriteGroupGCPPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupGCPPubSubOptions} message WriteGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupGCPPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.GCPPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.GCPPubSubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupGCPPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupGCPPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupGCPPubSubOptions} message WriteGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupGCPPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupGCPPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupGCPPubSubOptions} WriteGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupGCPPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupGCPPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.GCPPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.GCPPubSubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupGCPPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupGCPPubSubOptions} WriteGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupGCPPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupGCPPubSubOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupGCPPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.GCPPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.GCPPubSubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupGCPPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupGCPPubSubOptions} WriteGroupGCPPubSubOptions
             */
            WriteGroupGCPPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupGCPPubSubOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupGCPPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupGCPPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.GCPPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupGCPPubSubOptions.args: object expected");
                    message.args = $root.protos.args.GCPPubSubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupGCPPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.WriteGroupGCPPubSubOptions} message WriteGroupGCPPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupGCPPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.GCPPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.GCPPubSubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupGCPPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupGCPPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupGCPPubSubOptions;
        })();

        opts.WriteGroupKubeMQQueueOptions = (function() {

            /**
             * Properties of a WriteGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @interface IWriteGroupKubeMQQueueOptions
             * @property {protos.args.IKubeMQQueueConn|null} [_conn] WriteGroupKubeMQQueueOptions _conn
             * @property {protos.args.IKubeMQQueueWriteArgs|null} [args] WriteGroupKubeMQQueueOptions args
             */

            /**
             * Constructs a new WriteGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupKubeMQQueueOptions.
             * @implements IWriteGroupKubeMQQueueOptions
             * @constructor
             * @param {protos.opts.IWriteGroupKubeMQQueueOptions=} [properties] Properties to set
             */
            function WriteGroupKubeMQQueueOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupKubeMQQueueOptions _conn.
             * @member {protos.args.IKubeMQQueueConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @instance
             */
            WriteGroupKubeMQQueueOptions.prototype._conn = null;

            /**
             * WriteGroupKubeMQQueueOptions args.
             * @member {protos.args.IKubeMQQueueWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @instance
             */
            WriteGroupKubeMQQueueOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupKubeMQQueueOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IWriteGroupKubeMQQueueOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupKubeMQQueueOptions} WriteGroupKubeMQQueueOptions instance
             */
            WriteGroupKubeMQQueueOptions.create = function create(properties) {
                return new WriteGroupKubeMQQueueOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupKubeMQQueueOptions message. Does not implicitly {@link protos.opts.WriteGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IWriteGroupKubeMQQueueOptions} message WriteGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupKubeMQQueueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KubeMQQueueConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KubeMQQueueWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupKubeMQQueueOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IWriteGroupKubeMQQueueOptions} message WriteGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupKubeMQQueueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupKubeMQQueueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupKubeMQQueueOptions} WriteGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupKubeMQQueueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupKubeMQQueueOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KubeMQQueueConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KubeMQQueueWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupKubeMQQueueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupKubeMQQueueOptions} WriteGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupKubeMQQueueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupKubeMQQueueOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupKubeMQQueueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KubeMQQueueConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KubeMQQueueWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupKubeMQQueueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupKubeMQQueueOptions} WriteGroupKubeMQQueueOptions
             */
            WriteGroupKubeMQQueueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupKubeMQQueueOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupKubeMQQueueOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupKubeMQQueueOptions._conn: object expected");
                    message._conn = $root.protos.args.KubeMQQueueConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupKubeMQQueueOptions.args: object expected");
                    message.args = $root.protos.args.KubeMQQueueWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupKubeMQQueueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.WriteGroupKubeMQQueueOptions} message WriteGroupKubeMQQueueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupKubeMQQueueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KubeMQQueueConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KubeMQQueueWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupKubeMQQueueOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupKubeMQQueueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupKubeMQQueueOptions;
        })();

        opts.WriteGroupAWSKinesisOptions = (function() {

            /**
             * Properties of a WriteGroupAWSKinesisOptions.
             * @memberof protos.opts
             * @interface IWriteGroupAWSKinesisOptions
             * @property {protos.args.IAWSKinesisConn|null} [_conn] WriteGroupAWSKinesisOptions _conn
             * @property {protos.args.IAWSKinesisWriteArgs|null} [args] WriteGroupAWSKinesisOptions args
             */

            /**
             * Constructs a new WriteGroupAWSKinesisOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupAWSKinesisOptions.
             * @implements IWriteGroupAWSKinesisOptions
             * @constructor
             * @param {protos.opts.IWriteGroupAWSKinesisOptions=} [properties] Properties to set
             */
            function WriteGroupAWSKinesisOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupAWSKinesisOptions _conn.
             * @member {protos.args.IAWSKinesisConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @instance
             */
            WriteGroupAWSKinesisOptions.prototype._conn = null;

            /**
             * WriteGroupAWSKinesisOptions args.
             * @member {protos.args.IAWSKinesisWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @instance
             */
            WriteGroupAWSKinesisOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupAWSKinesisOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSKinesisOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupAWSKinesisOptions} WriteGroupAWSKinesisOptions instance
             */
            WriteGroupAWSKinesisOptions.create = function create(properties) {
                return new WriteGroupAWSKinesisOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupAWSKinesisOptions message. Does not implicitly {@link protos.opts.WriteGroupAWSKinesisOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSKinesisOptions} message WriteGroupAWSKinesisOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAWSKinesisOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSKinesisConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSKinesisWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupAWSKinesisOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupAWSKinesisOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSKinesisOptions} message WriteGroupAWSKinesisOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAWSKinesisOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupAWSKinesisOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupAWSKinesisOptions} WriteGroupAWSKinesisOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAWSKinesisOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupAWSKinesisOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSKinesisConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSKinesisWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupAWSKinesisOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupAWSKinesisOptions} WriteGroupAWSKinesisOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAWSKinesisOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupAWSKinesisOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupAWSKinesisOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSKinesisConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSKinesisWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupAWSKinesisOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupAWSKinesisOptions} WriteGroupAWSKinesisOptions
             */
            WriteGroupAWSKinesisOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupAWSKinesisOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupAWSKinesisOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupAWSKinesisOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSKinesisConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupAWSKinesisOptions.args: object expected");
                    message.args = $root.protos.args.AWSKinesisWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupAWSKinesisOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.WriteGroupAWSKinesisOptions} message WriteGroupAWSKinesisOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupAWSKinesisOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSKinesisConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSKinesisWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupAWSKinesisOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupAWSKinesisOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupAWSKinesisOptions;
        })();

        opts.WriteGroupMemphisOptions = (function() {

            /**
             * Properties of a WriteGroupMemphisOptions.
             * @memberof protos.opts
             * @interface IWriteGroupMemphisOptions
             * @property {protos.args.IMemphisConn|null} [_conn] WriteGroupMemphisOptions _conn
             * @property {protos.args.IMemphisWriteArgs|null} [args] WriteGroupMemphisOptions args
             */

            /**
             * Constructs a new WriteGroupMemphisOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupMemphisOptions.
             * @implements IWriteGroupMemphisOptions
             * @constructor
             * @param {protos.opts.IWriteGroupMemphisOptions=} [properties] Properties to set
             */
            function WriteGroupMemphisOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupMemphisOptions _conn.
             * @member {protos.args.IMemphisConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupMemphisOptions
             * @instance
             */
            WriteGroupMemphisOptions.prototype._conn = null;

            /**
             * WriteGroupMemphisOptions args.
             * @member {protos.args.IMemphisWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupMemphisOptions
             * @instance
             */
            WriteGroupMemphisOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupMemphisOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupMemphisOptions
             * @static
             * @param {protos.opts.IWriteGroupMemphisOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupMemphisOptions} WriteGroupMemphisOptions instance
             */
            WriteGroupMemphisOptions.create = function create(properties) {
                return new WriteGroupMemphisOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupMemphisOptions message. Does not implicitly {@link protos.opts.WriteGroupMemphisOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupMemphisOptions
             * @static
             * @param {protos.opts.IWriteGroupMemphisOptions} message WriteGroupMemphisOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupMemphisOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MemphisConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MemphisWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupMemphisOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupMemphisOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupMemphisOptions
             * @static
             * @param {protos.opts.IWriteGroupMemphisOptions} message WriteGroupMemphisOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupMemphisOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupMemphisOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupMemphisOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupMemphisOptions} WriteGroupMemphisOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupMemphisOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupMemphisOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MemphisConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MemphisWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupMemphisOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupMemphisOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupMemphisOptions} WriteGroupMemphisOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupMemphisOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupMemphisOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupMemphisOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupMemphisOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.MemphisConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.MemphisWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupMemphisOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupMemphisOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupMemphisOptions} WriteGroupMemphisOptions
             */
            WriteGroupMemphisOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupMemphisOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupMemphisOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupMemphisOptions._conn: object expected");
                    message._conn = $root.protos.args.MemphisConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupMemphisOptions.args: object expected");
                    message.args = $root.protos.args.MemphisWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupMemphisOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupMemphisOptions
             * @static
             * @param {protos.opts.WriteGroupMemphisOptions} message WriteGroupMemphisOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupMemphisOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MemphisConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MemphisWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupMemphisOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupMemphisOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupMemphisOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupMemphisOptions;
        })();

        return opts;
    })();

    protos.args = (function() {

        /**
         * Namespace args.
         * @memberof protos
         * @namespace
         */
        var args = {};

        args.ActiveMQConn = (function() {

            /**
             * Properties of an ActiveMQConn.
             * @memberof protos.args
             * @interface IActiveMQConn
             * @property {string|null} [address] ActiveMQConn address
             */

            /**
             * Constructs a new ActiveMQConn.
             * @memberof protos.args
             * @classdesc Represents an ActiveMQConn.
             * @implements IActiveMQConn
             * @constructor
             * @param {protos.args.IActiveMQConn=} [properties] Properties to set
             */
            function ActiveMQConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActiveMQConn address.
             * @member {string} address
             * @memberof protos.args.ActiveMQConn
             * @instance
             */
            ActiveMQConn.prototype.address = "";

            /**
             * Creates a new ActiveMQConn instance using the specified properties.
             * @function create
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {protos.args.IActiveMQConn=} [properties] Properties to set
             * @returns {protos.args.ActiveMQConn} ActiveMQConn instance
             */
            ActiveMQConn.create = function create(properties) {
                return new ActiveMQConn(properties);
            };

            /**
             * Encodes the specified ActiveMQConn message. Does not implicitly {@link protos.args.ActiveMQConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {protos.args.IActiveMQConn} message ActiveMQConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                return writer;
            };

            /**
             * Encodes the specified ActiveMQConn message, length delimited. Does not implicitly {@link protos.args.ActiveMQConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {protos.args.IActiveMQConn} message ActiveMQConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ActiveMQConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.ActiveMQConn} ActiveMQConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.ActiveMQConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ActiveMQConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.ActiveMQConn} ActiveMQConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ActiveMQConn message.
             * @function verify
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActiveMQConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                return null;
            };

            /**
             * Creates an ActiveMQConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.ActiveMQConn} ActiveMQConn
             */
            ActiveMQConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.ActiveMQConn)
                    return object;
                var message = new $root.protos.args.ActiveMQConn();
                if (object.address != null)
                    message.address = String(object.address);
                return message;
            };

            /**
             * Creates a plain object from an ActiveMQConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {protos.args.ActiveMQConn} message ActiveMQConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ActiveMQConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.address = "";
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                return object;
            };

            /**
             * Converts this ActiveMQConn to JSON.
             * @function toJSON
             * @memberof protos.args.ActiveMQConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ActiveMQConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ActiveMQConn;
        })();

        args.ActiveMQReadArgs = (function() {

            /**
             * Properties of an ActiveMQReadArgs.
             * @memberof protos.args
             * @interface IActiveMQReadArgs
             * @property {string|null} [topic] ActiveMQReadArgs topic
             * @property {string|null} [queue] ActiveMQReadArgs queue
             */

            /**
             * Constructs a new ActiveMQReadArgs.
             * @memberof protos.args
             * @classdesc Represents an ActiveMQReadArgs.
             * @implements IActiveMQReadArgs
             * @constructor
             * @param {protos.args.IActiveMQReadArgs=} [properties] Properties to set
             */
            function ActiveMQReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActiveMQReadArgs topic.
             * @member {string} topic
             * @memberof protos.args.ActiveMQReadArgs
             * @instance
             */
            ActiveMQReadArgs.prototype.topic = "";

            /**
             * ActiveMQReadArgs queue.
             * @member {string} queue
             * @memberof protos.args.ActiveMQReadArgs
             * @instance
             */
            ActiveMQReadArgs.prototype.queue = "";

            /**
             * Creates a new ActiveMQReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {protos.args.IActiveMQReadArgs=} [properties] Properties to set
             * @returns {protos.args.ActiveMQReadArgs} ActiveMQReadArgs instance
             */
            ActiveMQReadArgs.create = function create(properties) {
                return new ActiveMQReadArgs(properties);
            };

            /**
             * Encodes the specified ActiveMQReadArgs message. Does not implicitly {@link protos.args.ActiveMQReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {protos.args.IActiveMQReadArgs} message ActiveMQReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.queue != null && Object.hasOwnProperty.call(message, "queue"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.queue);
                return writer;
            };

            /**
             * Encodes the specified ActiveMQReadArgs message, length delimited. Does not implicitly {@link protos.args.ActiveMQReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {protos.args.IActiveMQReadArgs} message ActiveMQReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ActiveMQReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.ActiveMQReadArgs} ActiveMQReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.ActiveMQReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.queue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ActiveMQReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.ActiveMQReadArgs} ActiveMQReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ActiveMQReadArgs message.
             * @function verify
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActiveMQReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.queue != null && message.hasOwnProperty("queue"))
                    if (!$util.isString(message.queue))
                        return "queue: string expected";
                return null;
            };

            /**
             * Creates an ActiveMQReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.ActiveMQReadArgs} ActiveMQReadArgs
             */
            ActiveMQReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.ActiveMQReadArgs)
                    return object;
                var message = new $root.protos.args.ActiveMQReadArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.queue != null)
                    message.queue = String(object.queue);
                return message;
            };

            /**
             * Creates a plain object from an ActiveMQReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {protos.args.ActiveMQReadArgs} message ActiveMQReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ActiveMQReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.queue = "";
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.queue != null && message.hasOwnProperty("queue"))
                    object.queue = message.queue;
                return object;
            };

            /**
             * Converts this ActiveMQReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.ActiveMQReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ActiveMQReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ActiveMQReadArgs;
        })();

        args.ActiveMQWriteArgs = (function() {

            /**
             * Properties of an ActiveMQWriteArgs.
             * @memberof protos.args
             * @interface IActiveMQWriteArgs
             * @property {string|null} [topic] ActiveMQWriteArgs topic
             * @property {string|null} [queue] ActiveMQWriteArgs queue
             */

            /**
             * Constructs a new ActiveMQWriteArgs.
             * @memberof protos.args
             * @classdesc Represents an ActiveMQWriteArgs.
             * @implements IActiveMQWriteArgs
             * @constructor
             * @param {protos.args.IActiveMQWriteArgs=} [properties] Properties to set
             */
            function ActiveMQWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActiveMQWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.ActiveMQWriteArgs
             * @instance
             */
            ActiveMQWriteArgs.prototype.topic = "";

            /**
             * ActiveMQWriteArgs queue.
             * @member {string} queue
             * @memberof protos.args.ActiveMQWriteArgs
             * @instance
             */
            ActiveMQWriteArgs.prototype.queue = "";

            /**
             * Creates a new ActiveMQWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {protos.args.IActiveMQWriteArgs=} [properties] Properties to set
             * @returns {protos.args.ActiveMQWriteArgs} ActiveMQWriteArgs instance
             */
            ActiveMQWriteArgs.create = function create(properties) {
                return new ActiveMQWriteArgs(properties);
            };

            /**
             * Encodes the specified ActiveMQWriteArgs message. Does not implicitly {@link protos.args.ActiveMQWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {protos.args.IActiveMQWriteArgs} message ActiveMQWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.queue != null && Object.hasOwnProperty.call(message, "queue"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.queue);
                return writer;
            };

            /**
             * Encodes the specified ActiveMQWriteArgs message, length delimited. Does not implicitly {@link protos.args.ActiveMQWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {protos.args.IActiveMQWriteArgs} message ActiveMQWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ActiveMQWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.ActiveMQWriteArgs} ActiveMQWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.ActiveMQWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.queue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ActiveMQWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.ActiveMQWriteArgs} ActiveMQWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ActiveMQWriteArgs message.
             * @function verify
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActiveMQWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.queue != null && message.hasOwnProperty("queue"))
                    if (!$util.isString(message.queue))
                        return "queue: string expected";
                return null;
            };

            /**
             * Creates an ActiveMQWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.ActiveMQWriteArgs} ActiveMQWriteArgs
             */
            ActiveMQWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.ActiveMQWriteArgs)
                    return object;
                var message = new $root.protos.args.ActiveMQWriteArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.queue != null)
                    message.queue = String(object.queue);
                return message;
            };

            /**
             * Creates a plain object from an ActiveMQWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {protos.args.ActiveMQWriteArgs} message ActiveMQWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ActiveMQWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.queue = "";
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.queue != null && message.hasOwnProperty("queue"))
                    object.queue = message.queue;
                return object;
            };

            /**
             * Converts this ActiveMQWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.ActiveMQWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ActiveMQWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ActiveMQWriteArgs;
        })();

        args.AWSKinesisConn = (function() {

            /**
             * Properties of a AWSKinesisConn.
             * @memberof protos.args
             * @interface IAWSKinesisConn
             * @property {string|null} [awsRegion] AWSKinesisConn awsRegion
             * @property {string|null} [awsAccessKeyId] AWSKinesisConn awsAccessKeyId
             * @property {string|null} [awsSecretAccessKey] AWSKinesisConn awsSecretAccessKey
             * @property {string|null} [awsProfile] AWSKinesisConn awsProfile
             */

            /**
             * Constructs a new AWSKinesisConn.
             * @memberof protos.args
             * @classdesc Represents a AWSKinesisConn.
             * @implements IAWSKinesisConn
             * @constructor
             * @param {protos.args.IAWSKinesisConn=} [properties] Properties to set
             */
            function AWSKinesisConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSKinesisConn awsRegion.
             * @member {string} awsRegion
             * @memberof protos.args.AWSKinesisConn
             * @instance
             */
            AWSKinesisConn.prototype.awsRegion = "";

            /**
             * AWSKinesisConn awsAccessKeyId.
             * @member {string} awsAccessKeyId
             * @memberof protos.args.AWSKinesisConn
             * @instance
             */
            AWSKinesisConn.prototype.awsAccessKeyId = "";

            /**
             * AWSKinesisConn awsSecretAccessKey.
             * @member {string} awsSecretAccessKey
             * @memberof protos.args.AWSKinesisConn
             * @instance
             */
            AWSKinesisConn.prototype.awsSecretAccessKey = "";

            /**
             * AWSKinesisConn awsProfile.
             * @member {string} awsProfile
             * @memberof protos.args.AWSKinesisConn
             * @instance
             */
            AWSKinesisConn.prototype.awsProfile = "";

            /**
             * Creates a new AWSKinesisConn instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSKinesisConn
             * @static
             * @param {protos.args.IAWSKinesisConn=} [properties] Properties to set
             * @returns {protos.args.AWSKinesisConn} AWSKinesisConn instance
             */
            AWSKinesisConn.create = function create(properties) {
                return new AWSKinesisConn(properties);
            };

            /**
             * Encodes the specified AWSKinesisConn message. Does not implicitly {@link protos.args.AWSKinesisConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSKinesisConn
             * @static
             * @param {protos.args.IAWSKinesisConn} message AWSKinesisConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSKinesisConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.awsRegion != null && Object.hasOwnProperty.call(message, "awsRegion"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.awsRegion);
                if (message.awsAccessKeyId != null && Object.hasOwnProperty.call(message, "awsAccessKeyId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.awsAccessKeyId);
                if (message.awsSecretAccessKey != null && Object.hasOwnProperty.call(message, "awsSecretAccessKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.awsSecretAccessKey);
                if (message.awsProfile != null && Object.hasOwnProperty.call(message, "awsProfile"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.awsProfile);
                return writer;
            };

            /**
             * Encodes the specified AWSKinesisConn message, length delimited. Does not implicitly {@link protos.args.AWSKinesisConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSKinesisConn
             * @static
             * @param {protos.args.IAWSKinesisConn} message AWSKinesisConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSKinesisConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSKinesisConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSKinesisConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSKinesisConn} AWSKinesisConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSKinesisConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSKinesisConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.awsRegion = reader.string();
                        break;
                    case 2:
                        message.awsAccessKeyId = reader.string();
                        break;
                    case 3:
                        message.awsSecretAccessKey = reader.string();
                        break;
                    case 4:
                        message.awsProfile = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSKinesisConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSKinesisConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSKinesisConn} AWSKinesisConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSKinesisConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSKinesisConn message.
             * @function verify
             * @memberof protos.args.AWSKinesisConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSKinesisConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.awsRegion != null && message.hasOwnProperty("awsRegion"))
                    if (!$util.isString(message.awsRegion))
                        return "awsRegion: string expected";
                if (message.awsAccessKeyId != null && message.hasOwnProperty("awsAccessKeyId"))
                    if (!$util.isString(message.awsAccessKeyId))
                        return "awsAccessKeyId: string expected";
                if (message.awsSecretAccessKey != null && message.hasOwnProperty("awsSecretAccessKey"))
                    if (!$util.isString(message.awsSecretAccessKey))
                        return "awsSecretAccessKey: string expected";
                if (message.awsProfile != null && message.hasOwnProperty("awsProfile"))
                    if (!$util.isString(message.awsProfile))
                        return "awsProfile: string expected";
                return null;
            };

            /**
             * Creates a AWSKinesisConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSKinesisConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSKinesisConn} AWSKinesisConn
             */
            AWSKinesisConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSKinesisConn)
                    return object;
                var message = new $root.protos.args.AWSKinesisConn();
                if (object.awsRegion != null)
                    message.awsRegion = String(object.awsRegion);
                if (object.awsAccessKeyId != null)
                    message.awsAccessKeyId = String(object.awsAccessKeyId);
                if (object.awsSecretAccessKey != null)
                    message.awsSecretAccessKey = String(object.awsSecretAccessKey);
                if (object.awsProfile != null)
                    message.awsProfile = String(object.awsProfile);
                return message;
            };

            /**
             * Creates a plain object from a AWSKinesisConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSKinesisConn
             * @static
             * @param {protos.args.AWSKinesisConn} message AWSKinesisConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSKinesisConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.awsRegion = "";
                    object.awsAccessKeyId = "";
                    object.awsSecretAccessKey = "";
                    object.awsProfile = "";
                }
                if (message.awsRegion != null && message.hasOwnProperty("awsRegion"))
                    object.awsRegion = message.awsRegion;
                if (message.awsAccessKeyId != null && message.hasOwnProperty("awsAccessKeyId"))
                    object.awsAccessKeyId = message.awsAccessKeyId;
                if (message.awsSecretAccessKey != null && message.hasOwnProperty("awsSecretAccessKey"))
                    object.awsSecretAccessKey = message.awsSecretAccessKey;
                if (message.awsProfile != null && message.hasOwnProperty("awsProfile"))
                    object.awsProfile = message.awsProfile;
                return object;
            };

            /**
             * Converts this AWSKinesisConn to JSON.
             * @function toJSON
             * @memberof protos.args.AWSKinesisConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSKinesisConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSKinesisConn;
        })();

        args.AWSKinesisReadArgs = (function() {

            /**
             * Properties of a AWSKinesisReadArgs.
             * @memberof protos.args
             * @interface IAWSKinesisReadArgs
             * @property {string|null} [stream] AWSKinesisReadArgs stream
             * @property {string|null} [shard] AWSKinesisReadArgs shard
             * @property {number|Long|null} [maxRecords] AWSKinesisReadArgs maxRecords
             * @property {number|Long|null} [readFromTimestamp] AWSKinesisReadArgs readFromTimestamp
             * @property {string|null} [readSequenceNumber] AWSKinesisReadArgs readSequenceNumber
             * @property {string|null} [readAfterSequenceNumber] AWSKinesisReadArgs readAfterSequenceNumber
             * @property {boolean|null} [readTrimHorizon] AWSKinesisReadArgs readTrimHorizon
             * @property {boolean|null} [readLatest] AWSKinesisReadArgs readLatest
             */

            /**
             * Constructs a new AWSKinesisReadArgs.
             * @memberof protos.args
             * @classdesc Represents a AWSKinesisReadArgs.
             * @implements IAWSKinesisReadArgs
             * @constructor
             * @param {protos.args.IAWSKinesisReadArgs=} [properties] Properties to set
             */
            function AWSKinesisReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSKinesisReadArgs stream.
             * @member {string} stream
             * @memberof protos.args.AWSKinesisReadArgs
             * @instance
             */
            AWSKinesisReadArgs.prototype.stream = "";

            /**
             * AWSKinesisReadArgs shard.
             * @member {string} shard
             * @memberof protos.args.AWSKinesisReadArgs
             * @instance
             */
            AWSKinesisReadArgs.prototype.shard = "";

            /**
             * AWSKinesisReadArgs maxRecords.
             * @member {number|Long} maxRecords
             * @memberof protos.args.AWSKinesisReadArgs
             * @instance
             */
            AWSKinesisReadArgs.prototype.maxRecords = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AWSKinesisReadArgs readFromTimestamp.
             * @member {number|Long} readFromTimestamp
             * @memberof protos.args.AWSKinesisReadArgs
             * @instance
             */
            AWSKinesisReadArgs.prototype.readFromTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AWSKinesisReadArgs readSequenceNumber.
             * @member {string} readSequenceNumber
             * @memberof protos.args.AWSKinesisReadArgs
             * @instance
             */
            AWSKinesisReadArgs.prototype.readSequenceNumber = "";

            /**
             * AWSKinesisReadArgs readAfterSequenceNumber.
             * @member {string} readAfterSequenceNumber
             * @memberof protos.args.AWSKinesisReadArgs
             * @instance
             */
            AWSKinesisReadArgs.prototype.readAfterSequenceNumber = "";

            /**
             * AWSKinesisReadArgs readTrimHorizon.
             * @member {boolean} readTrimHorizon
             * @memberof protos.args.AWSKinesisReadArgs
             * @instance
             */
            AWSKinesisReadArgs.prototype.readTrimHorizon = false;

            /**
             * AWSKinesisReadArgs readLatest.
             * @member {boolean} readLatest
             * @memberof protos.args.AWSKinesisReadArgs
             * @instance
             */
            AWSKinesisReadArgs.prototype.readLatest = false;

            /**
             * Creates a new AWSKinesisReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSKinesisReadArgs
             * @static
             * @param {protos.args.IAWSKinesisReadArgs=} [properties] Properties to set
             * @returns {protos.args.AWSKinesisReadArgs} AWSKinesisReadArgs instance
             */
            AWSKinesisReadArgs.create = function create(properties) {
                return new AWSKinesisReadArgs(properties);
            };

            /**
             * Encodes the specified AWSKinesisReadArgs message. Does not implicitly {@link protos.args.AWSKinesisReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSKinesisReadArgs
             * @static
             * @param {protos.args.IAWSKinesisReadArgs} message AWSKinesisReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSKinesisReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stream);
                if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.shard);
                if (message.maxRecords != null && Object.hasOwnProperty.call(message, "maxRecords"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.maxRecords);
                if (message.readFromTimestamp != null && Object.hasOwnProperty.call(message, "readFromTimestamp"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.readFromTimestamp);
                if (message.readSequenceNumber != null && Object.hasOwnProperty.call(message, "readSequenceNumber"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.readSequenceNumber);
                if (message.readAfterSequenceNumber != null && Object.hasOwnProperty.call(message, "readAfterSequenceNumber"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.readAfterSequenceNumber);
                if (message.readTrimHorizon != null && Object.hasOwnProperty.call(message, "readTrimHorizon"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.readTrimHorizon);
                if (message.readLatest != null && Object.hasOwnProperty.call(message, "readLatest"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.readLatest);
                return writer;
            };

            /**
             * Encodes the specified AWSKinesisReadArgs message, length delimited. Does not implicitly {@link protos.args.AWSKinesisReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSKinesisReadArgs
             * @static
             * @param {protos.args.IAWSKinesisReadArgs} message AWSKinesisReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSKinesisReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSKinesisReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSKinesisReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSKinesisReadArgs} AWSKinesisReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSKinesisReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSKinesisReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stream = reader.string();
                        break;
                    case 2:
                        message.shard = reader.string();
                        break;
                    case 3:
                        message.maxRecords = reader.int64();
                        break;
                    case 4:
                        message.readFromTimestamp = reader.int64();
                        break;
                    case 5:
                        message.readSequenceNumber = reader.string();
                        break;
                    case 6:
                        message.readAfterSequenceNumber = reader.string();
                        break;
                    case 7:
                        message.readTrimHorizon = reader.bool();
                        break;
                    case 8:
                        message.readLatest = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSKinesisReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSKinesisReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSKinesisReadArgs} AWSKinesisReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSKinesisReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSKinesisReadArgs message.
             * @function verify
             * @memberof protos.args.AWSKinesisReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSKinesisReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isString(message.stream))
                        return "stream: string expected";
                if (message.shard != null && message.hasOwnProperty("shard"))
                    if (!$util.isString(message.shard))
                        return "shard: string expected";
                if (message.maxRecords != null && message.hasOwnProperty("maxRecords"))
                    if (!$util.isInteger(message.maxRecords) && !(message.maxRecords && $util.isInteger(message.maxRecords.low) && $util.isInteger(message.maxRecords.high)))
                        return "maxRecords: integer|Long expected";
                if (message.readFromTimestamp != null && message.hasOwnProperty("readFromTimestamp"))
                    if (!$util.isInteger(message.readFromTimestamp) && !(message.readFromTimestamp && $util.isInteger(message.readFromTimestamp.low) && $util.isInteger(message.readFromTimestamp.high)))
                        return "readFromTimestamp: integer|Long expected";
                if (message.readSequenceNumber != null && message.hasOwnProperty("readSequenceNumber"))
                    if (!$util.isString(message.readSequenceNumber))
                        return "readSequenceNumber: string expected";
                if (message.readAfterSequenceNumber != null && message.hasOwnProperty("readAfterSequenceNumber"))
                    if (!$util.isString(message.readAfterSequenceNumber))
                        return "readAfterSequenceNumber: string expected";
                if (message.readTrimHorizon != null && message.hasOwnProperty("readTrimHorizon"))
                    if (typeof message.readTrimHorizon !== "boolean")
                        return "readTrimHorizon: boolean expected";
                if (message.readLatest != null && message.hasOwnProperty("readLatest"))
                    if (typeof message.readLatest !== "boolean")
                        return "readLatest: boolean expected";
                return null;
            };

            /**
             * Creates a AWSKinesisReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSKinesisReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSKinesisReadArgs} AWSKinesisReadArgs
             */
            AWSKinesisReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSKinesisReadArgs)
                    return object;
                var message = new $root.protos.args.AWSKinesisReadArgs();
                if (object.stream != null)
                    message.stream = String(object.stream);
                if (object.shard != null)
                    message.shard = String(object.shard);
                if (object.maxRecords != null)
                    if ($util.Long)
                        (message.maxRecords = $util.Long.fromValue(object.maxRecords)).unsigned = false;
                    else if (typeof object.maxRecords === "string")
                        message.maxRecords = parseInt(object.maxRecords, 10);
                    else if (typeof object.maxRecords === "number")
                        message.maxRecords = object.maxRecords;
                    else if (typeof object.maxRecords === "object")
                        message.maxRecords = new $util.LongBits(object.maxRecords.low >>> 0, object.maxRecords.high >>> 0).toNumber();
                if (object.readFromTimestamp != null)
                    if ($util.Long)
                        (message.readFromTimestamp = $util.Long.fromValue(object.readFromTimestamp)).unsigned = false;
                    else if (typeof object.readFromTimestamp === "string")
                        message.readFromTimestamp = parseInt(object.readFromTimestamp, 10);
                    else if (typeof object.readFromTimestamp === "number")
                        message.readFromTimestamp = object.readFromTimestamp;
                    else if (typeof object.readFromTimestamp === "object")
                        message.readFromTimestamp = new $util.LongBits(object.readFromTimestamp.low >>> 0, object.readFromTimestamp.high >>> 0).toNumber();
                if (object.readSequenceNumber != null)
                    message.readSequenceNumber = String(object.readSequenceNumber);
                if (object.readAfterSequenceNumber != null)
                    message.readAfterSequenceNumber = String(object.readAfterSequenceNumber);
                if (object.readTrimHorizon != null)
                    message.readTrimHorizon = Boolean(object.readTrimHorizon);
                if (object.readLatest != null)
                    message.readLatest = Boolean(object.readLatest);
                return message;
            };

            /**
             * Creates a plain object from a AWSKinesisReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSKinesisReadArgs
             * @static
             * @param {protos.args.AWSKinesisReadArgs} message AWSKinesisReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSKinesisReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.stream = "";
                    object.shard = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.maxRecords = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.maxRecords = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.readFromTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.readFromTimestamp = options.longs === String ? "0" : 0;
                    object.readSequenceNumber = "";
                    object.readAfterSequenceNumber = "";
                    object.readTrimHorizon = false;
                    object.readLatest = false;
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                if (message.shard != null && message.hasOwnProperty("shard"))
                    object.shard = message.shard;
                if (message.maxRecords != null && message.hasOwnProperty("maxRecords"))
                    if (typeof message.maxRecords === "number")
                        object.maxRecords = options.longs === String ? String(message.maxRecords) : message.maxRecords;
                    else
                        object.maxRecords = options.longs === String ? $util.Long.prototype.toString.call(message.maxRecords) : options.longs === Number ? new $util.LongBits(message.maxRecords.low >>> 0, message.maxRecords.high >>> 0).toNumber() : message.maxRecords;
                if (message.readFromTimestamp != null && message.hasOwnProperty("readFromTimestamp"))
                    if (typeof message.readFromTimestamp === "number")
                        object.readFromTimestamp = options.longs === String ? String(message.readFromTimestamp) : message.readFromTimestamp;
                    else
                        object.readFromTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.readFromTimestamp) : options.longs === Number ? new $util.LongBits(message.readFromTimestamp.low >>> 0, message.readFromTimestamp.high >>> 0).toNumber() : message.readFromTimestamp;
                if (message.readSequenceNumber != null && message.hasOwnProperty("readSequenceNumber"))
                    object.readSequenceNumber = message.readSequenceNumber;
                if (message.readAfterSequenceNumber != null && message.hasOwnProperty("readAfterSequenceNumber"))
                    object.readAfterSequenceNumber = message.readAfterSequenceNumber;
                if (message.readTrimHorizon != null && message.hasOwnProperty("readTrimHorizon"))
                    object.readTrimHorizon = message.readTrimHorizon;
                if (message.readLatest != null && message.hasOwnProperty("readLatest"))
                    object.readLatest = message.readLatest;
                return object;
            };

            /**
             * Converts this AWSKinesisReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AWSKinesisReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSKinesisReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSKinesisReadArgs;
        })();

        args.AWSKinesisWriteArgs = (function() {

            /**
             * Properties of a AWSKinesisWriteArgs.
             * @memberof protos.args
             * @interface IAWSKinesisWriteArgs
             * @property {string|null} [stream] AWSKinesisWriteArgs stream
             * @property {string|null} [partitionKey] AWSKinesisWriteArgs partitionKey
             * @property {string|null} [sequenceNumber] AWSKinesisWriteArgs sequenceNumber
             */

            /**
             * Constructs a new AWSKinesisWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a AWSKinesisWriteArgs.
             * @implements IAWSKinesisWriteArgs
             * @constructor
             * @param {protos.args.IAWSKinesisWriteArgs=} [properties] Properties to set
             */
            function AWSKinesisWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSKinesisWriteArgs stream.
             * @member {string} stream
             * @memberof protos.args.AWSKinesisWriteArgs
             * @instance
             */
            AWSKinesisWriteArgs.prototype.stream = "";

            /**
             * AWSKinesisWriteArgs partitionKey.
             * @member {string} partitionKey
             * @memberof protos.args.AWSKinesisWriteArgs
             * @instance
             */
            AWSKinesisWriteArgs.prototype.partitionKey = "";

            /**
             * AWSKinesisWriteArgs sequenceNumber.
             * @member {string} sequenceNumber
             * @memberof protos.args.AWSKinesisWriteArgs
             * @instance
             */
            AWSKinesisWriteArgs.prototype.sequenceNumber = "";

            /**
             * Creates a new AWSKinesisWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSKinesisWriteArgs
             * @static
             * @param {protos.args.IAWSKinesisWriteArgs=} [properties] Properties to set
             * @returns {protos.args.AWSKinesisWriteArgs} AWSKinesisWriteArgs instance
             */
            AWSKinesisWriteArgs.create = function create(properties) {
                return new AWSKinesisWriteArgs(properties);
            };

            /**
             * Encodes the specified AWSKinesisWriteArgs message. Does not implicitly {@link protos.args.AWSKinesisWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSKinesisWriteArgs
             * @static
             * @param {protos.args.IAWSKinesisWriteArgs} message AWSKinesisWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSKinesisWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stream);
                if (message.partitionKey != null && Object.hasOwnProperty.call(message, "partitionKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.partitionKey);
                if (message.sequenceNumber != null && Object.hasOwnProperty.call(message, "sequenceNumber"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.sequenceNumber);
                return writer;
            };

            /**
             * Encodes the specified AWSKinesisWriteArgs message, length delimited. Does not implicitly {@link protos.args.AWSKinesisWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSKinesisWriteArgs
             * @static
             * @param {protos.args.IAWSKinesisWriteArgs} message AWSKinesisWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSKinesisWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSKinesisWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSKinesisWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSKinesisWriteArgs} AWSKinesisWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSKinesisWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSKinesisWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stream = reader.string();
                        break;
                    case 2:
                        message.partitionKey = reader.string();
                        break;
                    case 3:
                        message.sequenceNumber = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSKinesisWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSKinesisWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSKinesisWriteArgs} AWSKinesisWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSKinesisWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSKinesisWriteArgs message.
             * @function verify
             * @memberof protos.args.AWSKinesisWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSKinesisWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isString(message.stream))
                        return "stream: string expected";
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    if (!$util.isString(message.partitionKey))
                        return "partitionKey: string expected";
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    if (!$util.isString(message.sequenceNumber))
                        return "sequenceNumber: string expected";
                return null;
            };

            /**
             * Creates a AWSKinesisWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSKinesisWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSKinesisWriteArgs} AWSKinesisWriteArgs
             */
            AWSKinesisWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSKinesisWriteArgs)
                    return object;
                var message = new $root.protos.args.AWSKinesisWriteArgs();
                if (object.stream != null)
                    message.stream = String(object.stream);
                if (object.partitionKey != null)
                    message.partitionKey = String(object.partitionKey);
                if (object.sequenceNumber != null)
                    message.sequenceNumber = String(object.sequenceNumber);
                return message;
            };

            /**
             * Creates a plain object from a AWSKinesisWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSKinesisWriteArgs
             * @static
             * @param {protos.args.AWSKinesisWriteArgs} message AWSKinesisWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSKinesisWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.stream = "";
                    object.partitionKey = "";
                    object.sequenceNumber = "";
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    object.partitionKey = message.partitionKey;
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    object.sequenceNumber = message.sequenceNumber;
                return object;
            };

            /**
             * Converts this AWSKinesisWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AWSKinesisWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSKinesisWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSKinesisWriteArgs;
        })();

        args.AWSSNSConn = (function() {

            /**
             * Properties of a AWSSNSConn.
             * @memberof protos.args
             * @interface IAWSSNSConn
             * @property {string|null} [awsRegion] AWSSNSConn awsRegion
             * @property {string|null} [awsAccessKeyId] AWSSNSConn awsAccessKeyId
             * @property {string|null} [awsSecretAccessKey] AWSSNSConn awsSecretAccessKey
             * @property {string|null} [awsProfile] AWSSNSConn awsProfile
             */

            /**
             * Constructs a new AWSSNSConn.
             * @memberof protos.args
             * @classdesc Represents a AWSSNSConn.
             * @implements IAWSSNSConn
             * @constructor
             * @param {protos.args.IAWSSNSConn=} [properties] Properties to set
             */
            function AWSSNSConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSNSConn awsRegion.
             * @member {string} awsRegion
             * @memberof protos.args.AWSSNSConn
             * @instance
             */
            AWSSNSConn.prototype.awsRegion = "";

            /**
             * AWSSNSConn awsAccessKeyId.
             * @member {string} awsAccessKeyId
             * @memberof protos.args.AWSSNSConn
             * @instance
             */
            AWSSNSConn.prototype.awsAccessKeyId = "";

            /**
             * AWSSNSConn awsSecretAccessKey.
             * @member {string} awsSecretAccessKey
             * @memberof protos.args.AWSSNSConn
             * @instance
             */
            AWSSNSConn.prototype.awsSecretAccessKey = "";

            /**
             * AWSSNSConn awsProfile.
             * @member {string} awsProfile
             * @memberof protos.args.AWSSNSConn
             * @instance
             */
            AWSSNSConn.prototype.awsProfile = "";

            /**
             * Creates a new AWSSNSConn instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {protos.args.IAWSSNSConn=} [properties] Properties to set
             * @returns {protos.args.AWSSNSConn} AWSSNSConn instance
             */
            AWSSNSConn.create = function create(properties) {
                return new AWSSNSConn(properties);
            };

            /**
             * Encodes the specified AWSSNSConn message. Does not implicitly {@link protos.args.AWSSNSConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {protos.args.IAWSSNSConn} message AWSSNSConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSNSConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.awsRegion != null && Object.hasOwnProperty.call(message, "awsRegion"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.awsRegion);
                if (message.awsAccessKeyId != null && Object.hasOwnProperty.call(message, "awsAccessKeyId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.awsAccessKeyId);
                if (message.awsSecretAccessKey != null && Object.hasOwnProperty.call(message, "awsSecretAccessKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.awsSecretAccessKey);
                if (message.awsProfile != null && Object.hasOwnProperty.call(message, "awsProfile"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.awsProfile);
                return writer;
            };

            /**
             * Encodes the specified AWSSNSConn message, length delimited. Does not implicitly {@link protos.args.AWSSNSConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {protos.args.IAWSSNSConn} message AWSSNSConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSNSConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSNSConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSNSConn} AWSSNSConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSNSConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSNSConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.awsRegion = reader.string();
                        break;
                    case 2:
                        message.awsAccessKeyId = reader.string();
                        break;
                    case 3:
                        message.awsSecretAccessKey = reader.string();
                        break;
                    case 4:
                        message.awsProfile = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSNSConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSNSConn} AWSSNSConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSNSConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSNSConn message.
             * @function verify
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSNSConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.awsRegion != null && message.hasOwnProperty("awsRegion"))
                    if (!$util.isString(message.awsRegion))
                        return "awsRegion: string expected";
                if (message.awsAccessKeyId != null && message.hasOwnProperty("awsAccessKeyId"))
                    if (!$util.isString(message.awsAccessKeyId))
                        return "awsAccessKeyId: string expected";
                if (message.awsSecretAccessKey != null && message.hasOwnProperty("awsSecretAccessKey"))
                    if (!$util.isString(message.awsSecretAccessKey))
                        return "awsSecretAccessKey: string expected";
                if (message.awsProfile != null && message.hasOwnProperty("awsProfile"))
                    if (!$util.isString(message.awsProfile))
                        return "awsProfile: string expected";
                return null;
            };

            /**
             * Creates a AWSSNSConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSNSConn} AWSSNSConn
             */
            AWSSNSConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSNSConn)
                    return object;
                var message = new $root.protos.args.AWSSNSConn();
                if (object.awsRegion != null)
                    message.awsRegion = String(object.awsRegion);
                if (object.awsAccessKeyId != null)
                    message.awsAccessKeyId = String(object.awsAccessKeyId);
                if (object.awsSecretAccessKey != null)
                    message.awsSecretAccessKey = String(object.awsSecretAccessKey);
                if (object.awsProfile != null)
                    message.awsProfile = String(object.awsProfile);
                return message;
            };

            /**
             * Creates a plain object from a AWSSNSConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {protos.args.AWSSNSConn} message AWSSNSConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSNSConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.awsRegion = "";
                    object.awsAccessKeyId = "";
                    object.awsSecretAccessKey = "";
                    object.awsProfile = "";
                }
                if (message.awsRegion != null && message.hasOwnProperty("awsRegion"))
                    object.awsRegion = message.awsRegion;
                if (message.awsAccessKeyId != null && message.hasOwnProperty("awsAccessKeyId"))
                    object.awsAccessKeyId = message.awsAccessKeyId;
                if (message.awsSecretAccessKey != null && message.hasOwnProperty("awsSecretAccessKey"))
                    object.awsSecretAccessKey = message.awsSecretAccessKey;
                if (message.awsProfile != null && message.hasOwnProperty("awsProfile"))
                    object.awsProfile = message.awsProfile;
                return object;
            };

            /**
             * Converts this AWSSNSConn to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSNSConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSNSConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSNSConn;
        })();

        args.AWSSNSWriteArgs = (function() {

            /**
             * Properties of a AWSSNSWriteArgs.
             * @memberof protos.args
             * @interface IAWSSNSWriteArgs
             * @property {string|null} [topic] AWSSNSWriteArgs topic
             */

            /**
             * Constructs a new AWSSNSWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a AWSSNSWriteArgs.
             * @implements IAWSSNSWriteArgs
             * @constructor
             * @param {protos.args.IAWSSNSWriteArgs=} [properties] Properties to set
             */
            function AWSSNSWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSNSWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.AWSSNSWriteArgs
             * @instance
             */
            AWSSNSWriteArgs.prototype.topic = "";

            /**
             * Creates a new AWSSNSWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {protos.args.IAWSSNSWriteArgs=} [properties] Properties to set
             * @returns {protos.args.AWSSNSWriteArgs} AWSSNSWriteArgs instance
             */
            AWSSNSWriteArgs.create = function create(properties) {
                return new AWSSNSWriteArgs(properties);
            };

            /**
             * Encodes the specified AWSSNSWriteArgs message. Does not implicitly {@link protos.args.AWSSNSWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {protos.args.IAWSSNSWriteArgs} message AWSSNSWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSNSWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                return writer;
            };

            /**
             * Encodes the specified AWSSNSWriteArgs message, length delimited. Does not implicitly {@link protos.args.AWSSNSWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {protos.args.IAWSSNSWriteArgs} message AWSSNSWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSNSWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSNSWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSNSWriteArgs} AWSSNSWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSNSWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSNSWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSNSWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSNSWriteArgs} AWSSNSWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSNSWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSNSWriteArgs message.
             * @function verify
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSNSWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                return null;
            };

            /**
             * Creates a AWSSNSWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSNSWriteArgs} AWSSNSWriteArgs
             */
            AWSSNSWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSNSWriteArgs)
                    return object;
                var message = new $root.protos.args.AWSSNSWriteArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                return message;
            };

            /**
             * Creates a plain object from a AWSSNSWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {protos.args.AWSSNSWriteArgs} message AWSSNSWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSNSWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.topic = "";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                return object;
            };

            /**
             * Converts this AWSSNSWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSNSWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSNSWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSNSWriteArgs;
        })();

        args.AWSSQSConn = (function() {

            /**
             * Properties of a AWSSQSConn.
             * @memberof protos.args
             * @interface IAWSSQSConn
             * @property {string|null} [awsRegion] AWSSQSConn awsRegion
             * @property {string|null} [awsAccessKeyId] AWSSQSConn awsAccessKeyId
             * @property {string|null} [awsSecretAccessKey] AWSSQSConn awsSecretAccessKey
             * @property {string|null} [awsProfile] AWSSQSConn awsProfile
             */

            /**
             * Constructs a new AWSSQSConn.
             * @memberof protos.args
             * @classdesc Represents a AWSSQSConn.
             * @implements IAWSSQSConn
             * @constructor
             * @param {protos.args.IAWSSQSConn=} [properties] Properties to set
             */
            function AWSSQSConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSQSConn awsRegion.
             * @member {string} awsRegion
             * @memberof protos.args.AWSSQSConn
             * @instance
             */
            AWSSQSConn.prototype.awsRegion = "";

            /**
             * AWSSQSConn awsAccessKeyId.
             * @member {string} awsAccessKeyId
             * @memberof protos.args.AWSSQSConn
             * @instance
             */
            AWSSQSConn.prototype.awsAccessKeyId = "";

            /**
             * AWSSQSConn awsSecretAccessKey.
             * @member {string} awsSecretAccessKey
             * @memberof protos.args.AWSSQSConn
             * @instance
             */
            AWSSQSConn.prototype.awsSecretAccessKey = "";

            /**
             * AWSSQSConn awsProfile.
             * @member {string} awsProfile
             * @memberof protos.args.AWSSQSConn
             * @instance
             */
            AWSSQSConn.prototype.awsProfile = "";

            /**
             * Creates a new AWSSQSConn instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {protos.args.IAWSSQSConn=} [properties] Properties to set
             * @returns {protos.args.AWSSQSConn} AWSSQSConn instance
             */
            AWSSQSConn.create = function create(properties) {
                return new AWSSQSConn(properties);
            };

            /**
             * Encodes the specified AWSSQSConn message. Does not implicitly {@link protos.args.AWSSQSConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {protos.args.IAWSSQSConn} message AWSSQSConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.awsRegion != null && Object.hasOwnProperty.call(message, "awsRegion"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.awsRegion);
                if (message.awsAccessKeyId != null && Object.hasOwnProperty.call(message, "awsAccessKeyId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.awsAccessKeyId);
                if (message.awsSecretAccessKey != null && Object.hasOwnProperty.call(message, "awsSecretAccessKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.awsSecretAccessKey);
                if (message.awsProfile != null && Object.hasOwnProperty.call(message, "awsProfile"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.awsProfile);
                return writer;
            };

            /**
             * Encodes the specified AWSSQSConn message, length delimited. Does not implicitly {@link protos.args.AWSSQSConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {protos.args.IAWSSQSConn} message AWSSQSConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSQSConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSQSConn} AWSSQSConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSQSConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.awsRegion = reader.string();
                        break;
                    case 2:
                        message.awsAccessKeyId = reader.string();
                        break;
                    case 3:
                        message.awsSecretAccessKey = reader.string();
                        break;
                    case 4:
                        message.awsProfile = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSQSConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSQSConn} AWSSQSConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSQSConn message.
             * @function verify
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSQSConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.awsRegion != null && message.hasOwnProperty("awsRegion"))
                    if (!$util.isString(message.awsRegion))
                        return "awsRegion: string expected";
                if (message.awsAccessKeyId != null && message.hasOwnProperty("awsAccessKeyId"))
                    if (!$util.isString(message.awsAccessKeyId))
                        return "awsAccessKeyId: string expected";
                if (message.awsSecretAccessKey != null && message.hasOwnProperty("awsSecretAccessKey"))
                    if (!$util.isString(message.awsSecretAccessKey))
                        return "awsSecretAccessKey: string expected";
                if (message.awsProfile != null && message.hasOwnProperty("awsProfile"))
                    if (!$util.isString(message.awsProfile))
                        return "awsProfile: string expected";
                return null;
            };

            /**
             * Creates a AWSSQSConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSQSConn} AWSSQSConn
             */
            AWSSQSConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSQSConn)
                    return object;
                var message = new $root.protos.args.AWSSQSConn();
                if (object.awsRegion != null)
                    message.awsRegion = String(object.awsRegion);
                if (object.awsAccessKeyId != null)
                    message.awsAccessKeyId = String(object.awsAccessKeyId);
                if (object.awsSecretAccessKey != null)
                    message.awsSecretAccessKey = String(object.awsSecretAccessKey);
                if (object.awsProfile != null)
                    message.awsProfile = String(object.awsProfile);
                return message;
            };

            /**
             * Creates a plain object from a AWSSQSConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {protos.args.AWSSQSConn} message AWSSQSConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSQSConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.awsRegion = "";
                    object.awsAccessKeyId = "";
                    object.awsSecretAccessKey = "";
                    object.awsProfile = "";
                }
                if (message.awsRegion != null && message.hasOwnProperty("awsRegion"))
                    object.awsRegion = message.awsRegion;
                if (message.awsAccessKeyId != null && message.hasOwnProperty("awsAccessKeyId"))
                    object.awsAccessKeyId = message.awsAccessKeyId;
                if (message.awsSecretAccessKey != null && message.hasOwnProperty("awsSecretAccessKey"))
                    object.awsSecretAccessKey = message.awsSecretAccessKey;
                if (message.awsProfile != null && message.hasOwnProperty("awsProfile"))
                    object.awsProfile = message.awsProfile;
                return object;
            };

            /**
             * Converts this AWSSQSConn to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSQSConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSQSConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSQSConn;
        })();

        args.AWSSQSReadArgs = (function() {

            /**
             * Properties of a AWSSQSReadArgs.
             * @memberof protos.args
             * @interface IAWSSQSReadArgs
             * @property {string|null} [queueName] AWSSQSReadArgs queueName
             * @property {string|null} [remoteAccountId] AWSSQSReadArgs remoteAccountId
             * @property {number|Long|null} [maxNumMessages] AWSSQSReadArgs maxNumMessages
             * @property {string|null} [receiveRequestAttemptId] AWSSQSReadArgs receiveRequestAttemptId
             * @property {boolean|null} [autoDelete] AWSSQSReadArgs autoDelete
             * @property {number|Long|null} [waitTimeSeconds] AWSSQSReadArgs waitTimeSeconds
             */

            /**
             * Constructs a new AWSSQSReadArgs.
             * @memberof protos.args
             * @classdesc Represents a AWSSQSReadArgs.
             * @implements IAWSSQSReadArgs
             * @constructor
             * @param {protos.args.IAWSSQSReadArgs=} [properties] Properties to set
             */
            function AWSSQSReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSQSReadArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.queueName = "";

            /**
             * AWSSQSReadArgs remoteAccountId.
             * @member {string} remoteAccountId
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.remoteAccountId = "";

            /**
             * AWSSQSReadArgs maxNumMessages.
             * @member {number|Long} maxNumMessages
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.maxNumMessages = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AWSSQSReadArgs receiveRequestAttemptId.
             * @member {string} receiveRequestAttemptId
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.receiveRequestAttemptId = "";

            /**
             * AWSSQSReadArgs autoDelete.
             * @member {boolean} autoDelete
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.autoDelete = false;

            /**
             * AWSSQSReadArgs waitTimeSeconds.
             * @member {number|Long} waitTimeSeconds
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.waitTimeSeconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new AWSSQSReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {protos.args.IAWSSQSReadArgs=} [properties] Properties to set
             * @returns {protos.args.AWSSQSReadArgs} AWSSQSReadArgs instance
             */
            AWSSQSReadArgs.create = function create(properties) {
                return new AWSSQSReadArgs(properties);
            };

            /**
             * Encodes the specified AWSSQSReadArgs message. Does not implicitly {@link protos.args.AWSSQSReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {protos.args.IAWSSQSReadArgs} message AWSSQSReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queueName);
                if (message.remoteAccountId != null && Object.hasOwnProperty.call(message, "remoteAccountId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.remoteAccountId);
                if (message.maxNumMessages != null && Object.hasOwnProperty.call(message, "maxNumMessages"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.maxNumMessages);
                if (message.receiveRequestAttemptId != null && Object.hasOwnProperty.call(message, "receiveRequestAttemptId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.receiveRequestAttemptId);
                if (message.autoDelete != null && Object.hasOwnProperty.call(message, "autoDelete"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.autoDelete);
                if (message.waitTimeSeconds != null && Object.hasOwnProperty.call(message, "waitTimeSeconds"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.waitTimeSeconds);
                return writer;
            };

            /**
             * Encodes the specified AWSSQSReadArgs message, length delimited. Does not implicitly {@link protos.args.AWSSQSReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {protos.args.IAWSSQSReadArgs} message AWSSQSReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSQSReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSQSReadArgs} AWSSQSReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSQSReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queueName = reader.string();
                        break;
                    case 2:
                        message.remoteAccountId = reader.string();
                        break;
                    case 3:
                        message.maxNumMessages = reader.int64();
                        break;
                    case 4:
                        message.receiveRequestAttemptId = reader.string();
                        break;
                    case 5:
                        message.autoDelete = reader.bool();
                        break;
                    case 6:
                        message.waitTimeSeconds = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSQSReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSQSReadArgs} AWSSQSReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSQSReadArgs message.
             * @function verify
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSQSReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    if (!$util.isString(message.remoteAccountId))
                        return "remoteAccountId: string expected";
                if (message.maxNumMessages != null && message.hasOwnProperty("maxNumMessages"))
                    if (!$util.isInteger(message.maxNumMessages) && !(message.maxNumMessages && $util.isInteger(message.maxNumMessages.low) && $util.isInteger(message.maxNumMessages.high)))
                        return "maxNumMessages: integer|Long expected";
                if (message.receiveRequestAttemptId != null && message.hasOwnProperty("receiveRequestAttemptId"))
                    if (!$util.isString(message.receiveRequestAttemptId))
                        return "receiveRequestAttemptId: string expected";
                if (message.autoDelete != null && message.hasOwnProperty("autoDelete"))
                    if (typeof message.autoDelete !== "boolean")
                        return "autoDelete: boolean expected";
                if (message.waitTimeSeconds != null && message.hasOwnProperty("waitTimeSeconds"))
                    if (!$util.isInteger(message.waitTimeSeconds) && !(message.waitTimeSeconds && $util.isInteger(message.waitTimeSeconds.low) && $util.isInteger(message.waitTimeSeconds.high)))
                        return "waitTimeSeconds: integer|Long expected";
                return null;
            };

            /**
             * Creates a AWSSQSReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSQSReadArgs} AWSSQSReadArgs
             */
            AWSSQSReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSQSReadArgs)
                    return object;
                var message = new $root.protos.args.AWSSQSReadArgs();
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                if (object.remoteAccountId != null)
                    message.remoteAccountId = String(object.remoteAccountId);
                if (object.maxNumMessages != null)
                    if ($util.Long)
                        (message.maxNumMessages = $util.Long.fromValue(object.maxNumMessages)).unsigned = false;
                    else if (typeof object.maxNumMessages === "string")
                        message.maxNumMessages = parseInt(object.maxNumMessages, 10);
                    else if (typeof object.maxNumMessages === "number")
                        message.maxNumMessages = object.maxNumMessages;
                    else if (typeof object.maxNumMessages === "object")
                        message.maxNumMessages = new $util.LongBits(object.maxNumMessages.low >>> 0, object.maxNumMessages.high >>> 0).toNumber();
                if (object.receiveRequestAttemptId != null)
                    message.receiveRequestAttemptId = String(object.receiveRequestAttemptId);
                if (object.autoDelete != null)
                    message.autoDelete = Boolean(object.autoDelete);
                if (object.waitTimeSeconds != null)
                    if ($util.Long)
                        (message.waitTimeSeconds = $util.Long.fromValue(object.waitTimeSeconds)).unsigned = false;
                    else if (typeof object.waitTimeSeconds === "string")
                        message.waitTimeSeconds = parseInt(object.waitTimeSeconds, 10);
                    else if (typeof object.waitTimeSeconds === "number")
                        message.waitTimeSeconds = object.waitTimeSeconds;
                    else if (typeof object.waitTimeSeconds === "object")
                        message.waitTimeSeconds = new $util.LongBits(object.waitTimeSeconds.low >>> 0, object.waitTimeSeconds.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a AWSSQSReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {protos.args.AWSSQSReadArgs} message AWSSQSReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSQSReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.queueName = "";
                    object.remoteAccountId = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.maxNumMessages = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.maxNumMessages = options.longs === String ? "0" : 0;
                    object.receiveRequestAttemptId = "";
                    object.autoDelete = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.waitTimeSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.waitTimeSeconds = options.longs === String ? "0" : 0;
                }
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    object.remoteAccountId = message.remoteAccountId;
                if (message.maxNumMessages != null && message.hasOwnProperty("maxNumMessages"))
                    if (typeof message.maxNumMessages === "number")
                        object.maxNumMessages = options.longs === String ? String(message.maxNumMessages) : message.maxNumMessages;
                    else
                        object.maxNumMessages = options.longs === String ? $util.Long.prototype.toString.call(message.maxNumMessages) : options.longs === Number ? new $util.LongBits(message.maxNumMessages.low >>> 0, message.maxNumMessages.high >>> 0).toNumber() : message.maxNumMessages;
                if (message.receiveRequestAttemptId != null && message.hasOwnProperty("receiveRequestAttemptId"))
                    object.receiveRequestAttemptId = message.receiveRequestAttemptId;
                if (message.autoDelete != null && message.hasOwnProperty("autoDelete"))
                    object.autoDelete = message.autoDelete;
                if (message.waitTimeSeconds != null && message.hasOwnProperty("waitTimeSeconds"))
                    if (typeof message.waitTimeSeconds === "number")
                        object.waitTimeSeconds = options.longs === String ? String(message.waitTimeSeconds) : message.waitTimeSeconds;
                    else
                        object.waitTimeSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.waitTimeSeconds) : options.longs === Number ? new $util.LongBits(message.waitTimeSeconds.low >>> 0, message.waitTimeSeconds.high >>> 0).toNumber() : message.waitTimeSeconds;
                return object;
            };

            /**
             * Converts this AWSSQSReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSQSReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSQSReadArgs;
        })();

        args.AWSSQSWriteArgs = (function() {

            /**
             * Properties of a AWSSQSWriteArgs.
             * @memberof protos.args
             * @interface IAWSSQSWriteArgs
             * @property {string|null} [queueName] AWSSQSWriteArgs queueName
             * @property {string|null} [remoteAccountId] AWSSQSWriteArgs remoteAccountId
             * @property {number|Long|null} [delaySeconds] AWSSQSWriteArgs delaySeconds
             * @property {Object.<string,string>|null} [attributes] AWSSQSWriteArgs attributes
             * @property {string|null} [messageGroupId] AWSSQSWriteArgs messageGroupId
             * @property {string|null} [messageDeduplicationId] AWSSQSWriteArgs messageDeduplicationId
             */

            /**
             * Constructs a new AWSSQSWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a AWSSQSWriteArgs.
             * @implements IAWSSQSWriteArgs
             * @constructor
             * @param {protos.args.IAWSSQSWriteArgs=} [properties] Properties to set
             */
            function AWSSQSWriteArgs(properties) {
                this.attributes = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSQSWriteArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.queueName = "";

            /**
             * AWSSQSWriteArgs remoteAccountId.
             * @member {string} remoteAccountId
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.remoteAccountId = "";

            /**
             * AWSSQSWriteArgs delaySeconds.
             * @member {number|Long} delaySeconds
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.delaySeconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AWSSQSWriteArgs attributes.
             * @member {Object.<string,string>} attributes
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.attributes = $util.emptyObject;

            /**
             * AWSSQSWriteArgs messageGroupId.
             * @member {string} messageGroupId
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.messageGroupId = "";

            /**
             * AWSSQSWriteArgs messageDeduplicationId.
             * @member {string} messageDeduplicationId
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.messageDeduplicationId = "";

            /**
             * Creates a new AWSSQSWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {protos.args.IAWSSQSWriteArgs=} [properties] Properties to set
             * @returns {protos.args.AWSSQSWriteArgs} AWSSQSWriteArgs instance
             */
            AWSSQSWriteArgs.create = function create(properties) {
                return new AWSSQSWriteArgs(properties);
            };

            /**
             * Encodes the specified AWSSQSWriteArgs message. Does not implicitly {@link protos.args.AWSSQSWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {protos.args.IAWSSQSWriteArgs} message AWSSQSWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queueName);
                if (message.remoteAccountId != null && Object.hasOwnProperty.call(message, "remoteAccountId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.remoteAccountId);
                if (message.delaySeconds != null && Object.hasOwnProperty.call(message, "delaySeconds"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.delaySeconds);
                if (message.attributes != null && Object.hasOwnProperty.call(message, "attributes"))
                    for (var keys = Object.keys(message.attributes), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.attributes[keys[i]]).ldelim();
                if (message.messageGroupId != null && Object.hasOwnProperty.call(message, "messageGroupId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.messageGroupId);
                if (message.messageDeduplicationId != null && Object.hasOwnProperty.call(message, "messageDeduplicationId"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.messageDeduplicationId);
                return writer;
            };

            /**
             * Encodes the specified AWSSQSWriteArgs message, length delimited. Does not implicitly {@link protos.args.AWSSQSWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {protos.args.IAWSSQSWriteArgs} message AWSSQSWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSQSWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSQSWriteArgs} AWSSQSWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSQSWriteArgs(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queueName = reader.string();
                        break;
                    case 2:
                        message.remoteAccountId = reader.string();
                        break;
                    case 3:
                        message.delaySeconds = reader.int64();
                        break;
                    case 4:
                        if (message.attributes === $util.emptyObject)
                            message.attributes = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.attributes[key] = value;
                        break;
                    case 5:
                        message.messageGroupId = reader.string();
                        break;
                    case 6:
                        message.messageDeduplicationId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSQSWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSQSWriteArgs} AWSSQSWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSQSWriteArgs message.
             * @function verify
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSQSWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    if (!$util.isString(message.remoteAccountId))
                        return "remoteAccountId: string expected";
                if (message.delaySeconds != null && message.hasOwnProperty("delaySeconds"))
                    if (!$util.isInteger(message.delaySeconds) && !(message.delaySeconds && $util.isInteger(message.delaySeconds.low) && $util.isInteger(message.delaySeconds.high)))
                        return "delaySeconds: integer|Long expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    if (!$util.isObject(message.attributes))
                        return "attributes: object expected";
                    var key = Object.keys(message.attributes);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.attributes[key[i]]))
                            return "attributes: string{k:string} expected";
                }
                if (message.messageGroupId != null && message.hasOwnProperty("messageGroupId"))
                    if (!$util.isString(message.messageGroupId))
                        return "messageGroupId: string expected";
                if (message.messageDeduplicationId != null && message.hasOwnProperty("messageDeduplicationId"))
                    if (!$util.isString(message.messageDeduplicationId))
                        return "messageDeduplicationId: string expected";
                return null;
            };

            /**
             * Creates a AWSSQSWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSQSWriteArgs} AWSSQSWriteArgs
             */
            AWSSQSWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSQSWriteArgs)
                    return object;
                var message = new $root.protos.args.AWSSQSWriteArgs();
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                if (object.remoteAccountId != null)
                    message.remoteAccountId = String(object.remoteAccountId);
                if (object.delaySeconds != null)
                    if ($util.Long)
                        (message.delaySeconds = $util.Long.fromValue(object.delaySeconds)).unsigned = false;
                    else if (typeof object.delaySeconds === "string")
                        message.delaySeconds = parseInt(object.delaySeconds, 10);
                    else if (typeof object.delaySeconds === "number")
                        message.delaySeconds = object.delaySeconds;
                    else if (typeof object.delaySeconds === "object")
                        message.delaySeconds = new $util.LongBits(object.delaySeconds.low >>> 0, object.delaySeconds.high >>> 0).toNumber();
                if (object.attributes) {
                    if (typeof object.attributes !== "object")
                        throw TypeError(".protos.args.AWSSQSWriteArgs.attributes: object expected");
                    message.attributes = {};
                    for (var keys = Object.keys(object.attributes), i = 0; i < keys.length; ++i)
                        message.attributes[keys[i]] = String(object.attributes[keys[i]]);
                }
                if (object.messageGroupId != null)
                    message.messageGroupId = String(object.messageGroupId);
                if (object.messageDeduplicationId != null)
                    message.messageDeduplicationId = String(object.messageDeduplicationId);
                return message;
            };

            /**
             * Creates a plain object from a AWSSQSWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {protos.args.AWSSQSWriteArgs} message AWSSQSWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSQSWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.attributes = {};
                if (options.defaults) {
                    object.queueName = "";
                    object.remoteAccountId = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.delaySeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.delaySeconds = options.longs === String ? "0" : 0;
                    object.messageGroupId = "";
                    object.messageDeduplicationId = "";
                }
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    object.remoteAccountId = message.remoteAccountId;
                if (message.delaySeconds != null && message.hasOwnProperty("delaySeconds"))
                    if (typeof message.delaySeconds === "number")
                        object.delaySeconds = options.longs === String ? String(message.delaySeconds) : message.delaySeconds;
                    else
                        object.delaySeconds = options.longs === String ? $util.Long.prototype.toString.call(message.delaySeconds) : options.longs === Number ? new $util.LongBits(message.delaySeconds.low >>> 0, message.delaySeconds.high >>> 0).toNumber() : message.delaySeconds;
                var keys2;
                if (message.attributes && (keys2 = Object.keys(message.attributes)).length) {
                    object.attributes = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.attributes[keys2[j]] = message.attributes[keys2[j]];
                }
                if (message.messageGroupId != null && message.hasOwnProperty("messageGroupId"))
                    object.messageGroupId = message.messageGroupId;
                if (message.messageDeduplicationId != null && message.hasOwnProperty("messageDeduplicationId"))
                    object.messageDeduplicationId = message.messageDeduplicationId;
                return object;
            };

            /**
             * Converts this AWSSQSWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSQSWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSQSWriteArgs;
        })();

        args.AWSSQSRelayArgs = (function() {

            /**
             * Properties of a AWSSQSRelayArgs.
             * @memberof protos.args
             * @interface IAWSSQSRelayArgs
             * @property {string|null} [queueName] AWSSQSRelayArgs queueName
             * @property {string|null} [remoteAccountId] AWSSQSRelayArgs remoteAccountId
             * @property {number|Long|null} [maxNumMessages] AWSSQSRelayArgs maxNumMessages
             * @property {string|null} [receiveRequestAttemptId] AWSSQSRelayArgs receiveRequestAttemptId
             * @property {boolean|null} [autoDelete] AWSSQSRelayArgs autoDelete
             * @property {number|Long|null} [waitTimeSeconds] AWSSQSRelayArgs waitTimeSeconds
             */

            /**
             * Constructs a new AWSSQSRelayArgs.
             * @memberof protos.args
             * @classdesc Represents a AWSSQSRelayArgs.
             * @implements IAWSSQSRelayArgs
             * @constructor
             * @param {protos.args.IAWSSQSRelayArgs=} [properties] Properties to set
             */
            function AWSSQSRelayArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSQSRelayArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.queueName = "";

            /**
             * AWSSQSRelayArgs remoteAccountId.
             * @member {string} remoteAccountId
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.remoteAccountId = "";

            /**
             * AWSSQSRelayArgs maxNumMessages.
             * @member {number|Long} maxNumMessages
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.maxNumMessages = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AWSSQSRelayArgs receiveRequestAttemptId.
             * @member {string} receiveRequestAttemptId
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.receiveRequestAttemptId = "";

            /**
             * AWSSQSRelayArgs autoDelete.
             * @member {boolean} autoDelete
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.autoDelete = false;

            /**
             * AWSSQSRelayArgs waitTimeSeconds.
             * @member {number|Long} waitTimeSeconds
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.waitTimeSeconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new AWSSQSRelayArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {protos.args.IAWSSQSRelayArgs=} [properties] Properties to set
             * @returns {protos.args.AWSSQSRelayArgs} AWSSQSRelayArgs instance
             */
            AWSSQSRelayArgs.create = function create(properties) {
                return new AWSSQSRelayArgs(properties);
            };

            /**
             * Encodes the specified AWSSQSRelayArgs message. Does not implicitly {@link protos.args.AWSSQSRelayArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {protos.args.IAWSSQSRelayArgs} message AWSSQSRelayArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSRelayArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queueName);
                if (message.remoteAccountId != null && Object.hasOwnProperty.call(message, "remoteAccountId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.remoteAccountId);
                if (message.maxNumMessages != null && Object.hasOwnProperty.call(message, "maxNumMessages"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.maxNumMessages);
                if (message.receiveRequestAttemptId != null && Object.hasOwnProperty.call(message, "receiveRequestAttemptId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.receiveRequestAttemptId);
                if (message.autoDelete != null && Object.hasOwnProperty.call(message, "autoDelete"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.autoDelete);
                if (message.waitTimeSeconds != null && Object.hasOwnProperty.call(message, "waitTimeSeconds"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.waitTimeSeconds);
                return writer;
            };

            /**
             * Encodes the specified AWSSQSRelayArgs message, length delimited. Does not implicitly {@link protos.args.AWSSQSRelayArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {protos.args.IAWSSQSRelayArgs} message AWSSQSRelayArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSRelayArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSQSRelayArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSQSRelayArgs} AWSSQSRelayArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSRelayArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSQSRelayArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queueName = reader.string();
                        break;
                    case 2:
                        message.remoteAccountId = reader.string();
                        break;
                    case 3:
                        message.maxNumMessages = reader.int64();
                        break;
                    case 4:
                        message.receiveRequestAttemptId = reader.string();
                        break;
                    case 5:
                        message.autoDelete = reader.bool();
                        break;
                    case 6:
                        message.waitTimeSeconds = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSQSRelayArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSQSRelayArgs} AWSSQSRelayArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSRelayArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSQSRelayArgs message.
             * @function verify
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSQSRelayArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    if (!$util.isString(message.remoteAccountId))
                        return "remoteAccountId: string expected";
                if (message.maxNumMessages != null && message.hasOwnProperty("maxNumMessages"))
                    if (!$util.isInteger(message.maxNumMessages) && !(message.maxNumMessages && $util.isInteger(message.maxNumMessages.low) && $util.isInteger(message.maxNumMessages.high)))
                        return "maxNumMessages: integer|Long expected";
                if (message.receiveRequestAttemptId != null && message.hasOwnProperty("receiveRequestAttemptId"))
                    if (!$util.isString(message.receiveRequestAttemptId))
                        return "receiveRequestAttemptId: string expected";
                if (message.autoDelete != null && message.hasOwnProperty("autoDelete"))
                    if (typeof message.autoDelete !== "boolean")
                        return "autoDelete: boolean expected";
                if (message.waitTimeSeconds != null && message.hasOwnProperty("waitTimeSeconds"))
                    if (!$util.isInteger(message.waitTimeSeconds) && !(message.waitTimeSeconds && $util.isInteger(message.waitTimeSeconds.low) && $util.isInteger(message.waitTimeSeconds.high)))
                        return "waitTimeSeconds: integer|Long expected";
                return null;
            };

            /**
             * Creates a AWSSQSRelayArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSQSRelayArgs} AWSSQSRelayArgs
             */
            AWSSQSRelayArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSQSRelayArgs)
                    return object;
                var message = new $root.protos.args.AWSSQSRelayArgs();
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                if (object.remoteAccountId != null)
                    message.remoteAccountId = String(object.remoteAccountId);
                if (object.maxNumMessages != null)
                    if ($util.Long)
                        (message.maxNumMessages = $util.Long.fromValue(object.maxNumMessages)).unsigned = false;
                    else if (typeof object.maxNumMessages === "string")
                        message.maxNumMessages = parseInt(object.maxNumMessages, 10);
                    else if (typeof object.maxNumMessages === "number")
                        message.maxNumMessages = object.maxNumMessages;
                    else if (typeof object.maxNumMessages === "object")
                        message.maxNumMessages = new $util.LongBits(object.maxNumMessages.low >>> 0, object.maxNumMessages.high >>> 0).toNumber();
                if (object.receiveRequestAttemptId != null)
                    message.receiveRequestAttemptId = String(object.receiveRequestAttemptId);
                if (object.autoDelete != null)
                    message.autoDelete = Boolean(object.autoDelete);
                if (object.waitTimeSeconds != null)
                    if ($util.Long)
                        (message.waitTimeSeconds = $util.Long.fromValue(object.waitTimeSeconds)).unsigned = false;
                    else if (typeof object.waitTimeSeconds === "string")
                        message.waitTimeSeconds = parseInt(object.waitTimeSeconds, 10);
                    else if (typeof object.waitTimeSeconds === "number")
                        message.waitTimeSeconds = object.waitTimeSeconds;
                    else if (typeof object.waitTimeSeconds === "object")
                        message.waitTimeSeconds = new $util.LongBits(object.waitTimeSeconds.low >>> 0, object.waitTimeSeconds.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a AWSSQSRelayArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {protos.args.AWSSQSRelayArgs} message AWSSQSRelayArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSQSRelayArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.queueName = "";
                    object.remoteAccountId = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.maxNumMessages = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.maxNumMessages = options.longs === String ? "0" : 0;
                    object.receiveRequestAttemptId = "";
                    object.autoDelete = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.waitTimeSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.waitTimeSeconds = options.longs === String ? "0" : 0;
                }
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    object.remoteAccountId = message.remoteAccountId;
                if (message.maxNumMessages != null && message.hasOwnProperty("maxNumMessages"))
                    if (typeof message.maxNumMessages === "number")
                        object.maxNumMessages = options.longs === String ? String(message.maxNumMessages) : message.maxNumMessages;
                    else
                        object.maxNumMessages = options.longs === String ? $util.Long.prototype.toString.call(message.maxNumMessages) : options.longs === Number ? new $util.LongBits(message.maxNumMessages.low >>> 0, message.maxNumMessages.high >>> 0).toNumber() : message.maxNumMessages;
                if (message.receiveRequestAttemptId != null && message.hasOwnProperty("receiveRequestAttemptId"))
                    object.receiveRequestAttemptId = message.receiveRequestAttemptId;
                if (message.autoDelete != null && message.hasOwnProperty("autoDelete"))
                    object.autoDelete = message.autoDelete;
                if (message.waitTimeSeconds != null && message.hasOwnProperty("waitTimeSeconds"))
                    if (typeof message.waitTimeSeconds === "number")
                        object.waitTimeSeconds = options.longs === String ? String(message.waitTimeSeconds) : message.waitTimeSeconds;
                    else
                        object.waitTimeSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.waitTimeSeconds) : options.longs === Number ? new $util.LongBits(message.waitTimeSeconds.low >>> 0, message.waitTimeSeconds.high >>> 0).toNumber() : message.waitTimeSeconds;
                return object;
            };

            /**
             * Converts this AWSSQSRelayArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSQSRelayArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSQSRelayArgs;
        })();

        args.AzureEventHubConn = (function() {

            /**
             * Properties of an AzureEventHubConn.
             * @memberof protos.args
             * @interface IAzureEventHubConn
             * @property {string|null} [connectionString] AzureEventHubConn connectionString
             */

            /**
             * Constructs a new AzureEventHubConn.
             * @memberof protos.args
             * @classdesc Represents an AzureEventHubConn.
             * @implements IAzureEventHubConn
             * @constructor
             * @param {protos.args.IAzureEventHubConn=} [properties] Properties to set
             */
            function AzureEventHubConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureEventHubConn connectionString.
             * @member {string} connectionString
             * @memberof protos.args.AzureEventHubConn
             * @instance
             */
            AzureEventHubConn.prototype.connectionString = "";

            /**
             * Creates a new AzureEventHubConn instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {protos.args.IAzureEventHubConn=} [properties] Properties to set
             * @returns {protos.args.AzureEventHubConn} AzureEventHubConn instance
             */
            AzureEventHubConn.create = function create(properties) {
                return new AzureEventHubConn(properties);
            };

            /**
             * Encodes the specified AzureEventHubConn message. Does not implicitly {@link protos.args.AzureEventHubConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {protos.args.IAzureEventHubConn} message AzureEventHubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.connectionString != null && Object.hasOwnProperty.call(message, "connectionString"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionString);
                return writer;
            };

            /**
             * Encodes the specified AzureEventHubConn message, length delimited. Does not implicitly {@link protos.args.AzureEventHubConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {protos.args.IAzureEventHubConn} message AzureEventHubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureEventHubConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureEventHubConn} AzureEventHubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureEventHubConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.connectionString = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureEventHubConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureEventHubConn} AzureEventHubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureEventHubConn message.
             * @function verify
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureEventHubConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.connectionString != null && message.hasOwnProperty("connectionString"))
                    if (!$util.isString(message.connectionString))
                        return "connectionString: string expected";
                return null;
            };

            /**
             * Creates an AzureEventHubConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureEventHubConn} AzureEventHubConn
             */
            AzureEventHubConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureEventHubConn)
                    return object;
                var message = new $root.protos.args.AzureEventHubConn();
                if (object.connectionString != null)
                    message.connectionString = String(object.connectionString);
                return message;
            };

            /**
             * Creates a plain object from an AzureEventHubConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {protos.args.AzureEventHubConn} message AzureEventHubConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureEventHubConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.connectionString = "";
                if (message.connectionString != null && message.hasOwnProperty("connectionString"))
                    object.connectionString = message.connectionString;
                return object;
            };

            /**
             * Converts this AzureEventHubConn to JSON.
             * @function toJSON
             * @memberof protos.args.AzureEventHubConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureEventHubConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureEventHubConn;
        })();

        args.AzureEventHubReadArgs = (function() {

            /**
             * Properties of an AzureEventHubReadArgs.
             * @memberof protos.args
             * @interface IAzureEventHubReadArgs
             */

            /**
             * Constructs a new AzureEventHubReadArgs.
             * @memberof protos.args
             * @classdesc Represents an AzureEventHubReadArgs.
             * @implements IAzureEventHubReadArgs
             * @constructor
             * @param {protos.args.IAzureEventHubReadArgs=} [properties] Properties to set
             */
            function AzureEventHubReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new AzureEventHubReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {protos.args.IAzureEventHubReadArgs=} [properties] Properties to set
             * @returns {protos.args.AzureEventHubReadArgs} AzureEventHubReadArgs instance
             */
            AzureEventHubReadArgs.create = function create(properties) {
                return new AzureEventHubReadArgs(properties);
            };

            /**
             * Encodes the specified AzureEventHubReadArgs message. Does not implicitly {@link protos.args.AzureEventHubReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {protos.args.IAzureEventHubReadArgs} message AzureEventHubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified AzureEventHubReadArgs message, length delimited. Does not implicitly {@link protos.args.AzureEventHubReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {protos.args.IAzureEventHubReadArgs} message AzureEventHubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureEventHubReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureEventHubReadArgs} AzureEventHubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureEventHubReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureEventHubReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureEventHubReadArgs} AzureEventHubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureEventHubReadArgs message.
             * @function verify
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureEventHubReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an AzureEventHubReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureEventHubReadArgs} AzureEventHubReadArgs
             */
            AzureEventHubReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureEventHubReadArgs)
                    return object;
                return new $root.protos.args.AzureEventHubReadArgs();
            };

            /**
             * Creates a plain object from an AzureEventHubReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {protos.args.AzureEventHubReadArgs} message AzureEventHubReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureEventHubReadArgs.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this AzureEventHubReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AzureEventHubReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureEventHubReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureEventHubReadArgs;
        })();

        args.AzureEventHubWriteArgs = (function() {

            /**
             * Properties of an AzureEventHubWriteArgs.
             * @memberof protos.args
             * @interface IAzureEventHubWriteArgs
             * @property {string|null} [messageId] AzureEventHubWriteArgs messageId
             * @property {string|null} [partitionKey] AzureEventHubWriteArgs partitionKey
             */

            /**
             * Constructs a new AzureEventHubWriteArgs.
             * @memberof protos.args
             * @classdesc Represents an AzureEventHubWriteArgs.
             * @implements IAzureEventHubWriteArgs
             * @constructor
             * @param {protos.args.IAzureEventHubWriteArgs=} [properties] Properties to set
             */
            function AzureEventHubWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureEventHubWriteArgs messageId.
             * @member {string} messageId
             * @memberof protos.args.AzureEventHubWriteArgs
             * @instance
             */
            AzureEventHubWriteArgs.prototype.messageId = "";

            /**
             * AzureEventHubWriteArgs partitionKey.
             * @member {string} partitionKey
             * @memberof protos.args.AzureEventHubWriteArgs
             * @instance
             */
            AzureEventHubWriteArgs.prototype.partitionKey = "";

            /**
             * Creates a new AzureEventHubWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {protos.args.IAzureEventHubWriteArgs=} [properties] Properties to set
             * @returns {protos.args.AzureEventHubWriteArgs} AzureEventHubWriteArgs instance
             */
            AzureEventHubWriteArgs.create = function create(properties) {
                return new AzureEventHubWriteArgs(properties);
            };

            /**
             * Encodes the specified AzureEventHubWriteArgs message. Does not implicitly {@link protos.args.AzureEventHubWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {protos.args.IAzureEventHubWriteArgs} message AzureEventHubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.messageId);
                if (message.partitionKey != null && Object.hasOwnProperty.call(message, "partitionKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.partitionKey);
                return writer;
            };

            /**
             * Encodes the specified AzureEventHubWriteArgs message, length delimited. Does not implicitly {@link protos.args.AzureEventHubWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {protos.args.IAzureEventHubWriteArgs} message AzureEventHubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureEventHubWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureEventHubWriteArgs} AzureEventHubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureEventHubWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageId = reader.string();
                        break;
                    case 2:
                        message.partitionKey = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureEventHubWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureEventHubWriteArgs} AzureEventHubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureEventHubWriteArgs message.
             * @function verify
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureEventHubWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    if (!$util.isString(message.partitionKey))
                        return "partitionKey: string expected";
                return null;
            };

            /**
             * Creates an AzureEventHubWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureEventHubWriteArgs} AzureEventHubWriteArgs
             */
            AzureEventHubWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureEventHubWriteArgs)
                    return object;
                var message = new $root.protos.args.AzureEventHubWriteArgs();
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.partitionKey != null)
                    message.partitionKey = String(object.partitionKey);
                return message;
            };

            /**
             * Creates a plain object from an AzureEventHubWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {protos.args.AzureEventHubWriteArgs} message AzureEventHubWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureEventHubWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.messageId = "";
                    object.partitionKey = "";
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    object.partitionKey = message.partitionKey;
                return object;
            };

            /**
             * Converts this AzureEventHubWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AzureEventHubWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureEventHubWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureEventHubWriteArgs;
        })();

        args.AzureServiceBusConn = (function() {

            /**
             * Properties of an AzureServiceBusConn.
             * @memberof protos.args
             * @interface IAzureServiceBusConn
             * @property {string|null} [connectionString] AzureServiceBusConn connectionString
             */

            /**
             * Constructs a new AzureServiceBusConn.
             * @memberof protos.args
             * @classdesc Represents an AzureServiceBusConn.
             * @implements IAzureServiceBusConn
             * @constructor
             * @param {protos.args.IAzureServiceBusConn=} [properties] Properties to set
             */
            function AzureServiceBusConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureServiceBusConn connectionString.
             * @member {string} connectionString
             * @memberof protos.args.AzureServiceBusConn
             * @instance
             */
            AzureServiceBusConn.prototype.connectionString = "";

            /**
             * Creates a new AzureServiceBusConn instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {protos.args.IAzureServiceBusConn=} [properties] Properties to set
             * @returns {protos.args.AzureServiceBusConn} AzureServiceBusConn instance
             */
            AzureServiceBusConn.create = function create(properties) {
                return new AzureServiceBusConn(properties);
            };

            /**
             * Encodes the specified AzureServiceBusConn message. Does not implicitly {@link protos.args.AzureServiceBusConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {protos.args.IAzureServiceBusConn} message AzureServiceBusConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.connectionString != null && Object.hasOwnProperty.call(message, "connectionString"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionString);
                return writer;
            };

            /**
             * Encodes the specified AzureServiceBusConn message, length delimited. Does not implicitly {@link protos.args.AzureServiceBusConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {protos.args.IAzureServiceBusConn} message AzureServiceBusConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureServiceBusConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureServiceBusConn} AzureServiceBusConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureServiceBusConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.connectionString = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureServiceBusConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureServiceBusConn} AzureServiceBusConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureServiceBusConn message.
             * @function verify
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureServiceBusConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.connectionString != null && message.hasOwnProperty("connectionString"))
                    if (!$util.isString(message.connectionString))
                        return "connectionString: string expected";
                return null;
            };

            /**
             * Creates an AzureServiceBusConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureServiceBusConn} AzureServiceBusConn
             */
            AzureServiceBusConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureServiceBusConn)
                    return object;
                var message = new $root.protos.args.AzureServiceBusConn();
                if (object.connectionString != null)
                    message.connectionString = String(object.connectionString);
                return message;
            };

            /**
             * Creates a plain object from an AzureServiceBusConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {protos.args.AzureServiceBusConn} message AzureServiceBusConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureServiceBusConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.connectionString = "";
                if (message.connectionString != null && message.hasOwnProperty("connectionString"))
                    object.connectionString = message.connectionString;
                return object;
            };

            /**
             * Converts this AzureServiceBusConn to JSON.
             * @function toJSON
             * @memberof protos.args.AzureServiceBusConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureServiceBusConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureServiceBusConn;
        })();

        args.AzureServiceBusReadArgs = (function() {

            /**
             * Properties of an AzureServiceBusReadArgs.
             * @memberof protos.args
             * @interface IAzureServiceBusReadArgs
             * @property {string|null} [queue] AzureServiceBusReadArgs queue
             * @property {string|null} [topic] AzureServiceBusReadArgs topic
             * @property {string|null} [subscriptionName] AzureServiceBusReadArgs subscriptionName
             */

            /**
             * Constructs a new AzureServiceBusReadArgs.
             * @memberof protos.args
             * @classdesc Represents an AzureServiceBusReadArgs.
             * @implements IAzureServiceBusReadArgs
             * @constructor
             * @param {protos.args.IAzureServiceBusReadArgs=} [properties] Properties to set
             */
            function AzureServiceBusReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureServiceBusReadArgs queue.
             * @member {string} queue
             * @memberof protos.args.AzureServiceBusReadArgs
             * @instance
             */
            AzureServiceBusReadArgs.prototype.queue = "";

            /**
             * AzureServiceBusReadArgs topic.
             * @member {string} topic
             * @memberof protos.args.AzureServiceBusReadArgs
             * @instance
             */
            AzureServiceBusReadArgs.prototype.topic = "";

            /**
             * AzureServiceBusReadArgs subscriptionName.
             * @member {string} subscriptionName
             * @memberof protos.args.AzureServiceBusReadArgs
             * @instance
             */
            AzureServiceBusReadArgs.prototype.subscriptionName = "";

            /**
             * Creates a new AzureServiceBusReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {protos.args.IAzureServiceBusReadArgs=} [properties] Properties to set
             * @returns {protos.args.AzureServiceBusReadArgs} AzureServiceBusReadArgs instance
             */
            AzureServiceBusReadArgs.create = function create(properties) {
                return new AzureServiceBusReadArgs(properties);
            };

            /**
             * Encodes the specified AzureServiceBusReadArgs message. Does not implicitly {@link protos.args.AzureServiceBusReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {protos.args.IAzureServiceBusReadArgs} message AzureServiceBusReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queue != null && Object.hasOwnProperty.call(message, "queue"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queue);
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.topic);
                if (message.subscriptionName != null && Object.hasOwnProperty.call(message, "subscriptionName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.subscriptionName);
                return writer;
            };

            /**
             * Encodes the specified AzureServiceBusReadArgs message, length delimited. Does not implicitly {@link protos.args.AzureServiceBusReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {protos.args.IAzureServiceBusReadArgs} message AzureServiceBusReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureServiceBusReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureServiceBusReadArgs} AzureServiceBusReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureServiceBusReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queue = reader.string();
                        break;
                    case 2:
                        message.topic = reader.string();
                        break;
                    case 3:
                        message.subscriptionName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureServiceBusReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureServiceBusReadArgs} AzureServiceBusReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureServiceBusReadArgs message.
             * @function verify
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureServiceBusReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queue != null && message.hasOwnProperty("queue"))
                    if (!$util.isString(message.queue))
                        return "queue: string expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.subscriptionName != null && message.hasOwnProperty("subscriptionName"))
                    if (!$util.isString(message.subscriptionName))
                        return "subscriptionName: string expected";
                return null;
            };

            /**
             * Creates an AzureServiceBusReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureServiceBusReadArgs} AzureServiceBusReadArgs
             */
            AzureServiceBusReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureServiceBusReadArgs)
                    return object;
                var message = new $root.protos.args.AzureServiceBusReadArgs();
                if (object.queue != null)
                    message.queue = String(object.queue);
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.subscriptionName != null)
                    message.subscriptionName = String(object.subscriptionName);
                return message;
            };

            /**
             * Creates a plain object from an AzureServiceBusReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {protos.args.AzureServiceBusReadArgs} message AzureServiceBusReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureServiceBusReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.queue = "";
                    object.topic = "";
                    object.subscriptionName = "";
                }
                if (message.queue != null && message.hasOwnProperty("queue"))
                    object.queue = message.queue;
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.subscriptionName != null && message.hasOwnProperty("subscriptionName"))
                    object.subscriptionName = message.subscriptionName;
                return object;
            };

            /**
             * Converts this AzureServiceBusReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AzureServiceBusReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureServiceBusReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureServiceBusReadArgs;
        })();

        args.AzureServiceBusWriteArgs = (function() {

            /**
             * Properties of an AzureServiceBusWriteArgs.
             * @memberof protos.args
             * @interface IAzureServiceBusWriteArgs
             * @property {string|null} [queue] AzureServiceBusWriteArgs queue
             * @property {string|null} [topic] AzureServiceBusWriteArgs topic
             */

            /**
             * Constructs a new AzureServiceBusWriteArgs.
             * @memberof protos.args
             * @classdesc Represents an AzureServiceBusWriteArgs.
             * @implements IAzureServiceBusWriteArgs
             * @constructor
             * @param {protos.args.IAzureServiceBusWriteArgs=} [properties] Properties to set
             */
            function AzureServiceBusWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureServiceBusWriteArgs queue.
             * @member {string} queue
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @instance
             */
            AzureServiceBusWriteArgs.prototype.queue = "";

            /**
             * AzureServiceBusWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @instance
             */
            AzureServiceBusWriteArgs.prototype.topic = "";

            /**
             * Creates a new AzureServiceBusWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {protos.args.IAzureServiceBusWriteArgs=} [properties] Properties to set
             * @returns {protos.args.AzureServiceBusWriteArgs} AzureServiceBusWriteArgs instance
             */
            AzureServiceBusWriteArgs.create = function create(properties) {
                return new AzureServiceBusWriteArgs(properties);
            };

            /**
             * Encodes the specified AzureServiceBusWriteArgs message. Does not implicitly {@link protos.args.AzureServiceBusWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {protos.args.IAzureServiceBusWriteArgs} message AzureServiceBusWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queue != null && Object.hasOwnProperty.call(message, "queue"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queue);
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.topic);
                return writer;
            };

            /**
             * Encodes the specified AzureServiceBusWriteArgs message, length delimited. Does not implicitly {@link protos.args.AzureServiceBusWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {protos.args.IAzureServiceBusWriteArgs} message AzureServiceBusWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureServiceBusWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureServiceBusWriteArgs} AzureServiceBusWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureServiceBusWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queue = reader.string();
                        break;
                    case 2:
                        message.topic = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureServiceBusWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureServiceBusWriteArgs} AzureServiceBusWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureServiceBusWriteArgs message.
             * @function verify
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureServiceBusWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queue != null && message.hasOwnProperty("queue"))
                    if (!$util.isString(message.queue))
                        return "queue: string expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                return null;
            };

            /**
             * Creates an AzureServiceBusWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureServiceBusWriteArgs} AzureServiceBusWriteArgs
             */
            AzureServiceBusWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureServiceBusWriteArgs)
                    return object;
                var message = new $root.protos.args.AzureServiceBusWriteArgs();
                if (object.queue != null)
                    message.queue = String(object.queue);
                if (object.topic != null)
                    message.topic = String(object.topic);
                return message;
            };

            /**
             * Creates a plain object from an AzureServiceBusWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {protos.args.AzureServiceBusWriteArgs} message AzureServiceBusWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureServiceBusWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.queue = "";
                    object.topic = "";
                }
                if (message.queue != null && message.hasOwnProperty("queue"))
                    object.queue = message.queue;
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                return object;
            };

            /**
             * Converts this AzureServiceBusWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureServiceBusWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureServiceBusWriteArgs;
        })();

        args.GCPPubSubConn = (function() {

            /**
             * Properties of a GCPPubSubConn.
             * @memberof protos.args
             * @interface IGCPPubSubConn
             * @property {string|null} [projectId] GCPPubSubConn projectId
             * @property {string|null} [credentialsJson] GCPPubSubConn credentialsJson
             * @property {string|null} [credentialsFile] GCPPubSubConn credentialsFile
             */

            /**
             * Constructs a new GCPPubSubConn.
             * @memberof protos.args
             * @classdesc Represents a GCPPubSubConn.
             * @implements IGCPPubSubConn
             * @constructor
             * @param {protos.args.IGCPPubSubConn=} [properties] Properties to set
             */
            function GCPPubSubConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GCPPubSubConn projectId.
             * @member {string} projectId
             * @memberof protos.args.GCPPubSubConn
             * @instance
             */
            GCPPubSubConn.prototype.projectId = "";

            /**
             * GCPPubSubConn credentialsJson.
             * @member {string} credentialsJson
             * @memberof protos.args.GCPPubSubConn
             * @instance
             */
            GCPPubSubConn.prototype.credentialsJson = "";

            /**
             * GCPPubSubConn credentialsFile.
             * @member {string} credentialsFile
             * @memberof protos.args.GCPPubSubConn
             * @instance
             */
            GCPPubSubConn.prototype.credentialsFile = "";

            /**
             * Creates a new GCPPubSubConn instance using the specified properties.
             * @function create
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {protos.args.IGCPPubSubConn=} [properties] Properties to set
             * @returns {protos.args.GCPPubSubConn} GCPPubSubConn instance
             */
            GCPPubSubConn.create = function create(properties) {
                return new GCPPubSubConn(properties);
            };

            /**
             * Encodes the specified GCPPubSubConn message. Does not implicitly {@link protos.args.GCPPubSubConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {protos.args.IGCPPubSubConn} message GCPPubSubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.projectId != null && Object.hasOwnProperty.call(message, "projectId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.projectId);
                if (message.credentialsJson != null && Object.hasOwnProperty.call(message, "credentialsJson"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.credentialsJson);
                if (message.credentialsFile != null && Object.hasOwnProperty.call(message, "credentialsFile"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.credentialsFile);
                return writer;
            };

            /**
             * Encodes the specified GCPPubSubConn message, length delimited. Does not implicitly {@link protos.args.GCPPubSubConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {protos.args.IGCPPubSubConn} message GCPPubSubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GCPPubSubConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.GCPPubSubConn} GCPPubSubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.GCPPubSubConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.projectId = reader.string();
                        break;
                    case 2:
                        message.credentialsJson = reader.string();
                        break;
                    case 3:
                        message.credentialsFile = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GCPPubSubConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.GCPPubSubConn} GCPPubSubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GCPPubSubConn message.
             * @function verify
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GCPPubSubConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.projectId != null && message.hasOwnProperty("projectId"))
                    if (!$util.isString(message.projectId))
                        return "projectId: string expected";
                if (message.credentialsJson != null && message.hasOwnProperty("credentialsJson"))
                    if (!$util.isString(message.credentialsJson))
                        return "credentialsJson: string expected";
                if (message.credentialsFile != null && message.hasOwnProperty("credentialsFile"))
                    if (!$util.isString(message.credentialsFile))
                        return "credentialsFile: string expected";
                return null;
            };

            /**
             * Creates a GCPPubSubConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.GCPPubSubConn} GCPPubSubConn
             */
            GCPPubSubConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.GCPPubSubConn)
                    return object;
                var message = new $root.protos.args.GCPPubSubConn();
                if (object.projectId != null)
                    message.projectId = String(object.projectId);
                if (object.credentialsJson != null)
                    message.credentialsJson = String(object.credentialsJson);
                if (object.credentialsFile != null)
                    message.credentialsFile = String(object.credentialsFile);
                return message;
            };

            /**
             * Creates a plain object from a GCPPubSubConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {protos.args.GCPPubSubConn} message GCPPubSubConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GCPPubSubConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.projectId = "";
                    object.credentialsJson = "";
                    object.credentialsFile = "";
                }
                if (message.projectId != null && message.hasOwnProperty("projectId"))
                    object.projectId = message.projectId;
                if (message.credentialsJson != null && message.hasOwnProperty("credentialsJson"))
                    object.credentialsJson = message.credentialsJson;
                if (message.credentialsFile != null && message.hasOwnProperty("credentialsFile"))
                    object.credentialsFile = message.credentialsFile;
                return object;
            };

            /**
             * Converts this GCPPubSubConn to JSON.
             * @function toJSON
             * @memberof protos.args.GCPPubSubConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GCPPubSubConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GCPPubSubConn;
        })();

        args.GCPPubSubReadArgs = (function() {

            /**
             * Properties of a GCPPubSubReadArgs.
             * @memberof protos.args
             * @interface IGCPPubSubReadArgs
             * @property {string|null} [subscriptionId] GCPPubSubReadArgs subscriptionId
             * @property {boolean|null} [ackMessages] GCPPubSubReadArgs ackMessages
             */

            /**
             * Constructs a new GCPPubSubReadArgs.
             * @memberof protos.args
             * @classdesc Represents a GCPPubSubReadArgs.
             * @implements IGCPPubSubReadArgs
             * @constructor
             * @param {protos.args.IGCPPubSubReadArgs=} [properties] Properties to set
             */
            function GCPPubSubReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GCPPubSubReadArgs subscriptionId.
             * @member {string} subscriptionId
             * @memberof protos.args.GCPPubSubReadArgs
             * @instance
             */
            GCPPubSubReadArgs.prototype.subscriptionId = "";

            /**
             * GCPPubSubReadArgs ackMessages.
             * @member {boolean} ackMessages
             * @memberof protos.args.GCPPubSubReadArgs
             * @instance
             */
            GCPPubSubReadArgs.prototype.ackMessages = false;

            /**
             * Creates a new GCPPubSubReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {protos.args.IGCPPubSubReadArgs=} [properties] Properties to set
             * @returns {protos.args.GCPPubSubReadArgs} GCPPubSubReadArgs instance
             */
            GCPPubSubReadArgs.create = function create(properties) {
                return new GCPPubSubReadArgs(properties);
            };

            /**
             * Encodes the specified GCPPubSubReadArgs message. Does not implicitly {@link protos.args.GCPPubSubReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {protos.args.IGCPPubSubReadArgs} message GCPPubSubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subscriptionId != null && Object.hasOwnProperty.call(message, "subscriptionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.subscriptionId);
                if (message.ackMessages != null && Object.hasOwnProperty.call(message, "ackMessages"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.ackMessages);
                return writer;
            };

            /**
             * Encodes the specified GCPPubSubReadArgs message, length delimited. Does not implicitly {@link protos.args.GCPPubSubReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {protos.args.IGCPPubSubReadArgs} message GCPPubSubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GCPPubSubReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.GCPPubSubReadArgs} GCPPubSubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.GCPPubSubReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subscriptionId = reader.string();
                        break;
                    case 2:
                        message.ackMessages = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GCPPubSubReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.GCPPubSubReadArgs} GCPPubSubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GCPPubSubReadArgs message.
             * @function verify
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GCPPubSubReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subscriptionId != null && message.hasOwnProperty("subscriptionId"))
                    if (!$util.isString(message.subscriptionId))
                        return "subscriptionId: string expected";
                if (message.ackMessages != null && message.hasOwnProperty("ackMessages"))
                    if (typeof message.ackMessages !== "boolean")
                        return "ackMessages: boolean expected";
                return null;
            };

            /**
             * Creates a GCPPubSubReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.GCPPubSubReadArgs} GCPPubSubReadArgs
             */
            GCPPubSubReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.GCPPubSubReadArgs)
                    return object;
                var message = new $root.protos.args.GCPPubSubReadArgs();
                if (object.subscriptionId != null)
                    message.subscriptionId = String(object.subscriptionId);
                if (object.ackMessages != null)
                    message.ackMessages = Boolean(object.ackMessages);
                return message;
            };

            /**
             * Creates a plain object from a GCPPubSubReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {protos.args.GCPPubSubReadArgs} message GCPPubSubReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GCPPubSubReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.subscriptionId = "";
                    object.ackMessages = false;
                }
                if (message.subscriptionId != null && message.hasOwnProperty("subscriptionId"))
                    object.subscriptionId = message.subscriptionId;
                if (message.ackMessages != null && message.hasOwnProperty("ackMessages"))
                    object.ackMessages = message.ackMessages;
                return object;
            };

            /**
             * Converts this GCPPubSubReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.GCPPubSubReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GCPPubSubReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GCPPubSubReadArgs;
        })();

        args.GCPPubSubWriteArgs = (function() {

            /**
             * Properties of a GCPPubSubWriteArgs.
             * @memberof protos.args
             * @interface IGCPPubSubWriteArgs
             * @property {string|null} [topicId] GCPPubSubWriteArgs topicId
             */

            /**
             * Constructs a new GCPPubSubWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a GCPPubSubWriteArgs.
             * @implements IGCPPubSubWriteArgs
             * @constructor
             * @param {protos.args.IGCPPubSubWriteArgs=} [properties] Properties to set
             */
            function GCPPubSubWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GCPPubSubWriteArgs topicId.
             * @member {string} topicId
             * @memberof protos.args.GCPPubSubWriteArgs
             * @instance
             */
            GCPPubSubWriteArgs.prototype.topicId = "";

            /**
             * Creates a new GCPPubSubWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {protos.args.IGCPPubSubWriteArgs=} [properties] Properties to set
             * @returns {protos.args.GCPPubSubWriteArgs} GCPPubSubWriteArgs instance
             */
            GCPPubSubWriteArgs.create = function create(properties) {
                return new GCPPubSubWriteArgs(properties);
            };

            /**
             * Encodes the specified GCPPubSubWriteArgs message. Does not implicitly {@link protos.args.GCPPubSubWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {protos.args.IGCPPubSubWriteArgs} message GCPPubSubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topicId != null && Object.hasOwnProperty.call(message, "topicId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topicId);
                return writer;
            };

            /**
             * Encodes the specified GCPPubSubWriteArgs message, length delimited. Does not implicitly {@link protos.args.GCPPubSubWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {protos.args.IGCPPubSubWriteArgs} message GCPPubSubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GCPPubSubWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.GCPPubSubWriteArgs} GCPPubSubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.GCPPubSubWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topicId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GCPPubSubWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.GCPPubSubWriteArgs} GCPPubSubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GCPPubSubWriteArgs message.
             * @function verify
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GCPPubSubWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topicId != null && message.hasOwnProperty("topicId"))
                    if (!$util.isString(message.topicId))
                        return "topicId: string expected";
                return null;
            };

            /**
             * Creates a GCPPubSubWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.GCPPubSubWriteArgs} GCPPubSubWriteArgs
             */
            GCPPubSubWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.GCPPubSubWriteArgs)
                    return object;
                var message = new $root.protos.args.GCPPubSubWriteArgs();
                if (object.topicId != null)
                    message.topicId = String(object.topicId);
                return message;
            };

            /**
             * Creates a plain object from a GCPPubSubWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {protos.args.GCPPubSubWriteArgs} message GCPPubSubWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GCPPubSubWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.topicId = "";
                if (message.topicId != null && message.hasOwnProperty("topicId"))
                    object.topicId = message.topicId;
                return object;
            };

            /**
             * Converts this GCPPubSubWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.GCPPubSubWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GCPPubSubWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GCPPubSubWriteArgs;
        })();

        /**
         * SASLType enum.
         * @name protos.args.SASLType
         * @enum {number}
         * @property {number} NONE=0 NONE value
         * @property {number} PLAIN=1 PLAIN value
         * @property {number} SCRAM=2 SCRAM value
         */
        args.SASLType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NONE"] = 0;
            values[valuesById[1] = "PLAIN"] = 1;
            values[valuesById[2] = "SCRAM"] = 2;
            return values;
        })();

        args.KafkaConn = (function() {

            /**
             * Properties of a KafkaConn.
             * @memberof protos.args
             * @interface IKafkaConn
             * @property {Array.<string>|null} [address] KafkaConn address
             * @property {number|null} [timeoutSeconds] KafkaConn timeoutSeconds
             * @property {boolean|null} [useTls] KafkaConn useTls
             * @property {boolean|null} [tlsSkipVerify] KafkaConn tlsSkipVerify
             * @property {protos.args.SASLType|null} [saslType] KafkaConn saslType
             * @property {string|null} [saslUsername] KafkaConn saslUsername
             * @property {string|null} [saslPassword] KafkaConn saslPassword
             */

            /**
             * Constructs a new KafkaConn.
             * @memberof protos.args
             * @classdesc Represents a KafkaConn.
             * @implements IKafkaConn
             * @constructor
             * @param {protos.args.IKafkaConn=} [properties] Properties to set
             */
            function KafkaConn(properties) {
                this.address = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KafkaConn address.
             * @member {Array.<string>} address
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.address = $util.emptyArray;

            /**
             * KafkaConn timeoutSeconds.
             * @member {number} timeoutSeconds
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.timeoutSeconds = 0;

            /**
             * KafkaConn useTls.
             * @member {boolean} useTls
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.useTls = false;

            /**
             * KafkaConn tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.tlsSkipVerify = false;

            /**
             * KafkaConn saslType.
             * @member {protos.args.SASLType} saslType
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.saslType = 0;

            /**
             * KafkaConn saslUsername.
             * @member {string} saslUsername
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.saslUsername = "";

            /**
             * KafkaConn saslPassword.
             * @member {string} saslPassword
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.saslPassword = "";

            /**
             * Creates a new KafkaConn instance using the specified properties.
             * @function create
             * @memberof protos.args.KafkaConn
             * @static
             * @param {protos.args.IKafkaConn=} [properties] Properties to set
             * @returns {protos.args.KafkaConn} KafkaConn instance
             */
            KafkaConn.create = function create(properties) {
                return new KafkaConn(properties);
            };

            /**
             * Encodes the specified KafkaConn message. Does not implicitly {@link protos.args.KafkaConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KafkaConn
             * @static
             * @param {protos.args.IKafkaConn} message KafkaConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && message.address.length)
                    for (var i = 0; i < message.address.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.address[i]);
                if (message.timeoutSeconds != null && Object.hasOwnProperty.call(message, "timeoutSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.timeoutSeconds);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.useTls);
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.tlsSkipVerify);
                if (message.saslType != null && Object.hasOwnProperty.call(message, "saslType"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.saslType);
                if (message.saslUsername != null && Object.hasOwnProperty.call(message, "saslUsername"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.saslUsername);
                if (message.saslPassword != null && Object.hasOwnProperty.call(message, "saslPassword"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.saslPassword);
                return writer;
            };

            /**
             * Encodes the specified KafkaConn message, length delimited. Does not implicitly {@link protos.args.KafkaConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KafkaConn
             * @static
             * @param {protos.args.IKafkaConn} message KafkaConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KafkaConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KafkaConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KafkaConn} KafkaConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KafkaConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.address && message.address.length))
                            message.address = [];
                        message.address.push(reader.string());
                        break;
                    case 2:
                        message.timeoutSeconds = reader.int32();
                        break;
                    case 3:
                        message.useTls = reader.bool();
                        break;
                    case 4:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    case 5:
                        message.saslType = reader.int32();
                        break;
                    case 6:
                        message.saslUsername = reader.string();
                        break;
                    case 7:
                        message.saslPassword = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KafkaConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KafkaConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KafkaConn} KafkaConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KafkaConn message.
             * @function verify
             * @memberof protos.args.KafkaConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address")) {
                    if (!Array.isArray(message.address))
                        return "address: array expected";
                    for (var i = 0; i < message.address.length; ++i)
                        if (!$util.isString(message.address[i]))
                            return "address: string[] expected";
                }
                if (message.timeoutSeconds != null && message.hasOwnProperty("timeoutSeconds"))
                    if (!$util.isInteger(message.timeoutSeconds))
                        return "timeoutSeconds: integer expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                if (message.saslType != null && message.hasOwnProperty("saslType"))
                    switch (message.saslType) {
                    default:
                        return "saslType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.saslUsername != null && message.hasOwnProperty("saslUsername"))
                    if (!$util.isString(message.saslUsername))
                        return "saslUsername: string expected";
                if (message.saslPassword != null && message.hasOwnProperty("saslPassword"))
                    if (!$util.isString(message.saslPassword))
                        return "saslPassword: string expected";
                return null;
            };

            /**
             * Creates a KafkaConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KafkaConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KafkaConn} KafkaConn
             */
            KafkaConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KafkaConn)
                    return object;
                var message = new $root.protos.args.KafkaConn();
                if (object.address) {
                    if (!Array.isArray(object.address))
                        throw TypeError(".protos.args.KafkaConn.address: array expected");
                    message.address = [];
                    for (var i = 0; i < object.address.length; ++i)
                        message.address[i] = String(object.address[i]);
                }
                if (object.timeoutSeconds != null)
                    message.timeoutSeconds = object.timeoutSeconds | 0;
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                switch (object.saslType) {
                case "NONE":
                case 0:
                    message.saslType = 0;
                    break;
                case "PLAIN":
                case 1:
                    message.saslType = 1;
                    break;
                case "SCRAM":
                case 2:
                    message.saslType = 2;
                    break;
                }
                if (object.saslUsername != null)
                    message.saslUsername = String(object.saslUsername);
                if (object.saslPassword != null)
                    message.saslPassword = String(object.saslPassword);
                return message;
            };

            /**
             * Creates a plain object from a KafkaConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KafkaConn
             * @static
             * @param {protos.args.KafkaConn} message KafkaConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.address = [];
                if (options.defaults) {
                    object.timeoutSeconds = 0;
                    object.useTls = false;
                    object.tlsSkipVerify = false;
                    object.saslType = options.enums === String ? "NONE" : 0;
                    object.saslUsername = "";
                    object.saslPassword = "";
                }
                if (message.address && message.address.length) {
                    object.address = [];
                    for (var j = 0; j < message.address.length; ++j)
                        object.address[j] = message.address[j];
                }
                if (message.timeoutSeconds != null && message.hasOwnProperty("timeoutSeconds"))
                    object.timeoutSeconds = message.timeoutSeconds;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                if (message.saslType != null && message.hasOwnProperty("saslType"))
                    object.saslType = options.enums === String ? $root.protos.args.SASLType[message.saslType] : message.saslType;
                if (message.saslUsername != null && message.hasOwnProperty("saslUsername"))
                    object.saslUsername = message.saslUsername;
                if (message.saslPassword != null && message.hasOwnProperty("saslPassword"))
                    object.saslPassword = message.saslPassword;
                return object;
            };

            /**
             * Converts this KafkaConn to JSON.
             * @function toJSON
             * @memberof protos.args.KafkaConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KafkaConn;
        })();

        args.KafkaReadArgs = (function() {

            /**
             * Properties of a KafkaReadArgs.
             * @memberof protos.args
             * @interface IKafkaReadArgs
             * @property {Array.<string>|null} [topics] KafkaReadArgs topics
             * @property {number|Long|null} [readOffset] KafkaReadArgs readOffset
             * @property {boolean|null} [useConsumerGroup] KafkaReadArgs useConsumerGroup
             * @property {string|null} [consumerGroupName] KafkaReadArgs consumerGroupName
             * @property {number|null} [maxWaitSeconds] KafkaReadArgs maxWaitSeconds
             * @property {number|null} [minBytes] KafkaReadArgs minBytes
             * @property {number|null} [maxBytes] KafkaReadArgs maxBytes
             * @property {number|null} [commitIntervalSeconds] KafkaReadArgs commitIntervalSeconds
             * @property {number|null} [rebalanceTimeoutSeconds] KafkaReadArgs rebalanceTimeoutSeconds
             * @property {number|null} [queueCapacity] KafkaReadArgs queueCapacity
             * @property {boolean|null} [includeOffsetInfo] KafkaReadArgs includeOffsetInfo
             * @property {boolean|null} [lag] KafkaReadArgs lag
             * @property {string|null} [lagConsumerGroup] KafkaReadArgs lagConsumerGroup
             */

            /**
             * Constructs a new KafkaReadArgs.
             * @memberof protos.args
             * @classdesc Represents a KafkaReadArgs.
             * @implements IKafkaReadArgs
             * @constructor
             * @param {protos.args.IKafkaReadArgs=} [properties] Properties to set
             */
            function KafkaReadArgs(properties) {
                this.topics = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KafkaReadArgs topics.
             * @member {Array.<string>} topics
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.topics = $util.emptyArray;

            /**
             * KafkaReadArgs readOffset.
             * @member {number|Long} readOffset
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.readOffset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * KafkaReadArgs useConsumerGroup.
             * @member {boolean} useConsumerGroup
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.useConsumerGroup = false;

            /**
             * KafkaReadArgs consumerGroupName.
             * @member {string} consumerGroupName
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.consumerGroupName = "";

            /**
             * KafkaReadArgs maxWaitSeconds.
             * @member {number} maxWaitSeconds
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.maxWaitSeconds = 0;

            /**
             * KafkaReadArgs minBytes.
             * @member {number} minBytes
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.minBytes = 0;

            /**
             * KafkaReadArgs maxBytes.
             * @member {number} maxBytes
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.maxBytes = 0;

            /**
             * KafkaReadArgs commitIntervalSeconds.
             * @member {number} commitIntervalSeconds
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.commitIntervalSeconds = 0;

            /**
             * KafkaReadArgs rebalanceTimeoutSeconds.
             * @member {number} rebalanceTimeoutSeconds
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.rebalanceTimeoutSeconds = 0;

            /**
             * KafkaReadArgs queueCapacity.
             * @member {number} queueCapacity
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.queueCapacity = 0;

            /**
             * KafkaReadArgs includeOffsetInfo.
             * @member {boolean} includeOffsetInfo
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.includeOffsetInfo = false;

            /**
             * KafkaReadArgs lag.
             * @member {boolean} lag
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.lag = false;

            /**
             * KafkaReadArgs lagConsumerGroup.
             * @member {string} lagConsumerGroup
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.lagConsumerGroup = "";

            /**
             * Creates a new KafkaReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {protos.args.IKafkaReadArgs=} [properties] Properties to set
             * @returns {protos.args.KafkaReadArgs} KafkaReadArgs instance
             */
            KafkaReadArgs.create = function create(properties) {
                return new KafkaReadArgs(properties);
            };

            /**
             * Encodes the specified KafkaReadArgs message. Does not implicitly {@link protos.args.KafkaReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {protos.args.IKafkaReadArgs} message KafkaReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topics != null && message.topics.length)
                    for (var i = 0; i < message.topics.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.topics[i]);
                if (message.readOffset != null && Object.hasOwnProperty.call(message, "readOffset"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.readOffset);
                if (message.useConsumerGroup != null && Object.hasOwnProperty.call(message, "useConsumerGroup"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.useConsumerGroup);
                if (message.consumerGroupName != null && Object.hasOwnProperty.call(message, "consumerGroupName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.consumerGroupName);
                if (message.maxWaitSeconds != null && Object.hasOwnProperty.call(message, "maxWaitSeconds"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.maxWaitSeconds);
                if (message.minBytes != null && Object.hasOwnProperty.call(message, "minBytes"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.minBytes);
                if (message.maxBytes != null && Object.hasOwnProperty.call(message, "maxBytes"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.maxBytes);
                if (message.commitIntervalSeconds != null && Object.hasOwnProperty.call(message, "commitIntervalSeconds"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.commitIntervalSeconds);
                if (message.rebalanceTimeoutSeconds != null && Object.hasOwnProperty.call(message, "rebalanceTimeoutSeconds"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.rebalanceTimeoutSeconds);
                if (message.queueCapacity != null && Object.hasOwnProperty.call(message, "queueCapacity"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.queueCapacity);
                if (message.includeOffsetInfo != null && Object.hasOwnProperty.call(message, "includeOffsetInfo"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.includeOffsetInfo);
                if (message.lag != null && Object.hasOwnProperty.call(message, "lag"))
                    writer.uint32(/* id 12, wireType 0 =*/96).bool(message.lag);
                if (message.lagConsumerGroup != null && Object.hasOwnProperty.call(message, "lagConsumerGroup"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.lagConsumerGroup);
                return writer;
            };

            /**
             * Encodes the specified KafkaReadArgs message, length delimited. Does not implicitly {@link protos.args.KafkaReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {protos.args.IKafkaReadArgs} message KafkaReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KafkaReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KafkaReadArgs} KafkaReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KafkaReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.topics && message.topics.length))
                            message.topics = [];
                        message.topics.push(reader.string());
                        break;
                    case 2:
                        message.readOffset = reader.int64();
                        break;
                    case 3:
                        message.useConsumerGroup = reader.bool();
                        break;
                    case 4:
                        message.consumerGroupName = reader.string();
                        break;
                    case 5:
                        message.maxWaitSeconds = reader.int32();
                        break;
                    case 6:
                        message.minBytes = reader.int32();
                        break;
                    case 7:
                        message.maxBytes = reader.int32();
                        break;
                    case 8:
                        message.commitIntervalSeconds = reader.int32();
                        break;
                    case 9:
                        message.rebalanceTimeoutSeconds = reader.int32();
                        break;
                    case 10:
                        message.queueCapacity = reader.int32();
                        break;
                    case 11:
                        message.includeOffsetInfo = reader.bool();
                        break;
                    case 12:
                        message.lag = reader.bool();
                        break;
                    case 13:
                        message.lagConsumerGroup = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KafkaReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KafkaReadArgs} KafkaReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KafkaReadArgs message.
             * @function verify
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topics != null && message.hasOwnProperty("topics")) {
                    if (!Array.isArray(message.topics))
                        return "topics: array expected";
                    for (var i = 0; i < message.topics.length; ++i)
                        if (!$util.isString(message.topics[i]))
                            return "topics: string[] expected";
                }
                if (message.readOffset != null && message.hasOwnProperty("readOffset"))
                    if (!$util.isInteger(message.readOffset) && !(message.readOffset && $util.isInteger(message.readOffset.low) && $util.isInteger(message.readOffset.high)))
                        return "readOffset: integer|Long expected";
                if (message.useConsumerGroup != null && message.hasOwnProperty("useConsumerGroup"))
                    if (typeof message.useConsumerGroup !== "boolean")
                        return "useConsumerGroup: boolean expected";
                if (message.consumerGroupName != null && message.hasOwnProperty("consumerGroupName"))
                    if (!$util.isString(message.consumerGroupName))
                        return "consumerGroupName: string expected";
                if (message.maxWaitSeconds != null && message.hasOwnProperty("maxWaitSeconds"))
                    if (!$util.isInteger(message.maxWaitSeconds))
                        return "maxWaitSeconds: integer expected";
                if (message.minBytes != null && message.hasOwnProperty("minBytes"))
                    if (!$util.isInteger(message.minBytes))
                        return "minBytes: integer expected";
                if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
                    if (!$util.isInteger(message.maxBytes))
                        return "maxBytes: integer expected";
                if (message.commitIntervalSeconds != null && message.hasOwnProperty("commitIntervalSeconds"))
                    if (!$util.isInteger(message.commitIntervalSeconds))
                        return "commitIntervalSeconds: integer expected";
                if (message.rebalanceTimeoutSeconds != null && message.hasOwnProperty("rebalanceTimeoutSeconds"))
                    if (!$util.isInteger(message.rebalanceTimeoutSeconds))
                        return "rebalanceTimeoutSeconds: integer expected";
                if (message.queueCapacity != null && message.hasOwnProperty("queueCapacity"))
                    if (!$util.isInteger(message.queueCapacity))
                        return "queueCapacity: integer expected";
                if (message.includeOffsetInfo != null && message.hasOwnProperty("includeOffsetInfo"))
                    if (typeof message.includeOffsetInfo !== "boolean")
                        return "includeOffsetInfo: boolean expected";
                if (message.lag != null && message.hasOwnProperty("lag"))
                    if (typeof message.lag !== "boolean")
                        return "lag: boolean expected";
                if (message.lagConsumerGroup != null && message.hasOwnProperty("lagConsumerGroup"))
                    if (!$util.isString(message.lagConsumerGroup))
                        return "lagConsumerGroup: string expected";
                return null;
            };

            /**
             * Creates a KafkaReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KafkaReadArgs} KafkaReadArgs
             */
            KafkaReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KafkaReadArgs)
                    return object;
                var message = new $root.protos.args.KafkaReadArgs();
                if (object.topics) {
                    if (!Array.isArray(object.topics))
                        throw TypeError(".protos.args.KafkaReadArgs.topics: array expected");
                    message.topics = [];
                    for (var i = 0; i < object.topics.length; ++i)
                        message.topics[i] = String(object.topics[i]);
                }
                if (object.readOffset != null)
                    if ($util.Long)
                        (message.readOffset = $util.Long.fromValue(object.readOffset)).unsigned = false;
                    else if (typeof object.readOffset === "string")
                        message.readOffset = parseInt(object.readOffset, 10);
                    else if (typeof object.readOffset === "number")
                        message.readOffset = object.readOffset;
                    else if (typeof object.readOffset === "object")
                        message.readOffset = new $util.LongBits(object.readOffset.low >>> 0, object.readOffset.high >>> 0).toNumber();
                if (object.useConsumerGroup != null)
                    message.useConsumerGroup = Boolean(object.useConsumerGroup);
                if (object.consumerGroupName != null)
                    message.consumerGroupName = String(object.consumerGroupName);
                if (object.maxWaitSeconds != null)
                    message.maxWaitSeconds = object.maxWaitSeconds | 0;
                if (object.minBytes != null)
                    message.minBytes = object.minBytes | 0;
                if (object.maxBytes != null)
                    message.maxBytes = object.maxBytes | 0;
                if (object.commitIntervalSeconds != null)
                    message.commitIntervalSeconds = object.commitIntervalSeconds | 0;
                if (object.rebalanceTimeoutSeconds != null)
                    message.rebalanceTimeoutSeconds = object.rebalanceTimeoutSeconds | 0;
                if (object.queueCapacity != null)
                    message.queueCapacity = object.queueCapacity | 0;
                if (object.includeOffsetInfo != null)
                    message.includeOffsetInfo = Boolean(object.includeOffsetInfo);
                if (object.lag != null)
                    message.lag = Boolean(object.lag);
                if (object.lagConsumerGroup != null)
                    message.lagConsumerGroup = String(object.lagConsumerGroup);
                return message;
            };

            /**
             * Creates a plain object from a KafkaReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {protos.args.KafkaReadArgs} message KafkaReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.topics = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.readOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.readOffset = options.longs === String ? "0" : 0;
                    object.useConsumerGroup = false;
                    object.consumerGroupName = "";
                    object.maxWaitSeconds = 0;
                    object.minBytes = 0;
                    object.maxBytes = 0;
                    object.commitIntervalSeconds = 0;
                    object.rebalanceTimeoutSeconds = 0;
                    object.queueCapacity = 0;
                    object.includeOffsetInfo = false;
                    object.lag = false;
                    object.lagConsumerGroup = "";
                }
                if (message.topics && message.topics.length) {
                    object.topics = [];
                    for (var j = 0; j < message.topics.length; ++j)
                        object.topics[j] = message.topics[j];
                }
                if (message.readOffset != null && message.hasOwnProperty("readOffset"))
                    if (typeof message.readOffset === "number")
                        object.readOffset = options.longs === String ? String(message.readOffset) : message.readOffset;
                    else
                        object.readOffset = options.longs === String ? $util.Long.prototype.toString.call(message.readOffset) : options.longs === Number ? new $util.LongBits(message.readOffset.low >>> 0, message.readOffset.high >>> 0).toNumber() : message.readOffset;
                if (message.useConsumerGroup != null && message.hasOwnProperty("useConsumerGroup"))
                    object.useConsumerGroup = message.useConsumerGroup;
                if (message.consumerGroupName != null && message.hasOwnProperty("consumerGroupName"))
                    object.consumerGroupName = message.consumerGroupName;
                if (message.maxWaitSeconds != null && message.hasOwnProperty("maxWaitSeconds"))
                    object.maxWaitSeconds = message.maxWaitSeconds;
                if (message.minBytes != null && message.hasOwnProperty("minBytes"))
                    object.minBytes = message.minBytes;
                if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
                    object.maxBytes = message.maxBytes;
                if (message.commitIntervalSeconds != null && message.hasOwnProperty("commitIntervalSeconds"))
                    object.commitIntervalSeconds = message.commitIntervalSeconds;
                if (message.rebalanceTimeoutSeconds != null && message.hasOwnProperty("rebalanceTimeoutSeconds"))
                    object.rebalanceTimeoutSeconds = message.rebalanceTimeoutSeconds;
                if (message.queueCapacity != null && message.hasOwnProperty("queueCapacity"))
                    object.queueCapacity = message.queueCapacity;
                if (message.includeOffsetInfo != null && message.hasOwnProperty("includeOffsetInfo"))
                    object.includeOffsetInfo = message.includeOffsetInfo;
                if (message.lag != null && message.hasOwnProperty("lag"))
                    object.lag = message.lag;
                if (message.lagConsumerGroup != null && message.hasOwnProperty("lagConsumerGroup"))
                    object.lagConsumerGroup = message.lagConsumerGroup;
                return object;
            };

            /**
             * Converts this KafkaReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.KafkaReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KafkaReadArgs;
        })();

        args.KafkaWriteArgs = (function() {

            /**
             * Properties of a KafkaWriteArgs.
             * @memberof protos.args
             * @interface IKafkaWriteArgs
             * @property {string|null} [key] KafkaWriteArgs key
             * @property {Object.<string,string>|null} [headers] KafkaWriteArgs headers
             * @property {Array.<string>|null} [topics] KafkaWriteArgs topics
             */

            /**
             * Constructs a new KafkaWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a KafkaWriteArgs.
             * @implements IKafkaWriteArgs
             * @constructor
             * @param {protos.args.IKafkaWriteArgs=} [properties] Properties to set
             */
            function KafkaWriteArgs(properties) {
                this.headers = {};
                this.topics = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KafkaWriteArgs key.
             * @member {string} key
             * @memberof protos.args.KafkaWriteArgs
             * @instance
             */
            KafkaWriteArgs.prototype.key = "";

            /**
             * KafkaWriteArgs headers.
             * @member {Object.<string,string>} headers
             * @memberof protos.args.KafkaWriteArgs
             * @instance
             */
            KafkaWriteArgs.prototype.headers = $util.emptyObject;

            /**
             * KafkaWriteArgs topics.
             * @member {Array.<string>} topics
             * @memberof protos.args.KafkaWriteArgs
             * @instance
             */
            KafkaWriteArgs.prototype.topics = $util.emptyArray;

            /**
             * Creates a new KafkaWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {protos.args.IKafkaWriteArgs=} [properties] Properties to set
             * @returns {protos.args.KafkaWriteArgs} KafkaWriteArgs instance
             */
            KafkaWriteArgs.create = function create(properties) {
                return new KafkaWriteArgs(properties);
            };

            /**
             * Encodes the specified KafkaWriteArgs message. Does not implicitly {@link protos.args.KafkaWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {protos.args.IKafkaWriteArgs} message KafkaWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.headers != null && Object.hasOwnProperty.call(message, "headers"))
                    for (var keys = Object.keys(message.headers), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.headers[keys[i]]).ldelim();
                if (message.topics != null && message.topics.length)
                    for (var i = 0; i < message.topics.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.topics[i]);
                return writer;
            };

            /**
             * Encodes the specified KafkaWriteArgs message, length delimited. Does not implicitly {@link protos.args.KafkaWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {protos.args.IKafkaWriteArgs} message KafkaWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KafkaWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KafkaWriteArgs} KafkaWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KafkaWriteArgs(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        if (message.headers === $util.emptyObject)
                            message.headers = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.headers[key] = value;
                        break;
                    case 3:
                        if (!(message.topics && message.topics.length))
                            message.topics = [];
                        message.topics.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KafkaWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KafkaWriteArgs} KafkaWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KafkaWriteArgs message.
             * @function verify
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    if (!$util.isObject(message.headers))
                        return "headers: object expected";
                    var key = Object.keys(message.headers);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.headers[key[i]]))
                            return "headers: string{k:string} expected";
                }
                if (message.topics != null && message.hasOwnProperty("topics")) {
                    if (!Array.isArray(message.topics))
                        return "topics: array expected";
                    for (var i = 0; i < message.topics.length; ++i)
                        if (!$util.isString(message.topics[i]))
                            return "topics: string[] expected";
                }
                return null;
            };

            /**
             * Creates a KafkaWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KafkaWriteArgs} KafkaWriteArgs
             */
            KafkaWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KafkaWriteArgs)
                    return object;
                var message = new $root.protos.args.KafkaWriteArgs();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.headers) {
                    if (typeof object.headers !== "object")
                        throw TypeError(".protos.args.KafkaWriteArgs.headers: object expected");
                    message.headers = {};
                    for (var keys = Object.keys(object.headers), i = 0; i < keys.length; ++i)
                        message.headers[keys[i]] = String(object.headers[keys[i]]);
                }
                if (object.topics) {
                    if (!Array.isArray(object.topics))
                        throw TypeError(".protos.args.KafkaWriteArgs.topics: array expected");
                    message.topics = [];
                    for (var i = 0; i < object.topics.length; ++i)
                        message.topics[i] = String(object.topics[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a KafkaWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {protos.args.KafkaWriteArgs} message KafkaWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.topics = [];
                if (options.objects || options.defaults)
                    object.headers = {};
                if (options.defaults)
                    object.key = "";
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                var keys2;
                if (message.headers && (keys2 = Object.keys(message.headers)).length) {
                    object.headers = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.headers[keys2[j]] = message.headers[keys2[j]];
                }
                if (message.topics && message.topics.length) {
                    object.topics = [];
                    for (var j = 0; j < message.topics.length; ++j)
                        object.topics[j] = message.topics[j];
                }
                return object;
            };

            /**
             * Converts this KafkaWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.KafkaWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KafkaWriteArgs;
        })();

        args.KafkaRelayArgs = (function() {

            /**
             * Properties of a KafkaRelayArgs.
             * @memberof protos.args
             * @interface IKafkaRelayArgs
             * @property {Array.<string>|null} [topics] KafkaRelayArgs topics
             * @property {number|Long|null} [readOffset] KafkaRelayArgs readOffset
             * @property {boolean|null} [useConsumerGroup] KafkaRelayArgs useConsumerGroup
             * @property {string|null} [consumerGroupName] KafkaRelayArgs consumerGroupName
             * @property {number|null} [maxWaitSeconds] KafkaRelayArgs maxWaitSeconds
             * @property {number|null} [minBytes] KafkaRelayArgs minBytes
             * @property {number|null} [maxBytes] KafkaRelayArgs maxBytes
             * @property {number|null} [commitIntervalSeconds] KafkaRelayArgs commitIntervalSeconds
             * @property {number|null} [rebalanceTimeoutSeconds] KafkaRelayArgs rebalanceTimeoutSeconds
             * @property {number|null} [queueCapacity] KafkaRelayArgs queueCapacity
             */

            /**
             * Constructs a new KafkaRelayArgs.
             * @memberof protos.args
             * @classdesc Represents a KafkaRelayArgs.
             * @implements IKafkaRelayArgs
             * @constructor
             * @param {protos.args.IKafkaRelayArgs=} [properties] Properties to set
             */
            function KafkaRelayArgs(properties) {
                this.topics = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KafkaRelayArgs topics.
             * @member {Array.<string>} topics
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.topics = $util.emptyArray;

            /**
             * KafkaRelayArgs readOffset.
             * @member {number|Long} readOffset
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.readOffset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * KafkaRelayArgs useConsumerGroup.
             * @member {boolean} useConsumerGroup
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.useConsumerGroup = false;

            /**
             * KafkaRelayArgs consumerGroupName.
             * @member {string} consumerGroupName
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.consumerGroupName = "";

            /**
             * KafkaRelayArgs maxWaitSeconds.
             * @member {number} maxWaitSeconds
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.maxWaitSeconds = 0;

            /**
             * KafkaRelayArgs minBytes.
             * @member {number} minBytes
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.minBytes = 0;

            /**
             * KafkaRelayArgs maxBytes.
             * @member {number} maxBytes
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.maxBytes = 0;

            /**
             * KafkaRelayArgs commitIntervalSeconds.
             * @member {number} commitIntervalSeconds
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.commitIntervalSeconds = 0;

            /**
             * KafkaRelayArgs rebalanceTimeoutSeconds.
             * @member {number} rebalanceTimeoutSeconds
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.rebalanceTimeoutSeconds = 0;

            /**
             * KafkaRelayArgs queueCapacity.
             * @member {number} queueCapacity
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.queueCapacity = 0;

            /**
             * Creates a new KafkaRelayArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {protos.args.IKafkaRelayArgs=} [properties] Properties to set
             * @returns {protos.args.KafkaRelayArgs} KafkaRelayArgs instance
             */
            KafkaRelayArgs.create = function create(properties) {
                return new KafkaRelayArgs(properties);
            };

            /**
             * Encodes the specified KafkaRelayArgs message. Does not implicitly {@link protos.args.KafkaRelayArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {protos.args.IKafkaRelayArgs} message KafkaRelayArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaRelayArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topics != null && message.topics.length)
                    for (var i = 0; i < message.topics.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.topics[i]);
                if (message.readOffset != null && Object.hasOwnProperty.call(message, "readOffset"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.readOffset);
                if (message.useConsumerGroup != null && Object.hasOwnProperty.call(message, "useConsumerGroup"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.useConsumerGroup);
                if (message.consumerGroupName != null && Object.hasOwnProperty.call(message, "consumerGroupName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.consumerGroupName);
                if (message.maxWaitSeconds != null && Object.hasOwnProperty.call(message, "maxWaitSeconds"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.maxWaitSeconds);
                if (message.minBytes != null && Object.hasOwnProperty.call(message, "minBytes"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.minBytes);
                if (message.maxBytes != null && Object.hasOwnProperty.call(message, "maxBytes"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.maxBytes);
                if (message.commitIntervalSeconds != null && Object.hasOwnProperty.call(message, "commitIntervalSeconds"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.commitIntervalSeconds);
                if (message.rebalanceTimeoutSeconds != null && Object.hasOwnProperty.call(message, "rebalanceTimeoutSeconds"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.rebalanceTimeoutSeconds);
                if (message.queueCapacity != null && Object.hasOwnProperty.call(message, "queueCapacity"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.queueCapacity);
                return writer;
            };

            /**
             * Encodes the specified KafkaRelayArgs message, length delimited. Does not implicitly {@link protos.args.KafkaRelayArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {protos.args.IKafkaRelayArgs} message KafkaRelayArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaRelayArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KafkaRelayArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KafkaRelayArgs} KafkaRelayArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaRelayArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KafkaRelayArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.topics && message.topics.length))
                            message.topics = [];
                        message.topics.push(reader.string());
                        break;
                    case 2:
                        message.readOffset = reader.int64();
                        break;
                    case 3:
                        message.useConsumerGroup = reader.bool();
                        break;
                    case 4:
                        message.consumerGroupName = reader.string();
                        break;
                    case 5:
                        message.maxWaitSeconds = reader.int32();
                        break;
                    case 6:
                        message.minBytes = reader.int32();
                        break;
                    case 7:
                        message.maxBytes = reader.int32();
                        break;
                    case 8:
                        message.commitIntervalSeconds = reader.int32();
                        break;
                    case 9:
                        message.rebalanceTimeoutSeconds = reader.int32();
                        break;
                    case 10:
                        message.queueCapacity = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KafkaRelayArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KafkaRelayArgs} KafkaRelayArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaRelayArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KafkaRelayArgs message.
             * @function verify
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaRelayArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topics != null && message.hasOwnProperty("topics")) {
                    if (!Array.isArray(message.topics))
                        return "topics: array expected";
                    for (var i = 0; i < message.topics.length; ++i)
                        if (!$util.isString(message.topics[i]))
                            return "topics: string[] expected";
                }
                if (message.readOffset != null && message.hasOwnProperty("readOffset"))
                    if (!$util.isInteger(message.readOffset) && !(message.readOffset && $util.isInteger(message.readOffset.low) && $util.isInteger(message.readOffset.high)))
                        return "readOffset: integer|Long expected";
                if (message.useConsumerGroup != null && message.hasOwnProperty("useConsumerGroup"))
                    if (typeof message.useConsumerGroup !== "boolean")
                        return "useConsumerGroup: boolean expected";
                if (message.consumerGroupName != null && message.hasOwnProperty("consumerGroupName"))
                    if (!$util.isString(message.consumerGroupName))
                        return "consumerGroupName: string expected";
                if (message.maxWaitSeconds != null && message.hasOwnProperty("maxWaitSeconds"))
                    if (!$util.isInteger(message.maxWaitSeconds))
                        return "maxWaitSeconds: integer expected";
                if (message.minBytes != null && message.hasOwnProperty("minBytes"))
                    if (!$util.isInteger(message.minBytes))
                        return "minBytes: integer expected";
                if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
                    if (!$util.isInteger(message.maxBytes))
                        return "maxBytes: integer expected";
                if (message.commitIntervalSeconds != null && message.hasOwnProperty("commitIntervalSeconds"))
                    if (!$util.isInteger(message.commitIntervalSeconds))
                        return "commitIntervalSeconds: integer expected";
                if (message.rebalanceTimeoutSeconds != null && message.hasOwnProperty("rebalanceTimeoutSeconds"))
                    if (!$util.isInteger(message.rebalanceTimeoutSeconds))
                        return "rebalanceTimeoutSeconds: integer expected";
                if (message.queueCapacity != null && message.hasOwnProperty("queueCapacity"))
                    if (!$util.isInteger(message.queueCapacity))
                        return "queueCapacity: integer expected";
                return null;
            };

            /**
             * Creates a KafkaRelayArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KafkaRelayArgs} KafkaRelayArgs
             */
            KafkaRelayArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KafkaRelayArgs)
                    return object;
                var message = new $root.protos.args.KafkaRelayArgs();
                if (object.topics) {
                    if (!Array.isArray(object.topics))
                        throw TypeError(".protos.args.KafkaRelayArgs.topics: array expected");
                    message.topics = [];
                    for (var i = 0; i < object.topics.length; ++i)
                        message.topics[i] = String(object.topics[i]);
                }
                if (object.readOffset != null)
                    if ($util.Long)
                        (message.readOffset = $util.Long.fromValue(object.readOffset)).unsigned = false;
                    else if (typeof object.readOffset === "string")
                        message.readOffset = parseInt(object.readOffset, 10);
                    else if (typeof object.readOffset === "number")
                        message.readOffset = object.readOffset;
                    else if (typeof object.readOffset === "object")
                        message.readOffset = new $util.LongBits(object.readOffset.low >>> 0, object.readOffset.high >>> 0).toNumber();
                if (object.useConsumerGroup != null)
                    message.useConsumerGroup = Boolean(object.useConsumerGroup);
                if (object.consumerGroupName != null)
                    message.consumerGroupName = String(object.consumerGroupName);
                if (object.maxWaitSeconds != null)
                    message.maxWaitSeconds = object.maxWaitSeconds | 0;
                if (object.minBytes != null)
                    message.minBytes = object.minBytes | 0;
                if (object.maxBytes != null)
                    message.maxBytes = object.maxBytes | 0;
                if (object.commitIntervalSeconds != null)
                    message.commitIntervalSeconds = object.commitIntervalSeconds | 0;
                if (object.rebalanceTimeoutSeconds != null)
                    message.rebalanceTimeoutSeconds = object.rebalanceTimeoutSeconds | 0;
                if (object.queueCapacity != null)
                    message.queueCapacity = object.queueCapacity | 0;
                return message;
            };

            /**
             * Creates a plain object from a KafkaRelayArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {protos.args.KafkaRelayArgs} message KafkaRelayArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaRelayArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.topics = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.readOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.readOffset = options.longs === String ? "0" : 0;
                    object.useConsumerGroup = false;
                    object.consumerGroupName = "";
                    object.maxWaitSeconds = 0;
                    object.minBytes = 0;
                    object.maxBytes = 0;
                    object.commitIntervalSeconds = 0;
                    object.rebalanceTimeoutSeconds = 0;
                    object.queueCapacity = 0;
                }
                if (message.topics && message.topics.length) {
                    object.topics = [];
                    for (var j = 0; j < message.topics.length; ++j)
                        object.topics[j] = message.topics[j];
                }
                if (message.readOffset != null && message.hasOwnProperty("readOffset"))
                    if (typeof message.readOffset === "number")
                        object.readOffset = options.longs === String ? String(message.readOffset) : message.readOffset;
                    else
                        object.readOffset = options.longs === String ? $util.Long.prototype.toString.call(message.readOffset) : options.longs === Number ? new $util.LongBits(message.readOffset.low >>> 0, message.readOffset.high >>> 0).toNumber() : message.readOffset;
                if (message.useConsumerGroup != null && message.hasOwnProperty("useConsumerGroup"))
                    object.useConsumerGroup = message.useConsumerGroup;
                if (message.consumerGroupName != null && message.hasOwnProperty("consumerGroupName"))
                    object.consumerGroupName = message.consumerGroupName;
                if (message.maxWaitSeconds != null && message.hasOwnProperty("maxWaitSeconds"))
                    object.maxWaitSeconds = message.maxWaitSeconds;
                if (message.minBytes != null && message.hasOwnProperty("minBytes"))
                    object.minBytes = message.minBytes;
                if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
                    object.maxBytes = message.maxBytes;
                if (message.commitIntervalSeconds != null && message.hasOwnProperty("commitIntervalSeconds"))
                    object.commitIntervalSeconds = message.commitIntervalSeconds;
                if (message.rebalanceTimeoutSeconds != null && message.hasOwnProperty("rebalanceTimeoutSeconds"))
                    object.rebalanceTimeoutSeconds = message.rebalanceTimeoutSeconds;
                if (message.queueCapacity != null && message.hasOwnProperty("queueCapacity"))
                    object.queueCapacity = message.queueCapacity;
                return object;
            };

            /**
             * Converts this KafkaRelayArgs to JSON.
             * @function toJSON
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaRelayArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KafkaRelayArgs;
        })();

        args.KubeMQQueueConn = (function() {

            /**
             * Properties of a KubeMQQueueConn.
             * @memberof protos.args
             * @interface IKubeMQQueueConn
             * @property {string|null} [address] KubeMQQueueConn address
             * @property {string|null} [authToken] KubeMQQueueConn authToken
             * @property {string|null} [tlsClientCert] KubeMQQueueConn tlsClientCert
             * @property {string|null} [clientId] KubeMQQueueConn clientId
             */

            /**
             * Constructs a new KubeMQQueueConn.
             * @memberof protos.args
             * @classdesc Represents a KubeMQQueueConn.
             * @implements IKubeMQQueueConn
             * @constructor
             * @param {protos.args.IKubeMQQueueConn=} [properties] Properties to set
             */
            function KubeMQQueueConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KubeMQQueueConn address.
             * @member {string} address
             * @memberof protos.args.KubeMQQueueConn
             * @instance
             */
            KubeMQQueueConn.prototype.address = "";

            /**
             * KubeMQQueueConn authToken.
             * @member {string} authToken
             * @memberof protos.args.KubeMQQueueConn
             * @instance
             */
            KubeMQQueueConn.prototype.authToken = "";

            /**
             * KubeMQQueueConn tlsClientCert.
             * @member {string} tlsClientCert
             * @memberof protos.args.KubeMQQueueConn
             * @instance
             */
            KubeMQQueueConn.prototype.tlsClientCert = "";

            /**
             * KubeMQQueueConn clientId.
             * @member {string} clientId
             * @memberof protos.args.KubeMQQueueConn
             * @instance
             */
            KubeMQQueueConn.prototype.clientId = "";

            /**
             * Creates a new KubeMQQueueConn instance using the specified properties.
             * @function create
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {protos.args.IKubeMQQueueConn=} [properties] Properties to set
             * @returns {protos.args.KubeMQQueueConn} KubeMQQueueConn instance
             */
            KubeMQQueueConn.create = function create(properties) {
                return new KubeMQQueueConn(properties);
            };

            /**
             * Encodes the specified KubeMQQueueConn message. Does not implicitly {@link protos.args.KubeMQQueueConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {protos.args.IKubeMQQueueConn} message KubeMQQueueConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.authToken != null && Object.hasOwnProperty.call(message, "authToken"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.authToken);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.tlsClientCert);
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.clientId);
                return writer;
            };

            /**
             * Encodes the specified KubeMQQueueConn message, length delimited. Does not implicitly {@link protos.args.KubeMQQueueConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {protos.args.IKubeMQQueueConn} message KubeMQQueueConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KubeMQQueueConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KubeMQQueueConn} KubeMQQueueConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KubeMQQueueConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.authToken = reader.string();
                        break;
                    case 3:
                        message.tlsClientCert = reader.string();
                        break;
                    case 4:
                        message.clientId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KubeMQQueueConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KubeMQQueueConn} KubeMQQueueConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KubeMQQueueConn message.
             * @function verify
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KubeMQQueueConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.authToken != null && message.hasOwnProperty("authToken"))
                    if (!$util.isString(message.authToken))
                        return "authToken: string expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!$util.isString(message.tlsClientCert))
                        return "tlsClientCert: string expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                return null;
            };

            /**
             * Creates a KubeMQQueueConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KubeMQQueueConn} KubeMQQueueConn
             */
            KubeMQQueueConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KubeMQQueueConn)
                    return object;
                var message = new $root.protos.args.KubeMQQueueConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.authToken != null)
                    message.authToken = String(object.authToken);
                if (object.tlsClientCert != null)
                    message.tlsClientCert = String(object.tlsClientCert);
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                return message;
            };

            /**
             * Creates a plain object from a KubeMQQueueConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {protos.args.KubeMQQueueConn} message KubeMQQueueConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KubeMQQueueConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = "";
                    object.authToken = "";
                    object.tlsClientCert = "";
                    object.clientId = "";
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.authToken != null && message.hasOwnProperty("authToken"))
                    object.authToken = message.authToken;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = message.tlsClientCert;
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                return object;
            };

            /**
             * Converts this KubeMQQueueConn to JSON.
             * @function toJSON
             * @memberof protos.args.KubeMQQueueConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KubeMQQueueConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KubeMQQueueConn;
        })();

        args.KubeMQQueueReadArgs = (function() {

            /**
             * Properties of a KubeMQQueueReadArgs.
             * @memberof protos.args
             * @interface IKubeMQQueueReadArgs
             * @property {string|null} [queueName] KubeMQQueueReadArgs queueName
             */

            /**
             * Constructs a new KubeMQQueueReadArgs.
             * @memberof protos.args
             * @classdesc Represents a KubeMQQueueReadArgs.
             * @implements IKubeMQQueueReadArgs
             * @constructor
             * @param {protos.args.IKubeMQQueueReadArgs=} [properties] Properties to set
             */
            function KubeMQQueueReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KubeMQQueueReadArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.KubeMQQueueReadArgs
             * @instance
             */
            KubeMQQueueReadArgs.prototype.queueName = "";

            /**
             * Creates a new KubeMQQueueReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {protos.args.IKubeMQQueueReadArgs=} [properties] Properties to set
             * @returns {protos.args.KubeMQQueueReadArgs} KubeMQQueueReadArgs instance
             */
            KubeMQQueueReadArgs.create = function create(properties) {
                return new KubeMQQueueReadArgs(properties);
            };

            /**
             * Encodes the specified KubeMQQueueReadArgs message. Does not implicitly {@link protos.args.KubeMQQueueReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {protos.args.IKubeMQQueueReadArgs} message KubeMQQueueReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queueName);
                return writer;
            };

            /**
             * Encodes the specified KubeMQQueueReadArgs message, length delimited. Does not implicitly {@link protos.args.KubeMQQueueReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {protos.args.IKubeMQQueueReadArgs} message KubeMQQueueReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KubeMQQueueReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KubeMQQueueReadArgs} KubeMQQueueReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KubeMQQueueReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queueName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KubeMQQueueReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KubeMQQueueReadArgs} KubeMQQueueReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KubeMQQueueReadArgs message.
             * @function verify
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KubeMQQueueReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                return null;
            };

            /**
             * Creates a KubeMQQueueReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KubeMQQueueReadArgs} KubeMQQueueReadArgs
             */
            KubeMQQueueReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KubeMQQueueReadArgs)
                    return object;
                var message = new $root.protos.args.KubeMQQueueReadArgs();
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                return message;
            };

            /**
             * Creates a plain object from a KubeMQQueueReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {protos.args.KubeMQQueueReadArgs} message KubeMQQueueReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KubeMQQueueReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.queueName = "";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                return object;
            };

            /**
             * Converts this KubeMQQueueReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.KubeMQQueueReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KubeMQQueueReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KubeMQQueueReadArgs;
        })();

        args.KubeMQQueueWriteArgs = (function() {

            /**
             * Properties of a KubeMQQueueWriteArgs.
             * @memberof protos.args
             * @interface IKubeMQQueueWriteArgs
             * @property {string|null} [queueName] KubeMQQueueWriteArgs queueName
             */

            /**
             * Constructs a new KubeMQQueueWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a KubeMQQueueWriteArgs.
             * @implements IKubeMQQueueWriteArgs
             * @constructor
             * @param {protos.args.IKubeMQQueueWriteArgs=} [properties] Properties to set
             */
            function KubeMQQueueWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KubeMQQueueWriteArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @instance
             */
            KubeMQQueueWriteArgs.prototype.queueName = "";

            /**
             * Creates a new KubeMQQueueWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {protos.args.IKubeMQQueueWriteArgs=} [properties] Properties to set
             * @returns {protos.args.KubeMQQueueWriteArgs} KubeMQQueueWriteArgs instance
             */
            KubeMQQueueWriteArgs.create = function create(properties) {
                return new KubeMQQueueWriteArgs(properties);
            };

            /**
             * Encodes the specified KubeMQQueueWriteArgs message. Does not implicitly {@link protos.args.KubeMQQueueWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {protos.args.IKubeMQQueueWriteArgs} message KubeMQQueueWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queueName);
                return writer;
            };

            /**
             * Encodes the specified KubeMQQueueWriteArgs message, length delimited. Does not implicitly {@link protos.args.KubeMQQueueWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {protos.args.IKubeMQQueueWriteArgs} message KubeMQQueueWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KubeMQQueueWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KubeMQQueueWriteArgs} KubeMQQueueWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KubeMQQueueWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queueName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KubeMQQueueWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KubeMQQueueWriteArgs} KubeMQQueueWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KubeMQQueueWriteArgs message.
             * @function verify
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KubeMQQueueWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                return null;
            };

            /**
             * Creates a KubeMQQueueWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KubeMQQueueWriteArgs} KubeMQQueueWriteArgs
             */
            KubeMQQueueWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KubeMQQueueWriteArgs)
                    return object;
                var message = new $root.protos.args.KubeMQQueueWriteArgs();
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                return message;
            };

            /**
             * Creates a plain object from a KubeMQQueueWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {protos.args.KubeMQQueueWriteArgs} message KubeMQQueueWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KubeMQQueueWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.queueName = "";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                return object;
            };

            /**
             * Converts this KubeMQQueueWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KubeMQQueueWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KubeMQQueueWriteArgs;
        })();

        args.MemphisConn = (function() {

            /**
             * Properties of a MemphisConn.
             * @memberof protos.args
             * @interface IMemphisConn
             * @property {string|null} [address] MemphisConn address
             * @property {string|null} [username] MemphisConn username
             * @property {string|null} [brokerToken] MemphisConn brokerToken
             */

            /**
             * Constructs a new MemphisConn.
             * @memberof protos.args
             * @classdesc Represents a MemphisConn.
             * @implements IMemphisConn
             * @constructor
             * @param {protos.args.IMemphisConn=} [properties] Properties to set
             */
            function MemphisConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MemphisConn address.
             * @member {string} address
             * @memberof protos.args.MemphisConn
             * @instance
             */
            MemphisConn.prototype.address = "";

            /**
             * MemphisConn username.
             * @member {string} username
             * @memberof protos.args.MemphisConn
             * @instance
             */
            MemphisConn.prototype.username = "";

            /**
             * MemphisConn brokerToken.
             * @member {string} brokerToken
             * @memberof protos.args.MemphisConn
             * @instance
             */
            MemphisConn.prototype.brokerToken = "";

            /**
             * Creates a new MemphisConn instance using the specified properties.
             * @function create
             * @memberof protos.args.MemphisConn
             * @static
             * @param {protos.args.IMemphisConn=} [properties] Properties to set
             * @returns {protos.args.MemphisConn} MemphisConn instance
             */
            MemphisConn.create = function create(properties) {
                return new MemphisConn(properties);
            };

            /**
             * Encodes the specified MemphisConn message. Does not implicitly {@link protos.args.MemphisConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MemphisConn
             * @static
             * @param {protos.args.IMemphisConn} message MemphisConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemphisConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
                if (message.brokerToken != null && Object.hasOwnProperty.call(message, "brokerToken"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.brokerToken);
                return writer;
            };

            /**
             * Encodes the specified MemphisConn message, length delimited. Does not implicitly {@link protos.args.MemphisConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MemphisConn
             * @static
             * @param {protos.args.IMemphisConn} message MemphisConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemphisConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MemphisConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MemphisConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MemphisConn} MemphisConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemphisConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MemphisConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.username = reader.string();
                        break;
                    case 3:
                        message.brokerToken = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MemphisConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MemphisConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MemphisConn} MemphisConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemphisConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MemphisConn message.
             * @function verify
             * @memberof protos.args.MemphisConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MemphisConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.brokerToken != null && message.hasOwnProperty("brokerToken"))
                    if (!$util.isString(message.brokerToken))
                        return "brokerToken: string expected";
                return null;
            };

            /**
             * Creates a MemphisConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MemphisConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MemphisConn} MemphisConn
             */
            MemphisConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MemphisConn)
                    return object;
                var message = new $root.protos.args.MemphisConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.username != null)
                    message.username = String(object.username);
                if (object.brokerToken != null)
                    message.brokerToken = String(object.brokerToken);
                return message;
            };

            /**
             * Creates a plain object from a MemphisConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MemphisConn
             * @static
             * @param {protos.args.MemphisConn} message MemphisConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MemphisConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = "";
                    object.username = "";
                    object.brokerToken = "";
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.brokerToken != null && message.hasOwnProperty("brokerToken"))
                    object.brokerToken = message.brokerToken;
                return object;
            };

            /**
             * Converts this MemphisConn to JSON.
             * @function toJSON
             * @memberof protos.args.MemphisConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MemphisConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MemphisConn;
        })();

        args.MemphisReadArgs = (function() {

            /**
             * Properties of a MemphisReadArgs.
             * @memberof protos.args
             * @interface IMemphisReadArgs
             * @property {string|null} [station] MemphisReadArgs station
             * @property {string|null} [consumerName] MemphisReadArgs consumerName
             * @property {string|null} [consumerGroup] MemphisReadArgs consumerGroup
             */

            /**
             * Constructs a new MemphisReadArgs.
             * @memberof protos.args
             * @classdesc Represents a MemphisReadArgs.
             * @implements IMemphisReadArgs
             * @constructor
             * @param {protos.args.IMemphisReadArgs=} [properties] Properties to set
             */
            function MemphisReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MemphisReadArgs station.
             * @member {string} station
             * @memberof protos.args.MemphisReadArgs
             * @instance
             */
            MemphisReadArgs.prototype.station = "";

            /**
             * MemphisReadArgs consumerName.
             * @member {string} consumerName
             * @memberof protos.args.MemphisReadArgs
             * @instance
             */
            MemphisReadArgs.prototype.consumerName = "";

            /**
             * MemphisReadArgs consumerGroup.
             * @member {string} consumerGroup
             * @memberof protos.args.MemphisReadArgs
             * @instance
             */
            MemphisReadArgs.prototype.consumerGroup = "";

            /**
             * Creates a new MemphisReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.MemphisReadArgs
             * @static
             * @param {protos.args.IMemphisReadArgs=} [properties] Properties to set
             * @returns {protos.args.MemphisReadArgs} MemphisReadArgs instance
             */
            MemphisReadArgs.create = function create(properties) {
                return new MemphisReadArgs(properties);
            };

            /**
             * Encodes the specified MemphisReadArgs message. Does not implicitly {@link protos.args.MemphisReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MemphisReadArgs
             * @static
             * @param {protos.args.IMemphisReadArgs} message MemphisReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemphisReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.station != null && Object.hasOwnProperty.call(message, "station"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.station);
                if (message.consumerName != null && Object.hasOwnProperty.call(message, "consumerName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.consumerName);
                if (message.consumerGroup != null && Object.hasOwnProperty.call(message, "consumerGroup"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.consumerGroup);
                return writer;
            };

            /**
             * Encodes the specified MemphisReadArgs message, length delimited. Does not implicitly {@link protos.args.MemphisReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MemphisReadArgs
             * @static
             * @param {protos.args.IMemphisReadArgs} message MemphisReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemphisReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MemphisReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MemphisReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MemphisReadArgs} MemphisReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemphisReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MemphisReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.station = reader.string();
                        break;
                    case 2:
                        message.consumerName = reader.string();
                        break;
                    case 3:
                        message.consumerGroup = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MemphisReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MemphisReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MemphisReadArgs} MemphisReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemphisReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MemphisReadArgs message.
             * @function verify
             * @memberof protos.args.MemphisReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MemphisReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.station != null && message.hasOwnProperty("station"))
                    if (!$util.isString(message.station))
                        return "station: string expected";
                if (message.consumerName != null && message.hasOwnProperty("consumerName"))
                    if (!$util.isString(message.consumerName))
                        return "consumerName: string expected";
                if (message.consumerGroup != null && message.hasOwnProperty("consumerGroup"))
                    if (!$util.isString(message.consumerGroup))
                        return "consumerGroup: string expected";
                return null;
            };

            /**
             * Creates a MemphisReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MemphisReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MemphisReadArgs} MemphisReadArgs
             */
            MemphisReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MemphisReadArgs)
                    return object;
                var message = new $root.protos.args.MemphisReadArgs();
                if (object.station != null)
                    message.station = String(object.station);
                if (object.consumerName != null)
                    message.consumerName = String(object.consumerName);
                if (object.consumerGroup != null)
                    message.consumerGroup = String(object.consumerGroup);
                return message;
            };

            /**
             * Creates a plain object from a MemphisReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MemphisReadArgs
             * @static
             * @param {protos.args.MemphisReadArgs} message MemphisReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MemphisReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.station = "";
                    object.consumerName = "";
                    object.consumerGroup = "";
                }
                if (message.station != null && message.hasOwnProperty("station"))
                    object.station = message.station;
                if (message.consumerName != null && message.hasOwnProperty("consumerName"))
                    object.consumerName = message.consumerName;
                if (message.consumerGroup != null && message.hasOwnProperty("consumerGroup"))
                    object.consumerGroup = message.consumerGroup;
                return object;
            };

            /**
             * Converts this MemphisReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.MemphisReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MemphisReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MemphisReadArgs;
        })();

        args.MemphisWriteArgs = (function() {

            /**
             * Properties of a MemphisWriteArgs.
             * @memberof protos.args
             * @interface IMemphisWriteArgs
             * @property {string|null} [station] MemphisWriteArgs station
             * @property {string|null} [producerName] MemphisWriteArgs producerName
             * @property {Object.<string,string>|null} [headers] MemphisWriteArgs headers
             * @property {string|null} [messageId] MemphisWriteArgs messageId
             */

            /**
             * Constructs a new MemphisWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a MemphisWriteArgs.
             * @implements IMemphisWriteArgs
             * @constructor
             * @param {protos.args.IMemphisWriteArgs=} [properties] Properties to set
             */
            function MemphisWriteArgs(properties) {
                this.headers = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MemphisWriteArgs station.
             * @member {string} station
             * @memberof protos.args.MemphisWriteArgs
             * @instance
             */
            MemphisWriteArgs.prototype.station = "";

            /**
             * MemphisWriteArgs producerName.
             * @member {string} producerName
             * @memberof protos.args.MemphisWriteArgs
             * @instance
             */
            MemphisWriteArgs.prototype.producerName = "";

            /**
             * MemphisWriteArgs headers.
             * @member {Object.<string,string>} headers
             * @memberof protos.args.MemphisWriteArgs
             * @instance
             */
            MemphisWriteArgs.prototype.headers = $util.emptyObject;

            /**
             * MemphisWriteArgs messageId.
             * @member {string} messageId
             * @memberof protos.args.MemphisWriteArgs
             * @instance
             */
            MemphisWriteArgs.prototype.messageId = "";

            /**
             * Creates a new MemphisWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.MemphisWriteArgs
             * @static
             * @param {protos.args.IMemphisWriteArgs=} [properties] Properties to set
             * @returns {protos.args.MemphisWriteArgs} MemphisWriteArgs instance
             */
            MemphisWriteArgs.create = function create(properties) {
                return new MemphisWriteArgs(properties);
            };

            /**
             * Encodes the specified MemphisWriteArgs message. Does not implicitly {@link protos.args.MemphisWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MemphisWriteArgs
             * @static
             * @param {protos.args.IMemphisWriteArgs} message MemphisWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemphisWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.station != null && Object.hasOwnProperty.call(message, "station"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.station);
                if (message.producerName != null && Object.hasOwnProperty.call(message, "producerName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.producerName);
                if (message.headers != null && Object.hasOwnProperty.call(message, "headers"))
                    for (var keys = Object.keys(message.headers), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.headers[keys[i]]).ldelim();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.messageId);
                return writer;
            };

            /**
             * Encodes the specified MemphisWriteArgs message, length delimited. Does not implicitly {@link protos.args.MemphisWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MemphisWriteArgs
             * @static
             * @param {protos.args.IMemphisWriteArgs} message MemphisWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemphisWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MemphisWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MemphisWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MemphisWriteArgs} MemphisWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemphisWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MemphisWriteArgs(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.station = reader.string();
                        break;
                    case 2:
                        message.producerName = reader.string();
                        break;
                    case 3:
                        if (message.headers === $util.emptyObject)
                            message.headers = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.headers[key] = value;
                        break;
                    case 4:
                        message.messageId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MemphisWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MemphisWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MemphisWriteArgs} MemphisWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemphisWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MemphisWriteArgs message.
             * @function verify
             * @memberof protos.args.MemphisWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MemphisWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.station != null && message.hasOwnProperty("station"))
                    if (!$util.isString(message.station))
                        return "station: string expected";
                if (message.producerName != null && message.hasOwnProperty("producerName"))
                    if (!$util.isString(message.producerName))
                        return "producerName: string expected";
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    if (!$util.isObject(message.headers))
                        return "headers: object expected";
                    var key = Object.keys(message.headers);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.headers[key[i]]))
                            return "headers: string{k:string} expected";
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                return null;
            };

            /**
             * Creates a MemphisWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MemphisWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MemphisWriteArgs} MemphisWriteArgs
             */
            MemphisWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MemphisWriteArgs)
                    return object;
                var message = new $root.protos.args.MemphisWriteArgs();
                if (object.station != null)
                    message.station = String(object.station);
                if (object.producerName != null)
                    message.producerName = String(object.producerName);
                if (object.headers) {
                    if (typeof object.headers !== "object")
                        throw TypeError(".protos.args.MemphisWriteArgs.headers: object expected");
                    message.headers = {};
                    for (var keys = Object.keys(object.headers), i = 0; i < keys.length; ++i)
                        message.headers[keys[i]] = String(object.headers[keys[i]]);
                }
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                return message;
            };

            /**
             * Creates a plain object from a MemphisWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MemphisWriteArgs
             * @static
             * @param {protos.args.MemphisWriteArgs} message MemphisWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MemphisWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.headers = {};
                if (options.defaults) {
                    object.station = "";
                    object.producerName = "";
                    object.messageId = "";
                }
                if (message.station != null && message.hasOwnProperty("station"))
                    object.station = message.station;
                if (message.producerName != null && message.hasOwnProperty("producerName"))
                    object.producerName = message.producerName;
                var keys2;
                if (message.headers && (keys2 = Object.keys(message.headers)).length) {
                    object.headers = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.headers[keys2[j]] = message.headers[keys2[j]];
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                return object;
            };

            /**
             * Converts this MemphisWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.MemphisWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MemphisWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MemphisWriteArgs;
        })();

        args.MongoConn = (function() {

            /**
             * Properties of a MongoConn.
             * @memberof protos.args
             * @interface IMongoConn
             * @property {string|null} [dsn] MongoConn dsn
             */

            /**
             * Constructs a new MongoConn.
             * @memberof protos.args
             * @classdesc Represents a MongoConn.
             * @implements IMongoConn
             * @constructor
             * @param {protos.args.IMongoConn=} [properties] Properties to set
             */
            function MongoConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MongoConn dsn.
             * @member {string} dsn
             * @memberof protos.args.MongoConn
             * @instance
             */
            MongoConn.prototype.dsn = "";

            /**
             * Creates a new MongoConn instance using the specified properties.
             * @function create
             * @memberof protos.args.MongoConn
             * @static
             * @param {protos.args.IMongoConn=} [properties] Properties to set
             * @returns {protos.args.MongoConn} MongoConn instance
             */
            MongoConn.create = function create(properties) {
                return new MongoConn(properties);
            };

            /**
             * Encodes the specified MongoConn message. Does not implicitly {@link protos.args.MongoConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MongoConn
             * @static
             * @param {protos.args.IMongoConn} message MongoConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MongoConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                return writer;
            };

            /**
             * Encodes the specified MongoConn message, length delimited. Does not implicitly {@link protos.args.MongoConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MongoConn
             * @static
             * @param {protos.args.IMongoConn} message MongoConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MongoConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MongoConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MongoConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MongoConn} MongoConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MongoConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MongoConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MongoConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MongoConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MongoConn} MongoConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MongoConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MongoConn message.
             * @function verify
             * @memberof protos.args.MongoConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MongoConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                return null;
            };

            /**
             * Creates a MongoConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MongoConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MongoConn} MongoConn
             */
            MongoConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MongoConn)
                    return object;
                var message = new $root.protos.args.MongoConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                return message;
            };

            /**
             * Creates a plain object from a MongoConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MongoConn
             * @static
             * @param {protos.args.MongoConn} message MongoConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MongoConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.dsn = "";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                return object;
            };

            /**
             * Converts this MongoConn to JSON.
             * @function toJSON
             * @memberof protos.args.MongoConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MongoConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MongoConn;
        })();

        args.MongoReadArgs = (function() {

            /**
             * Properties of a MongoReadArgs.
             * @memberof protos.args
             * @interface IMongoReadArgs
             * @property {string|null} [database] MongoReadArgs database
             * @property {string|null} [collection] MongoReadArgs collection
             * @property {boolean|null} [includeFullDocument] MongoReadArgs includeFullDocument
             */

            /**
             * Constructs a new MongoReadArgs.
             * @memberof protos.args
             * @classdesc Represents a MongoReadArgs.
             * @implements IMongoReadArgs
             * @constructor
             * @param {protos.args.IMongoReadArgs=} [properties] Properties to set
             */
            function MongoReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MongoReadArgs database.
             * @member {string} database
             * @memberof protos.args.MongoReadArgs
             * @instance
             */
            MongoReadArgs.prototype.database = "";

            /**
             * MongoReadArgs collection.
             * @member {string} collection
             * @memberof protos.args.MongoReadArgs
             * @instance
             */
            MongoReadArgs.prototype.collection = "";

            /**
             * MongoReadArgs includeFullDocument.
             * @member {boolean} includeFullDocument
             * @memberof protos.args.MongoReadArgs
             * @instance
             */
            MongoReadArgs.prototype.includeFullDocument = false;

            /**
             * Creates a new MongoReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {protos.args.IMongoReadArgs=} [properties] Properties to set
             * @returns {protos.args.MongoReadArgs} MongoReadArgs instance
             */
            MongoReadArgs.create = function create(properties) {
                return new MongoReadArgs(properties);
            };

            /**
             * Encodes the specified MongoReadArgs message. Does not implicitly {@link protos.args.MongoReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {protos.args.IMongoReadArgs} message MongoReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MongoReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.database);
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.collection);
                if (message.includeFullDocument != null && Object.hasOwnProperty.call(message, "includeFullDocument"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.includeFullDocument);
                return writer;
            };

            /**
             * Encodes the specified MongoReadArgs message, length delimited. Does not implicitly {@link protos.args.MongoReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {protos.args.IMongoReadArgs} message MongoReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MongoReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MongoReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MongoReadArgs} MongoReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MongoReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MongoReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.database = reader.string();
                        break;
                    case 2:
                        message.collection = reader.string();
                        break;
                    case 3:
                        message.includeFullDocument = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MongoReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MongoReadArgs} MongoReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MongoReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MongoReadArgs message.
             * @function verify
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MongoReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                if (message.includeFullDocument != null && message.hasOwnProperty("includeFullDocument"))
                    if (typeof message.includeFullDocument !== "boolean")
                        return "includeFullDocument: boolean expected";
                return null;
            };

            /**
             * Creates a MongoReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MongoReadArgs} MongoReadArgs
             */
            MongoReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MongoReadArgs)
                    return object;
                var message = new $root.protos.args.MongoReadArgs();
                if (object.database != null)
                    message.database = String(object.database);
                if (object.collection != null)
                    message.collection = String(object.collection);
                if (object.includeFullDocument != null)
                    message.includeFullDocument = Boolean(object.includeFullDocument);
                return message;
            };

            /**
             * Creates a plain object from a MongoReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {protos.args.MongoReadArgs} message MongoReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MongoReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.database = "";
                    object.collection = "";
                    object.includeFullDocument = false;
                }
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                if (message.includeFullDocument != null && message.hasOwnProperty("includeFullDocument"))
                    object.includeFullDocument = message.includeFullDocument;
                return object;
            };

            /**
             * Converts this MongoReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.MongoReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MongoReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MongoReadArgs;
        })();

        /**
         * MQTTQoSLevel enum.
         * @name protos.args.MQTTQoSLevel
         * @enum {number}
         * @property {number} MQTT_QOS_LEVEL_AT_MOST_ONCE=0 MQTT_QOS_LEVEL_AT_MOST_ONCE value
         * @property {number} MQTT_QOS_LEVEL_AT_LEAST_ONCE=1 MQTT_QOS_LEVEL_AT_LEAST_ONCE value
         * @property {number} MQTT_QOS_LEVEL_EXACTLY_ONCE=2 MQTT_QOS_LEVEL_EXACTLY_ONCE value
         */
        args.MQTTQoSLevel = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "MQTT_QOS_LEVEL_AT_MOST_ONCE"] = 0;
            values[valuesById[1] = "MQTT_QOS_LEVEL_AT_LEAST_ONCE"] = 1;
            values[valuesById[2] = "MQTT_QOS_LEVEL_EXACTLY_ONCE"] = 2;
            return values;
        })();

        args.MQTTTLSOptions = (function() {

            /**
             * Properties of a MQTTTLSOptions.
             * @memberof protos.args
             * @interface IMQTTTLSOptions
             * @property {string|null} [tlsCaCert] MQTTTLSOptions tlsCaCert
             * @property {string|null} [tlsClientCert] MQTTTLSOptions tlsClientCert
             * @property {string|null} [tlsClientKey] MQTTTLSOptions tlsClientKey
             * @property {boolean|null} [tlsSkipVerify] MQTTTLSOptions tlsSkipVerify
             */

            /**
             * Constructs a new MQTTTLSOptions.
             * @memberof protos.args
             * @classdesc Represents a MQTTTLSOptions.
             * @implements IMQTTTLSOptions
             * @constructor
             * @param {protos.args.IMQTTTLSOptions=} [properties] Properties to set
             */
            function MQTTTLSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MQTTTLSOptions tlsCaCert.
             * @member {string} tlsCaCert
             * @memberof protos.args.MQTTTLSOptions
             * @instance
             */
            MQTTTLSOptions.prototype.tlsCaCert = "";

            /**
             * MQTTTLSOptions tlsClientCert.
             * @member {string} tlsClientCert
             * @memberof protos.args.MQTTTLSOptions
             * @instance
             */
            MQTTTLSOptions.prototype.tlsClientCert = "";

            /**
             * MQTTTLSOptions tlsClientKey.
             * @member {string} tlsClientKey
             * @memberof protos.args.MQTTTLSOptions
             * @instance
             */
            MQTTTLSOptions.prototype.tlsClientKey = "";

            /**
             * MQTTTLSOptions tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.args.MQTTTLSOptions
             * @instance
             */
            MQTTTLSOptions.prototype.tlsSkipVerify = false;

            /**
             * Creates a new MQTTTLSOptions instance using the specified properties.
             * @function create
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {protos.args.IMQTTTLSOptions=} [properties] Properties to set
             * @returns {protos.args.MQTTTLSOptions} MQTTTLSOptions instance
             */
            MQTTTLSOptions.create = function create(properties) {
                return new MQTTTLSOptions(properties);
            };

            /**
             * Encodes the specified MQTTTLSOptions message. Does not implicitly {@link protos.args.MQTTTLSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {protos.args.IMQTTTLSOptions} message MQTTTLSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTTLSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tlsCaCert != null && Object.hasOwnProperty.call(message, "tlsCaCert"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tlsCaCert);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.tlsClientCert);
                if (message.tlsClientKey != null && Object.hasOwnProperty.call(message, "tlsClientKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.tlsClientKey);
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.tlsSkipVerify);
                return writer;
            };

            /**
             * Encodes the specified MQTTTLSOptions message, length delimited. Does not implicitly {@link protos.args.MQTTTLSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {protos.args.IMQTTTLSOptions} message MQTTTLSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTTLSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MQTTTLSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MQTTTLSOptions} MQTTTLSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTTLSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MQTTTLSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tlsCaCert = reader.string();
                        break;
                    case 2:
                        message.tlsClientCert = reader.string();
                        break;
                    case 3:
                        message.tlsClientKey = reader.string();
                        break;
                    case 4:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MQTTTLSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MQTTTLSOptions} MQTTTLSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTTLSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MQTTTLSOptions message.
             * @function verify
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MQTTTLSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    if (!$util.isString(message.tlsCaCert))
                        return "tlsCaCert: string expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!$util.isString(message.tlsClientCert))
                        return "tlsClientCert: string expected";
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    if (!$util.isString(message.tlsClientKey))
                        return "tlsClientKey: string expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                return null;
            };

            /**
             * Creates a MQTTTLSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MQTTTLSOptions} MQTTTLSOptions
             */
            MQTTTLSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MQTTTLSOptions)
                    return object;
                var message = new $root.protos.args.MQTTTLSOptions();
                if (object.tlsCaCert != null)
                    message.tlsCaCert = String(object.tlsCaCert);
                if (object.tlsClientCert != null)
                    message.tlsClientCert = String(object.tlsClientCert);
                if (object.tlsClientKey != null)
                    message.tlsClientKey = String(object.tlsClientKey);
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                return message;
            };

            /**
             * Creates a plain object from a MQTTTLSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {protos.args.MQTTTLSOptions} message MQTTTLSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MQTTTLSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tlsCaCert = "";
                    object.tlsClientCert = "";
                    object.tlsClientKey = "";
                    object.tlsSkipVerify = false;
                }
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    object.tlsCaCert = message.tlsCaCert;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = message.tlsClientCert;
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    object.tlsClientKey = message.tlsClientKey;
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                return object;
            };

            /**
             * Converts this MQTTTLSOptions to JSON.
             * @function toJSON
             * @memberof protos.args.MQTTTLSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MQTTTLSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MQTTTLSOptions;
        })();

        args.MQTTConn = (function() {

            /**
             * Properties of a MQTTConn.
             * @memberof protos.args
             * @interface IMQTTConn
             * @property {string|null} [address] MQTTConn address
             * @property {number|null} [connTimeoutSeconds] MQTTConn connTimeoutSeconds
             * @property {string|null} [clientId] MQTTConn clientId
             * @property {protos.args.MQTTQoSLevel|null} [qosLevel] MQTTConn qosLevel
             * @property {protos.args.IMQTTTLSOptions|null} [tlsOptions] MQTTConn tlsOptions
             */

            /**
             * Constructs a new MQTTConn.
             * @memberof protos.args
             * @classdesc Represents a MQTTConn.
             * @implements IMQTTConn
             * @constructor
             * @param {protos.args.IMQTTConn=} [properties] Properties to set
             */
            function MQTTConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MQTTConn address.
             * @member {string} address
             * @memberof protos.args.MQTTConn
             * @instance
             */
            MQTTConn.prototype.address = "";

            /**
             * MQTTConn connTimeoutSeconds.
             * @member {number} connTimeoutSeconds
             * @memberof protos.args.MQTTConn
             * @instance
             */
            MQTTConn.prototype.connTimeoutSeconds = 0;

            /**
             * MQTTConn clientId.
             * @member {string} clientId
             * @memberof protos.args.MQTTConn
             * @instance
             */
            MQTTConn.prototype.clientId = "";

            /**
             * MQTTConn qosLevel.
             * @member {protos.args.MQTTQoSLevel} qosLevel
             * @memberof protos.args.MQTTConn
             * @instance
             */
            MQTTConn.prototype.qosLevel = 0;

            /**
             * MQTTConn tlsOptions.
             * @member {protos.args.IMQTTTLSOptions|null|undefined} tlsOptions
             * @memberof protos.args.MQTTConn
             * @instance
             */
            MQTTConn.prototype.tlsOptions = null;

            /**
             * Creates a new MQTTConn instance using the specified properties.
             * @function create
             * @memberof protos.args.MQTTConn
             * @static
             * @param {protos.args.IMQTTConn=} [properties] Properties to set
             * @returns {protos.args.MQTTConn} MQTTConn instance
             */
            MQTTConn.create = function create(properties) {
                return new MQTTConn(properties);
            };

            /**
             * Encodes the specified MQTTConn message. Does not implicitly {@link protos.args.MQTTConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MQTTConn
             * @static
             * @param {protos.args.IMQTTConn} message MQTTConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.connTimeoutSeconds != null && Object.hasOwnProperty.call(message, "connTimeoutSeconds"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.connTimeoutSeconds);
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.clientId);
                if (message.qosLevel != null && Object.hasOwnProperty.call(message, "qosLevel"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.qosLevel);
                if (message.tlsOptions != null && Object.hasOwnProperty.call(message, "tlsOptions"))
                    $root.protos.args.MQTTTLSOptions.encode(message.tlsOptions, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MQTTConn message, length delimited. Does not implicitly {@link protos.args.MQTTConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MQTTConn
             * @static
             * @param {protos.args.IMQTTConn} message MQTTConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MQTTConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MQTTConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MQTTConn} MQTTConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MQTTConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 3:
                        message.connTimeoutSeconds = reader.uint32();
                        break;
                    case 4:
                        message.clientId = reader.string();
                        break;
                    case 5:
                        message.qosLevel = reader.int32();
                        break;
                    case 6:
                        message.tlsOptions = $root.protos.args.MQTTTLSOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MQTTConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MQTTConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MQTTConn} MQTTConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MQTTConn message.
             * @function verify
             * @memberof protos.args.MQTTConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MQTTConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.connTimeoutSeconds != null && message.hasOwnProperty("connTimeoutSeconds"))
                    if (!$util.isInteger(message.connTimeoutSeconds))
                        return "connTimeoutSeconds: integer expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                if (message.qosLevel != null && message.hasOwnProperty("qosLevel"))
                    switch (message.qosLevel) {
                    default:
                        return "qosLevel: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.tlsOptions != null && message.hasOwnProperty("tlsOptions")) {
                    var error = $root.protos.args.MQTTTLSOptions.verify(message.tlsOptions);
                    if (error)
                        return "tlsOptions." + error;
                }
                return null;
            };

            /**
             * Creates a MQTTConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MQTTConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MQTTConn} MQTTConn
             */
            MQTTConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MQTTConn)
                    return object;
                var message = new $root.protos.args.MQTTConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.connTimeoutSeconds != null)
                    message.connTimeoutSeconds = object.connTimeoutSeconds >>> 0;
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                switch (object.qosLevel) {
                case "MQTT_QOS_LEVEL_AT_MOST_ONCE":
                case 0:
                    message.qosLevel = 0;
                    break;
                case "MQTT_QOS_LEVEL_AT_LEAST_ONCE":
                case 1:
                    message.qosLevel = 1;
                    break;
                case "MQTT_QOS_LEVEL_EXACTLY_ONCE":
                case 2:
                    message.qosLevel = 2;
                    break;
                }
                if (object.tlsOptions != null) {
                    if (typeof object.tlsOptions !== "object")
                        throw TypeError(".protos.args.MQTTConn.tlsOptions: object expected");
                    message.tlsOptions = $root.protos.args.MQTTTLSOptions.fromObject(object.tlsOptions);
                }
                return message;
            };

            /**
             * Creates a plain object from a MQTTConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MQTTConn
             * @static
             * @param {protos.args.MQTTConn} message MQTTConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MQTTConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = "";
                    object.connTimeoutSeconds = 0;
                    object.clientId = "";
                    object.qosLevel = options.enums === String ? "MQTT_QOS_LEVEL_AT_MOST_ONCE" : 0;
                    object.tlsOptions = null;
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.connTimeoutSeconds != null && message.hasOwnProperty("connTimeoutSeconds"))
                    object.connTimeoutSeconds = message.connTimeoutSeconds;
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                if (message.qosLevel != null && message.hasOwnProperty("qosLevel"))
                    object.qosLevel = options.enums === String ? $root.protos.args.MQTTQoSLevel[message.qosLevel] : message.qosLevel;
                if (message.tlsOptions != null && message.hasOwnProperty("tlsOptions"))
                    object.tlsOptions = $root.protos.args.MQTTTLSOptions.toObject(message.tlsOptions, options);
                return object;
            };

            /**
             * Converts this MQTTConn to JSON.
             * @function toJSON
             * @memberof protos.args.MQTTConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MQTTConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MQTTConn;
        })();

        args.MQTTReadArgs = (function() {

            /**
             * Properties of a MQTTReadArgs.
             * @memberof protos.args
             * @interface IMQTTReadArgs
             * @property {string|null} [topic] MQTTReadArgs topic
             * @property {number|null} [readTimeoutSeconds] MQTTReadArgs readTimeoutSeconds
             */

            /**
             * Constructs a new MQTTReadArgs.
             * @memberof protos.args
             * @classdesc Represents a MQTTReadArgs.
             * @implements IMQTTReadArgs
             * @constructor
             * @param {protos.args.IMQTTReadArgs=} [properties] Properties to set
             */
            function MQTTReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MQTTReadArgs topic.
             * @member {string} topic
             * @memberof protos.args.MQTTReadArgs
             * @instance
             */
            MQTTReadArgs.prototype.topic = "";

            /**
             * MQTTReadArgs readTimeoutSeconds.
             * @member {number} readTimeoutSeconds
             * @memberof protos.args.MQTTReadArgs
             * @instance
             */
            MQTTReadArgs.prototype.readTimeoutSeconds = 0;

            /**
             * Creates a new MQTTReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {protos.args.IMQTTReadArgs=} [properties] Properties to set
             * @returns {protos.args.MQTTReadArgs} MQTTReadArgs instance
             */
            MQTTReadArgs.create = function create(properties) {
                return new MQTTReadArgs(properties);
            };

            /**
             * Encodes the specified MQTTReadArgs message. Does not implicitly {@link protos.args.MQTTReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {protos.args.IMQTTReadArgs} message MQTTReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.readTimeoutSeconds != null && Object.hasOwnProperty.call(message, "readTimeoutSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.readTimeoutSeconds);
                return writer;
            };

            /**
             * Encodes the specified MQTTReadArgs message, length delimited. Does not implicitly {@link protos.args.MQTTReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {protos.args.IMQTTReadArgs} message MQTTReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MQTTReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MQTTReadArgs} MQTTReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MQTTReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.readTimeoutSeconds = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MQTTReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MQTTReadArgs} MQTTReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MQTTReadArgs message.
             * @function verify
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MQTTReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.readTimeoutSeconds != null && message.hasOwnProperty("readTimeoutSeconds"))
                    if (!$util.isInteger(message.readTimeoutSeconds))
                        return "readTimeoutSeconds: integer expected";
                return null;
            };

            /**
             * Creates a MQTTReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MQTTReadArgs} MQTTReadArgs
             */
            MQTTReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MQTTReadArgs)
                    return object;
                var message = new $root.protos.args.MQTTReadArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.readTimeoutSeconds != null)
                    message.readTimeoutSeconds = object.readTimeoutSeconds >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a MQTTReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {protos.args.MQTTReadArgs} message MQTTReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MQTTReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.readTimeoutSeconds = 0;
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.readTimeoutSeconds != null && message.hasOwnProperty("readTimeoutSeconds"))
                    object.readTimeoutSeconds = message.readTimeoutSeconds;
                return object;
            };

            /**
             * Converts this MQTTReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.MQTTReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MQTTReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MQTTReadArgs;
        })();

        args.MQTTWriteArgs = (function() {

            /**
             * Properties of a MQTTWriteArgs.
             * @memberof protos.args
             * @interface IMQTTWriteArgs
             * @property {string|null} [topic] MQTTWriteArgs topic
             * @property {number|null} [writeTimeoutSeconds] MQTTWriteArgs writeTimeoutSeconds
             */

            /**
             * Constructs a new MQTTWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a MQTTWriteArgs.
             * @implements IMQTTWriteArgs
             * @constructor
             * @param {protos.args.IMQTTWriteArgs=} [properties] Properties to set
             */
            function MQTTWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MQTTWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.MQTTWriteArgs
             * @instance
             */
            MQTTWriteArgs.prototype.topic = "";

            /**
             * MQTTWriteArgs writeTimeoutSeconds.
             * @member {number} writeTimeoutSeconds
             * @memberof protos.args.MQTTWriteArgs
             * @instance
             */
            MQTTWriteArgs.prototype.writeTimeoutSeconds = 0;

            /**
             * Creates a new MQTTWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {protos.args.IMQTTWriteArgs=} [properties] Properties to set
             * @returns {protos.args.MQTTWriteArgs} MQTTWriteArgs instance
             */
            MQTTWriteArgs.create = function create(properties) {
                return new MQTTWriteArgs(properties);
            };

            /**
             * Encodes the specified MQTTWriteArgs message. Does not implicitly {@link protos.args.MQTTWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {protos.args.IMQTTWriteArgs} message MQTTWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.writeTimeoutSeconds != null && Object.hasOwnProperty.call(message, "writeTimeoutSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.writeTimeoutSeconds);
                return writer;
            };

            /**
             * Encodes the specified MQTTWriteArgs message, length delimited. Does not implicitly {@link protos.args.MQTTWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {protos.args.IMQTTWriteArgs} message MQTTWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MQTTWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MQTTWriteArgs} MQTTWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MQTTWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.writeTimeoutSeconds = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MQTTWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MQTTWriteArgs} MQTTWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MQTTWriteArgs message.
             * @function verify
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MQTTWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.writeTimeoutSeconds != null && message.hasOwnProperty("writeTimeoutSeconds"))
                    if (!$util.isInteger(message.writeTimeoutSeconds))
                        return "writeTimeoutSeconds: integer expected";
                return null;
            };

            /**
             * Creates a MQTTWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MQTTWriteArgs} MQTTWriteArgs
             */
            MQTTWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MQTTWriteArgs)
                    return object;
                var message = new $root.protos.args.MQTTWriteArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.writeTimeoutSeconds != null)
                    message.writeTimeoutSeconds = object.writeTimeoutSeconds >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a MQTTWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {protos.args.MQTTWriteArgs} message MQTTWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MQTTWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.writeTimeoutSeconds = 0;
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.writeTimeoutSeconds != null && message.hasOwnProperty("writeTimeoutSeconds"))
                    object.writeTimeoutSeconds = message.writeTimeoutSeconds;
                return object;
            };

            /**
             * Converts this MQTTWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.MQTTWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MQTTWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MQTTWriteArgs;
        })();

        args.NatsConn = (function() {

            /**
             * Properties of a NatsConn.
             * @memberof protos.args
             * @interface INatsConn
             * @property {string|null} [dsn] NatsConn dsn
             * @property {string|null} [userCredentials] NatsConn userCredentials
             * @property {protos.args.INatsTLSOptions|null} [tlsOptions] NatsConn tlsOptions
             * @property {string|null} [nkey] NatsConn nkey
             */

            /**
             * Constructs a new NatsConn.
             * @memberof protos.args
             * @classdesc Represents a NatsConn.
             * @implements INatsConn
             * @constructor
             * @param {protos.args.INatsConn=} [properties] Properties to set
             */
            function NatsConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsConn dsn.
             * @member {string} dsn
             * @memberof protos.args.NatsConn
             * @instance
             */
            NatsConn.prototype.dsn = "";

            /**
             * NatsConn userCredentials.
             * @member {string} userCredentials
             * @memberof protos.args.NatsConn
             * @instance
             */
            NatsConn.prototype.userCredentials = "";

            /**
             * NatsConn tlsOptions.
             * @member {protos.args.INatsTLSOptions|null|undefined} tlsOptions
             * @memberof protos.args.NatsConn
             * @instance
             */
            NatsConn.prototype.tlsOptions = null;

            /**
             * NatsConn nkey.
             * @member {string} nkey
             * @memberof protos.args.NatsConn
             * @instance
             */
            NatsConn.prototype.nkey = "";

            /**
             * Creates a new NatsConn instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsConn
             * @static
             * @param {protos.args.INatsConn=} [properties] Properties to set
             * @returns {protos.args.NatsConn} NatsConn instance
             */
            NatsConn.create = function create(properties) {
                return new NatsConn(properties);
            };

            /**
             * Encodes the specified NatsConn message. Does not implicitly {@link protos.args.NatsConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsConn
             * @static
             * @param {protos.args.INatsConn} message NatsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                if (message.userCredentials != null && Object.hasOwnProperty.call(message, "userCredentials"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.userCredentials);
                if (message.tlsOptions != null && Object.hasOwnProperty.call(message, "tlsOptions"))
                    $root.protos.args.NatsTLSOptions.encode(message.tlsOptions, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.nkey != null && Object.hasOwnProperty.call(message, "nkey"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.nkey);
                return writer;
            };

            /**
             * Encodes the specified NatsConn message, length delimited. Does not implicitly {@link protos.args.NatsConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsConn
             * @static
             * @param {protos.args.INatsConn} message NatsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsConn} NatsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    case 2:
                        message.userCredentials = reader.string();
                        break;
                    case 3:
                        message.tlsOptions = $root.protos.args.NatsTLSOptions.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.nkey = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsConn} NatsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsConn message.
             * @function verify
             * @memberof protos.args.NatsConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                if (message.userCredentials != null && message.hasOwnProperty("userCredentials"))
                    if (!$util.isString(message.userCredentials))
                        return "userCredentials: string expected";
                if (message.tlsOptions != null && message.hasOwnProperty("tlsOptions")) {
                    var error = $root.protos.args.NatsTLSOptions.verify(message.tlsOptions);
                    if (error)
                        return "tlsOptions." + error;
                }
                if (message.nkey != null && message.hasOwnProperty("nkey"))
                    if (!$util.isString(message.nkey))
                        return "nkey: string expected";
                return null;
            };

            /**
             * Creates a NatsConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsConn} NatsConn
             */
            NatsConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsConn)
                    return object;
                var message = new $root.protos.args.NatsConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                if (object.userCredentials != null)
                    message.userCredentials = String(object.userCredentials);
                if (object.tlsOptions != null) {
                    if (typeof object.tlsOptions !== "object")
                        throw TypeError(".protos.args.NatsConn.tlsOptions: object expected");
                    message.tlsOptions = $root.protos.args.NatsTLSOptions.fromObject(object.tlsOptions);
                }
                if (object.nkey != null)
                    message.nkey = String(object.nkey);
                return message;
            };

            /**
             * Creates a plain object from a NatsConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsConn
             * @static
             * @param {protos.args.NatsConn} message NatsConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.dsn = "";
                    object.userCredentials = "";
                    object.tlsOptions = null;
                    object.nkey = "";
                }
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                if (message.userCredentials != null && message.hasOwnProperty("userCredentials"))
                    object.userCredentials = message.userCredentials;
                if (message.tlsOptions != null && message.hasOwnProperty("tlsOptions"))
                    object.tlsOptions = $root.protos.args.NatsTLSOptions.toObject(message.tlsOptions, options);
                if (message.nkey != null && message.hasOwnProperty("nkey"))
                    object.nkey = message.nkey;
                return object;
            };

            /**
             * Converts this NatsConn to JSON.
             * @function toJSON
             * @memberof protos.args.NatsConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsConn;
        })();

        args.NatsTLSOptions = (function() {

            /**
             * Properties of a NatsTLSOptions.
             * @memberof protos.args
             * @interface INatsTLSOptions
             * @property {boolean|null} [tlsSkipVerify] NatsTLSOptions tlsSkipVerify
             * @property {string|null} [tlsCaCert] NatsTLSOptions tlsCaCert
             * @property {string|null} [tlsClientCert] NatsTLSOptions tlsClientCert
             * @property {string|null} [tlsClientKey] NatsTLSOptions tlsClientKey
             * @property {boolean|null} [useTls] NatsTLSOptions useTls
             */

            /**
             * Constructs a new NatsTLSOptions.
             * @memberof protos.args
             * @classdesc Represents a NatsTLSOptions.
             * @implements INatsTLSOptions
             * @constructor
             * @param {protos.args.INatsTLSOptions=} [properties] Properties to set
             */
            function NatsTLSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsTLSOptions tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.args.NatsTLSOptions
             * @instance
             */
            NatsTLSOptions.prototype.tlsSkipVerify = false;

            /**
             * NatsTLSOptions tlsCaCert.
             * @member {string} tlsCaCert
             * @memberof protos.args.NatsTLSOptions
             * @instance
             */
            NatsTLSOptions.prototype.tlsCaCert = "";

            /**
             * NatsTLSOptions tlsClientCert.
             * @member {string} tlsClientCert
             * @memberof protos.args.NatsTLSOptions
             * @instance
             */
            NatsTLSOptions.prototype.tlsClientCert = "";

            /**
             * NatsTLSOptions tlsClientKey.
             * @member {string} tlsClientKey
             * @memberof protos.args.NatsTLSOptions
             * @instance
             */
            NatsTLSOptions.prototype.tlsClientKey = "";

            /**
             * NatsTLSOptions useTls.
             * @member {boolean} useTls
             * @memberof protos.args.NatsTLSOptions
             * @instance
             */
            NatsTLSOptions.prototype.useTls = false;

            /**
             * Creates a new NatsTLSOptions instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsTLSOptions
             * @static
             * @param {protos.args.INatsTLSOptions=} [properties] Properties to set
             * @returns {protos.args.NatsTLSOptions} NatsTLSOptions instance
             */
            NatsTLSOptions.create = function create(properties) {
                return new NatsTLSOptions(properties);
            };

            /**
             * Encodes the specified NatsTLSOptions message. Does not implicitly {@link protos.args.NatsTLSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsTLSOptions
             * @static
             * @param {protos.args.INatsTLSOptions} message NatsTLSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsTLSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.tlsSkipVerify);
                if (message.tlsCaCert != null && Object.hasOwnProperty.call(message, "tlsCaCert"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.tlsCaCert);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.tlsClientCert);
                if (message.tlsClientKey != null && Object.hasOwnProperty.call(message, "tlsClientKey"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.tlsClientKey);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.useTls);
                return writer;
            };

            /**
             * Encodes the specified NatsTLSOptions message, length delimited. Does not implicitly {@link protos.args.NatsTLSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsTLSOptions
             * @static
             * @param {protos.args.INatsTLSOptions} message NatsTLSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsTLSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsTLSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsTLSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsTLSOptions} NatsTLSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsTLSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsTLSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    case 2:
                        message.tlsCaCert = reader.string();
                        break;
                    case 3:
                        message.tlsClientCert = reader.string();
                        break;
                    case 4:
                        message.tlsClientKey = reader.string();
                        break;
                    case 5:
                        message.useTls = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsTLSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsTLSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsTLSOptions} NatsTLSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsTLSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsTLSOptions message.
             * @function verify
             * @memberof protos.args.NatsTLSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsTLSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    if (!$util.isString(message.tlsCaCert))
                        return "tlsCaCert: string expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!$util.isString(message.tlsClientCert))
                        return "tlsClientCert: string expected";
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    if (!$util.isString(message.tlsClientKey))
                        return "tlsClientKey: string expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                return null;
            };

            /**
             * Creates a NatsTLSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsTLSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsTLSOptions} NatsTLSOptions
             */
            NatsTLSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsTLSOptions)
                    return object;
                var message = new $root.protos.args.NatsTLSOptions();
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                if (object.tlsCaCert != null)
                    message.tlsCaCert = String(object.tlsCaCert);
                if (object.tlsClientCert != null)
                    message.tlsClientCert = String(object.tlsClientCert);
                if (object.tlsClientKey != null)
                    message.tlsClientKey = String(object.tlsClientKey);
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                return message;
            };

            /**
             * Creates a plain object from a NatsTLSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsTLSOptions
             * @static
             * @param {protos.args.NatsTLSOptions} message NatsTLSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsTLSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tlsSkipVerify = false;
                    object.tlsCaCert = "";
                    object.tlsClientCert = "";
                    object.tlsClientKey = "";
                    object.useTls = false;
                }
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    object.tlsCaCert = message.tlsCaCert;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = message.tlsClientCert;
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    object.tlsClientKey = message.tlsClientKey;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                return object;
            };

            /**
             * Converts this NatsTLSOptions to JSON.
             * @function toJSON
             * @memberof protos.args.NatsTLSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsTLSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsTLSOptions;
        })();

        args.NatsReadArgs = (function() {

            /**
             * Properties of a NatsReadArgs.
             * @memberof protos.args
             * @interface INatsReadArgs
             * @property {string|null} [subject] NatsReadArgs subject
             */

            /**
             * Constructs a new NatsReadArgs.
             * @memberof protos.args
             * @classdesc Represents a NatsReadArgs.
             * @implements INatsReadArgs
             * @constructor
             * @param {protos.args.INatsReadArgs=} [properties] Properties to set
             */
            function NatsReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsReadArgs subject.
             * @member {string} subject
             * @memberof protos.args.NatsReadArgs
             * @instance
             */
            NatsReadArgs.prototype.subject = "";

            /**
             * Creates a new NatsReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {protos.args.INatsReadArgs=} [properties] Properties to set
             * @returns {protos.args.NatsReadArgs} NatsReadArgs instance
             */
            NatsReadArgs.create = function create(properties) {
                return new NatsReadArgs(properties);
            };

            /**
             * Encodes the specified NatsReadArgs message. Does not implicitly {@link protos.args.NatsReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {protos.args.INatsReadArgs} message NatsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.subject);
                return writer;
            };

            /**
             * Encodes the specified NatsReadArgs message, length delimited. Does not implicitly {@link protos.args.NatsReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {protos.args.INatsReadArgs} message NatsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsReadArgs} NatsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subject = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsReadArgs} NatsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsReadArgs message.
             * @function verify
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    if (!$util.isString(message.subject))
                        return "subject: string expected";
                return null;
            };

            /**
             * Creates a NatsReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsReadArgs} NatsReadArgs
             */
            NatsReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsReadArgs)
                    return object;
                var message = new $root.protos.args.NatsReadArgs();
                if (object.subject != null)
                    message.subject = String(object.subject);
                return message;
            };

            /**
             * Creates a plain object from a NatsReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {protos.args.NatsReadArgs} message NatsReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.subject = "";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    object.subject = message.subject;
                return object;
            };

            /**
             * Converts this NatsReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NatsReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsReadArgs;
        })();

        args.NatsWriteArgs = (function() {

            /**
             * Properties of a NatsWriteArgs.
             * @memberof protos.args
             * @interface INatsWriteArgs
             * @property {string|null} [subject] NatsWriteArgs subject
             */

            /**
             * Constructs a new NatsWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a NatsWriteArgs.
             * @implements INatsWriteArgs
             * @constructor
             * @param {protos.args.INatsWriteArgs=} [properties] Properties to set
             */
            function NatsWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsWriteArgs subject.
             * @member {string} subject
             * @memberof protos.args.NatsWriteArgs
             * @instance
             */
            NatsWriteArgs.prototype.subject = "";

            /**
             * Creates a new NatsWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {protos.args.INatsWriteArgs=} [properties] Properties to set
             * @returns {protos.args.NatsWriteArgs} NatsWriteArgs instance
             */
            NatsWriteArgs.create = function create(properties) {
                return new NatsWriteArgs(properties);
            };

            /**
             * Encodes the specified NatsWriteArgs message. Does not implicitly {@link protos.args.NatsWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {protos.args.INatsWriteArgs} message NatsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.subject);
                return writer;
            };

            /**
             * Encodes the specified NatsWriteArgs message, length delimited. Does not implicitly {@link protos.args.NatsWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {protos.args.INatsWriteArgs} message NatsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsWriteArgs} NatsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subject = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsWriteArgs} NatsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsWriteArgs message.
             * @function verify
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    if (!$util.isString(message.subject))
                        return "subject: string expected";
                return null;
            };

            /**
             * Creates a NatsWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsWriteArgs} NatsWriteArgs
             */
            NatsWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsWriteArgs)
                    return object;
                var message = new $root.protos.args.NatsWriteArgs();
                if (object.subject != null)
                    message.subject = String(object.subject);
                return message;
            };

            /**
             * Creates a plain object from a NatsWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {protos.args.NatsWriteArgs} message NatsWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.subject = "";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    object.subject = message.subject;
                return object;
            };

            /**
             * Converts this NatsWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NatsWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsWriteArgs;
        })();

        args.NatsJetstreamTLSOptions = (function() {

            /**
             * Properties of a NatsJetstreamTLSOptions.
             * @memberof protos.args
             * @interface INatsJetstreamTLSOptions
             * @property {string|null} [tlsCaCert] NatsJetstreamTLSOptions tlsCaCert
             * @property {string|null} [tlsClientCert] NatsJetstreamTLSOptions tlsClientCert
             * @property {string|null} [tlsClientKey] NatsJetstreamTLSOptions tlsClientKey
             * @property {boolean|null} [tlsSkipVerify] NatsJetstreamTLSOptions tlsSkipVerify
             * @property {boolean|null} [useTls] NatsJetstreamTLSOptions useTls
             */

            /**
             * Constructs a new NatsJetstreamTLSOptions.
             * @memberof protos.args
             * @classdesc Represents a NatsJetstreamTLSOptions.
             * @implements INatsJetstreamTLSOptions
             * @constructor
             * @param {protos.args.INatsJetstreamTLSOptions=} [properties] Properties to set
             */
            function NatsJetstreamTLSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsJetstreamTLSOptions tlsCaCert.
             * @member {string} tlsCaCert
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @instance
             */
            NatsJetstreamTLSOptions.prototype.tlsCaCert = "";

            /**
             * NatsJetstreamTLSOptions tlsClientCert.
             * @member {string} tlsClientCert
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @instance
             */
            NatsJetstreamTLSOptions.prototype.tlsClientCert = "";

            /**
             * NatsJetstreamTLSOptions tlsClientKey.
             * @member {string} tlsClientKey
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @instance
             */
            NatsJetstreamTLSOptions.prototype.tlsClientKey = "";

            /**
             * NatsJetstreamTLSOptions tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @instance
             */
            NatsJetstreamTLSOptions.prototype.tlsSkipVerify = false;

            /**
             * NatsJetstreamTLSOptions useTls.
             * @member {boolean} useTls
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @instance
             */
            NatsJetstreamTLSOptions.prototype.useTls = false;

            /**
             * Creates a new NatsJetstreamTLSOptions instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @static
             * @param {protos.args.INatsJetstreamTLSOptions=} [properties] Properties to set
             * @returns {protos.args.NatsJetstreamTLSOptions} NatsJetstreamTLSOptions instance
             */
            NatsJetstreamTLSOptions.create = function create(properties) {
                return new NatsJetstreamTLSOptions(properties);
            };

            /**
             * Encodes the specified NatsJetstreamTLSOptions message. Does not implicitly {@link protos.args.NatsJetstreamTLSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @static
             * @param {protos.args.INatsJetstreamTLSOptions} message NatsJetstreamTLSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsJetstreamTLSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tlsCaCert != null && Object.hasOwnProperty.call(message, "tlsCaCert"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tlsCaCert);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.tlsClientCert);
                if (message.tlsClientKey != null && Object.hasOwnProperty.call(message, "tlsClientKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.tlsClientKey);
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.tlsSkipVerify);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.useTls);
                return writer;
            };

            /**
             * Encodes the specified NatsJetstreamTLSOptions message, length delimited. Does not implicitly {@link protos.args.NatsJetstreamTLSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @static
             * @param {protos.args.INatsJetstreamTLSOptions} message NatsJetstreamTLSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsJetstreamTLSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsJetstreamTLSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsJetstreamTLSOptions} NatsJetstreamTLSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsJetstreamTLSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsJetstreamTLSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tlsCaCert = reader.string();
                        break;
                    case 2:
                        message.tlsClientCert = reader.string();
                        break;
                    case 3:
                        message.tlsClientKey = reader.string();
                        break;
                    case 4:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    case 5:
                        message.useTls = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsJetstreamTLSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsJetstreamTLSOptions} NatsJetstreamTLSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsJetstreamTLSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsJetstreamTLSOptions message.
             * @function verify
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsJetstreamTLSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    if (!$util.isString(message.tlsCaCert))
                        return "tlsCaCert: string expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!$util.isString(message.tlsClientCert))
                        return "tlsClientCert: string expected";
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    if (!$util.isString(message.tlsClientKey))
                        return "tlsClientKey: string expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                return null;
            };

            /**
             * Creates a NatsJetstreamTLSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsJetstreamTLSOptions} NatsJetstreamTLSOptions
             */
            NatsJetstreamTLSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsJetstreamTLSOptions)
                    return object;
                var message = new $root.protos.args.NatsJetstreamTLSOptions();
                if (object.tlsCaCert != null)
                    message.tlsCaCert = String(object.tlsCaCert);
                if (object.tlsClientCert != null)
                    message.tlsClientCert = String(object.tlsClientCert);
                if (object.tlsClientKey != null)
                    message.tlsClientKey = String(object.tlsClientKey);
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                return message;
            };

            /**
             * Creates a plain object from a NatsJetstreamTLSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @static
             * @param {protos.args.NatsJetstreamTLSOptions} message NatsJetstreamTLSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsJetstreamTLSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tlsCaCert = "";
                    object.tlsClientCert = "";
                    object.tlsClientKey = "";
                    object.tlsSkipVerify = false;
                    object.useTls = false;
                }
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    object.tlsCaCert = message.tlsCaCert;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = message.tlsClientCert;
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    object.tlsClientKey = message.tlsClientKey;
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                return object;
            };

            /**
             * Converts this NatsJetstreamTLSOptions to JSON.
             * @function toJSON
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsJetstreamTLSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsJetstreamTLSOptions;
        })();

        args.NatsJetstreamConn = (function() {

            /**
             * Properties of a NatsJetstreamConn.
             * @memberof protos.args
             * @interface INatsJetstreamConn
             * @property {string|null} [dsn] NatsJetstreamConn dsn
             * @property {string|null} [userCredentials] NatsJetstreamConn userCredentials
             * @property {string|null} [clientId] NatsJetstreamConn clientId
             * @property {protos.args.INatsJetstreamTLSOptions|null} [tlsOptions] NatsJetstreamConn tlsOptions
             * @property {string|null} [nkey] NatsJetstreamConn nkey
             */

            /**
             * Constructs a new NatsJetstreamConn.
             * @memberof protos.args
             * @classdesc Represents a NatsJetstreamConn.
             * @implements INatsJetstreamConn
             * @constructor
             * @param {protos.args.INatsJetstreamConn=} [properties] Properties to set
             */
            function NatsJetstreamConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsJetstreamConn dsn.
             * @member {string} dsn
             * @memberof protos.args.NatsJetstreamConn
             * @instance
             */
            NatsJetstreamConn.prototype.dsn = "";

            /**
             * NatsJetstreamConn userCredentials.
             * @member {string} userCredentials
             * @memberof protos.args.NatsJetstreamConn
             * @instance
             */
            NatsJetstreamConn.prototype.userCredentials = "";

            /**
             * NatsJetstreamConn clientId.
             * @member {string} clientId
             * @memberof protos.args.NatsJetstreamConn
             * @instance
             */
            NatsJetstreamConn.prototype.clientId = "";

            /**
             * NatsJetstreamConn tlsOptions.
             * @member {protos.args.INatsJetstreamTLSOptions|null|undefined} tlsOptions
             * @memberof protos.args.NatsJetstreamConn
             * @instance
             */
            NatsJetstreamConn.prototype.tlsOptions = null;

            /**
             * NatsJetstreamConn nkey.
             * @member {string} nkey
             * @memberof protos.args.NatsJetstreamConn
             * @instance
             */
            NatsJetstreamConn.prototype.nkey = "";

            /**
             * Creates a new NatsJetstreamConn instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsJetstreamConn
             * @static
             * @param {protos.args.INatsJetstreamConn=} [properties] Properties to set
             * @returns {protos.args.NatsJetstreamConn} NatsJetstreamConn instance
             */
            NatsJetstreamConn.create = function create(properties) {
                return new NatsJetstreamConn(properties);
            };

            /**
             * Encodes the specified NatsJetstreamConn message. Does not implicitly {@link protos.args.NatsJetstreamConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsJetstreamConn
             * @static
             * @param {protos.args.INatsJetstreamConn} message NatsJetstreamConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsJetstreamConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                if (message.userCredentials != null && Object.hasOwnProperty.call(message, "userCredentials"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.userCredentials);
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.clientId);
                if (message.tlsOptions != null && Object.hasOwnProperty.call(message, "tlsOptions"))
                    $root.protos.args.NatsJetstreamTLSOptions.encode(message.tlsOptions, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.nkey != null && Object.hasOwnProperty.call(message, "nkey"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.nkey);
                return writer;
            };

            /**
             * Encodes the specified NatsJetstreamConn message, length delimited. Does not implicitly {@link protos.args.NatsJetstreamConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsJetstreamConn
             * @static
             * @param {protos.args.INatsJetstreamConn} message NatsJetstreamConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsJetstreamConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsJetstreamConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsJetstreamConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsJetstreamConn} NatsJetstreamConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsJetstreamConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsJetstreamConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    case 2:
                        message.userCredentials = reader.string();
                        break;
                    case 3:
                        message.clientId = reader.string();
                        break;
                    case 4:
                        message.tlsOptions = $root.protos.args.NatsJetstreamTLSOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.nkey = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsJetstreamConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsJetstreamConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsJetstreamConn} NatsJetstreamConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsJetstreamConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsJetstreamConn message.
             * @function verify
             * @memberof protos.args.NatsJetstreamConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsJetstreamConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                if (message.userCredentials != null && message.hasOwnProperty("userCredentials"))
                    if (!$util.isString(message.userCredentials))
                        return "userCredentials: string expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                if (message.tlsOptions != null && message.hasOwnProperty("tlsOptions")) {
                    var error = $root.protos.args.NatsJetstreamTLSOptions.verify(message.tlsOptions);
                    if (error)
                        return "tlsOptions." + error;
                }
                if (message.nkey != null && message.hasOwnProperty("nkey"))
                    if (!$util.isString(message.nkey))
                        return "nkey: string expected";
                return null;
            };

            /**
             * Creates a NatsJetstreamConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsJetstreamConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsJetstreamConn} NatsJetstreamConn
             */
            NatsJetstreamConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsJetstreamConn)
                    return object;
                var message = new $root.protos.args.NatsJetstreamConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                if (object.userCredentials != null)
                    message.userCredentials = String(object.userCredentials);
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                if (object.tlsOptions != null) {
                    if (typeof object.tlsOptions !== "object")
                        throw TypeError(".protos.args.NatsJetstreamConn.tlsOptions: object expected");
                    message.tlsOptions = $root.protos.args.NatsJetstreamTLSOptions.fromObject(object.tlsOptions);
                }
                if (object.nkey != null)
                    message.nkey = String(object.nkey);
                return message;
            };

            /**
             * Creates a plain object from a NatsJetstreamConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsJetstreamConn
             * @static
             * @param {protos.args.NatsJetstreamConn} message NatsJetstreamConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsJetstreamConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.dsn = "";
                    object.userCredentials = "";
                    object.clientId = "";
                    object.tlsOptions = null;
                    object.nkey = "";
                }
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                if (message.userCredentials != null && message.hasOwnProperty("userCredentials"))
                    object.userCredentials = message.userCredentials;
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                if (message.tlsOptions != null && message.hasOwnProperty("tlsOptions"))
                    object.tlsOptions = $root.protos.args.NatsJetstreamTLSOptions.toObject(message.tlsOptions, options);
                if (message.nkey != null && message.hasOwnProperty("nkey"))
                    object.nkey = message.nkey;
                return object;
            };

            /**
             * Converts this NatsJetstreamConn to JSON.
             * @function toJSON
             * @memberof protos.args.NatsJetstreamConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsJetstreamConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsJetstreamConn;
        })();

        args.NatsJetstreamReadArgs = (function() {

            /**
             * Properties of a NatsJetstreamReadArgs.
             * @memberof protos.args
             * @interface INatsJetstreamReadArgs
             * @property {string|null} [stream] NatsJetstreamReadArgs stream
             * @property {string|null} [consumerName] NatsJetstreamReadArgs consumerName
             * @property {boolean|null} [createDurableConsumer] NatsJetstreamReadArgs createDurableConsumer
             * @property {boolean|null} [existingDurableConsumer] NatsJetstreamReadArgs existingDurableConsumer
             * @property {boolean|null} [keepConsumer] NatsJetstreamReadArgs keepConsumer
             * @property {number|Long|null} [consumerStartSequence] NatsJetstreamReadArgs consumerStartSequence
             * @property {string|null} [consumerStartTime] NatsJetstreamReadArgs consumerStartTime
             * @property {string|null} [consumerFilterSubject] NatsJetstreamReadArgs consumerFilterSubject
             */

            /**
             * Constructs a new NatsJetstreamReadArgs.
             * @memberof protos.args
             * @classdesc Represents a NatsJetstreamReadArgs.
             * @implements INatsJetstreamReadArgs
             * @constructor
             * @param {protos.args.INatsJetstreamReadArgs=} [properties] Properties to set
             */
            function NatsJetstreamReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsJetstreamReadArgs stream.
             * @member {string} stream
             * @memberof protos.args.NatsJetstreamReadArgs
             * @instance
             */
            NatsJetstreamReadArgs.prototype.stream = "";

            /**
             * NatsJetstreamReadArgs consumerName.
             * @member {string} consumerName
             * @memberof protos.args.NatsJetstreamReadArgs
             * @instance
             */
            NatsJetstreamReadArgs.prototype.consumerName = "";

            /**
             * NatsJetstreamReadArgs createDurableConsumer.
             * @member {boolean} createDurableConsumer
             * @memberof protos.args.NatsJetstreamReadArgs
             * @instance
             */
            NatsJetstreamReadArgs.prototype.createDurableConsumer = false;

            /**
             * NatsJetstreamReadArgs existingDurableConsumer.
             * @member {boolean} existingDurableConsumer
             * @memberof protos.args.NatsJetstreamReadArgs
             * @instance
             */
            NatsJetstreamReadArgs.prototype.existingDurableConsumer = false;

            /**
             * NatsJetstreamReadArgs keepConsumer.
             * @member {boolean} keepConsumer
             * @memberof protos.args.NatsJetstreamReadArgs
             * @instance
             */
            NatsJetstreamReadArgs.prototype.keepConsumer = false;

            /**
             * NatsJetstreamReadArgs consumerStartSequence.
             * @member {number|Long} consumerStartSequence
             * @memberof protos.args.NatsJetstreamReadArgs
             * @instance
             */
            NatsJetstreamReadArgs.prototype.consumerStartSequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * NatsJetstreamReadArgs consumerStartTime.
             * @member {string} consumerStartTime
             * @memberof protos.args.NatsJetstreamReadArgs
             * @instance
             */
            NatsJetstreamReadArgs.prototype.consumerStartTime = "";

            /**
             * NatsJetstreamReadArgs consumerFilterSubject.
             * @member {string} consumerFilterSubject
             * @memberof protos.args.NatsJetstreamReadArgs
             * @instance
             */
            NatsJetstreamReadArgs.prototype.consumerFilterSubject = "";

            /**
             * Creates a new NatsJetstreamReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsJetstreamReadArgs
             * @static
             * @param {protos.args.INatsJetstreamReadArgs=} [properties] Properties to set
             * @returns {protos.args.NatsJetstreamReadArgs} NatsJetstreamReadArgs instance
             */
            NatsJetstreamReadArgs.create = function create(properties) {
                return new NatsJetstreamReadArgs(properties);
            };

            /**
             * Encodes the specified NatsJetstreamReadArgs message. Does not implicitly {@link protos.args.NatsJetstreamReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsJetstreamReadArgs
             * @static
             * @param {protos.args.INatsJetstreamReadArgs} message NatsJetstreamReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsJetstreamReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stream);
                if (message.consumerName != null && Object.hasOwnProperty.call(message, "consumerName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.consumerName);
                if (message.createDurableConsumer != null && Object.hasOwnProperty.call(message, "createDurableConsumer"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.createDurableConsumer);
                if (message.existingDurableConsumer != null && Object.hasOwnProperty.call(message, "existingDurableConsumer"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.existingDurableConsumer);
                if (message.keepConsumer != null && Object.hasOwnProperty.call(message, "keepConsumer"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.keepConsumer);
                if (message.consumerStartSequence != null && Object.hasOwnProperty.call(message, "consumerStartSequence"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.consumerStartSequence);
                if (message.consumerStartTime != null && Object.hasOwnProperty.call(message, "consumerStartTime"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.consumerStartTime);
                if (message.consumerFilterSubject != null && Object.hasOwnProperty.call(message, "consumerFilterSubject"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.consumerFilterSubject);
                return writer;
            };

            /**
             * Encodes the specified NatsJetstreamReadArgs message, length delimited. Does not implicitly {@link protos.args.NatsJetstreamReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsJetstreamReadArgs
             * @static
             * @param {protos.args.INatsJetstreamReadArgs} message NatsJetstreamReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsJetstreamReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsJetstreamReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsJetstreamReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsJetstreamReadArgs} NatsJetstreamReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsJetstreamReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsJetstreamReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stream = reader.string();
                        break;
                    case 2:
                        message.consumerName = reader.string();
                        break;
                    case 3:
                        message.createDurableConsumer = reader.bool();
                        break;
                    case 4:
                        message.existingDurableConsumer = reader.bool();
                        break;
                    case 5:
                        message.keepConsumer = reader.bool();
                        break;
                    case 6:
                        message.consumerStartSequence = reader.int64();
                        break;
                    case 7:
                        message.consumerStartTime = reader.string();
                        break;
                    case 8:
                        message.consumerFilterSubject = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsJetstreamReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsJetstreamReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsJetstreamReadArgs} NatsJetstreamReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsJetstreamReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsJetstreamReadArgs message.
             * @function verify
             * @memberof protos.args.NatsJetstreamReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsJetstreamReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isString(message.stream))
                        return "stream: string expected";
                if (message.consumerName != null && message.hasOwnProperty("consumerName"))
                    if (!$util.isString(message.consumerName))
                        return "consumerName: string expected";
                if (message.createDurableConsumer != null && message.hasOwnProperty("createDurableConsumer"))
                    if (typeof message.createDurableConsumer !== "boolean")
                        return "createDurableConsumer: boolean expected";
                if (message.existingDurableConsumer != null && message.hasOwnProperty("existingDurableConsumer"))
                    if (typeof message.existingDurableConsumer !== "boolean")
                        return "existingDurableConsumer: boolean expected";
                if (message.keepConsumer != null && message.hasOwnProperty("keepConsumer"))
                    if (typeof message.keepConsumer !== "boolean")
                        return "keepConsumer: boolean expected";
                if (message.consumerStartSequence != null && message.hasOwnProperty("consumerStartSequence"))
                    if (!$util.isInteger(message.consumerStartSequence) && !(message.consumerStartSequence && $util.isInteger(message.consumerStartSequence.low) && $util.isInteger(message.consumerStartSequence.high)))
                        return "consumerStartSequence: integer|Long expected";
                if (message.consumerStartTime != null && message.hasOwnProperty("consumerStartTime"))
                    if (!$util.isString(message.consumerStartTime))
                        return "consumerStartTime: string expected";
                if (message.consumerFilterSubject != null && message.hasOwnProperty("consumerFilterSubject"))
                    if (!$util.isString(message.consumerFilterSubject))
                        return "consumerFilterSubject: string expected";
                return null;
            };

            /**
             * Creates a NatsJetstreamReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsJetstreamReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsJetstreamReadArgs} NatsJetstreamReadArgs
             */
            NatsJetstreamReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsJetstreamReadArgs)
                    return object;
                var message = new $root.protos.args.NatsJetstreamReadArgs();
                if (object.stream != null)
                    message.stream = String(object.stream);
                if (object.consumerName != null)
                    message.consumerName = String(object.consumerName);
                if (object.createDurableConsumer != null)
                    message.createDurableConsumer = Boolean(object.createDurableConsumer);
                if (object.existingDurableConsumer != null)
                    message.existingDurableConsumer = Boolean(object.existingDurableConsumer);
                if (object.keepConsumer != null)
                    message.keepConsumer = Boolean(object.keepConsumer);
                if (object.consumerStartSequence != null)
                    if ($util.Long)
                        (message.consumerStartSequence = $util.Long.fromValue(object.consumerStartSequence)).unsigned = false;
                    else if (typeof object.consumerStartSequence === "string")
                        message.consumerStartSequence = parseInt(object.consumerStartSequence, 10);
                    else if (typeof object.consumerStartSequence === "number")
                        message.consumerStartSequence = object.consumerStartSequence;
                    else if (typeof object.consumerStartSequence === "object")
                        message.consumerStartSequence = new $util.LongBits(object.consumerStartSequence.low >>> 0, object.consumerStartSequence.high >>> 0).toNumber();
                if (object.consumerStartTime != null)
                    message.consumerStartTime = String(object.consumerStartTime);
                if (object.consumerFilterSubject != null)
                    message.consumerFilterSubject = String(object.consumerFilterSubject);
                return message;
            };

            /**
             * Creates a plain object from a NatsJetstreamReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsJetstreamReadArgs
             * @static
             * @param {protos.args.NatsJetstreamReadArgs} message NatsJetstreamReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsJetstreamReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.stream = "";
                    object.consumerName = "";
                    object.createDurableConsumer = false;
                    object.existingDurableConsumer = false;
                    object.keepConsumer = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.consumerStartSequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.consumerStartSequence = options.longs === String ? "0" : 0;
                    object.consumerStartTime = "";
                    object.consumerFilterSubject = "";
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                if (message.consumerName != null && message.hasOwnProperty("consumerName"))
                    object.consumerName = message.consumerName;
                if (message.createDurableConsumer != null && message.hasOwnProperty("createDurableConsumer"))
                    object.createDurableConsumer = message.createDurableConsumer;
                if (message.existingDurableConsumer != null && message.hasOwnProperty("existingDurableConsumer"))
                    object.existingDurableConsumer = message.existingDurableConsumer;
                if (message.keepConsumer != null && message.hasOwnProperty("keepConsumer"))
                    object.keepConsumer = message.keepConsumer;
                if (message.consumerStartSequence != null && message.hasOwnProperty("consumerStartSequence"))
                    if (typeof message.consumerStartSequence === "number")
                        object.consumerStartSequence = options.longs === String ? String(message.consumerStartSequence) : message.consumerStartSequence;
                    else
                        object.consumerStartSequence = options.longs === String ? $util.Long.prototype.toString.call(message.consumerStartSequence) : options.longs === Number ? new $util.LongBits(message.consumerStartSequence.low >>> 0, message.consumerStartSequence.high >>> 0).toNumber() : message.consumerStartSequence;
                if (message.consumerStartTime != null && message.hasOwnProperty("consumerStartTime"))
                    object.consumerStartTime = message.consumerStartTime;
                if (message.consumerFilterSubject != null && message.hasOwnProperty("consumerFilterSubject"))
                    object.consumerFilterSubject = message.consumerFilterSubject;
                return object;
            };

            /**
             * Converts this NatsJetstreamReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NatsJetstreamReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsJetstreamReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsJetstreamReadArgs;
        })();

        args.NatsJetstreamWriteArgs = (function() {

            /**
             * Properties of a NatsJetstreamWriteArgs.
             * @memberof protos.args
             * @interface INatsJetstreamWriteArgs
             * @property {string|null} [subject] NatsJetstreamWriteArgs subject
             */

            /**
             * Constructs a new NatsJetstreamWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a NatsJetstreamWriteArgs.
             * @implements INatsJetstreamWriteArgs
             * @constructor
             * @param {protos.args.INatsJetstreamWriteArgs=} [properties] Properties to set
             */
            function NatsJetstreamWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsJetstreamWriteArgs subject.
             * @member {string} subject
             * @memberof protos.args.NatsJetstreamWriteArgs
             * @instance
             */
            NatsJetstreamWriteArgs.prototype.subject = "";

            /**
             * Creates a new NatsJetstreamWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsJetstreamWriteArgs
             * @static
             * @param {protos.args.INatsJetstreamWriteArgs=} [properties] Properties to set
             * @returns {protos.args.NatsJetstreamWriteArgs} NatsJetstreamWriteArgs instance
             */
            NatsJetstreamWriteArgs.create = function create(properties) {
                return new NatsJetstreamWriteArgs(properties);
            };

            /**
             * Encodes the specified NatsJetstreamWriteArgs message. Does not implicitly {@link protos.args.NatsJetstreamWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsJetstreamWriteArgs
             * @static
             * @param {protos.args.INatsJetstreamWriteArgs} message NatsJetstreamWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsJetstreamWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.subject);
                return writer;
            };

            /**
             * Encodes the specified NatsJetstreamWriteArgs message, length delimited. Does not implicitly {@link protos.args.NatsJetstreamWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsJetstreamWriteArgs
             * @static
             * @param {protos.args.INatsJetstreamWriteArgs} message NatsJetstreamWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsJetstreamWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsJetstreamWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsJetstreamWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsJetstreamWriteArgs} NatsJetstreamWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsJetstreamWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsJetstreamWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subject = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsJetstreamWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsJetstreamWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsJetstreamWriteArgs} NatsJetstreamWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsJetstreamWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsJetstreamWriteArgs message.
             * @function verify
             * @memberof protos.args.NatsJetstreamWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsJetstreamWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    if (!$util.isString(message.subject))
                        return "subject: string expected";
                return null;
            };

            /**
             * Creates a NatsJetstreamWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsJetstreamWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsJetstreamWriteArgs} NatsJetstreamWriteArgs
             */
            NatsJetstreamWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsJetstreamWriteArgs)
                    return object;
                var message = new $root.protos.args.NatsJetstreamWriteArgs();
                if (object.subject != null)
                    message.subject = String(object.subject);
                return message;
            };

            /**
             * Creates a plain object from a NatsJetstreamWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsJetstreamWriteArgs
             * @static
             * @param {protos.args.NatsJetstreamWriteArgs} message NatsJetstreamWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsJetstreamWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.subject = "";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    object.subject = message.subject;
                return object;
            };

            /**
             * Converts this NatsJetstreamWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NatsJetstreamWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsJetstreamWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsJetstreamWriteArgs;
        })();

        args.NatsStreamingTLSOptions = (function() {

            /**
             * Properties of a NatsStreamingTLSOptions.
             * @memberof protos.args
             * @interface INatsStreamingTLSOptions
             * @property {string|null} [tlsCaCert] NatsStreamingTLSOptions tlsCaCert
             * @property {string|null} [tlsClientCert] NatsStreamingTLSOptions tlsClientCert
             * @property {string|null} [tlsClientKey] NatsStreamingTLSOptions tlsClientKey
             * @property {boolean|null} [tlsSkipVerify] NatsStreamingTLSOptions tlsSkipVerify
             * @property {boolean|null} [useTls] NatsStreamingTLSOptions useTls
             */

            /**
             * Constructs a new NatsStreamingTLSOptions.
             * @memberof protos.args
             * @classdesc Represents a NatsStreamingTLSOptions.
             * @implements INatsStreamingTLSOptions
             * @constructor
             * @param {protos.args.INatsStreamingTLSOptions=} [properties] Properties to set
             */
            function NatsStreamingTLSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsStreamingTLSOptions tlsCaCert.
             * @member {string} tlsCaCert
             * @memberof protos.args.NatsStreamingTLSOptions
             * @instance
             */
            NatsStreamingTLSOptions.prototype.tlsCaCert = "";

            /**
             * NatsStreamingTLSOptions tlsClientCert.
             * @member {string} tlsClientCert
             * @memberof protos.args.NatsStreamingTLSOptions
             * @instance
             */
            NatsStreamingTLSOptions.prototype.tlsClientCert = "";

            /**
             * NatsStreamingTLSOptions tlsClientKey.
             * @member {string} tlsClientKey
             * @memberof protos.args.NatsStreamingTLSOptions
             * @instance
             */
            NatsStreamingTLSOptions.prototype.tlsClientKey = "";

            /**
             * NatsStreamingTLSOptions tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.args.NatsStreamingTLSOptions
             * @instance
             */
            NatsStreamingTLSOptions.prototype.tlsSkipVerify = false;

            /**
             * NatsStreamingTLSOptions useTls.
             * @member {boolean} useTls
             * @memberof protos.args.NatsStreamingTLSOptions
             * @instance
             */
            NatsStreamingTLSOptions.prototype.useTls = false;

            /**
             * Creates a new NatsStreamingTLSOptions instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsStreamingTLSOptions
             * @static
             * @param {protos.args.INatsStreamingTLSOptions=} [properties] Properties to set
             * @returns {protos.args.NatsStreamingTLSOptions} NatsStreamingTLSOptions instance
             */
            NatsStreamingTLSOptions.create = function create(properties) {
                return new NatsStreamingTLSOptions(properties);
            };

            /**
             * Encodes the specified NatsStreamingTLSOptions message. Does not implicitly {@link protos.args.NatsStreamingTLSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsStreamingTLSOptions
             * @static
             * @param {protos.args.INatsStreamingTLSOptions} message NatsStreamingTLSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingTLSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tlsCaCert != null && Object.hasOwnProperty.call(message, "tlsCaCert"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tlsCaCert);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.tlsClientCert);
                if (message.tlsClientKey != null && Object.hasOwnProperty.call(message, "tlsClientKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.tlsClientKey);
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.tlsSkipVerify);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.useTls);
                return writer;
            };

            /**
             * Encodes the specified NatsStreamingTLSOptions message, length delimited. Does not implicitly {@link protos.args.NatsStreamingTLSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsStreamingTLSOptions
             * @static
             * @param {protos.args.INatsStreamingTLSOptions} message NatsStreamingTLSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingTLSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsStreamingTLSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsStreamingTLSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsStreamingTLSOptions} NatsStreamingTLSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingTLSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsStreamingTLSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tlsCaCert = reader.string();
                        break;
                    case 2:
                        message.tlsClientCert = reader.string();
                        break;
                    case 3:
                        message.tlsClientKey = reader.string();
                        break;
                    case 4:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    case 5:
                        message.useTls = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsStreamingTLSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsStreamingTLSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsStreamingTLSOptions} NatsStreamingTLSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingTLSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsStreamingTLSOptions message.
             * @function verify
             * @memberof protos.args.NatsStreamingTLSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsStreamingTLSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    if (!$util.isString(message.tlsCaCert))
                        return "tlsCaCert: string expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!$util.isString(message.tlsClientCert))
                        return "tlsClientCert: string expected";
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    if (!$util.isString(message.tlsClientKey))
                        return "tlsClientKey: string expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                return null;
            };

            /**
             * Creates a NatsStreamingTLSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsStreamingTLSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsStreamingTLSOptions} NatsStreamingTLSOptions
             */
            NatsStreamingTLSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsStreamingTLSOptions)
                    return object;
                var message = new $root.protos.args.NatsStreamingTLSOptions();
                if (object.tlsCaCert != null)
                    message.tlsCaCert = String(object.tlsCaCert);
                if (object.tlsClientCert != null)
                    message.tlsClientCert = String(object.tlsClientCert);
                if (object.tlsClientKey != null)
                    message.tlsClientKey = String(object.tlsClientKey);
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                return message;
            };

            /**
             * Creates a plain object from a NatsStreamingTLSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsStreamingTLSOptions
             * @static
             * @param {protos.args.NatsStreamingTLSOptions} message NatsStreamingTLSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsStreamingTLSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tlsCaCert = "";
                    object.tlsClientCert = "";
                    object.tlsClientKey = "";
                    object.tlsSkipVerify = false;
                    object.useTls = false;
                }
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    object.tlsCaCert = message.tlsCaCert;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = message.tlsClientCert;
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    object.tlsClientKey = message.tlsClientKey;
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                return object;
            };

            /**
             * Converts this NatsStreamingTLSOptions to JSON.
             * @function toJSON
             * @memberof protos.args.NatsStreamingTLSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsStreamingTLSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsStreamingTLSOptions;
        })();

        args.NatsStreamingConn = (function() {

            /**
             * Properties of a NatsStreamingConn.
             * @memberof protos.args
             * @interface INatsStreamingConn
             * @property {string|null} [dsn] NatsStreamingConn dsn
             * @property {string|null} [userCredentials] NatsStreamingConn userCredentials
             * @property {string|null} [clusterId] NatsStreamingConn clusterId
             * @property {string|null} [clientId] NatsStreamingConn clientId
             * @property {protos.args.INatsStreamingTLSOptions|null} [tlsOptions] NatsStreamingConn tlsOptions
             */

            /**
             * Constructs a new NatsStreamingConn.
             * @memberof protos.args
             * @classdesc Represents a NatsStreamingConn.
             * @implements INatsStreamingConn
             * @constructor
             * @param {protos.args.INatsStreamingConn=} [properties] Properties to set
             */
            function NatsStreamingConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsStreamingConn dsn.
             * @member {string} dsn
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.dsn = "";

            /**
             * NatsStreamingConn userCredentials.
             * @member {string} userCredentials
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.userCredentials = "";

            /**
             * NatsStreamingConn clusterId.
             * @member {string} clusterId
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.clusterId = "";

            /**
             * NatsStreamingConn clientId.
             * @member {string} clientId
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.clientId = "";

            /**
             * NatsStreamingConn tlsOptions.
             * @member {protos.args.INatsStreamingTLSOptions|null|undefined} tlsOptions
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.tlsOptions = null;

            /**
             * Creates a new NatsStreamingConn instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {protos.args.INatsStreamingConn=} [properties] Properties to set
             * @returns {protos.args.NatsStreamingConn} NatsStreamingConn instance
             */
            NatsStreamingConn.create = function create(properties) {
                return new NatsStreamingConn(properties);
            };

            /**
             * Encodes the specified NatsStreamingConn message. Does not implicitly {@link protos.args.NatsStreamingConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {protos.args.INatsStreamingConn} message NatsStreamingConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                if (message.userCredentials != null && Object.hasOwnProperty.call(message, "userCredentials"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.userCredentials);
                if (message.clusterId != null && Object.hasOwnProperty.call(message, "clusterId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.clusterId);
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.clientId);
                if (message.tlsOptions != null && Object.hasOwnProperty.call(message, "tlsOptions"))
                    $root.protos.args.NatsStreamingTLSOptions.encode(message.tlsOptions, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NatsStreamingConn message, length delimited. Does not implicitly {@link protos.args.NatsStreamingConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {protos.args.INatsStreamingConn} message NatsStreamingConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsStreamingConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsStreamingConn} NatsStreamingConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsStreamingConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    case 2:
                        message.userCredentials = reader.string();
                        break;
                    case 3:
                        message.clusterId = reader.string();
                        break;
                    case 4:
                        message.clientId = reader.string();
                        break;
                    case 5:
                        message.tlsOptions = $root.protos.args.NatsStreamingTLSOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsStreamingConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsStreamingConn} NatsStreamingConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsStreamingConn message.
             * @function verify
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsStreamingConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                if (message.userCredentials != null && message.hasOwnProperty("userCredentials"))
                    if (!$util.isString(message.userCredentials))
                        return "userCredentials: string expected";
                if (message.clusterId != null && message.hasOwnProperty("clusterId"))
                    if (!$util.isString(message.clusterId))
                        return "clusterId: string expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                if (message.tlsOptions != null && message.hasOwnProperty("tlsOptions")) {
                    var error = $root.protos.args.NatsStreamingTLSOptions.verify(message.tlsOptions);
                    if (error)
                        return "tlsOptions." + error;
                }
                return null;
            };

            /**
             * Creates a NatsStreamingConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsStreamingConn} NatsStreamingConn
             */
            NatsStreamingConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsStreamingConn)
                    return object;
                var message = new $root.protos.args.NatsStreamingConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                if (object.userCredentials != null)
                    message.userCredentials = String(object.userCredentials);
                if (object.clusterId != null)
                    message.clusterId = String(object.clusterId);
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                if (object.tlsOptions != null) {
                    if (typeof object.tlsOptions !== "object")
                        throw TypeError(".protos.args.NatsStreamingConn.tlsOptions: object expected");
                    message.tlsOptions = $root.protos.args.NatsStreamingTLSOptions.fromObject(object.tlsOptions);
                }
                return message;
            };

            /**
             * Creates a plain object from a NatsStreamingConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {protos.args.NatsStreamingConn} message NatsStreamingConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsStreamingConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.dsn = "";
                    object.userCredentials = "";
                    object.clusterId = "";
                    object.clientId = "";
                    object.tlsOptions = null;
                }
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                if (message.userCredentials != null && message.hasOwnProperty("userCredentials"))
                    object.userCredentials = message.userCredentials;
                if (message.clusterId != null && message.hasOwnProperty("clusterId"))
                    object.clusterId = message.clusterId;
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                if (message.tlsOptions != null && message.hasOwnProperty("tlsOptions"))
                    object.tlsOptions = $root.protos.args.NatsStreamingTLSOptions.toObject(message.tlsOptions, options);
                return object;
            };

            /**
             * Converts this NatsStreamingConn to JSON.
             * @function toJSON
             * @memberof protos.args.NatsStreamingConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsStreamingConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsStreamingConn;
        })();

        args.NatsStreamingReadArgs = (function() {

            /**
             * Properties of a NatsStreamingReadArgs.
             * @memberof protos.args
             * @interface INatsStreamingReadArgs
             * @property {string|null} [channel] NatsStreamingReadArgs channel
             * @property {string|null} [durableName] NatsStreamingReadArgs durableName
             * @property {boolean|null} [readLastAvailable] NatsStreamingReadArgs readLastAvailable
             * @property {number|null} [readSequenceNumber] NatsStreamingReadArgs readSequenceNumber
             * @property {string|null} [readSince] NatsStreamingReadArgs readSince
             * @property {boolean|null} [readAll] NatsStreamingReadArgs readAll
             */

            /**
             * Constructs a new NatsStreamingReadArgs.
             * @memberof protos.args
             * @classdesc Represents a NatsStreamingReadArgs.
             * @implements INatsStreamingReadArgs
             * @constructor
             * @param {protos.args.INatsStreamingReadArgs=} [properties] Properties to set
             */
            function NatsStreamingReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsStreamingReadArgs channel.
             * @member {string} channel
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.channel = "";

            /**
             * NatsStreamingReadArgs durableName.
             * @member {string} durableName
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.durableName = "";

            /**
             * NatsStreamingReadArgs readLastAvailable.
             * @member {boolean} readLastAvailable
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.readLastAvailable = false;

            /**
             * NatsStreamingReadArgs readSequenceNumber.
             * @member {number} readSequenceNumber
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.readSequenceNumber = 0;

            /**
             * NatsStreamingReadArgs readSince.
             * @member {string} readSince
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.readSince = "";

            /**
             * NatsStreamingReadArgs readAll.
             * @member {boolean} readAll
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.readAll = false;

            /**
             * Creates a new NatsStreamingReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {protos.args.INatsStreamingReadArgs=} [properties] Properties to set
             * @returns {protos.args.NatsStreamingReadArgs} NatsStreamingReadArgs instance
             */
            NatsStreamingReadArgs.create = function create(properties) {
                return new NatsStreamingReadArgs(properties);
            };

            /**
             * Encodes the specified NatsStreamingReadArgs message. Does not implicitly {@link protos.args.NatsStreamingReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {protos.args.INatsStreamingReadArgs} message NatsStreamingReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);
                if (message.durableName != null && Object.hasOwnProperty.call(message, "durableName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.durableName);
                if (message.readLastAvailable != null && Object.hasOwnProperty.call(message, "readLastAvailable"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.readLastAvailable);
                if (message.readSequenceNumber != null && Object.hasOwnProperty.call(message, "readSequenceNumber"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.readSequenceNumber);
                if (message.readSince != null && Object.hasOwnProperty.call(message, "readSince"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.readSince);
                if (message.readAll != null && Object.hasOwnProperty.call(message, "readAll"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.readAll);
                return writer;
            };

            /**
             * Encodes the specified NatsStreamingReadArgs message, length delimited. Does not implicitly {@link protos.args.NatsStreamingReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {protos.args.INatsStreamingReadArgs} message NatsStreamingReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsStreamingReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsStreamingReadArgs} NatsStreamingReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsStreamingReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = reader.string();
                        break;
                    case 2:
                        message.durableName = reader.string();
                        break;
                    case 3:
                        message.readLastAvailable = reader.bool();
                        break;
                    case 4:
                        message.readSequenceNumber = reader.uint32();
                        break;
                    case 5:
                        message.readSince = reader.string();
                        break;
                    case 6:
                        message.readAll = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsStreamingReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsStreamingReadArgs} NatsStreamingReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsStreamingReadArgs message.
             * @function verify
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsStreamingReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                if (message.durableName != null && message.hasOwnProperty("durableName"))
                    if (!$util.isString(message.durableName))
                        return "durableName: string expected";
                if (message.readLastAvailable != null && message.hasOwnProperty("readLastAvailable"))
                    if (typeof message.readLastAvailable !== "boolean")
                        return "readLastAvailable: boolean expected";
                if (message.readSequenceNumber != null && message.hasOwnProperty("readSequenceNumber"))
                    if (!$util.isInteger(message.readSequenceNumber))
                        return "readSequenceNumber: integer expected";
                if (message.readSince != null && message.hasOwnProperty("readSince"))
                    if (!$util.isString(message.readSince))
                        return "readSince: string expected";
                if (message.readAll != null && message.hasOwnProperty("readAll"))
                    if (typeof message.readAll !== "boolean")
                        return "readAll: boolean expected";
                return null;
            };

            /**
             * Creates a NatsStreamingReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsStreamingReadArgs} NatsStreamingReadArgs
             */
            NatsStreamingReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsStreamingReadArgs)
                    return object;
                var message = new $root.protos.args.NatsStreamingReadArgs();
                if (object.channel != null)
                    message.channel = String(object.channel);
                if (object.durableName != null)
                    message.durableName = String(object.durableName);
                if (object.readLastAvailable != null)
                    message.readLastAvailable = Boolean(object.readLastAvailable);
                if (object.readSequenceNumber != null)
                    message.readSequenceNumber = object.readSequenceNumber >>> 0;
                if (object.readSince != null)
                    message.readSince = String(object.readSince);
                if (object.readAll != null)
                    message.readAll = Boolean(object.readAll);
                return message;
            };

            /**
             * Creates a plain object from a NatsStreamingReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {protos.args.NatsStreamingReadArgs} message NatsStreamingReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsStreamingReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.channel = "";
                    object.durableName = "";
                    object.readLastAvailable = false;
                    object.readSequenceNumber = 0;
                    object.readSince = "";
                    object.readAll = false;
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.durableName != null && message.hasOwnProperty("durableName"))
                    object.durableName = message.durableName;
                if (message.readLastAvailable != null && message.hasOwnProperty("readLastAvailable"))
                    object.readLastAvailable = message.readLastAvailable;
                if (message.readSequenceNumber != null && message.hasOwnProperty("readSequenceNumber"))
                    object.readSequenceNumber = message.readSequenceNumber;
                if (message.readSince != null && message.hasOwnProperty("readSince"))
                    object.readSince = message.readSince;
                if (message.readAll != null && message.hasOwnProperty("readAll"))
                    object.readAll = message.readAll;
                return object;
            };

            /**
             * Converts this NatsStreamingReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsStreamingReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsStreamingReadArgs;
        })();

        args.NatsStreamingWriteArgs = (function() {

            /**
             * Properties of a NatsStreamingWriteArgs.
             * @memberof protos.args
             * @interface INatsStreamingWriteArgs
             * @property {string|null} [channel] NatsStreamingWriteArgs channel
             */

            /**
             * Constructs a new NatsStreamingWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a NatsStreamingWriteArgs.
             * @implements INatsStreamingWriteArgs
             * @constructor
             * @param {protos.args.INatsStreamingWriteArgs=} [properties] Properties to set
             */
            function NatsStreamingWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsStreamingWriteArgs channel.
             * @member {string} channel
             * @memberof protos.args.NatsStreamingWriteArgs
             * @instance
             */
            NatsStreamingWriteArgs.prototype.channel = "";

            /**
             * Creates a new NatsStreamingWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {protos.args.INatsStreamingWriteArgs=} [properties] Properties to set
             * @returns {protos.args.NatsStreamingWriteArgs} NatsStreamingWriteArgs instance
             */
            NatsStreamingWriteArgs.create = function create(properties) {
                return new NatsStreamingWriteArgs(properties);
            };

            /**
             * Encodes the specified NatsStreamingWriteArgs message. Does not implicitly {@link protos.args.NatsStreamingWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {protos.args.INatsStreamingWriteArgs} message NatsStreamingWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);
                return writer;
            };

            /**
             * Encodes the specified NatsStreamingWriteArgs message, length delimited. Does not implicitly {@link protos.args.NatsStreamingWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {protos.args.INatsStreamingWriteArgs} message NatsStreamingWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsStreamingWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsStreamingWriteArgs} NatsStreamingWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsStreamingWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsStreamingWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsStreamingWriteArgs} NatsStreamingWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsStreamingWriteArgs message.
             * @function verify
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsStreamingWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                return null;
            };

            /**
             * Creates a NatsStreamingWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsStreamingWriteArgs} NatsStreamingWriteArgs
             */
            NatsStreamingWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsStreamingWriteArgs)
                    return object;
                var message = new $root.protos.args.NatsStreamingWriteArgs();
                if (object.channel != null)
                    message.channel = String(object.channel);
                return message;
            };

            /**
             * Creates a plain object from a NatsStreamingWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {protos.args.NatsStreamingWriteArgs} message NatsStreamingWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsStreamingWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.channel = "";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                return object;
            };

            /**
             * Converts this NatsStreamingWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NatsStreamingWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsStreamingWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsStreamingWriteArgs;
        })();

        args.NSQConn = (function() {

            /**
             * Properties of a NSQConn.
             * @memberof protos.args
             * @interface INSQConn
             * @property {string|null} [nsqdAddress] NSQConn nsqdAddress
             * @property {string|null} [lookupdAddress] NSQConn lookupdAddress
             * @property {boolean|null} [useTls] NSQConn useTls
             * @property {boolean|null} [tlsSkipVerify] NSQConn tlsSkipVerify
             * @property {string|null} [tlsCaCert] NSQConn tlsCaCert
             * @property {string|null} [tlsClientCert] NSQConn tlsClientCert
             * @property {string|null} [tlsClientKey] NSQConn tlsClientKey
             * @property {string|null} [authSecret] NSQConn authSecret
             * @property {string|null} [clientId] NSQConn clientId
             */

            /**
             * Constructs a new NSQConn.
             * @memberof protos.args
             * @classdesc Represents a NSQConn.
             * @implements INSQConn
             * @constructor
             * @param {protos.args.INSQConn=} [properties] Properties to set
             */
            function NSQConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NSQConn nsqdAddress.
             * @member {string} nsqdAddress
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.nsqdAddress = "";

            /**
             * NSQConn lookupdAddress.
             * @member {string} lookupdAddress
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.lookupdAddress = "";

            /**
             * NSQConn useTls.
             * @member {boolean} useTls
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.useTls = false;

            /**
             * NSQConn tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.tlsSkipVerify = false;

            /**
             * NSQConn tlsCaCert.
             * @member {string} tlsCaCert
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.tlsCaCert = "";

            /**
             * NSQConn tlsClientCert.
             * @member {string} tlsClientCert
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.tlsClientCert = "";

            /**
             * NSQConn tlsClientKey.
             * @member {string} tlsClientKey
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.tlsClientKey = "";

            /**
             * NSQConn authSecret.
             * @member {string} authSecret
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.authSecret = "";

            /**
             * NSQConn clientId.
             * @member {string} clientId
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.clientId = "";

            /**
             * Creates a new NSQConn instance using the specified properties.
             * @function create
             * @memberof protos.args.NSQConn
             * @static
             * @param {protos.args.INSQConn=} [properties] Properties to set
             * @returns {protos.args.NSQConn} NSQConn instance
             */
            NSQConn.create = function create(properties) {
                return new NSQConn(properties);
            };

            /**
             * Encodes the specified NSQConn message. Does not implicitly {@link protos.args.NSQConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NSQConn
             * @static
             * @param {protos.args.INSQConn} message NSQConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nsqdAddress != null && Object.hasOwnProperty.call(message, "nsqdAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nsqdAddress);
                if (message.lookupdAddress != null && Object.hasOwnProperty.call(message, "lookupdAddress"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.lookupdAddress);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.useTls);
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.tlsSkipVerify);
                if (message.tlsCaCert != null && Object.hasOwnProperty.call(message, "tlsCaCert"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.tlsCaCert);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.tlsClientCert);
                if (message.tlsClientKey != null && Object.hasOwnProperty.call(message, "tlsClientKey"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.tlsClientKey);
                if (message.authSecret != null && Object.hasOwnProperty.call(message, "authSecret"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.authSecret);
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.clientId);
                return writer;
            };

            /**
             * Encodes the specified NSQConn message, length delimited. Does not implicitly {@link protos.args.NSQConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NSQConn
             * @static
             * @param {protos.args.INSQConn} message NSQConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NSQConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NSQConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NSQConn} NSQConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NSQConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nsqdAddress = reader.string();
                        break;
                    case 2:
                        message.lookupdAddress = reader.string();
                        break;
                    case 3:
                        message.useTls = reader.bool();
                        break;
                    case 4:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    case 5:
                        message.tlsCaCert = reader.string();
                        break;
                    case 6:
                        message.tlsClientCert = reader.string();
                        break;
                    case 7:
                        message.tlsClientKey = reader.string();
                        break;
                    case 8:
                        message.authSecret = reader.string();
                        break;
                    case 9:
                        message.clientId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NSQConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NSQConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NSQConn} NSQConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NSQConn message.
             * @function verify
             * @memberof protos.args.NSQConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NSQConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nsqdAddress != null && message.hasOwnProperty("nsqdAddress"))
                    if (!$util.isString(message.nsqdAddress))
                        return "nsqdAddress: string expected";
                if (message.lookupdAddress != null && message.hasOwnProperty("lookupdAddress"))
                    if (!$util.isString(message.lookupdAddress))
                        return "lookupdAddress: string expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    if (!$util.isString(message.tlsCaCert))
                        return "tlsCaCert: string expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!$util.isString(message.tlsClientCert))
                        return "tlsClientCert: string expected";
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    if (!$util.isString(message.tlsClientKey))
                        return "tlsClientKey: string expected";
                if (message.authSecret != null && message.hasOwnProperty("authSecret"))
                    if (!$util.isString(message.authSecret))
                        return "authSecret: string expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                return null;
            };

            /**
             * Creates a NSQConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NSQConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NSQConn} NSQConn
             */
            NSQConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NSQConn)
                    return object;
                var message = new $root.protos.args.NSQConn();
                if (object.nsqdAddress != null)
                    message.nsqdAddress = String(object.nsqdAddress);
                if (object.lookupdAddress != null)
                    message.lookupdAddress = String(object.lookupdAddress);
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                if (object.tlsCaCert != null)
                    message.tlsCaCert = String(object.tlsCaCert);
                if (object.tlsClientCert != null)
                    message.tlsClientCert = String(object.tlsClientCert);
                if (object.tlsClientKey != null)
                    message.tlsClientKey = String(object.tlsClientKey);
                if (object.authSecret != null)
                    message.authSecret = String(object.authSecret);
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                return message;
            };

            /**
             * Creates a plain object from a NSQConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NSQConn
             * @static
             * @param {protos.args.NSQConn} message NSQConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NSQConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.nsqdAddress = "";
                    object.lookupdAddress = "";
                    object.useTls = false;
                    object.tlsSkipVerify = false;
                    object.tlsCaCert = "";
                    object.tlsClientCert = "";
                    object.tlsClientKey = "";
                    object.authSecret = "";
                    object.clientId = "";
                }
                if (message.nsqdAddress != null && message.hasOwnProperty("nsqdAddress"))
                    object.nsqdAddress = message.nsqdAddress;
                if (message.lookupdAddress != null && message.hasOwnProperty("lookupdAddress"))
                    object.lookupdAddress = message.lookupdAddress;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    object.tlsCaCert = message.tlsCaCert;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = message.tlsClientCert;
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    object.tlsClientKey = message.tlsClientKey;
                if (message.authSecret != null && message.hasOwnProperty("authSecret"))
                    object.authSecret = message.authSecret;
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                return object;
            };

            /**
             * Converts this NSQConn to JSON.
             * @function toJSON
             * @memberof protos.args.NSQConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NSQConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NSQConn;
        })();

        args.NSQReadArgs = (function() {

            /**
             * Properties of a NSQReadArgs.
             * @memberof protos.args
             * @interface INSQReadArgs
             * @property {string|null} [topic] NSQReadArgs topic
             * @property {string|null} [channel] NSQReadArgs channel
             */

            /**
             * Constructs a new NSQReadArgs.
             * @memberof protos.args
             * @classdesc Represents a NSQReadArgs.
             * @implements INSQReadArgs
             * @constructor
             * @param {protos.args.INSQReadArgs=} [properties] Properties to set
             */
            function NSQReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NSQReadArgs topic.
             * @member {string} topic
             * @memberof protos.args.NSQReadArgs
             * @instance
             */
            NSQReadArgs.prototype.topic = "";

            /**
             * NSQReadArgs channel.
             * @member {string} channel
             * @memberof protos.args.NSQReadArgs
             * @instance
             */
            NSQReadArgs.prototype.channel = "";

            /**
             * Creates a new NSQReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {protos.args.INSQReadArgs=} [properties] Properties to set
             * @returns {protos.args.NSQReadArgs} NSQReadArgs instance
             */
            NSQReadArgs.create = function create(properties) {
                return new NSQReadArgs(properties);
            };

            /**
             * Encodes the specified NSQReadArgs message. Does not implicitly {@link protos.args.NSQReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {protos.args.INSQReadArgs} message NSQReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.channel);
                return writer;
            };

            /**
             * Encodes the specified NSQReadArgs message, length delimited. Does not implicitly {@link protos.args.NSQReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {protos.args.INSQReadArgs} message NSQReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NSQReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NSQReadArgs} NSQReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NSQReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.channel = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NSQReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NSQReadArgs} NSQReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NSQReadArgs message.
             * @function verify
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NSQReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                return null;
            };

            /**
             * Creates a NSQReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NSQReadArgs} NSQReadArgs
             */
            NSQReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NSQReadArgs)
                    return object;
                var message = new $root.protos.args.NSQReadArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.channel != null)
                    message.channel = String(object.channel);
                return message;
            };

            /**
             * Creates a plain object from a NSQReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {protos.args.NSQReadArgs} message NSQReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NSQReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.channel = "";
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                return object;
            };

            /**
             * Converts this NSQReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NSQReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NSQReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NSQReadArgs;
        })();

        args.NSQWriteArgs = (function() {

            /**
             * Properties of a NSQWriteArgs.
             * @memberof protos.args
             * @interface INSQWriteArgs
             * @property {string|null} [topic] NSQWriteArgs topic
             */

            /**
             * Constructs a new NSQWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a NSQWriteArgs.
             * @implements INSQWriteArgs
             * @constructor
             * @param {protos.args.INSQWriteArgs=} [properties] Properties to set
             */
            function NSQWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NSQWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.NSQWriteArgs
             * @instance
             */
            NSQWriteArgs.prototype.topic = "";

            /**
             * Creates a new NSQWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {protos.args.INSQWriteArgs=} [properties] Properties to set
             * @returns {protos.args.NSQWriteArgs} NSQWriteArgs instance
             */
            NSQWriteArgs.create = function create(properties) {
                return new NSQWriteArgs(properties);
            };

            /**
             * Encodes the specified NSQWriteArgs message. Does not implicitly {@link protos.args.NSQWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {protos.args.INSQWriteArgs} message NSQWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                return writer;
            };

            /**
             * Encodes the specified NSQWriteArgs message, length delimited. Does not implicitly {@link protos.args.NSQWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {protos.args.INSQWriteArgs} message NSQWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NSQWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NSQWriteArgs} NSQWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NSQWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NSQWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NSQWriteArgs} NSQWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NSQWriteArgs message.
             * @function verify
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NSQWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                return null;
            };

            /**
             * Creates a NSQWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NSQWriteArgs} NSQWriteArgs
             */
            NSQWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NSQWriteArgs)
                    return object;
                var message = new $root.protos.args.NSQWriteArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                return message;
            };

            /**
             * Creates a plain object from a NSQWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {protos.args.NSQWriteArgs} message NSQWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NSQWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.topic = "";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                return object;
            };

            /**
             * Converts this NSQWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NSQWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NSQWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NSQWriteArgs;
        })();

        args.PostgresConn = (function() {

            /**
             * Properties of a PostgresConn.
             * @memberof protos.args
             * @interface IPostgresConn
             * @property {string|null} [address] PostgresConn address
             * @property {number|null} [port] PostgresConn port
             * @property {string|null} [username] PostgresConn username
             * @property {string|null} [password] PostgresConn password
             * @property {string|null} [database] PostgresConn database
             * @property {boolean|null} [useTls] PostgresConn useTls
             * @property {boolean|null} [tlsSkipVerify] PostgresConn tlsSkipVerify
             */

            /**
             * Constructs a new PostgresConn.
             * @memberof protos.args
             * @classdesc Represents a PostgresConn.
             * @implements IPostgresConn
             * @constructor
             * @param {protos.args.IPostgresConn=} [properties] Properties to set
             */
            function PostgresConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PostgresConn address.
             * @member {string} address
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.address = "";

            /**
             * PostgresConn port.
             * @member {number} port
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.port = 0;

            /**
             * PostgresConn username.
             * @member {string} username
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.username = "";

            /**
             * PostgresConn password.
             * @member {string} password
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.password = "";

            /**
             * PostgresConn database.
             * @member {string} database
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.database = "";

            /**
             * PostgresConn useTls.
             * @member {boolean} useTls
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.useTls = false;

            /**
             * PostgresConn tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.tlsSkipVerify = false;

            /**
             * Creates a new PostgresConn instance using the specified properties.
             * @function create
             * @memberof protos.args.PostgresConn
             * @static
             * @param {protos.args.IPostgresConn=} [properties] Properties to set
             * @returns {protos.args.PostgresConn} PostgresConn instance
             */
            PostgresConn.create = function create(properties) {
                return new PostgresConn(properties);
            };

            /**
             * Encodes the specified PostgresConn message. Does not implicitly {@link protos.args.PostgresConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.PostgresConn
             * @static
             * @param {protos.args.IPostgresConn} message PostgresConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PostgresConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.username);
                if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.password);
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.database);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.useTls);
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.tlsSkipVerify);
                return writer;
            };

            /**
             * Encodes the specified PostgresConn message, length delimited. Does not implicitly {@link protos.args.PostgresConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.PostgresConn
             * @static
             * @param {protos.args.IPostgresConn} message PostgresConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PostgresConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PostgresConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.PostgresConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.PostgresConn} PostgresConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PostgresConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.PostgresConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.port = reader.uint32();
                        break;
                    case 3:
                        message.username = reader.string();
                        break;
                    case 4:
                        message.password = reader.string();
                        break;
                    case 5:
                        message.database = reader.string();
                        break;
                    case 6:
                        message.useTls = reader.bool();
                        break;
                    case 7:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PostgresConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.PostgresConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.PostgresConn} PostgresConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PostgresConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PostgresConn message.
             * @function verify
             * @memberof protos.args.PostgresConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PostgresConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!$util.isString(message.password))
                        return "password: string expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                return null;
            };

            /**
             * Creates a PostgresConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.PostgresConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.PostgresConn} PostgresConn
             */
            PostgresConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.PostgresConn)
                    return object;
                var message = new $root.protos.args.PostgresConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.port != null)
                    message.port = object.port >>> 0;
                if (object.username != null)
                    message.username = String(object.username);
                if (object.password != null)
                    message.password = String(object.password);
                if (object.database != null)
                    message.database = String(object.database);
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                return message;
            };

            /**
             * Creates a plain object from a PostgresConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.PostgresConn
             * @static
             * @param {protos.args.PostgresConn} message PostgresConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PostgresConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = "";
                    object.port = 0;
                    object.username = "";
                    object.password = "";
                    object.database = "";
                    object.useTls = false;
                    object.tlsSkipVerify = false;
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = message.password;
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                return object;
            };

            /**
             * Converts this PostgresConn to JSON.
             * @function toJSON
             * @memberof protos.args.PostgresConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PostgresConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PostgresConn;
        })();

        args.PostgresReadArgs = (function() {

            /**
             * Properties of a PostgresReadArgs.
             * @memberof protos.args
             * @interface IPostgresReadArgs
             * @property {string|null} [replicationSlotName] PostgresReadArgs replicationSlotName
             * @property {string|null} [publisherName] PostgresReadArgs publisherName
             */

            /**
             * Constructs a new PostgresReadArgs.
             * @memberof protos.args
             * @classdesc Represents a PostgresReadArgs.
             * @implements IPostgresReadArgs
             * @constructor
             * @param {protos.args.IPostgresReadArgs=} [properties] Properties to set
             */
            function PostgresReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PostgresReadArgs replicationSlotName.
             * @member {string} replicationSlotName
             * @memberof protos.args.PostgresReadArgs
             * @instance
             */
            PostgresReadArgs.prototype.replicationSlotName = "";

            /**
             * PostgresReadArgs publisherName.
             * @member {string} publisherName
             * @memberof protos.args.PostgresReadArgs
             * @instance
             */
            PostgresReadArgs.prototype.publisherName = "";

            /**
             * Creates a new PostgresReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {protos.args.IPostgresReadArgs=} [properties] Properties to set
             * @returns {protos.args.PostgresReadArgs} PostgresReadArgs instance
             */
            PostgresReadArgs.create = function create(properties) {
                return new PostgresReadArgs(properties);
            };

            /**
             * Encodes the specified PostgresReadArgs message. Does not implicitly {@link protos.args.PostgresReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {protos.args.IPostgresReadArgs} message PostgresReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PostgresReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.replicationSlotName != null && Object.hasOwnProperty.call(message, "replicationSlotName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.replicationSlotName);
                if (message.publisherName != null && Object.hasOwnProperty.call(message, "publisherName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.publisherName);
                return writer;
            };

            /**
             * Encodes the specified PostgresReadArgs message, length delimited. Does not implicitly {@link protos.args.PostgresReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {protos.args.IPostgresReadArgs} message PostgresReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PostgresReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PostgresReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.PostgresReadArgs} PostgresReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PostgresReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.PostgresReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.replicationSlotName = reader.string();
                        break;
                    case 3:
                        message.publisherName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PostgresReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.PostgresReadArgs} PostgresReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PostgresReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PostgresReadArgs message.
             * @function verify
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PostgresReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.replicationSlotName != null && message.hasOwnProperty("replicationSlotName"))
                    if (!$util.isString(message.replicationSlotName))
                        return "replicationSlotName: string expected";
                if (message.publisherName != null && message.hasOwnProperty("publisherName"))
                    if (!$util.isString(message.publisherName))
                        return "publisherName: string expected";
                return null;
            };

            /**
             * Creates a PostgresReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.PostgresReadArgs} PostgresReadArgs
             */
            PostgresReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.PostgresReadArgs)
                    return object;
                var message = new $root.protos.args.PostgresReadArgs();
                if (object.replicationSlotName != null)
                    message.replicationSlotName = String(object.replicationSlotName);
                if (object.publisherName != null)
                    message.publisherName = String(object.publisherName);
                return message;
            };

            /**
             * Creates a plain object from a PostgresReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {protos.args.PostgresReadArgs} message PostgresReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PostgresReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.replicationSlotName = "";
                    object.publisherName = "";
                }
                if (message.replicationSlotName != null && message.hasOwnProperty("replicationSlotName"))
                    object.replicationSlotName = message.replicationSlotName;
                if (message.publisherName != null && message.hasOwnProperty("publisherName"))
                    object.publisherName = message.publisherName;
                return object;
            };

            /**
             * Converts this PostgresReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.PostgresReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PostgresReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PostgresReadArgs;
        })();

        /**
         * SubscriptionType enum.
         * @name protos.args.SubscriptionType
         * @enum {number}
         * @property {number} SHARED=0 SHARED value
         * @property {number} EXCLUSIVE=1 EXCLUSIVE value
         * @property {number} FAILOVER=2 FAILOVER value
         * @property {number} KEYSHARED=3 KEYSHARED value
         */
        args.SubscriptionType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SHARED"] = 0;
            values[valuesById[1] = "EXCLUSIVE"] = 1;
            values[valuesById[2] = "FAILOVER"] = 2;
            values[valuesById[3] = "KEYSHARED"] = 3;
            return values;
        })();

        /**
         * SubscriptionInitialPosition enum.
         * @name protos.args.SubscriptionInitialPosition
         * @enum {number}
         * @property {number} PULSAR_LATEST=0 PULSAR_LATEST value
         * @property {number} PULSAR_EARLIEST=1 PULSAR_EARLIEST value
         */
        args.SubscriptionInitialPosition = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PULSAR_LATEST"] = 0;
            values[valuesById[1] = "PULSAR_EARLIEST"] = 1;
            return values;
        })();

        args.PulsarConn = (function() {

            /**
             * Properties of a PulsarConn.
             * @memberof protos.args
             * @interface IPulsarConn
             * @property {string|null} [dsn] PulsarConn dsn
             * @property {number|null} [connectTimeoutSeconds] PulsarConn connectTimeoutSeconds
             * @property {boolean|null} [tlsSkipVerify] PulsarConn tlsSkipVerify
             * @property {string|null} [tlsClientCert] PulsarConn tlsClientCert
             * @property {string|null} [tlsClientKey] PulsarConn tlsClientKey
             * @property {string|null} [token] PulsarConn token
             * @property {string|null} [listenerName] PulsarConn listenerName
             */

            /**
             * Constructs a new PulsarConn.
             * @memberof protos.args
             * @classdesc Represents a PulsarConn.
             * @implements IPulsarConn
             * @constructor
             * @param {protos.args.IPulsarConn=} [properties] Properties to set
             */
            function PulsarConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PulsarConn dsn.
             * @member {string} dsn
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.dsn = "";

            /**
             * PulsarConn connectTimeoutSeconds.
             * @member {number} connectTimeoutSeconds
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.connectTimeoutSeconds = 0;

            /**
             * PulsarConn tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.tlsSkipVerify = false;

            /**
             * PulsarConn tlsClientCert.
             * @member {string} tlsClientCert
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.tlsClientCert = "";

            /**
             * PulsarConn tlsClientKey.
             * @member {string} tlsClientKey
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.tlsClientKey = "";

            /**
             * PulsarConn token.
             * @member {string} token
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.token = "";

            /**
             * PulsarConn listenerName.
             * @member {string} listenerName
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.listenerName = "";

            /**
             * Creates a new PulsarConn instance using the specified properties.
             * @function create
             * @memberof protos.args.PulsarConn
             * @static
             * @param {protos.args.IPulsarConn=} [properties] Properties to set
             * @returns {protos.args.PulsarConn} PulsarConn instance
             */
            PulsarConn.create = function create(properties) {
                return new PulsarConn(properties);
            };

            /**
             * Encodes the specified PulsarConn message. Does not implicitly {@link protos.args.PulsarConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.PulsarConn
             * @static
             * @param {protos.args.IPulsarConn} message PulsarConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                if (message.connectTimeoutSeconds != null && Object.hasOwnProperty.call(message, "connectTimeoutSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.connectTimeoutSeconds);
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.tlsSkipVerify);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.tlsClientCert);
                if (message.tlsClientKey != null && Object.hasOwnProperty.call(message, "tlsClientKey"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.tlsClientKey);
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.token);
                if (message.listenerName != null && Object.hasOwnProperty.call(message, "listenerName"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.listenerName);
                return writer;
            };

            /**
             * Encodes the specified PulsarConn message, length delimited. Does not implicitly {@link protos.args.PulsarConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.PulsarConn
             * @static
             * @param {protos.args.IPulsarConn} message PulsarConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PulsarConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.PulsarConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.PulsarConn} PulsarConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.PulsarConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    case 2:
                        message.connectTimeoutSeconds = reader.uint32();
                        break;
                    case 3:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    case 4:
                        message.tlsClientCert = reader.string();
                        break;
                    case 5:
                        message.tlsClientKey = reader.string();
                        break;
                    case 6:
                        message.token = reader.string();
                        break;
                    case 7:
                        message.listenerName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PulsarConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.PulsarConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.PulsarConn} PulsarConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PulsarConn message.
             * @function verify
             * @memberof protos.args.PulsarConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PulsarConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                if (message.connectTimeoutSeconds != null && message.hasOwnProperty("connectTimeoutSeconds"))
                    if (!$util.isInteger(message.connectTimeoutSeconds))
                        return "connectTimeoutSeconds: integer expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!$util.isString(message.tlsClientCert))
                        return "tlsClientCert: string expected";
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    if (!$util.isString(message.tlsClientKey))
                        return "tlsClientKey: string expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                if (message.listenerName != null && message.hasOwnProperty("listenerName"))
                    if (!$util.isString(message.listenerName))
                        return "listenerName: string expected";
                return null;
            };

            /**
             * Creates a PulsarConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.PulsarConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.PulsarConn} PulsarConn
             */
            PulsarConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.PulsarConn)
                    return object;
                var message = new $root.protos.args.PulsarConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                if (object.connectTimeoutSeconds != null)
                    message.connectTimeoutSeconds = object.connectTimeoutSeconds >>> 0;
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                if (object.tlsClientCert != null)
                    message.tlsClientCert = String(object.tlsClientCert);
                if (object.tlsClientKey != null)
                    message.tlsClientKey = String(object.tlsClientKey);
                if (object.token != null)
                    message.token = String(object.token);
                if (object.listenerName != null)
                    message.listenerName = String(object.listenerName);
                return message;
            };

            /**
             * Creates a plain object from a PulsarConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.PulsarConn
             * @static
             * @param {protos.args.PulsarConn} message PulsarConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PulsarConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.dsn = "";
                    object.connectTimeoutSeconds = 0;
                    object.tlsSkipVerify = false;
                    object.tlsClientCert = "";
                    object.tlsClientKey = "";
                    object.token = "";
                    object.listenerName = "";
                }
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                if (message.connectTimeoutSeconds != null && message.hasOwnProperty("connectTimeoutSeconds"))
                    object.connectTimeoutSeconds = message.connectTimeoutSeconds;
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = message.tlsClientCert;
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    object.tlsClientKey = message.tlsClientKey;
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = message.token;
                if (message.listenerName != null && message.hasOwnProperty("listenerName"))
                    object.listenerName = message.listenerName;
                return object;
            };

            /**
             * Converts this PulsarConn to JSON.
             * @function toJSON
             * @memberof protos.args.PulsarConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PulsarConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PulsarConn;
        })();

        args.PulsarReadArgs = (function() {

            /**
             * Properties of a PulsarReadArgs.
             * @memberof protos.args
             * @interface IPulsarReadArgs
             * @property {string|null} [topic] PulsarReadArgs topic
             * @property {string|null} [subscriptionName] PulsarReadArgs subscriptionName
             * @property {protos.args.SubscriptionType|null} [subscriptionType] PulsarReadArgs subscriptionType
             * @property {protos.args.SubscriptionInitialPosition|null} [initialPosition] PulsarReadArgs initialPosition
             */

            /**
             * Constructs a new PulsarReadArgs.
             * @memberof protos.args
             * @classdesc Represents a PulsarReadArgs.
             * @implements IPulsarReadArgs
             * @constructor
             * @param {protos.args.IPulsarReadArgs=} [properties] Properties to set
             */
            function PulsarReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PulsarReadArgs topic.
             * @member {string} topic
             * @memberof protos.args.PulsarReadArgs
             * @instance
             */
            PulsarReadArgs.prototype.topic = "";

            /**
             * PulsarReadArgs subscriptionName.
             * @member {string} subscriptionName
             * @memberof protos.args.PulsarReadArgs
             * @instance
             */
            PulsarReadArgs.prototype.subscriptionName = "";

            /**
             * PulsarReadArgs subscriptionType.
             * @member {protos.args.SubscriptionType} subscriptionType
             * @memberof protos.args.PulsarReadArgs
             * @instance
             */
            PulsarReadArgs.prototype.subscriptionType = 0;

            /**
             * PulsarReadArgs initialPosition.
             * @member {protos.args.SubscriptionInitialPosition} initialPosition
             * @memberof protos.args.PulsarReadArgs
             * @instance
             */
            PulsarReadArgs.prototype.initialPosition = 0;

            /**
             * Creates a new PulsarReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {protos.args.IPulsarReadArgs=} [properties] Properties to set
             * @returns {protos.args.PulsarReadArgs} PulsarReadArgs instance
             */
            PulsarReadArgs.create = function create(properties) {
                return new PulsarReadArgs(properties);
            };

            /**
             * Encodes the specified PulsarReadArgs message. Does not implicitly {@link protos.args.PulsarReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {protos.args.IPulsarReadArgs} message PulsarReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.subscriptionName != null && Object.hasOwnProperty.call(message, "subscriptionName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.subscriptionName);
                if (message.subscriptionType != null && Object.hasOwnProperty.call(message, "subscriptionType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.subscriptionType);
                if (message.initialPosition != null && Object.hasOwnProperty.call(message, "initialPosition"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.initialPosition);
                return writer;
            };

            /**
             * Encodes the specified PulsarReadArgs message, length delimited. Does not implicitly {@link protos.args.PulsarReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {protos.args.IPulsarReadArgs} message PulsarReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PulsarReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.PulsarReadArgs} PulsarReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.PulsarReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.subscriptionName = reader.string();
                        break;
                    case 3:
                        message.subscriptionType = reader.int32();
                        break;
                    case 4:
                        message.initialPosition = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PulsarReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.PulsarReadArgs} PulsarReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PulsarReadArgs message.
             * @function verify
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PulsarReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.subscriptionName != null && message.hasOwnProperty("subscriptionName"))
                    if (!$util.isString(message.subscriptionName))
                        return "subscriptionName: string expected";
                if (message.subscriptionType != null && message.hasOwnProperty("subscriptionType"))
                    switch (message.subscriptionType) {
                    default:
                        return "subscriptionType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.initialPosition != null && message.hasOwnProperty("initialPosition"))
                    switch (message.initialPosition) {
                    default:
                        return "initialPosition: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a PulsarReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.PulsarReadArgs} PulsarReadArgs
             */
            PulsarReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.PulsarReadArgs)
                    return object;
                var message = new $root.protos.args.PulsarReadArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.subscriptionName != null)
                    message.subscriptionName = String(object.subscriptionName);
                switch (object.subscriptionType) {
                case "SHARED":
                case 0:
                    message.subscriptionType = 0;
                    break;
                case "EXCLUSIVE":
                case 1:
                    message.subscriptionType = 1;
                    break;
                case "FAILOVER":
                case 2:
                    message.subscriptionType = 2;
                    break;
                case "KEYSHARED":
                case 3:
                    message.subscriptionType = 3;
                    break;
                }
                switch (object.initialPosition) {
                case "PULSAR_LATEST":
                case 0:
                    message.initialPosition = 0;
                    break;
                case "PULSAR_EARLIEST":
                case 1:
                    message.initialPosition = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a PulsarReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {protos.args.PulsarReadArgs} message PulsarReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PulsarReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.subscriptionName = "";
                    object.subscriptionType = options.enums === String ? "SHARED" : 0;
                    object.initialPosition = options.enums === String ? "PULSAR_LATEST" : 0;
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.subscriptionName != null && message.hasOwnProperty("subscriptionName"))
                    object.subscriptionName = message.subscriptionName;
                if (message.subscriptionType != null && message.hasOwnProperty("subscriptionType"))
                    object.subscriptionType = options.enums === String ? $root.protos.args.SubscriptionType[message.subscriptionType] : message.subscriptionType;
                if (message.initialPosition != null && message.hasOwnProperty("initialPosition"))
                    object.initialPosition = options.enums === String ? $root.protos.args.SubscriptionInitialPosition[message.initialPosition] : message.initialPosition;
                return object;
            };

            /**
             * Converts this PulsarReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.PulsarReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PulsarReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PulsarReadArgs;
        })();

        args.PulsarWriteArgs = (function() {

            /**
             * Properties of a PulsarWriteArgs.
             * @memberof protos.args
             * @interface IPulsarWriteArgs
             * @property {string|null} [topic] PulsarWriteArgs topic
             */

            /**
             * Constructs a new PulsarWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a PulsarWriteArgs.
             * @implements IPulsarWriteArgs
             * @constructor
             * @param {protos.args.IPulsarWriteArgs=} [properties] Properties to set
             */
            function PulsarWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PulsarWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.PulsarWriteArgs
             * @instance
             */
            PulsarWriteArgs.prototype.topic = "";

            /**
             * Creates a new PulsarWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {protos.args.IPulsarWriteArgs=} [properties] Properties to set
             * @returns {protos.args.PulsarWriteArgs} PulsarWriteArgs instance
             */
            PulsarWriteArgs.create = function create(properties) {
                return new PulsarWriteArgs(properties);
            };

            /**
             * Encodes the specified PulsarWriteArgs message. Does not implicitly {@link protos.args.PulsarWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {protos.args.IPulsarWriteArgs} message PulsarWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                return writer;
            };

            /**
             * Encodes the specified PulsarWriteArgs message, length delimited. Does not implicitly {@link protos.args.PulsarWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {protos.args.IPulsarWriteArgs} message PulsarWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PulsarWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.PulsarWriteArgs} PulsarWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.PulsarWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PulsarWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.PulsarWriteArgs} PulsarWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PulsarWriteArgs message.
             * @function verify
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PulsarWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                return null;
            };

            /**
             * Creates a PulsarWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.PulsarWriteArgs} PulsarWriteArgs
             */
            PulsarWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.PulsarWriteArgs)
                    return object;
                var message = new $root.protos.args.PulsarWriteArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                return message;
            };

            /**
             * Creates a plain object from a PulsarWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {protos.args.PulsarWriteArgs} message PulsarWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PulsarWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.topic = "";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                return object;
            };

            /**
             * Converts this PulsarWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.PulsarWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PulsarWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PulsarWriteArgs;
        })();

        args.RabbitConn = (function() {

            /**
             * Properties of a RabbitConn.
             * @memberof protos.args
             * @interface IRabbitConn
             * @property {string|null} [address] RabbitConn address
             * @property {boolean|null} [useTls] RabbitConn useTls
             * @property {boolean|null} [tlsSkipVerify] RabbitConn tlsSkipVerify
             */

            /**
             * Constructs a new RabbitConn.
             * @memberof protos.args
             * @classdesc Represents a RabbitConn.
             * @implements IRabbitConn
             * @constructor
             * @param {protos.args.IRabbitConn=} [properties] Properties to set
             */
            function RabbitConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitConn address.
             * @member {string} address
             * @memberof protos.args.RabbitConn
             * @instance
             */
            RabbitConn.prototype.address = "";

            /**
             * RabbitConn useTls.
             * @member {boolean} useTls
             * @memberof protos.args.RabbitConn
             * @instance
             */
            RabbitConn.prototype.useTls = false;

            /**
             * RabbitConn tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.args.RabbitConn
             * @instance
             */
            RabbitConn.prototype.tlsSkipVerify = false;

            /**
             * Creates a new RabbitConn instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitConn
             * @static
             * @param {protos.args.IRabbitConn=} [properties] Properties to set
             * @returns {protos.args.RabbitConn} RabbitConn instance
             */
            RabbitConn.create = function create(properties) {
                return new RabbitConn(properties);
            };

            /**
             * Encodes the specified RabbitConn message. Does not implicitly {@link protos.args.RabbitConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitConn
             * @static
             * @param {protos.args.IRabbitConn} message RabbitConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.useTls);
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.tlsSkipVerify);
                return writer;
            };

            /**
             * Encodes the specified RabbitConn message, length delimited. Does not implicitly {@link protos.args.RabbitConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitConn
             * @static
             * @param {protos.args.IRabbitConn} message RabbitConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitConn} RabbitConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.useTls = reader.bool();
                        break;
                    case 3:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitConn} RabbitConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitConn message.
             * @function verify
             * @memberof protos.args.RabbitConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                return null;
            };

            /**
             * Creates a RabbitConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitConn} RabbitConn
             */
            RabbitConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitConn)
                    return object;
                var message = new $root.protos.args.RabbitConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                return message;
            };

            /**
             * Creates a plain object from a RabbitConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitConn
             * @static
             * @param {protos.args.RabbitConn} message RabbitConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = "";
                    object.useTls = false;
                    object.tlsSkipVerify = false;
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                return object;
            };

            /**
             * Converts this RabbitConn to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitConn;
        })();

        args.RabbitReadArgs = (function() {

            /**
             * Properties of a RabbitReadArgs.
             * @memberof protos.args
             * @interface IRabbitReadArgs
             * @property {string|null} [exchangeName] RabbitReadArgs exchangeName
             * @property {string|null} [queueName] RabbitReadArgs queueName
             * @property {string|null} [bindingKey] RabbitReadArgs bindingKey
             * @property {boolean|null} [queueExclusive] RabbitReadArgs queueExclusive
             * @property {boolean|null} [queueDeclare] RabbitReadArgs queueDeclare
             * @property {boolean|null} [queueDurable] RabbitReadArgs queueDurable
             * @property {boolean|null} [autoAck] RabbitReadArgs autoAck
             * @property {string|null} [consumerTag] RabbitReadArgs consumerTag
             * @property {boolean|null} [queueDelete] RabbitReadArgs queueDelete
             * @property {Object.<string,string>|null} [queueArg] RabbitReadArgs queueArg
             * @property {string|null} [excludeBindingKeyRegex] RabbitReadArgs excludeBindingKeyRegex
             */

            /**
             * Constructs a new RabbitReadArgs.
             * @memberof protos.args
             * @classdesc Represents a RabbitReadArgs.
             * @implements IRabbitReadArgs
             * @constructor
             * @param {protos.args.IRabbitReadArgs=} [properties] Properties to set
             */
            function RabbitReadArgs(properties) {
                this.queueArg = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitReadArgs exchangeName.
             * @member {string} exchangeName
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.exchangeName = "";

            /**
             * RabbitReadArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueName = "";

            /**
             * RabbitReadArgs bindingKey.
             * @member {string} bindingKey
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.bindingKey = "";

            /**
             * RabbitReadArgs queueExclusive.
             * @member {boolean} queueExclusive
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueExclusive = false;

            /**
             * RabbitReadArgs queueDeclare.
             * @member {boolean} queueDeclare
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueDeclare = false;

            /**
             * RabbitReadArgs queueDurable.
             * @member {boolean} queueDurable
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueDurable = false;

            /**
             * RabbitReadArgs autoAck.
             * @member {boolean} autoAck
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.autoAck = false;

            /**
             * RabbitReadArgs consumerTag.
             * @member {string} consumerTag
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.consumerTag = "";

            /**
             * RabbitReadArgs queueDelete.
             * @member {boolean} queueDelete
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueDelete = false;

            /**
             * RabbitReadArgs queueArg.
             * @member {Object.<string,string>} queueArg
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueArg = $util.emptyObject;

            /**
             * RabbitReadArgs excludeBindingKeyRegex.
             * @member {string} excludeBindingKeyRegex
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.excludeBindingKeyRegex = "";

            /**
             * Creates a new RabbitReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {protos.args.IRabbitReadArgs=} [properties] Properties to set
             * @returns {protos.args.RabbitReadArgs} RabbitReadArgs instance
             */
            RabbitReadArgs.create = function create(properties) {
                return new RabbitReadArgs(properties);
            };

            /**
             * Encodes the specified RabbitReadArgs message. Does not implicitly {@link protos.args.RabbitReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {protos.args.IRabbitReadArgs} message RabbitReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.exchangeName != null && Object.hasOwnProperty.call(message, "exchangeName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.exchangeName);
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.queueName);
                if (message.bindingKey != null && Object.hasOwnProperty.call(message, "bindingKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.bindingKey);
                if (message.queueExclusive != null && Object.hasOwnProperty.call(message, "queueExclusive"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.queueExclusive);
                if (message.queueDeclare != null && Object.hasOwnProperty.call(message, "queueDeclare"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.queueDeclare);
                if (message.queueDurable != null && Object.hasOwnProperty.call(message, "queueDurable"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.queueDurable);
                if (message.autoAck != null && Object.hasOwnProperty.call(message, "autoAck"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.autoAck);
                if (message.consumerTag != null && Object.hasOwnProperty.call(message, "consumerTag"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.consumerTag);
                if (message.queueDelete != null && Object.hasOwnProperty.call(message, "queueDelete"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.queueDelete);
                if (message.queueArg != null && Object.hasOwnProperty.call(message, "queueArg"))
                    for (var keys = Object.keys(message.queueArg), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.queueArg[keys[i]]).ldelim();
                if (message.excludeBindingKeyRegex != null && Object.hasOwnProperty.call(message, "excludeBindingKeyRegex"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.excludeBindingKeyRegex);
                return writer;
            };

            /**
             * Encodes the specified RabbitReadArgs message, length delimited. Does not implicitly {@link protos.args.RabbitReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {protos.args.IRabbitReadArgs} message RabbitReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitReadArgs} RabbitReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitReadArgs(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.exchangeName = reader.string();
                        break;
                    case 2:
                        message.queueName = reader.string();
                        break;
                    case 3:
                        message.bindingKey = reader.string();
                        break;
                    case 4:
                        message.queueExclusive = reader.bool();
                        break;
                    case 5:
                        message.queueDeclare = reader.bool();
                        break;
                    case 6:
                        message.queueDurable = reader.bool();
                        break;
                    case 7:
                        message.autoAck = reader.bool();
                        break;
                    case 8:
                        message.consumerTag = reader.string();
                        break;
                    case 9:
                        message.queueDelete = reader.bool();
                        break;
                    case 10:
                        if (message.queueArg === $util.emptyObject)
                            message.queueArg = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.queueArg[key] = value;
                        break;
                    case 11:
                        message.excludeBindingKeyRegex = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitReadArgs} RabbitReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitReadArgs message.
             * @function verify
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.exchangeName != null && message.hasOwnProperty("exchangeName"))
                    if (!$util.isString(message.exchangeName))
                        return "exchangeName: string expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                if (message.bindingKey != null && message.hasOwnProperty("bindingKey"))
                    if (!$util.isString(message.bindingKey))
                        return "bindingKey: string expected";
                if (message.queueExclusive != null && message.hasOwnProperty("queueExclusive"))
                    if (typeof message.queueExclusive !== "boolean")
                        return "queueExclusive: boolean expected";
                if (message.queueDeclare != null && message.hasOwnProperty("queueDeclare"))
                    if (typeof message.queueDeclare !== "boolean")
                        return "queueDeclare: boolean expected";
                if (message.queueDurable != null && message.hasOwnProperty("queueDurable"))
                    if (typeof message.queueDurable !== "boolean")
                        return "queueDurable: boolean expected";
                if (message.autoAck != null && message.hasOwnProperty("autoAck"))
                    if (typeof message.autoAck !== "boolean")
                        return "autoAck: boolean expected";
                if (message.consumerTag != null && message.hasOwnProperty("consumerTag"))
                    if (!$util.isString(message.consumerTag))
                        return "consumerTag: string expected";
                if (message.queueDelete != null && message.hasOwnProperty("queueDelete"))
                    if (typeof message.queueDelete !== "boolean")
                        return "queueDelete: boolean expected";
                if (message.queueArg != null && message.hasOwnProperty("queueArg")) {
                    if (!$util.isObject(message.queueArg))
                        return "queueArg: object expected";
                    var key = Object.keys(message.queueArg);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.queueArg[key[i]]))
                            return "queueArg: string{k:string} expected";
                }
                if (message.excludeBindingKeyRegex != null && message.hasOwnProperty("excludeBindingKeyRegex"))
                    if (!$util.isString(message.excludeBindingKeyRegex))
                        return "excludeBindingKeyRegex: string expected";
                return null;
            };

            /**
             * Creates a RabbitReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitReadArgs} RabbitReadArgs
             */
            RabbitReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitReadArgs)
                    return object;
                var message = new $root.protos.args.RabbitReadArgs();
                if (object.exchangeName != null)
                    message.exchangeName = String(object.exchangeName);
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                if (object.bindingKey != null)
                    message.bindingKey = String(object.bindingKey);
                if (object.queueExclusive != null)
                    message.queueExclusive = Boolean(object.queueExclusive);
                if (object.queueDeclare != null)
                    message.queueDeclare = Boolean(object.queueDeclare);
                if (object.queueDurable != null)
                    message.queueDurable = Boolean(object.queueDurable);
                if (object.autoAck != null)
                    message.autoAck = Boolean(object.autoAck);
                if (object.consumerTag != null)
                    message.consumerTag = String(object.consumerTag);
                if (object.queueDelete != null)
                    message.queueDelete = Boolean(object.queueDelete);
                if (object.queueArg) {
                    if (typeof object.queueArg !== "object")
                        throw TypeError(".protos.args.RabbitReadArgs.queueArg: object expected");
                    message.queueArg = {};
                    for (var keys = Object.keys(object.queueArg), i = 0; i < keys.length; ++i)
                        message.queueArg[keys[i]] = String(object.queueArg[keys[i]]);
                }
                if (object.excludeBindingKeyRegex != null)
                    message.excludeBindingKeyRegex = String(object.excludeBindingKeyRegex);
                return message;
            };

            /**
             * Creates a plain object from a RabbitReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {protos.args.RabbitReadArgs} message RabbitReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.queueArg = {};
                if (options.defaults) {
                    object.exchangeName = "";
                    object.queueName = "";
                    object.bindingKey = "";
                    object.queueExclusive = false;
                    object.queueDeclare = false;
                    object.queueDurable = false;
                    object.autoAck = false;
                    object.consumerTag = "";
                    object.queueDelete = false;
                    object.excludeBindingKeyRegex = "";
                }
                if (message.exchangeName != null && message.hasOwnProperty("exchangeName"))
                    object.exchangeName = message.exchangeName;
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                if (message.bindingKey != null && message.hasOwnProperty("bindingKey"))
                    object.bindingKey = message.bindingKey;
                if (message.queueExclusive != null && message.hasOwnProperty("queueExclusive"))
                    object.queueExclusive = message.queueExclusive;
                if (message.queueDeclare != null && message.hasOwnProperty("queueDeclare"))
                    object.queueDeclare = message.queueDeclare;
                if (message.queueDurable != null && message.hasOwnProperty("queueDurable"))
                    object.queueDurable = message.queueDurable;
                if (message.autoAck != null && message.hasOwnProperty("autoAck"))
                    object.autoAck = message.autoAck;
                if (message.consumerTag != null && message.hasOwnProperty("consumerTag"))
                    object.consumerTag = message.consumerTag;
                if (message.queueDelete != null && message.hasOwnProperty("queueDelete"))
                    object.queueDelete = message.queueDelete;
                var keys2;
                if (message.queueArg && (keys2 = Object.keys(message.queueArg)).length) {
                    object.queueArg = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.queueArg[keys2[j]] = message.queueArg[keys2[j]];
                }
                if (message.excludeBindingKeyRegex != null && message.hasOwnProperty("excludeBindingKeyRegex"))
                    object.excludeBindingKeyRegex = message.excludeBindingKeyRegex;
                return object;
            };

            /**
             * Converts this RabbitReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitReadArgs;
        })();

        args.RabbitWriteArgs = (function() {

            /**
             * Properties of a RabbitWriteArgs.
             * @memberof protos.args
             * @interface IRabbitWriteArgs
             * @property {string|null} [exchangeName] RabbitWriteArgs exchangeName
             * @property {string|null} [routingKey] RabbitWriteArgs routingKey
             * @property {string|null} [appId] RabbitWriteArgs appId
             * @property {string|null} [exchangeType] RabbitWriteArgs exchangeType
             * @property {boolean|null} [exchangeDeclare] RabbitWriteArgs exchangeDeclare
             * @property {boolean|null} [exchangeDurable] RabbitWriteArgs exchangeDurable
             * @property {boolean|null} [exchangeAutoDelete] RabbitWriteArgs exchangeAutoDelete
             */

            /**
             * Constructs a new RabbitWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a RabbitWriteArgs.
             * @implements IRabbitWriteArgs
             * @constructor
             * @param {protos.args.IRabbitWriteArgs=} [properties] Properties to set
             */
            function RabbitWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitWriteArgs exchangeName.
             * @member {string} exchangeName
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.exchangeName = "";

            /**
             * RabbitWriteArgs routingKey.
             * @member {string} routingKey
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.routingKey = "";

            /**
             * RabbitWriteArgs appId.
             * @member {string} appId
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.appId = "";

            /**
             * RabbitWriteArgs exchangeType.
             * @member {string} exchangeType
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.exchangeType = "";

            /**
             * RabbitWriteArgs exchangeDeclare.
             * @member {boolean} exchangeDeclare
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.exchangeDeclare = false;

            /**
             * RabbitWriteArgs exchangeDurable.
             * @member {boolean} exchangeDurable
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.exchangeDurable = false;

            /**
             * RabbitWriteArgs exchangeAutoDelete.
             * @member {boolean} exchangeAutoDelete
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.exchangeAutoDelete = false;

            /**
             * Creates a new RabbitWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {protos.args.IRabbitWriteArgs=} [properties] Properties to set
             * @returns {protos.args.RabbitWriteArgs} RabbitWriteArgs instance
             */
            RabbitWriteArgs.create = function create(properties) {
                return new RabbitWriteArgs(properties);
            };

            /**
             * Encodes the specified RabbitWriteArgs message. Does not implicitly {@link protos.args.RabbitWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {protos.args.IRabbitWriteArgs} message RabbitWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.exchangeName != null && Object.hasOwnProperty.call(message, "exchangeName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.exchangeName);
                if (message.routingKey != null && Object.hasOwnProperty.call(message, "routingKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.routingKey);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.appId);
                if (message.exchangeType != null && Object.hasOwnProperty.call(message, "exchangeType"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.exchangeType);
                if (message.exchangeDeclare != null && Object.hasOwnProperty.call(message, "exchangeDeclare"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.exchangeDeclare);
                if (message.exchangeDurable != null && Object.hasOwnProperty.call(message, "exchangeDurable"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.exchangeDurable);
                if (message.exchangeAutoDelete != null && Object.hasOwnProperty.call(message, "exchangeAutoDelete"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.exchangeAutoDelete);
                return writer;
            };

            /**
             * Encodes the specified RabbitWriteArgs message, length delimited. Does not implicitly {@link protos.args.RabbitWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {protos.args.IRabbitWriteArgs} message RabbitWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitWriteArgs} RabbitWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.exchangeName = reader.string();
                        break;
                    case 2:
                        message.routingKey = reader.string();
                        break;
                    case 3:
                        message.appId = reader.string();
                        break;
                    case 4:
                        message.exchangeType = reader.string();
                        break;
                    case 5:
                        message.exchangeDeclare = reader.bool();
                        break;
                    case 6:
                        message.exchangeDurable = reader.bool();
                        break;
                    case 7:
                        message.exchangeAutoDelete = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitWriteArgs} RabbitWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitWriteArgs message.
             * @function verify
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.exchangeName != null && message.hasOwnProperty("exchangeName"))
                    if (!$util.isString(message.exchangeName))
                        return "exchangeName: string expected";
                if (message.routingKey != null && message.hasOwnProperty("routingKey"))
                    if (!$util.isString(message.routingKey))
                        return "routingKey: string expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!$util.isString(message.appId))
                        return "appId: string expected";
                if (message.exchangeType != null && message.hasOwnProperty("exchangeType"))
                    if (!$util.isString(message.exchangeType))
                        return "exchangeType: string expected";
                if (message.exchangeDeclare != null && message.hasOwnProperty("exchangeDeclare"))
                    if (typeof message.exchangeDeclare !== "boolean")
                        return "exchangeDeclare: boolean expected";
                if (message.exchangeDurable != null && message.hasOwnProperty("exchangeDurable"))
                    if (typeof message.exchangeDurable !== "boolean")
                        return "exchangeDurable: boolean expected";
                if (message.exchangeAutoDelete != null && message.hasOwnProperty("exchangeAutoDelete"))
                    if (typeof message.exchangeAutoDelete !== "boolean")
                        return "exchangeAutoDelete: boolean expected";
                return null;
            };

            /**
             * Creates a RabbitWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitWriteArgs} RabbitWriteArgs
             */
            RabbitWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitWriteArgs)
                    return object;
                var message = new $root.protos.args.RabbitWriteArgs();
                if (object.exchangeName != null)
                    message.exchangeName = String(object.exchangeName);
                if (object.routingKey != null)
                    message.routingKey = String(object.routingKey);
                if (object.appId != null)
                    message.appId = String(object.appId);
                if (object.exchangeType != null)
                    message.exchangeType = String(object.exchangeType);
                if (object.exchangeDeclare != null)
                    message.exchangeDeclare = Boolean(object.exchangeDeclare);
                if (object.exchangeDurable != null)
                    message.exchangeDurable = Boolean(object.exchangeDurable);
                if (object.exchangeAutoDelete != null)
                    message.exchangeAutoDelete = Boolean(object.exchangeAutoDelete);
                return message;
            };

            /**
             * Creates a plain object from a RabbitWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {protos.args.RabbitWriteArgs} message RabbitWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.exchangeName = "";
                    object.routingKey = "";
                    object.appId = "";
                    object.exchangeType = "";
                    object.exchangeDeclare = false;
                    object.exchangeDurable = false;
                    object.exchangeAutoDelete = false;
                }
                if (message.exchangeName != null && message.hasOwnProperty("exchangeName"))
                    object.exchangeName = message.exchangeName;
                if (message.routingKey != null && message.hasOwnProperty("routingKey"))
                    object.routingKey = message.routingKey;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = message.appId;
                if (message.exchangeType != null && message.hasOwnProperty("exchangeType"))
                    object.exchangeType = message.exchangeType;
                if (message.exchangeDeclare != null && message.hasOwnProperty("exchangeDeclare"))
                    object.exchangeDeclare = message.exchangeDeclare;
                if (message.exchangeDurable != null && message.hasOwnProperty("exchangeDurable"))
                    object.exchangeDurable = message.exchangeDurable;
                if (message.exchangeAutoDelete != null && message.hasOwnProperty("exchangeAutoDelete"))
                    object.exchangeAutoDelete = message.exchangeAutoDelete;
                return object;
            };

            /**
             * Converts this RabbitWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitWriteArgs;
        })();

        args.RabbitStreamsConn = (function() {

            /**
             * Properties of a RabbitStreamsConn.
             * @memberof protos.args
             * @interface IRabbitStreamsConn
             * @property {string|null} [dsn] RabbitStreamsConn dsn
             * @property {boolean|null} [useTls] RabbitStreamsConn useTls
             * @property {boolean|null} [tlsSkipVerify] RabbitStreamsConn tlsSkipVerify
             * @property {string|null} [username] RabbitStreamsConn username
             * @property {string|null} [password] RabbitStreamsConn password
             * @property {string|null} [clientName] RabbitStreamsConn clientName
             */

            /**
             * Constructs a new RabbitStreamsConn.
             * @memberof protos.args
             * @classdesc Represents a RabbitStreamsConn.
             * @implements IRabbitStreamsConn
             * @constructor
             * @param {protos.args.IRabbitStreamsConn=} [properties] Properties to set
             */
            function RabbitStreamsConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreamsConn dsn.
             * @member {string} dsn
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.dsn = "";

            /**
             * RabbitStreamsConn useTls.
             * @member {boolean} useTls
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.useTls = false;

            /**
             * RabbitStreamsConn tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.tlsSkipVerify = false;

            /**
             * RabbitStreamsConn username.
             * @member {string} username
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.username = "";

            /**
             * RabbitStreamsConn password.
             * @member {string} password
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.password = "";

            /**
             * RabbitStreamsConn clientName.
             * @member {string} clientName
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.clientName = "";

            /**
             * Creates a new RabbitStreamsConn instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {protos.args.IRabbitStreamsConn=} [properties] Properties to set
             * @returns {protos.args.RabbitStreamsConn} RabbitStreamsConn instance
             */
            RabbitStreamsConn.create = function create(properties) {
                return new RabbitStreamsConn(properties);
            };

            /**
             * Encodes the specified RabbitStreamsConn message. Does not implicitly {@link protos.args.RabbitStreamsConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {protos.args.IRabbitStreamsConn} message RabbitStreamsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.useTls);
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.tlsSkipVerify);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.username);
                if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.password);
                if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.clientName);
                return writer;
            };

            /**
             * Encodes the specified RabbitStreamsConn message, length delimited. Does not implicitly {@link protos.args.RabbitStreamsConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {protos.args.IRabbitStreamsConn} message RabbitStreamsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreamsConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitStreamsConn} RabbitStreamsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitStreamsConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    case 2:
                        message.useTls = reader.bool();
                        break;
                    case 3:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    case 4:
                        message.username = reader.string();
                        break;
                    case 5:
                        message.password = reader.string();
                        break;
                    case 6:
                        message.clientName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreamsConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitStreamsConn} RabbitStreamsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreamsConn message.
             * @function verify
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreamsConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!$util.isString(message.password))
                        return "password: string expected";
                if (message.clientName != null && message.hasOwnProperty("clientName"))
                    if (!$util.isString(message.clientName))
                        return "clientName: string expected";
                return null;
            };

            /**
             * Creates a RabbitStreamsConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitStreamsConn} RabbitStreamsConn
             */
            RabbitStreamsConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitStreamsConn)
                    return object;
                var message = new $root.protos.args.RabbitStreamsConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                if (object.username != null)
                    message.username = String(object.username);
                if (object.password != null)
                    message.password = String(object.password);
                if (object.clientName != null)
                    message.clientName = String(object.clientName);
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreamsConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {protos.args.RabbitStreamsConn} message RabbitStreamsConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreamsConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.dsn = "";
                    object.useTls = false;
                    object.tlsSkipVerify = false;
                    object.username = "";
                    object.password = "";
                    object.clientName = "";
                }
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = message.password;
                if (message.clientName != null && message.hasOwnProperty("clientName"))
                    object.clientName = message.clientName;
                return object;
            };

            /**
             * Converts this RabbitStreamsConn to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreamsConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreamsConn;
        })();

        args.RabbitStreamsOffsetOptions = (function() {

            /**
             * Properties of a RabbitStreamsOffsetOptions.
             * @memberof protos.args
             * @interface IRabbitStreamsOffsetOptions
             * @property {number|Long|null} [specificOffset] RabbitStreamsOffsetOptions specificOffset
             * @property {boolean|null} [lastOffset] RabbitStreamsOffsetOptions lastOffset
             * @property {boolean|null} [lastConsumed] RabbitStreamsOffsetOptions lastConsumed
             * @property {boolean|null} [firstOffset] RabbitStreamsOffsetOptions firstOffset
             * @property {boolean|null} [nextOffset] RabbitStreamsOffsetOptions nextOffset
             */

            /**
             * Constructs a new RabbitStreamsOffsetOptions.
             * @memberof protos.args
             * @classdesc Represents a RabbitStreamsOffsetOptions.
             * @implements IRabbitStreamsOffsetOptions
             * @constructor
             * @param {protos.args.IRabbitStreamsOffsetOptions=} [properties] Properties to set
             */
            function RabbitStreamsOffsetOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreamsOffsetOptions specificOffset.
             * @member {number|Long} specificOffset
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             */
            RabbitStreamsOffsetOptions.prototype.specificOffset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * RabbitStreamsOffsetOptions lastOffset.
             * @member {boolean} lastOffset
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             */
            RabbitStreamsOffsetOptions.prototype.lastOffset = false;

            /**
             * RabbitStreamsOffsetOptions lastConsumed.
             * @member {boolean} lastConsumed
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             */
            RabbitStreamsOffsetOptions.prototype.lastConsumed = false;

            /**
             * RabbitStreamsOffsetOptions firstOffset.
             * @member {boolean} firstOffset
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             */
            RabbitStreamsOffsetOptions.prototype.firstOffset = false;

            /**
             * RabbitStreamsOffsetOptions nextOffset.
             * @member {boolean} nextOffset
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             */
            RabbitStreamsOffsetOptions.prototype.nextOffset = false;

            /**
             * Creates a new RabbitStreamsOffsetOptions instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {protos.args.IRabbitStreamsOffsetOptions=} [properties] Properties to set
             * @returns {protos.args.RabbitStreamsOffsetOptions} RabbitStreamsOffsetOptions instance
             */
            RabbitStreamsOffsetOptions.create = function create(properties) {
                return new RabbitStreamsOffsetOptions(properties);
            };

            /**
             * Encodes the specified RabbitStreamsOffsetOptions message. Does not implicitly {@link protos.args.RabbitStreamsOffsetOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {protos.args.IRabbitStreamsOffsetOptions} message RabbitStreamsOffsetOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsOffsetOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.specificOffset != null && Object.hasOwnProperty.call(message, "specificOffset"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.specificOffset);
                if (message.lastOffset != null && Object.hasOwnProperty.call(message, "lastOffset"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.lastOffset);
                if (message.lastConsumed != null && Object.hasOwnProperty.call(message, "lastConsumed"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.lastConsumed);
                if (message.firstOffset != null && Object.hasOwnProperty.call(message, "firstOffset"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.firstOffset);
                if (message.nextOffset != null && Object.hasOwnProperty.call(message, "nextOffset"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.nextOffset);
                return writer;
            };

            /**
             * Encodes the specified RabbitStreamsOffsetOptions message, length delimited. Does not implicitly {@link protos.args.RabbitStreamsOffsetOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {protos.args.IRabbitStreamsOffsetOptions} message RabbitStreamsOffsetOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsOffsetOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreamsOffsetOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitStreamsOffsetOptions} RabbitStreamsOffsetOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsOffsetOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitStreamsOffsetOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.specificOffset = reader.int64();
                        break;
                    case 2:
                        message.lastOffset = reader.bool();
                        break;
                    case 3:
                        message.lastConsumed = reader.bool();
                        break;
                    case 4:
                        message.firstOffset = reader.bool();
                        break;
                    case 5:
                        message.nextOffset = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreamsOffsetOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitStreamsOffsetOptions} RabbitStreamsOffsetOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsOffsetOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreamsOffsetOptions message.
             * @function verify
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreamsOffsetOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.specificOffset != null && message.hasOwnProperty("specificOffset"))
                    if (!$util.isInteger(message.specificOffset) && !(message.specificOffset && $util.isInteger(message.specificOffset.low) && $util.isInteger(message.specificOffset.high)))
                        return "specificOffset: integer|Long expected";
                if (message.lastOffset != null && message.hasOwnProperty("lastOffset"))
                    if (typeof message.lastOffset !== "boolean")
                        return "lastOffset: boolean expected";
                if (message.lastConsumed != null && message.hasOwnProperty("lastConsumed"))
                    if (typeof message.lastConsumed !== "boolean")
                        return "lastConsumed: boolean expected";
                if (message.firstOffset != null && message.hasOwnProperty("firstOffset"))
                    if (typeof message.firstOffset !== "boolean")
                        return "firstOffset: boolean expected";
                if (message.nextOffset != null && message.hasOwnProperty("nextOffset"))
                    if (typeof message.nextOffset !== "boolean")
                        return "nextOffset: boolean expected";
                return null;
            };

            /**
             * Creates a RabbitStreamsOffsetOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitStreamsOffsetOptions} RabbitStreamsOffsetOptions
             */
            RabbitStreamsOffsetOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitStreamsOffsetOptions)
                    return object;
                var message = new $root.protos.args.RabbitStreamsOffsetOptions();
                if (object.specificOffset != null)
                    if ($util.Long)
                        (message.specificOffset = $util.Long.fromValue(object.specificOffset)).unsigned = false;
                    else if (typeof object.specificOffset === "string")
                        message.specificOffset = parseInt(object.specificOffset, 10);
                    else if (typeof object.specificOffset === "number")
                        message.specificOffset = object.specificOffset;
                    else if (typeof object.specificOffset === "object")
                        message.specificOffset = new $util.LongBits(object.specificOffset.low >>> 0, object.specificOffset.high >>> 0).toNumber();
                if (object.lastOffset != null)
                    message.lastOffset = Boolean(object.lastOffset);
                if (object.lastConsumed != null)
                    message.lastConsumed = Boolean(object.lastConsumed);
                if (object.firstOffset != null)
                    message.firstOffset = Boolean(object.firstOffset);
                if (object.nextOffset != null)
                    message.nextOffset = Boolean(object.nextOffset);
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreamsOffsetOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {protos.args.RabbitStreamsOffsetOptions} message RabbitStreamsOffsetOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreamsOffsetOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.specificOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.specificOffset = options.longs === String ? "0" : 0;
                    object.lastOffset = false;
                    object.lastConsumed = false;
                    object.firstOffset = false;
                    object.nextOffset = false;
                }
                if (message.specificOffset != null && message.hasOwnProperty("specificOffset"))
                    if (typeof message.specificOffset === "number")
                        object.specificOffset = options.longs === String ? String(message.specificOffset) : message.specificOffset;
                    else
                        object.specificOffset = options.longs === String ? $util.Long.prototype.toString.call(message.specificOffset) : options.longs === Number ? new $util.LongBits(message.specificOffset.low >>> 0, message.specificOffset.high >>> 0).toNumber() : message.specificOffset;
                if (message.lastOffset != null && message.hasOwnProperty("lastOffset"))
                    object.lastOffset = message.lastOffset;
                if (message.lastConsumed != null && message.hasOwnProperty("lastConsumed"))
                    object.lastConsumed = message.lastConsumed;
                if (message.firstOffset != null && message.hasOwnProperty("firstOffset"))
                    object.firstOffset = message.firstOffset;
                if (message.nextOffset != null && message.hasOwnProperty("nextOffset"))
                    object.nextOffset = message.nextOffset;
                return object;
            };

            /**
             * Converts this RabbitStreamsOffsetOptions to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreamsOffsetOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreamsOffsetOptions;
        })();

        args.RabbitStreamsReadArgs = (function() {

            /**
             * Properties of a RabbitStreamsReadArgs.
             * @memberof protos.args
             * @interface IRabbitStreamsReadArgs
             * @property {string|null} [stream] RabbitStreamsReadArgs stream
             * @property {boolean|null} [declareStream] RabbitStreamsReadArgs declareStream
             * @property {string|null} [declareStreamSize] RabbitStreamsReadArgs declareStreamSize
             * @property {protos.args.IRabbitStreamsOffsetOptions|null} [offsetOptions] RabbitStreamsReadArgs offsetOptions
             */

            /**
             * Constructs a new RabbitStreamsReadArgs.
             * @memberof protos.args
             * @classdesc Represents a RabbitStreamsReadArgs.
             * @implements IRabbitStreamsReadArgs
             * @constructor
             * @param {protos.args.IRabbitStreamsReadArgs=} [properties] Properties to set
             */
            function RabbitStreamsReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreamsReadArgs stream.
             * @member {string} stream
             * @memberof protos.args.RabbitStreamsReadArgs
             * @instance
             */
            RabbitStreamsReadArgs.prototype.stream = "";

            /**
             * RabbitStreamsReadArgs declareStream.
             * @member {boolean} declareStream
             * @memberof protos.args.RabbitStreamsReadArgs
             * @instance
             */
            RabbitStreamsReadArgs.prototype.declareStream = false;

            /**
             * RabbitStreamsReadArgs declareStreamSize.
             * @member {string} declareStreamSize
             * @memberof protos.args.RabbitStreamsReadArgs
             * @instance
             */
            RabbitStreamsReadArgs.prototype.declareStreamSize = "";

            /**
             * RabbitStreamsReadArgs offsetOptions.
             * @member {protos.args.IRabbitStreamsOffsetOptions|null|undefined} offsetOptions
             * @memberof protos.args.RabbitStreamsReadArgs
             * @instance
             */
            RabbitStreamsReadArgs.prototype.offsetOptions = null;

            /**
             * Creates a new RabbitStreamsReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {protos.args.IRabbitStreamsReadArgs=} [properties] Properties to set
             * @returns {protos.args.RabbitStreamsReadArgs} RabbitStreamsReadArgs instance
             */
            RabbitStreamsReadArgs.create = function create(properties) {
                return new RabbitStreamsReadArgs(properties);
            };

            /**
             * Encodes the specified RabbitStreamsReadArgs message. Does not implicitly {@link protos.args.RabbitStreamsReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {protos.args.IRabbitStreamsReadArgs} message RabbitStreamsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stream);
                if (message.declareStream != null && Object.hasOwnProperty.call(message, "declareStream"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.declareStream);
                if (message.declareStreamSize != null && Object.hasOwnProperty.call(message, "declareStreamSize"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.declareStreamSize);
                if (message.offsetOptions != null && Object.hasOwnProperty.call(message, "offsetOptions"))
                    $root.protos.args.RabbitStreamsOffsetOptions.encode(message.offsetOptions, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RabbitStreamsReadArgs message, length delimited. Does not implicitly {@link protos.args.RabbitStreamsReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {protos.args.IRabbitStreamsReadArgs} message RabbitStreamsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreamsReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitStreamsReadArgs} RabbitStreamsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitStreamsReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stream = reader.string();
                        break;
                    case 2:
                        message.declareStream = reader.bool();
                        break;
                    case 3:
                        message.declareStreamSize = reader.string();
                        break;
                    case 4:
                        message.offsetOptions = $root.protos.args.RabbitStreamsOffsetOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreamsReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitStreamsReadArgs} RabbitStreamsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreamsReadArgs message.
             * @function verify
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreamsReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isString(message.stream))
                        return "stream: string expected";
                if (message.declareStream != null && message.hasOwnProperty("declareStream"))
                    if (typeof message.declareStream !== "boolean")
                        return "declareStream: boolean expected";
                if (message.declareStreamSize != null && message.hasOwnProperty("declareStreamSize"))
                    if (!$util.isString(message.declareStreamSize))
                        return "declareStreamSize: string expected";
                if (message.offsetOptions != null && message.hasOwnProperty("offsetOptions")) {
                    var error = $root.protos.args.RabbitStreamsOffsetOptions.verify(message.offsetOptions);
                    if (error)
                        return "offsetOptions." + error;
                }
                return null;
            };

            /**
             * Creates a RabbitStreamsReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitStreamsReadArgs} RabbitStreamsReadArgs
             */
            RabbitStreamsReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitStreamsReadArgs)
                    return object;
                var message = new $root.protos.args.RabbitStreamsReadArgs();
                if (object.stream != null)
                    message.stream = String(object.stream);
                if (object.declareStream != null)
                    message.declareStream = Boolean(object.declareStream);
                if (object.declareStreamSize != null)
                    message.declareStreamSize = String(object.declareStreamSize);
                if (object.offsetOptions != null) {
                    if (typeof object.offsetOptions !== "object")
                        throw TypeError(".protos.args.RabbitStreamsReadArgs.offsetOptions: object expected");
                    message.offsetOptions = $root.protos.args.RabbitStreamsOffsetOptions.fromObject(object.offsetOptions);
                }
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreamsReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {protos.args.RabbitStreamsReadArgs} message RabbitStreamsReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreamsReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.stream = "";
                    object.declareStream = false;
                    object.declareStreamSize = "";
                    object.offsetOptions = null;
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                if (message.declareStream != null && message.hasOwnProperty("declareStream"))
                    object.declareStream = message.declareStream;
                if (message.declareStreamSize != null && message.hasOwnProperty("declareStreamSize"))
                    object.declareStreamSize = message.declareStreamSize;
                if (message.offsetOptions != null && message.hasOwnProperty("offsetOptions"))
                    object.offsetOptions = $root.protos.args.RabbitStreamsOffsetOptions.toObject(message.offsetOptions, options);
                return object;
            };

            /**
             * Converts this RabbitStreamsReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitStreamsReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreamsReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreamsReadArgs;
        })();

        args.RabbitStreamsWriteArgs = (function() {

            /**
             * Properties of a RabbitStreamsWriteArgs.
             * @memberof protos.args
             * @interface IRabbitStreamsWriteArgs
             * @property {string|null} [stream] RabbitStreamsWriteArgs stream
             * @property {boolean|null} [declareStream] RabbitStreamsWriteArgs declareStream
             * @property {string|null} [declareStreamSize] RabbitStreamsWriteArgs declareStreamSize
             */

            /**
             * Constructs a new RabbitStreamsWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a RabbitStreamsWriteArgs.
             * @implements IRabbitStreamsWriteArgs
             * @constructor
             * @param {protos.args.IRabbitStreamsWriteArgs=} [properties] Properties to set
             */
            function RabbitStreamsWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreamsWriteArgs stream.
             * @member {string} stream
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @instance
             */
            RabbitStreamsWriteArgs.prototype.stream = "";

            /**
             * RabbitStreamsWriteArgs declareStream.
             * @member {boolean} declareStream
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @instance
             */
            RabbitStreamsWriteArgs.prototype.declareStream = false;

            /**
             * RabbitStreamsWriteArgs declareStreamSize.
             * @member {string} declareStreamSize
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @instance
             */
            RabbitStreamsWriteArgs.prototype.declareStreamSize = "";

            /**
             * Creates a new RabbitStreamsWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {protos.args.IRabbitStreamsWriteArgs=} [properties] Properties to set
             * @returns {protos.args.RabbitStreamsWriteArgs} RabbitStreamsWriteArgs instance
             */
            RabbitStreamsWriteArgs.create = function create(properties) {
                return new RabbitStreamsWriteArgs(properties);
            };

            /**
             * Encodes the specified RabbitStreamsWriteArgs message. Does not implicitly {@link protos.args.RabbitStreamsWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {protos.args.IRabbitStreamsWriteArgs} message RabbitStreamsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stream);
                if (message.declareStream != null && Object.hasOwnProperty.call(message, "declareStream"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.declareStream);
                if (message.declareStreamSize != null && Object.hasOwnProperty.call(message, "declareStreamSize"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.declareStreamSize);
                return writer;
            };

            /**
             * Encodes the specified RabbitStreamsWriteArgs message, length delimited. Does not implicitly {@link protos.args.RabbitStreamsWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {protos.args.IRabbitStreamsWriteArgs} message RabbitStreamsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreamsWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitStreamsWriteArgs} RabbitStreamsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitStreamsWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stream = reader.string();
                        break;
                    case 2:
                        message.declareStream = reader.bool();
                        break;
                    case 3:
                        message.declareStreamSize = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreamsWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitStreamsWriteArgs} RabbitStreamsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreamsWriteArgs message.
             * @function verify
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreamsWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isString(message.stream))
                        return "stream: string expected";
                if (message.declareStream != null && message.hasOwnProperty("declareStream"))
                    if (typeof message.declareStream !== "boolean")
                        return "declareStream: boolean expected";
                if (message.declareStreamSize != null && message.hasOwnProperty("declareStreamSize"))
                    if (!$util.isString(message.declareStreamSize))
                        return "declareStreamSize: string expected";
                return null;
            };

            /**
             * Creates a RabbitStreamsWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitStreamsWriteArgs} RabbitStreamsWriteArgs
             */
            RabbitStreamsWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitStreamsWriteArgs)
                    return object;
                var message = new $root.protos.args.RabbitStreamsWriteArgs();
                if (object.stream != null)
                    message.stream = String(object.stream);
                if (object.declareStream != null)
                    message.declareStream = Boolean(object.declareStream);
                if (object.declareStreamSize != null)
                    message.declareStreamSize = String(object.declareStreamSize);
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreamsWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {protos.args.RabbitStreamsWriteArgs} message RabbitStreamsWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreamsWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.stream = "";
                    object.declareStream = false;
                    object.declareStreamSize = "";
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                if (message.declareStream != null && message.hasOwnProperty("declareStream"))
                    object.declareStream = message.declareStream;
                if (message.declareStreamSize != null && message.hasOwnProperty("declareStreamSize"))
                    object.declareStreamSize = message.declareStreamSize;
                return object;
            };

            /**
             * Converts this RabbitStreamsWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreamsWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreamsWriteArgs;
        })();

        args.RedisPubSubConn = (function() {

            /**
             * Properties of a RedisPubSubConn.
             * @memberof protos.args
             * @interface IRedisPubSubConn
             * @property {string|null} [address] RedisPubSubConn address
             * @property {string|null} [username] RedisPubSubConn username
             * @property {string|null} [password] RedisPubSubConn password
             * @property {number|null} [database] RedisPubSubConn database
             */

            /**
             * Constructs a new RedisPubSubConn.
             * @memberof protos.args
             * @classdesc Represents a RedisPubSubConn.
             * @implements IRedisPubSubConn
             * @constructor
             * @param {protos.args.IRedisPubSubConn=} [properties] Properties to set
             */
            function RedisPubSubConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisPubSubConn address.
             * @member {string} address
             * @memberof protos.args.RedisPubSubConn
             * @instance
             */
            RedisPubSubConn.prototype.address = "";

            /**
             * RedisPubSubConn username.
             * @member {string} username
             * @memberof protos.args.RedisPubSubConn
             * @instance
             */
            RedisPubSubConn.prototype.username = "";

            /**
             * RedisPubSubConn password.
             * @member {string} password
             * @memberof protos.args.RedisPubSubConn
             * @instance
             */
            RedisPubSubConn.prototype.password = "";

            /**
             * RedisPubSubConn database.
             * @member {number} database
             * @memberof protos.args.RedisPubSubConn
             * @instance
             */
            RedisPubSubConn.prototype.database = 0;

            /**
             * Creates a new RedisPubSubConn instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {protos.args.IRedisPubSubConn=} [properties] Properties to set
             * @returns {protos.args.RedisPubSubConn} RedisPubSubConn instance
             */
            RedisPubSubConn.create = function create(properties) {
                return new RedisPubSubConn(properties);
            };

            /**
             * Encodes the specified RedisPubSubConn message. Does not implicitly {@link protos.args.RedisPubSubConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {protos.args.IRedisPubSubConn} message RedisPubSubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
                if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.password);
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.database);
                return writer;
            };

            /**
             * Encodes the specified RedisPubSubConn message, length delimited. Does not implicitly {@link protos.args.RedisPubSubConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {protos.args.IRedisPubSubConn} message RedisPubSubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisPubSubConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisPubSubConn} RedisPubSubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisPubSubConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.username = reader.string();
                        break;
                    case 3:
                        message.password = reader.string();
                        break;
                    case 4:
                        message.database = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisPubSubConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisPubSubConn} RedisPubSubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisPubSubConn message.
             * @function verify
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisPubSubConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!$util.isString(message.password))
                        return "password: string expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isInteger(message.database))
                        return "database: integer expected";
                return null;
            };

            /**
             * Creates a RedisPubSubConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisPubSubConn} RedisPubSubConn
             */
            RedisPubSubConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisPubSubConn)
                    return object;
                var message = new $root.protos.args.RedisPubSubConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.username != null)
                    message.username = String(object.username);
                if (object.password != null)
                    message.password = String(object.password);
                if (object.database != null)
                    message.database = object.database >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a RedisPubSubConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {protos.args.RedisPubSubConn} message RedisPubSubConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisPubSubConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = "";
                    object.username = "";
                    object.password = "";
                    object.database = 0;
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = message.password;
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                return object;
            };

            /**
             * Converts this RedisPubSubConn to JSON.
             * @function toJSON
             * @memberof protos.args.RedisPubSubConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisPubSubConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisPubSubConn;
        })();

        args.RedisPubSubReadArgs = (function() {

            /**
             * Properties of a RedisPubSubReadArgs.
             * @memberof protos.args
             * @interface IRedisPubSubReadArgs
             * @property {Array.<string>|null} [channels] RedisPubSubReadArgs channels
             */

            /**
             * Constructs a new RedisPubSubReadArgs.
             * @memberof protos.args
             * @classdesc Represents a RedisPubSubReadArgs.
             * @implements IRedisPubSubReadArgs
             * @constructor
             * @param {protos.args.IRedisPubSubReadArgs=} [properties] Properties to set
             */
            function RedisPubSubReadArgs(properties) {
                this.channels = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisPubSubReadArgs channels.
             * @member {Array.<string>} channels
             * @memberof protos.args.RedisPubSubReadArgs
             * @instance
             */
            RedisPubSubReadArgs.prototype.channels = $util.emptyArray;

            /**
             * Creates a new RedisPubSubReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {protos.args.IRedisPubSubReadArgs=} [properties] Properties to set
             * @returns {protos.args.RedisPubSubReadArgs} RedisPubSubReadArgs instance
             */
            RedisPubSubReadArgs.create = function create(properties) {
                return new RedisPubSubReadArgs(properties);
            };

            /**
             * Encodes the specified RedisPubSubReadArgs message. Does not implicitly {@link protos.args.RedisPubSubReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {protos.args.IRedisPubSubReadArgs} message RedisPubSubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channels != null && message.channels.length)
                    for (var i = 0; i < message.channels.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.channels[i]);
                return writer;
            };

            /**
             * Encodes the specified RedisPubSubReadArgs message, length delimited. Does not implicitly {@link protos.args.RedisPubSubReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {protos.args.IRedisPubSubReadArgs} message RedisPubSubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisPubSubReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisPubSubReadArgs} RedisPubSubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisPubSubReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.channels && message.channels.length))
                            message.channels = [];
                        message.channels.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisPubSubReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisPubSubReadArgs} RedisPubSubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisPubSubReadArgs message.
             * @function verify
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisPubSubReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channels != null && message.hasOwnProperty("channels")) {
                    if (!Array.isArray(message.channels))
                        return "channels: array expected";
                    for (var i = 0; i < message.channels.length; ++i)
                        if (!$util.isString(message.channels[i]))
                            return "channels: string[] expected";
                }
                return null;
            };

            /**
             * Creates a RedisPubSubReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisPubSubReadArgs} RedisPubSubReadArgs
             */
            RedisPubSubReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisPubSubReadArgs)
                    return object;
                var message = new $root.protos.args.RedisPubSubReadArgs();
                if (object.channels) {
                    if (!Array.isArray(object.channels))
                        throw TypeError(".protos.args.RedisPubSubReadArgs.channels: array expected");
                    message.channels = [];
                    for (var i = 0; i < object.channels.length; ++i)
                        message.channels[i] = String(object.channels[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a RedisPubSubReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {protos.args.RedisPubSubReadArgs} message RedisPubSubReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisPubSubReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.channels = [];
                if (message.channels && message.channels.length) {
                    object.channels = [];
                    for (var j = 0; j < message.channels.length; ++j)
                        object.channels[j] = message.channels[j];
                }
                return object;
            };

            /**
             * Converts this RedisPubSubReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RedisPubSubReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisPubSubReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisPubSubReadArgs;
        })();

        args.RedisPubSubWriteArgs = (function() {

            /**
             * Properties of a RedisPubSubWriteArgs.
             * @memberof protos.args
             * @interface IRedisPubSubWriteArgs
             * @property {Array.<string>|null} [channels] RedisPubSubWriteArgs channels
             */

            /**
             * Constructs a new RedisPubSubWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a RedisPubSubWriteArgs.
             * @implements IRedisPubSubWriteArgs
             * @constructor
             * @param {protos.args.IRedisPubSubWriteArgs=} [properties] Properties to set
             */
            function RedisPubSubWriteArgs(properties) {
                this.channels = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisPubSubWriteArgs channels.
             * @member {Array.<string>} channels
             * @memberof protos.args.RedisPubSubWriteArgs
             * @instance
             */
            RedisPubSubWriteArgs.prototype.channels = $util.emptyArray;

            /**
             * Creates a new RedisPubSubWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {protos.args.IRedisPubSubWriteArgs=} [properties] Properties to set
             * @returns {protos.args.RedisPubSubWriteArgs} RedisPubSubWriteArgs instance
             */
            RedisPubSubWriteArgs.create = function create(properties) {
                return new RedisPubSubWriteArgs(properties);
            };

            /**
             * Encodes the specified RedisPubSubWriteArgs message. Does not implicitly {@link protos.args.RedisPubSubWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {protos.args.IRedisPubSubWriteArgs} message RedisPubSubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channels != null && message.channels.length)
                    for (var i = 0; i < message.channels.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.channels[i]);
                return writer;
            };

            /**
             * Encodes the specified RedisPubSubWriteArgs message, length delimited. Does not implicitly {@link protos.args.RedisPubSubWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {protos.args.IRedisPubSubWriteArgs} message RedisPubSubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisPubSubWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisPubSubWriteArgs} RedisPubSubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisPubSubWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.channels && message.channels.length))
                            message.channels = [];
                        message.channels.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisPubSubWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisPubSubWriteArgs} RedisPubSubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisPubSubWriteArgs message.
             * @function verify
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisPubSubWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channels != null && message.hasOwnProperty("channels")) {
                    if (!Array.isArray(message.channels))
                        return "channels: array expected";
                    for (var i = 0; i < message.channels.length; ++i)
                        if (!$util.isString(message.channels[i]))
                            return "channels: string[] expected";
                }
                return null;
            };

            /**
             * Creates a RedisPubSubWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisPubSubWriteArgs} RedisPubSubWriteArgs
             */
            RedisPubSubWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisPubSubWriteArgs)
                    return object;
                var message = new $root.protos.args.RedisPubSubWriteArgs();
                if (object.channels) {
                    if (!Array.isArray(object.channels))
                        throw TypeError(".protos.args.RedisPubSubWriteArgs.channels: array expected");
                    message.channels = [];
                    for (var i = 0; i < object.channels.length; ++i)
                        message.channels[i] = String(object.channels[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a RedisPubSubWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {protos.args.RedisPubSubWriteArgs} message RedisPubSubWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisPubSubWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.channels = [];
                if (message.channels && message.channels.length) {
                    object.channels = [];
                    for (var j = 0; j < message.channels.length; ++j)
                        object.channels[j] = message.channels[j];
                }
                return object;
            };

            /**
             * Converts this RedisPubSubWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RedisPubSubWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisPubSubWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisPubSubWriteArgs;
        })();

        /**
         * OffsetStart enum.
         * @name protos.args.OffsetStart
         * @enum {number}
         * @property {number} LATEST=0 LATEST value
         * @property {number} OLDEST=1 OLDEST value
         */
        args.OffsetStart = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "LATEST"] = 0;
            values[valuesById[1] = "OLDEST"] = 1;
            return values;
        })();

        args.RedisStreamsConn = (function() {

            /**
             * Properties of a RedisStreamsConn.
             * @memberof protos.args
             * @interface IRedisStreamsConn
             * @property {string|null} [address] RedisStreamsConn address
             * @property {string|null} [username] RedisStreamsConn username
             * @property {string|null} [password] RedisStreamsConn password
             * @property {number|null} [database] RedisStreamsConn database
             */

            /**
             * Constructs a new RedisStreamsConn.
             * @memberof protos.args
             * @classdesc Represents a RedisStreamsConn.
             * @implements IRedisStreamsConn
             * @constructor
             * @param {protos.args.IRedisStreamsConn=} [properties] Properties to set
             */
            function RedisStreamsConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisStreamsConn address.
             * @member {string} address
             * @memberof protos.args.RedisStreamsConn
             * @instance
             */
            RedisStreamsConn.prototype.address = "";

            /**
             * RedisStreamsConn username.
             * @member {string} username
             * @memberof protos.args.RedisStreamsConn
             * @instance
             */
            RedisStreamsConn.prototype.username = "";

            /**
             * RedisStreamsConn password.
             * @member {string} password
             * @memberof protos.args.RedisStreamsConn
             * @instance
             */
            RedisStreamsConn.prototype.password = "";

            /**
             * RedisStreamsConn database.
             * @member {number} database
             * @memberof protos.args.RedisStreamsConn
             * @instance
             */
            RedisStreamsConn.prototype.database = 0;

            /**
             * Creates a new RedisStreamsConn instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {protos.args.IRedisStreamsConn=} [properties] Properties to set
             * @returns {protos.args.RedisStreamsConn} RedisStreamsConn instance
             */
            RedisStreamsConn.create = function create(properties) {
                return new RedisStreamsConn(properties);
            };

            /**
             * Encodes the specified RedisStreamsConn message. Does not implicitly {@link protos.args.RedisStreamsConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {protos.args.IRedisStreamsConn} message RedisStreamsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
                if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.password);
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.database);
                return writer;
            };

            /**
             * Encodes the specified RedisStreamsConn message, length delimited. Does not implicitly {@link protos.args.RedisStreamsConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {protos.args.IRedisStreamsConn} message RedisStreamsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisStreamsConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisStreamsConn} RedisStreamsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisStreamsConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.username = reader.string();
                        break;
                    case 3:
                        message.password = reader.string();
                        break;
                    case 4:
                        message.database = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisStreamsConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisStreamsConn} RedisStreamsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisStreamsConn message.
             * @function verify
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisStreamsConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!$util.isString(message.password))
                        return "password: string expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isInteger(message.database))
                        return "database: integer expected";
                return null;
            };

            /**
             * Creates a RedisStreamsConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisStreamsConn} RedisStreamsConn
             */
            RedisStreamsConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisStreamsConn)
                    return object;
                var message = new $root.protos.args.RedisStreamsConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.username != null)
                    message.username = String(object.username);
                if (object.password != null)
                    message.password = String(object.password);
                if (object.database != null)
                    message.database = object.database >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a RedisStreamsConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {protos.args.RedisStreamsConn} message RedisStreamsConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisStreamsConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = "";
                    object.username = "";
                    object.password = "";
                    object.database = 0;
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = message.password;
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                return object;
            };

            /**
             * Converts this RedisStreamsConn to JSON.
             * @function toJSON
             * @memberof protos.args.RedisStreamsConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisStreamsConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisStreamsConn;
        })();

        args.CreateConsumerConfig = (function() {

            /**
             * Properties of a CreateConsumerConfig.
             * @memberof protos.args
             * @interface ICreateConsumerConfig
             * @property {boolean|null} [createStreams] CreateConsumerConfig createStreams
             * @property {boolean|null} [recreateConsumerGroup] CreateConsumerConfig recreateConsumerGroup
             * @property {protos.args.OffsetStart|null} [offsetStart] CreateConsumerConfig offsetStart
             */

            /**
             * Constructs a new CreateConsumerConfig.
             * @memberof protos.args
             * @classdesc Represents a CreateConsumerConfig.
             * @implements ICreateConsumerConfig
             * @constructor
             * @param {protos.args.ICreateConsumerConfig=} [properties] Properties to set
             */
            function CreateConsumerConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateConsumerConfig createStreams.
             * @member {boolean} createStreams
             * @memberof protos.args.CreateConsumerConfig
             * @instance
             */
            CreateConsumerConfig.prototype.createStreams = false;

            /**
             * CreateConsumerConfig recreateConsumerGroup.
             * @member {boolean} recreateConsumerGroup
             * @memberof protos.args.CreateConsumerConfig
             * @instance
             */
            CreateConsumerConfig.prototype.recreateConsumerGroup = false;

            /**
             * CreateConsumerConfig offsetStart.
             * @member {protos.args.OffsetStart} offsetStart
             * @memberof protos.args.CreateConsumerConfig
             * @instance
             */
            CreateConsumerConfig.prototype.offsetStart = 0;

            /**
             * Creates a new CreateConsumerConfig instance using the specified properties.
             * @function create
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {protos.args.ICreateConsumerConfig=} [properties] Properties to set
             * @returns {protos.args.CreateConsumerConfig} CreateConsumerConfig instance
             */
            CreateConsumerConfig.create = function create(properties) {
                return new CreateConsumerConfig(properties);
            };

            /**
             * Encodes the specified CreateConsumerConfig message. Does not implicitly {@link protos.args.CreateConsumerConfig.verify|verify} messages.
             * @function encode
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {protos.args.ICreateConsumerConfig} message CreateConsumerConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateConsumerConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.createStreams != null && Object.hasOwnProperty.call(message, "createStreams"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.createStreams);
                if (message.recreateConsumerGroup != null && Object.hasOwnProperty.call(message, "recreateConsumerGroup"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.recreateConsumerGroup);
                if (message.offsetStart != null && Object.hasOwnProperty.call(message, "offsetStart"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.offsetStart);
                return writer;
            };

            /**
             * Encodes the specified CreateConsumerConfig message, length delimited. Does not implicitly {@link protos.args.CreateConsumerConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {protos.args.ICreateConsumerConfig} message CreateConsumerConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateConsumerConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateConsumerConfig message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.CreateConsumerConfig} CreateConsumerConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateConsumerConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.CreateConsumerConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.createStreams = reader.bool();
                        break;
                    case 2:
                        message.recreateConsumerGroup = reader.bool();
                        break;
                    case 3:
                        message.offsetStart = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateConsumerConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.CreateConsumerConfig} CreateConsumerConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateConsumerConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateConsumerConfig message.
             * @function verify
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateConsumerConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.createStreams != null && message.hasOwnProperty("createStreams"))
                    if (typeof message.createStreams !== "boolean")
                        return "createStreams: boolean expected";
                if (message.recreateConsumerGroup != null && message.hasOwnProperty("recreateConsumerGroup"))
                    if (typeof message.recreateConsumerGroup !== "boolean")
                        return "recreateConsumerGroup: boolean expected";
                if (message.offsetStart != null && message.hasOwnProperty("offsetStart"))
                    switch (message.offsetStart) {
                    default:
                        return "offsetStart: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a CreateConsumerConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.CreateConsumerConfig} CreateConsumerConfig
             */
            CreateConsumerConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.CreateConsumerConfig)
                    return object;
                var message = new $root.protos.args.CreateConsumerConfig();
                if (object.createStreams != null)
                    message.createStreams = Boolean(object.createStreams);
                if (object.recreateConsumerGroup != null)
                    message.recreateConsumerGroup = Boolean(object.recreateConsumerGroup);
                switch (object.offsetStart) {
                case "LATEST":
                case 0:
                    message.offsetStart = 0;
                    break;
                case "OLDEST":
                case 1:
                    message.offsetStart = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateConsumerConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {protos.args.CreateConsumerConfig} message CreateConsumerConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateConsumerConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.createStreams = false;
                    object.recreateConsumerGroup = false;
                    object.offsetStart = options.enums === String ? "LATEST" : 0;
                }
                if (message.createStreams != null && message.hasOwnProperty("createStreams"))
                    object.createStreams = message.createStreams;
                if (message.recreateConsumerGroup != null && message.hasOwnProperty("recreateConsumerGroup"))
                    object.recreateConsumerGroup = message.recreateConsumerGroup;
                if (message.offsetStart != null && message.hasOwnProperty("offsetStart"))
                    object.offsetStart = options.enums === String ? $root.protos.args.OffsetStart[message.offsetStart] : message.offsetStart;
                return object;
            };

            /**
             * Converts this CreateConsumerConfig to JSON.
             * @function toJSON
             * @memberof protos.args.CreateConsumerConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateConsumerConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateConsumerConfig;
        })();

        args.RedisStreamsReadArgs = (function() {

            /**
             * Properties of a RedisStreamsReadArgs.
             * @memberof protos.args
             * @interface IRedisStreamsReadArgs
             * @property {Array.<string>|null} [streams] RedisStreamsReadArgs streams
             * @property {string|null} [consumerGroup] RedisStreamsReadArgs consumerGroup
             * @property {string|null} [consumerName] RedisStreamsReadArgs consumerName
             * @property {number|null} [count] RedisStreamsReadArgs count
             * @property {protos.args.ICreateConsumerConfig|null} [createConsumerConfig] RedisStreamsReadArgs createConsumerConfig
             */

            /**
             * Constructs a new RedisStreamsReadArgs.
             * @memberof protos.args
             * @classdesc Represents a RedisStreamsReadArgs.
             * @implements IRedisStreamsReadArgs
             * @constructor
             * @param {protos.args.IRedisStreamsReadArgs=} [properties] Properties to set
             */
            function RedisStreamsReadArgs(properties) {
                this.streams = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisStreamsReadArgs streams.
             * @member {Array.<string>} streams
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.streams = $util.emptyArray;

            /**
             * RedisStreamsReadArgs consumerGroup.
             * @member {string} consumerGroup
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.consumerGroup = "";

            /**
             * RedisStreamsReadArgs consumerName.
             * @member {string} consumerName
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.consumerName = "";

            /**
             * RedisStreamsReadArgs count.
             * @member {number} count
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.count = 0;

            /**
             * RedisStreamsReadArgs createConsumerConfig.
             * @member {protos.args.ICreateConsumerConfig|null|undefined} createConsumerConfig
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.createConsumerConfig = null;

            /**
             * Creates a new RedisStreamsReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {protos.args.IRedisStreamsReadArgs=} [properties] Properties to set
             * @returns {protos.args.RedisStreamsReadArgs} RedisStreamsReadArgs instance
             */
            RedisStreamsReadArgs.create = function create(properties) {
                return new RedisStreamsReadArgs(properties);
            };

            /**
             * Encodes the specified RedisStreamsReadArgs message. Does not implicitly {@link protos.args.RedisStreamsReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {protos.args.IRedisStreamsReadArgs} message RedisStreamsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.streams != null && message.streams.length)
                    for (var i = 0; i < message.streams.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.streams[i]);
                if (message.consumerGroup != null && Object.hasOwnProperty.call(message, "consumerGroup"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.consumerGroup);
                if (message.consumerName != null && Object.hasOwnProperty.call(message, "consumerName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.consumerName);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.count);
                if (message.createConsumerConfig != null && Object.hasOwnProperty.call(message, "createConsumerConfig"))
                    $root.protos.args.CreateConsumerConfig.encode(message.createConsumerConfig, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RedisStreamsReadArgs message, length delimited. Does not implicitly {@link protos.args.RedisStreamsReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {protos.args.IRedisStreamsReadArgs} message RedisStreamsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisStreamsReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisStreamsReadArgs} RedisStreamsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisStreamsReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.streams && message.streams.length))
                            message.streams = [];
                        message.streams.push(reader.string());
                        break;
                    case 2:
                        message.consumerGroup = reader.string();
                        break;
                    case 3:
                        message.consumerName = reader.string();
                        break;
                    case 4:
                        message.count = reader.uint32();
                        break;
                    case 5:
                        message.createConsumerConfig = $root.protos.args.CreateConsumerConfig.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisStreamsReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisStreamsReadArgs} RedisStreamsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisStreamsReadArgs message.
             * @function verify
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisStreamsReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.streams != null && message.hasOwnProperty("streams")) {
                    if (!Array.isArray(message.streams))
                        return "streams: array expected";
                    for (var i = 0; i < message.streams.length; ++i)
                        if (!$util.isString(message.streams[i]))
                            return "streams: string[] expected";
                }
                if (message.consumerGroup != null && message.hasOwnProperty("consumerGroup"))
                    if (!$util.isString(message.consumerGroup))
                        return "consumerGroup: string expected";
                if (message.consumerName != null && message.hasOwnProperty("consumerName"))
                    if (!$util.isString(message.consumerName))
                        return "consumerName: string expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                if (message.createConsumerConfig != null && message.hasOwnProperty("createConsumerConfig")) {
                    var error = $root.protos.args.CreateConsumerConfig.verify(message.createConsumerConfig);
                    if (error)
                        return "createConsumerConfig." + error;
                }
                return null;
            };

            /**
             * Creates a RedisStreamsReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisStreamsReadArgs} RedisStreamsReadArgs
             */
            RedisStreamsReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisStreamsReadArgs)
                    return object;
                var message = new $root.protos.args.RedisStreamsReadArgs();
                if (object.streams) {
                    if (!Array.isArray(object.streams))
                        throw TypeError(".protos.args.RedisStreamsReadArgs.streams: array expected");
                    message.streams = [];
                    for (var i = 0; i < object.streams.length; ++i)
                        message.streams[i] = String(object.streams[i]);
                }
                if (object.consumerGroup != null)
                    message.consumerGroup = String(object.consumerGroup);
                if (object.consumerName != null)
                    message.consumerName = String(object.consumerName);
                if (object.count != null)
                    message.count = object.count >>> 0;
                if (object.createConsumerConfig != null) {
                    if (typeof object.createConsumerConfig !== "object")
                        throw TypeError(".protos.args.RedisStreamsReadArgs.createConsumerConfig: object expected");
                    message.createConsumerConfig = $root.protos.args.CreateConsumerConfig.fromObject(object.createConsumerConfig);
                }
                return message;
            };

            /**
             * Creates a plain object from a RedisStreamsReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {protos.args.RedisStreamsReadArgs} message RedisStreamsReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisStreamsReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.streams = [];
                if (options.defaults) {
                    object.consumerGroup = "";
                    object.consumerName = "";
                    object.count = 0;
                    object.createConsumerConfig = null;
                }
                if (message.streams && message.streams.length) {
                    object.streams = [];
                    for (var j = 0; j < message.streams.length; ++j)
                        object.streams[j] = message.streams[j];
                }
                if (message.consumerGroup != null && message.hasOwnProperty("consumerGroup"))
                    object.consumerGroup = message.consumerGroup;
                if (message.consumerName != null && message.hasOwnProperty("consumerName"))
                    object.consumerName = message.consumerName;
                if (message.count != null && message.hasOwnProperty("count"))
                    object.count = message.count;
                if (message.createConsumerConfig != null && message.hasOwnProperty("createConsumerConfig"))
                    object.createConsumerConfig = $root.protos.args.CreateConsumerConfig.toObject(message.createConsumerConfig, options);
                return object;
            };

            /**
             * Converts this RedisStreamsReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisStreamsReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisStreamsReadArgs;
        })();

        args.RedisStreamsWriteArgs = (function() {

            /**
             * Properties of a RedisStreamsWriteArgs.
             * @memberof protos.args
             * @interface IRedisStreamsWriteArgs
             * @property {string|null} [writeId] RedisStreamsWriteArgs writeId
             * @property {Array.<string>|null} [streams] RedisStreamsWriteArgs streams
             * @property {string|null} [key] RedisStreamsWriteArgs key
             */

            /**
             * Constructs a new RedisStreamsWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a RedisStreamsWriteArgs.
             * @implements IRedisStreamsWriteArgs
             * @constructor
             * @param {protos.args.IRedisStreamsWriteArgs=} [properties] Properties to set
             */
            function RedisStreamsWriteArgs(properties) {
                this.streams = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisStreamsWriteArgs writeId.
             * @member {string} writeId
             * @memberof protos.args.RedisStreamsWriteArgs
             * @instance
             */
            RedisStreamsWriteArgs.prototype.writeId = "";

            /**
             * RedisStreamsWriteArgs streams.
             * @member {Array.<string>} streams
             * @memberof protos.args.RedisStreamsWriteArgs
             * @instance
             */
            RedisStreamsWriteArgs.prototype.streams = $util.emptyArray;

            /**
             * RedisStreamsWriteArgs key.
             * @member {string} key
             * @memberof protos.args.RedisStreamsWriteArgs
             * @instance
             */
            RedisStreamsWriteArgs.prototype.key = "";

            /**
             * Creates a new RedisStreamsWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {protos.args.IRedisStreamsWriteArgs=} [properties] Properties to set
             * @returns {protos.args.RedisStreamsWriteArgs} RedisStreamsWriteArgs instance
             */
            RedisStreamsWriteArgs.create = function create(properties) {
                return new RedisStreamsWriteArgs(properties);
            };

            /**
             * Encodes the specified RedisStreamsWriteArgs message. Does not implicitly {@link protos.args.RedisStreamsWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {protos.args.IRedisStreamsWriteArgs} message RedisStreamsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.writeId != null && Object.hasOwnProperty.call(message, "writeId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.writeId);
                if (message.streams != null && message.streams.length)
                    for (var i = 0; i < message.streams.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.streams[i]);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.key);
                return writer;
            };

            /**
             * Encodes the specified RedisStreamsWriteArgs message, length delimited. Does not implicitly {@link protos.args.RedisStreamsWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {protos.args.IRedisStreamsWriteArgs} message RedisStreamsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisStreamsWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisStreamsWriteArgs} RedisStreamsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisStreamsWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.writeId = reader.string();
                        break;
                    case 2:
                        if (!(message.streams && message.streams.length))
                            message.streams = [];
                        message.streams.push(reader.string());
                        break;
                    case 3:
                        message.key = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisStreamsWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisStreamsWriteArgs} RedisStreamsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisStreamsWriteArgs message.
             * @function verify
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisStreamsWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.writeId != null && message.hasOwnProperty("writeId"))
                    if (!$util.isString(message.writeId))
                        return "writeId: string expected";
                if (message.streams != null && message.hasOwnProperty("streams")) {
                    if (!Array.isArray(message.streams))
                        return "streams: array expected";
                    for (var i = 0; i < message.streams.length; ++i)
                        if (!$util.isString(message.streams[i]))
                            return "streams: string[] expected";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                return null;
            };

            /**
             * Creates a RedisStreamsWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisStreamsWriteArgs} RedisStreamsWriteArgs
             */
            RedisStreamsWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisStreamsWriteArgs)
                    return object;
                var message = new $root.protos.args.RedisStreamsWriteArgs();
                if (object.writeId != null)
                    message.writeId = String(object.writeId);
                if (object.streams) {
                    if (!Array.isArray(object.streams))
                        throw TypeError(".protos.args.RedisStreamsWriteArgs.streams: array expected");
                    message.streams = [];
                    for (var i = 0; i < object.streams.length; ++i)
                        message.streams[i] = String(object.streams[i]);
                }
                if (object.key != null)
                    message.key = String(object.key);
                return message;
            };

            /**
             * Creates a plain object from a RedisStreamsWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {protos.args.RedisStreamsWriteArgs} message RedisStreamsWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisStreamsWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.streams = [];
                if (options.defaults) {
                    object.writeId = "";
                    object.key = "";
                }
                if (message.writeId != null && message.hasOwnProperty("writeId"))
                    object.writeId = message.writeId;
                if (message.streams && message.streams.length) {
                    object.streams = [];
                    for (var j = 0; j < message.streams.length; ++j)
                        object.streams[j] = message.streams[j];
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                return object;
            };

            /**
             * Converts this RedisStreamsWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RedisStreamsWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisStreamsWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisStreamsWriteArgs;
        })();

        return args;
    })();

    protos.GetAllRelaysRequest = (function() {

        /**
         * Properties of a GetAllRelaysRequest.
         * @memberof protos
         * @interface IGetAllRelaysRequest
         * @property {protos.common.IAuth|null} [auth] GetAllRelaysRequest auth
         */

        /**
         * Constructs a new GetAllRelaysRequest.
         * @memberof protos
         * @classdesc Represents a GetAllRelaysRequest.
         * @implements IGetAllRelaysRequest
         * @constructor
         * @param {protos.IGetAllRelaysRequest=} [properties] Properties to set
         */
        function GetAllRelaysRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllRelaysRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetAllRelaysRequest
         * @instance
         */
        GetAllRelaysRequest.prototype.auth = null;

        /**
         * Creates a new GetAllRelaysRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {protos.IGetAllRelaysRequest=} [properties] Properties to set
         * @returns {protos.GetAllRelaysRequest} GetAllRelaysRequest instance
         */
        GetAllRelaysRequest.create = function create(properties) {
            return new GetAllRelaysRequest(properties);
        };

        /**
         * Encodes the specified GetAllRelaysRequest message. Does not implicitly {@link protos.GetAllRelaysRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {protos.IGetAllRelaysRequest} message GetAllRelaysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllRelaysRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllRelaysRequest message, length delimited. Does not implicitly {@link protos.GetAllRelaysRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {protos.IGetAllRelaysRequest} message GetAllRelaysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllRelaysRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllRelaysRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllRelaysRequest} GetAllRelaysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllRelaysRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllRelaysRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllRelaysRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllRelaysRequest} GetAllRelaysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllRelaysRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllRelaysRequest message.
         * @function verify
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllRelaysRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };

        /**
         * Creates a GetAllRelaysRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllRelaysRequest} GetAllRelaysRequest
         */
        GetAllRelaysRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllRelaysRequest)
                return object;
            var message = new $root.protos.GetAllRelaysRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetAllRelaysRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllRelaysRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {protos.GetAllRelaysRequest} message GetAllRelaysRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllRelaysRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.auth = null;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetAllRelaysRequest to JSON.
         * @function toJSON
         * @memberof protos.GetAllRelaysRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllRelaysRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllRelaysRequest;
    })();

    protos.GetAllRelaysResponse = (function() {

        /**
         * Properties of a GetAllRelaysResponse.
         * @memberof protos
         * @interface IGetAllRelaysResponse
         * @property {protos.common.IStatus|null} [status] GetAllRelaysResponse status
         * @property {Array.<protos.opts.IRelayOptions>|null} [opts] GetAllRelaysResponse opts
         */

        /**
         * Constructs a new GetAllRelaysResponse.
         * @memberof protos
         * @classdesc Represents a GetAllRelaysResponse.
         * @implements IGetAllRelaysResponse
         * @constructor
         * @param {protos.IGetAllRelaysResponse=} [properties] Properties to set
         */
        function GetAllRelaysResponse(properties) {
            this.opts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllRelaysResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.GetAllRelaysResponse
         * @instance
         */
        GetAllRelaysResponse.prototype.status = null;

        /**
         * GetAllRelaysResponse opts.
         * @member {Array.<protos.opts.IRelayOptions>} opts
         * @memberof protos.GetAllRelaysResponse
         * @instance
         */
        GetAllRelaysResponse.prototype.opts = $util.emptyArray;

        /**
         * Creates a new GetAllRelaysResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {protos.IGetAllRelaysResponse=} [properties] Properties to set
         * @returns {protos.GetAllRelaysResponse} GetAllRelaysResponse instance
         */
        GetAllRelaysResponse.create = function create(properties) {
            return new GetAllRelaysResponse(properties);
        };

        /**
         * Encodes the specified GetAllRelaysResponse message. Does not implicitly {@link protos.GetAllRelaysResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {protos.IGetAllRelaysResponse} message GetAllRelaysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllRelaysResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.opts != null && message.opts.length)
                for (var i = 0; i < message.opts.length; ++i)
                    $root.protos.opts.RelayOptions.encode(message.opts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllRelaysResponse message, length delimited. Does not implicitly {@link protos.GetAllRelaysResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {protos.IGetAllRelaysResponse} message GetAllRelaysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllRelaysResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllRelaysResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllRelaysResponse} GetAllRelaysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllRelaysResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllRelaysResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    if (!(message.opts && message.opts.length))
                        message.opts = [];
                    message.opts.push($root.protos.opts.RelayOptions.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllRelaysResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllRelaysResponse} GetAllRelaysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllRelaysResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllRelaysResponse message.
         * @function verify
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllRelaysResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.opts != null && message.hasOwnProperty("opts")) {
                if (!Array.isArray(message.opts))
                    return "opts: array expected";
                for (var i = 0; i < message.opts.length; ++i) {
                    var error = $root.protos.opts.RelayOptions.verify(message.opts[i]);
                    if (error)
                        return "opts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetAllRelaysResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllRelaysResponse} GetAllRelaysResponse
         */
        GetAllRelaysResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllRelaysResponse)
                return object;
            var message = new $root.protos.GetAllRelaysResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.GetAllRelaysResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.opts) {
                if (!Array.isArray(object.opts))
                    throw TypeError(".protos.GetAllRelaysResponse.opts: array expected");
                message.opts = [];
                for (var i = 0; i < object.opts.length; ++i) {
                    if (typeof object.opts[i] !== "object")
                        throw TypeError(".protos.GetAllRelaysResponse.opts: object expected");
                    message.opts[i] = $root.protos.opts.RelayOptions.fromObject(object.opts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllRelaysResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {protos.GetAllRelaysResponse} message GetAllRelaysResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllRelaysResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.opts = [];
            if (options.defaults)
                object.status = null;
            if (message.opts && message.opts.length) {
                object.opts = [];
                for (var j = 0; j < message.opts.length; ++j)
                    object.opts[j] = $root.protos.opts.RelayOptions.toObject(message.opts[j], options);
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this GetAllRelaysResponse to JSON.
         * @function toJSON
         * @memberof protos.GetAllRelaysResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllRelaysResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllRelaysResponse;
    })();

    protos.GetRelayRequest = (function() {

        /**
         * Properties of a GetRelayRequest.
         * @memberof protos
         * @interface IGetRelayRequest
         * @property {protos.common.IAuth|null} [auth] GetRelayRequest auth
         * @property {string|null} [relayId] GetRelayRequest relayId
         */

        /**
         * Constructs a new GetRelayRequest.
         * @memberof protos
         * @classdesc Represents a GetRelayRequest.
         * @implements IGetRelayRequest
         * @constructor
         * @param {protos.IGetRelayRequest=} [properties] Properties to set
         */
        function GetRelayRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRelayRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetRelayRequest
         * @instance
         */
        GetRelayRequest.prototype.auth = null;

        /**
         * GetRelayRequest relayId.
         * @member {string} relayId
         * @memberof protos.GetRelayRequest
         * @instance
         */
        GetRelayRequest.prototype.relayId = "";

        /**
         * Creates a new GetRelayRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetRelayRequest
         * @static
         * @param {protos.IGetRelayRequest=} [properties] Properties to set
         * @returns {protos.GetRelayRequest} GetRelayRequest instance
         */
        GetRelayRequest.create = function create(properties) {
            return new GetRelayRequest(properties);
        };

        /**
         * Encodes the specified GetRelayRequest message. Does not implicitly {@link protos.GetRelayRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetRelayRequest
         * @static
         * @param {protos.IGetRelayRequest} message GetRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRelayRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relayId != null && Object.hasOwnProperty.call(message, "relayId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.relayId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetRelayRequest message, length delimited. Does not implicitly {@link protos.GetRelayRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetRelayRequest
         * @static
         * @param {protos.IGetRelayRequest} message GetRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRelayRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRelayRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetRelayRequest} GetRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRelayRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetRelayRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.relayId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRelayRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetRelayRequest} GetRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRelayRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRelayRequest message.
         * @function verify
         * @memberof protos.GetRelayRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRelayRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                if (!$util.isString(message.relayId))
                    return "relayId: string expected";
            return null;
        };

        /**
         * Creates a GetRelayRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetRelayRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetRelayRequest} GetRelayRequest
         */
        GetRelayRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetRelayRequest)
                return object;
            var message = new $root.protos.GetRelayRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetRelayRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.relayId != null)
                message.relayId = String(object.relayId);
            return message;
        };

        /**
         * Creates a plain object from a GetRelayRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetRelayRequest
         * @static
         * @param {protos.GetRelayRequest} message GetRelayRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetRelayRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relayId = "";
                object.auth = null;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                object.relayId = message.relayId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetRelayRequest to JSON.
         * @function toJSON
         * @memberof protos.GetRelayRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetRelayRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetRelayRequest;
    })();

    protos.GetRelayResponse = (function() {

        /**
         * Properties of a GetRelayResponse.
         * @memberof protos
         * @interface IGetRelayResponse
         * @property {protos.common.IStatus|null} [status] GetRelayResponse status
         * @property {protos.opts.IRelayOptions|null} [opts] GetRelayResponse opts
         */

        /**
         * Constructs a new GetRelayResponse.
         * @memberof protos
         * @classdesc Represents a GetRelayResponse.
         * @implements IGetRelayResponse
         * @constructor
         * @param {protos.IGetRelayResponse=} [properties] Properties to set
         */
        function GetRelayResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRelayResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.GetRelayResponse
         * @instance
         */
        GetRelayResponse.prototype.status = null;

        /**
         * GetRelayResponse opts.
         * @member {protos.opts.IRelayOptions|null|undefined} opts
         * @memberof protos.GetRelayResponse
         * @instance
         */
        GetRelayResponse.prototype.opts = null;

        /**
         * Creates a new GetRelayResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetRelayResponse
         * @static
         * @param {protos.IGetRelayResponse=} [properties] Properties to set
         * @returns {protos.GetRelayResponse} GetRelayResponse instance
         */
        GetRelayResponse.create = function create(properties) {
            return new GetRelayResponse(properties);
        };

        /**
         * Encodes the specified GetRelayResponse message. Does not implicitly {@link protos.GetRelayResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetRelayResponse
         * @static
         * @param {protos.IGetRelayResponse} message GetRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRelayResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.opts != null && Object.hasOwnProperty.call(message, "opts"))
                $root.protos.opts.RelayOptions.encode(message.opts, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetRelayResponse message, length delimited. Does not implicitly {@link protos.GetRelayResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetRelayResponse
         * @static
         * @param {protos.IGetRelayResponse} message GetRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRelayResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRelayResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetRelayResponse} GetRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRelayResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetRelayResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.opts = $root.protos.opts.RelayOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRelayResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetRelayResponse} GetRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRelayResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRelayResponse message.
         * @function verify
         * @memberof protos.GetRelayResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRelayResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.opts != null && message.hasOwnProperty("opts")) {
                var error = $root.protos.opts.RelayOptions.verify(message.opts);
                if (error)
                    return "opts." + error;
            }
            return null;
        };

        /**
         * Creates a GetRelayResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetRelayResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetRelayResponse} GetRelayResponse
         */
        GetRelayResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetRelayResponse)
                return object;
            var message = new $root.protos.GetRelayResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.GetRelayResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.opts != null) {
                if (typeof object.opts !== "object")
                    throw TypeError(".protos.GetRelayResponse.opts: object expected");
                message.opts = $root.protos.opts.RelayOptions.fromObject(object.opts);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetRelayResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetRelayResponse
         * @static
         * @param {protos.GetRelayResponse} message GetRelayResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetRelayResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.opts = null;
                object.status = null;
            }
            if (message.opts != null && message.hasOwnProperty("opts"))
                object.opts = $root.protos.opts.RelayOptions.toObject(message.opts, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this GetRelayResponse to JSON.
         * @function toJSON
         * @memberof protos.GetRelayResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetRelayResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetRelayResponse;
    })();

    protos.CreateRelayRequest = (function() {

        /**
         * Properties of a CreateRelayRequest.
         * @memberof protos
         * @interface ICreateRelayRequest
         * @property {protos.common.IAuth|null} [auth] CreateRelayRequest auth
         * @property {protos.opts.IRelayOptions|null} [opts] CreateRelayRequest opts
         */

        /**
         * Constructs a new CreateRelayRequest.
         * @memberof protos
         * @classdesc Represents a CreateRelayRequest.
         * @implements ICreateRelayRequest
         * @constructor
         * @param {protos.ICreateRelayRequest=} [properties] Properties to set
         */
        function CreateRelayRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateRelayRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.CreateRelayRequest
         * @instance
         */
        CreateRelayRequest.prototype.auth = null;

        /**
         * CreateRelayRequest opts.
         * @member {protos.opts.IRelayOptions|null|undefined} opts
         * @memberof protos.CreateRelayRequest
         * @instance
         */
        CreateRelayRequest.prototype.opts = null;

        /**
         * Creates a new CreateRelayRequest instance using the specified properties.
         * @function create
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {protos.ICreateRelayRequest=} [properties] Properties to set
         * @returns {protos.CreateRelayRequest} CreateRelayRequest instance
         */
        CreateRelayRequest.create = function create(properties) {
            return new CreateRelayRequest(properties);
        };

        /**
         * Encodes the specified CreateRelayRequest message. Does not implicitly {@link protos.CreateRelayRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {protos.ICreateRelayRequest} message CreateRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateRelayRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.opts != null && Object.hasOwnProperty.call(message, "opts"))
                $root.protos.opts.RelayOptions.encode(message.opts, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateRelayRequest message, length delimited. Does not implicitly {@link protos.CreateRelayRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {protos.ICreateRelayRequest} message CreateRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateRelayRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateRelayRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateRelayRequest} CreateRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateRelayRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateRelayRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.opts = $root.protos.opts.RelayOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateRelayRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateRelayRequest} CreateRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateRelayRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateRelayRequest message.
         * @function verify
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateRelayRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.opts != null && message.hasOwnProperty("opts")) {
                var error = $root.protos.opts.RelayOptions.verify(message.opts);
                if (error)
                    return "opts." + error;
            }
            return null;
        };

        /**
         * Creates a CreateRelayRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateRelayRequest} CreateRelayRequest
         */
        CreateRelayRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateRelayRequest)
                return object;
            var message = new $root.protos.CreateRelayRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.CreateRelayRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.opts != null) {
                if (typeof object.opts !== "object")
                    throw TypeError(".protos.CreateRelayRequest.opts: object expected");
                message.opts = $root.protos.opts.RelayOptions.fromObject(object.opts);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateRelayRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {protos.CreateRelayRequest} message CreateRelayRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateRelayRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.opts = null;
                object.auth = null;
            }
            if (message.opts != null && message.hasOwnProperty("opts"))
                object.opts = $root.protos.opts.RelayOptions.toObject(message.opts, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this CreateRelayRequest to JSON.
         * @function toJSON
         * @memberof protos.CreateRelayRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateRelayRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateRelayRequest;
    })();

    protos.CreateRelayResponse = (function() {

        /**
         * Properties of a CreateRelayResponse.
         * @memberof protos
         * @interface ICreateRelayResponse
         * @property {protos.common.IStatus|null} [status] CreateRelayResponse status
         * @property {string|null} [relayId] CreateRelayResponse relayId
         */

        /**
         * Constructs a new CreateRelayResponse.
         * @memberof protos
         * @classdesc Represents a CreateRelayResponse.
         * @implements ICreateRelayResponse
         * @constructor
         * @param {protos.ICreateRelayResponse=} [properties] Properties to set
         */
        function CreateRelayResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateRelayResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.CreateRelayResponse
         * @instance
         */
        CreateRelayResponse.prototype.status = null;

        /**
         * CreateRelayResponse relayId.
         * @member {string} relayId
         * @memberof protos.CreateRelayResponse
         * @instance
         */
        CreateRelayResponse.prototype.relayId = "";

        /**
         * Creates a new CreateRelayResponse instance using the specified properties.
         * @function create
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {protos.ICreateRelayResponse=} [properties] Properties to set
         * @returns {protos.CreateRelayResponse} CreateRelayResponse instance
         */
        CreateRelayResponse.create = function create(properties) {
            return new CreateRelayResponse(properties);
        };

        /**
         * Encodes the specified CreateRelayResponse message. Does not implicitly {@link protos.CreateRelayResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {protos.ICreateRelayResponse} message CreateRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateRelayResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relayId != null && Object.hasOwnProperty.call(message, "relayId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.relayId);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateRelayResponse message, length delimited. Does not implicitly {@link protos.CreateRelayResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {protos.ICreateRelayResponse} message CreateRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateRelayResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateRelayResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateRelayResponse} CreateRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateRelayResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateRelayResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.relayId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateRelayResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateRelayResponse} CreateRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateRelayResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateRelayResponse message.
         * @function verify
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateRelayResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                if (!$util.isString(message.relayId))
                    return "relayId: string expected";
            return null;
        };

        /**
         * Creates a CreateRelayResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateRelayResponse} CreateRelayResponse
         */
        CreateRelayResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateRelayResponse)
                return object;
            var message = new $root.protos.CreateRelayResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.CreateRelayResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.relayId != null)
                message.relayId = String(object.relayId);
            return message;
        };

        /**
         * Creates a plain object from a CreateRelayResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {protos.CreateRelayResponse} message CreateRelayResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateRelayResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relayId = "";
                object.status = null;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                object.relayId = message.relayId;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this CreateRelayResponse to JSON.
         * @function toJSON
         * @memberof protos.CreateRelayResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateRelayResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateRelayResponse;
    })();

    protos.UpdateRelayRequest = (function() {

        /**
         * Properties of an UpdateRelayRequest.
         * @memberof protos
         * @interface IUpdateRelayRequest
         * @property {protos.common.IAuth|null} [auth] UpdateRelayRequest auth
         * @property {string|null} [relayId] UpdateRelayRequest relayId
         * @property {protos.opts.IRelayOptions|null} [opts] UpdateRelayRequest opts
         */

        /**
         * Constructs a new UpdateRelayRequest.
         * @memberof protos
         * @classdesc Represents an UpdateRelayRequest.
         * @implements IUpdateRelayRequest
         * @constructor
         * @param {protos.IUpdateRelayRequest=} [properties] Properties to set
         */
        function UpdateRelayRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateRelayRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.UpdateRelayRequest
         * @instance
         */
        UpdateRelayRequest.prototype.auth = null;

        /**
         * UpdateRelayRequest relayId.
         * @member {string} relayId
         * @memberof protos.UpdateRelayRequest
         * @instance
         */
        UpdateRelayRequest.prototype.relayId = "";

        /**
         * UpdateRelayRequest opts.
         * @member {protos.opts.IRelayOptions|null|undefined} opts
         * @memberof protos.UpdateRelayRequest
         * @instance
         */
        UpdateRelayRequest.prototype.opts = null;

        /**
         * Creates a new UpdateRelayRequest instance using the specified properties.
         * @function create
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {protos.IUpdateRelayRequest=} [properties] Properties to set
         * @returns {protos.UpdateRelayRequest} UpdateRelayRequest instance
         */
        UpdateRelayRequest.create = function create(properties) {
            return new UpdateRelayRequest(properties);
        };

        /**
         * Encodes the specified UpdateRelayRequest message. Does not implicitly {@link protos.UpdateRelayRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {protos.IUpdateRelayRequest} message UpdateRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateRelayRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relayId != null && Object.hasOwnProperty.call(message, "relayId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.relayId);
            if (message.opts != null && Object.hasOwnProperty.call(message, "opts"))
                $root.protos.opts.RelayOptions.encode(message.opts, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateRelayRequest message, length delimited. Does not implicitly {@link protos.UpdateRelayRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {protos.IUpdateRelayRequest} message UpdateRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateRelayRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateRelayRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateRelayRequest} UpdateRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateRelayRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateRelayRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.relayId = reader.string();
                    break;
                case 2:
                    message.opts = $root.protos.opts.RelayOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateRelayRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateRelayRequest} UpdateRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateRelayRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateRelayRequest message.
         * @function verify
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateRelayRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                if (!$util.isString(message.relayId))
                    return "relayId: string expected";
            if (message.opts != null && message.hasOwnProperty("opts")) {
                var error = $root.protos.opts.RelayOptions.verify(message.opts);
                if (error)
                    return "opts." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateRelayRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateRelayRequest} UpdateRelayRequest
         */
        UpdateRelayRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateRelayRequest)
                return object;
            var message = new $root.protos.UpdateRelayRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.UpdateRelayRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.relayId != null)
                message.relayId = String(object.relayId);
            if (object.opts != null) {
                if (typeof object.opts !== "object")
                    throw TypeError(".protos.UpdateRelayRequest.opts: object expected");
                message.opts = $root.protos.opts.RelayOptions.fromObject(object.opts);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateRelayRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {protos.UpdateRelayRequest} message UpdateRelayRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateRelayRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relayId = "";
                object.opts = null;
                object.auth = null;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                object.relayId = message.relayId;
            if (message.opts != null && message.hasOwnProperty("opts"))
                object.opts = $root.protos.opts.RelayOptions.toObject(message.opts, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this UpdateRelayRequest to JSON.
         * @function toJSON
         * @memberof protos.UpdateRelayRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateRelayRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateRelayRequest;
    })();

    protos.UpdateRelayResponse = (function() {

        /**
         * Properties of an UpdateRelayResponse.
         * @memberof protos
         * @interface IUpdateRelayResponse
         * @property {protos.common.IStatus|null} [status] UpdateRelayResponse status
         */

        /**
         * Constructs a new UpdateRelayResponse.
         * @memberof protos
         * @classdesc Represents an UpdateRelayResponse.
         * @implements IUpdateRelayResponse
         * @constructor
         * @param {protos.IUpdateRelayResponse=} [properties] Properties to set
         */
        function UpdateRelayResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateRelayResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.UpdateRelayResponse
         * @instance
         */
        UpdateRelayResponse.prototype.status = null;

        /**
         * Creates a new UpdateRelayResponse instance using the specified properties.
         * @function create
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {protos.IUpdateRelayResponse=} [properties] Properties to set
         * @returns {protos.UpdateRelayResponse} UpdateRelayResponse instance
         */
        UpdateRelayResponse.create = function create(properties) {
            return new UpdateRelayResponse(properties);
        };

        /**
         * Encodes the specified UpdateRelayResponse message. Does not implicitly {@link protos.UpdateRelayResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {protos.IUpdateRelayResponse} message UpdateRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateRelayResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateRelayResponse message, length delimited. Does not implicitly {@link protos.UpdateRelayResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {protos.IUpdateRelayResponse} message UpdateRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateRelayResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateRelayResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateRelayResponse} UpdateRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateRelayResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateRelayResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateRelayResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateRelayResponse} UpdateRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateRelayResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateRelayResponse message.
         * @function verify
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateRelayResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateRelayResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateRelayResponse} UpdateRelayResponse
         */
        UpdateRelayResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateRelayResponse)
                return object;
            var message = new $root.protos.UpdateRelayResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.UpdateRelayResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateRelayResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {protos.UpdateRelayResponse} message UpdateRelayResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateRelayResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this UpdateRelayResponse to JSON.
         * @function toJSON
         * @memberof protos.UpdateRelayResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateRelayResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateRelayResponse;
    })();

    protos.ResumeRelayRequest = (function() {

        /**
         * Properties of a ResumeRelayRequest.
         * @memberof protos
         * @interface IResumeRelayRequest
         * @property {protos.common.IAuth|null} [auth] ResumeRelayRequest auth
         * @property {string|null} [relayId] ResumeRelayRequest relayId
         */

        /**
         * Constructs a new ResumeRelayRequest.
         * @memberof protos
         * @classdesc Represents a ResumeRelayRequest.
         * @implements IResumeRelayRequest
         * @constructor
         * @param {protos.IResumeRelayRequest=} [properties] Properties to set
         */
        function ResumeRelayRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResumeRelayRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.ResumeRelayRequest
         * @instance
         */
        ResumeRelayRequest.prototype.auth = null;

        /**
         * ResumeRelayRequest relayId.
         * @member {string} relayId
         * @memberof protos.ResumeRelayRequest
         * @instance
         */
        ResumeRelayRequest.prototype.relayId = "";

        /**
         * Creates a new ResumeRelayRequest instance using the specified properties.
         * @function create
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {protos.IResumeRelayRequest=} [properties] Properties to set
         * @returns {protos.ResumeRelayRequest} ResumeRelayRequest instance
         */
        ResumeRelayRequest.create = function create(properties) {
            return new ResumeRelayRequest(properties);
        };

        /**
         * Encodes the specified ResumeRelayRequest message. Does not implicitly {@link protos.ResumeRelayRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {protos.IResumeRelayRequest} message ResumeRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeRelayRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relayId != null && Object.hasOwnProperty.call(message, "relayId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.relayId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResumeRelayRequest message, length delimited. Does not implicitly {@link protos.ResumeRelayRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {protos.IResumeRelayRequest} message ResumeRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeRelayRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResumeRelayRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ResumeRelayRequest} ResumeRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeRelayRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ResumeRelayRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.relayId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResumeRelayRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ResumeRelayRequest} ResumeRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeRelayRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResumeRelayRequest message.
         * @function verify
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResumeRelayRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                if (!$util.isString(message.relayId))
                    return "relayId: string expected";
            return null;
        };

        /**
         * Creates a ResumeRelayRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ResumeRelayRequest} ResumeRelayRequest
         */
        ResumeRelayRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ResumeRelayRequest)
                return object;
            var message = new $root.protos.ResumeRelayRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.ResumeRelayRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.relayId != null)
                message.relayId = String(object.relayId);
            return message;
        };

        /**
         * Creates a plain object from a ResumeRelayRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {protos.ResumeRelayRequest} message ResumeRelayRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResumeRelayRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relayId = "";
                object.auth = null;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                object.relayId = message.relayId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this ResumeRelayRequest to JSON.
         * @function toJSON
         * @memberof protos.ResumeRelayRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResumeRelayRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResumeRelayRequest;
    })();

    protos.ResumeRelayResponse = (function() {

        /**
         * Properties of a ResumeRelayResponse.
         * @memberof protos
         * @interface IResumeRelayResponse
         * @property {protos.common.IStatus|null} [status] ResumeRelayResponse status
         */

        /**
         * Constructs a new ResumeRelayResponse.
         * @memberof protos
         * @classdesc Represents a ResumeRelayResponse.
         * @implements IResumeRelayResponse
         * @constructor
         * @param {protos.IResumeRelayResponse=} [properties] Properties to set
         */
        function ResumeRelayResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResumeRelayResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.ResumeRelayResponse
         * @instance
         */
        ResumeRelayResponse.prototype.status = null;

        /**
         * Creates a new ResumeRelayResponse instance using the specified properties.
         * @function create
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {protos.IResumeRelayResponse=} [properties] Properties to set
         * @returns {protos.ResumeRelayResponse} ResumeRelayResponse instance
         */
        ResumeRelayResponse.create = function create(properties) {
            return new ResumeRelayResponse(properties);
        };

        /**
         * Encodes the specified ResumeRelayResponse message. Does not implicitly {@link protos.ResumeRelayResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {protos.IResumeRelayResponse} message ResumeRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeRelayResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResumeRelayResponse message, length delimited. Does not implicitly {@link protos.ResumeRelayResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {protos.IResumeRelayResponse} message ResumeRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeRelayResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResumeRelayResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ResumeRelayResponse} ResumeRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeRelayResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ResumeRelayResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResumeRelayResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ResumeRelayResponse} ResumeRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeRelayResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResumeRelayResponse message.
         * @function verify
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResumeRelayResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a ResumeRelayResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ResumeRelayResponse} ResumeRelayResponse
         */
        ResumeRelayResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ResumeRelayResponse)
                return object;
            var message = new $root.protos.ResumeRelayResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.ResumeRelayResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a ResumeRelayResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {protos.ResumeRelayResponse} message ResumeRelayResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResumeRelayResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this ResumeRelayResponse to JSON.
         * @function toJSON
         * @memberof protos.ResumeRelayResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResumeRelayResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResumeRelayResponse;
    })();

    protos.StopRelayRequest = (function() {

        /**
         * Properties of a StopRelayRequest.
         * @memberof protos
         * @interface IStopRelayRequest
         * @property {protos.common.IAuth|null} [auth] StopRelayRequest auth
         * @property {string|null} [relayId] StopRelayRequest relayId
         */

        /**
         * Constructs a new StopRelayRequest.
         * @memberof protos
         * @classdesc Represents a StopRelayRequest.
         * @implements IStopRelayRequest
         * @constructor
         * @param {protos.IStopRelayRequest=} [properties] Properties to set
         */
        function StopRelayRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StopRelayRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.StopRelayRequest
         * @instance
         */
        StopRelayRequest.prototype.auth = null;

        /**
         * StopRelayRequest relayId.
         * @member {string} relayId
         * @memberof protos.StopRelayRequest
         * @instance
         */
        StopRelayRequest.prototype.relayId = "";

        /**
         * Creates a new StopRelayRequest instance using the specified properties.
         * @function create
         * @memberof protos.StopRelayRequest
         * @static
         * @param {protos.IStopRelayRequest=} [properties] Properties to set
         * @returns {protos.StopRelayRequest} StopRelayRequest instance
         */
        StopRelayRequest.create = function create(properties) {
            return new StopRelayRequest(properties);
        };

        /**
         * Encodes the specified StopRelayRequest message. Does not implicitly {@link protos.StopRelayRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.StopRelayRequest
         * @static
         * @param {protos.IStopRelayRequest} message StopRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopRelayRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relayId != null && Object.hasOwnProperty.call(message, "relayId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.relayId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StopRelayRequest message, length delimited. Does not implicitly {@link protos.StopRelayRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.StopRelayRequest
         * @static
         * @param {protos.IStopRelayRequest} message StopRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopRelayRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopRelayRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.StopRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.StopRelayRequest} StopRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopRelayRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.StopRelayRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.relayId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopRelayRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.StopRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.StopRelayRequest} StopRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopRelayRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopRelayRequest message.
         * @function verify
         * @memberof protos.StopRelayRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopRelayRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                if (!$util.isString(message.relayId))
                    return "relayId: string expected";
            return null;
        };

        /**
         * Creates a StopRelayRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.StopRelayRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.StopRelayRequest} StopRelayRequest
         */
        StopRelayRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.StopRelayRequest)
                return object;
            var message = new $root.protos.StopRelayRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.StopRelayRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.relayId != null)
                message.relayId = String(object.relayId);
            return message;
        };

        /**
         * Creates a plain object from a StopRelayRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.StopRelayRequest
         * @static
         * @param {protos.StopRelayRequest} message StopRelayRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopRelayRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relayId = "";
                object.auth = null;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                object.relayId = message.relayId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this StopRelayRequest to JSON.
         * @function toJSON
         * @memberof protos.StopRelayRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopRelayRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopRelayRequest;
    })();

    protos.StopRelayResponse = (function() {

        /**
         * Properties of a StopRelayResponse.
         * @memberof protos
         * @interface IStopRelayResponse
         * @property {protos.common.IStatus|null} [status] StopRelayResponse status
         */

        /**
         * Constructs a new StopRelayResponse.
         * @memberof protos
         * @classdesc Represents a StopRelayResponse.
         * @implements IStopRelayResponse
         * @constructor
         * @param {protos.IStopRelayResponse=} [properties] Properties to set
         */
        function StopRelayResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StopRelayResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.StopRelayResponse
         * @instance
         */
        StopRelayResponse.prototype.status = null;

        /**
         * Creates a new StopRelayResponse instance using the specified properties.
         * @function create
         * @memberof protos.StopRelayResponse
         * @static
         * @param {protos.IStopRelayResponse=} [properties] Properties to set
         * @returns {protos.StopRelayResponse} StopRelayResponse instance
         */
        StopRelayResponse.create = function create(properties) {
            return new StopRelayResponse(properties);
        };

        /**
         * Encodes the specified StopRelayResponse message. Does not implicitly {@link protos.StopRelayResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.StopRelayResponse
         * @static
         * @param {protos.IStopRelayResponse} message StopRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopRelayResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StopRelayResponse message, length delimited. Does not implicitly {@link protos.StopRelayResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.StopRelayResponse
         * @static
         * @param {protos.IStopRelayResponse} message StopRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopRelayResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopRelayResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.StopRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.StopRelayResponse} StopRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopRelayResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.StopRelayResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopRelayResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.StopRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.StopRelayResponse} StopRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopRelayResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopRelayResponse message.
         * @function verify
         * @memberof protos.StopRelayResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopRelayResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a StopRelayResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.StopRelayResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.StopRelayResponse} StopRelayResponse
         */
        StopRelayResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.StopRelayResponse)
                return object;
            var message = new $root.protos.StopRelayResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.StopRelayResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a StopRelayResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.StopRelayResponse
         * @static
         * @param {protos.StopRelayResponse} message StopRelayResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopRelayResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this StopRelayResponse to JSON.
         * @function toJSON
         * @memberof protos.StopRelayResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopRelayResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopRelayResponse;
    })();

    protos.DeleteRelayRequest = (function() {

        /**
         * Properties of a DeleteRelayRequest.
         * @memberof protos
         * @interface IDeleteRelayRequest
         * @property {protos.common.IAuth|null} [auth] DeleteRelayRequest auth
         * @property {string|null} [relayId] DeleteRelayRequest relayId
         */

        /**
         * Constructs a new DeleteRelayRequest.
         * @memberof protos
         * @classdesc Represents a DeleteRelayRequest.
         * @implements IDeleteRelayRequest
         * @constructor
         * @param {protos.IDeleteRelayRequest=} [properties] Properties to set
         */
        function DeleteRelayRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteRelayRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.DeleteRelayRequest
         * @instance
         */
        DeleteRelayRequest.prototype.auth = null;

        /**
         * DeleteRelayRequest relayId.
         * @member {string} relayId
         * @memberof protos.DeleteRelayRequest
         * @instance
         */
        DeleteRelayRequest.prototype.relayId = "";

        /**
         * Creates a new DeleteRelayRequest instance using the specified properties.
         * @function create
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {protos.IDeleteRelayRequest=} [properties] Properties to set
         * @returns {protos.DeleteRelayRequest} DeleteRelayRequest instance
         */
        DeleteRelayRequest.create = function create(properties) {
            return new DeleteRelayRequest(properties);
        };

        /**
         * Encodes the specified DeleteRelayRequest message. Does not implicitly {@link protos.DeleteRelayRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {protos.IDeleteRelayRequest} message DeleteRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteRelayRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relayId != null && Object.hasOwnProperty.call(message, "relayId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.relayId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteRelayRequest message, length delimited. Does not implicitly {@link protos.DeleteRelayRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {protos.IDeleteRelayRequest} message DeleteRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteRelayRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteRelayRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteRelayRequest} DeleteRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteRelayRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteRelayRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.relayId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteRelayRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteRelayRequest} DeleteRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteRelayRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteRelayRequest message.
         * @function verify
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteRelayRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                if (!$util.isString(message.relayId))
                    return "relayId: string expected";
            return null;
        };

        /**
         * Creates a DeleteRelayRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteRelayRequest} DeleteRelayRequest
         */
        DeleteRelayRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteRelayRequest)
                return object;
            var message = new $root.protos.DeleteRelayRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.DeleteRelayRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.relayId != null)
                message.relayId = String(object.relayId);
            return message;
        };

        /**
         * Creates a plain object from a DeleteRelayRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {protos.DeleteRelayRequest} message DeleteRelayRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteRelayRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relayId = "";
                object.auth = null;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                object.relayId = message.relayId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this DeleteRelayRequest to JSON.
         * @function toJSON
         * @memberof protos.DeleteRelayRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteRelayRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteRelayRequest;
    })();

    protos.DeleteRelayResponse = (function() {

        /**
         * Properties of a DeleteRelayResponse.
         * @memberof protos
         * @interface IDeleteRelayResponse
         * @property {protos.common.IStatus|null} [status] DeleteRelayResponse status
         */

        /**
         * Constructs a new DeleteRelayResponse.
         * @memberof protos
         * @classdesc Represents a DeleteRelayResponse.
         * @implements IDeleteRelayResponse
         * @constructor
         * @param {protos.IDeleteRelayResponse=} [properties] Properties to set
         */
        function DeleteRelayResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteRelayResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.DeleteRelayResponse
         * @instance
         */
        DeleteRelayResponse.prototype.status = null;

        /**
         * Creates a new DeleteRelayResponse instance using the specified properties.
         * @function create
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {protos.IDeleteRelayResponse=} [properties] Properties to set
         * @returns {protos.DeleteRelayResponse} DeleteRelayResponse instance
         */
        DeleteRelayResponse.create = function create(properties) {
            return new DeleteRelayResponse(properties);
        };

        /**
         * Encodes the specified DeleteRelayResponse message. Does not implicitly {@link protos.DeleteRelayResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {protos.IDeleteRelayResponse} message DeleteRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteRelayResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteRelayResponse message, length delimited. Does not implicitly {@link protos.DeleteRelayResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {protos.IDeleteRelayResponse} message DeleteRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteRelayResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteRelayResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteRelayResponse} DeleteRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteRelayResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteRelayResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteRelayResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteRelayResponse} DeleteRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteRelayResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteRelayResponse message.
         * @function verify
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteRelayResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a DeleteRelayResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteRelayResponse} DeleteRelayResponse
         */
        DeleteRelayResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteRelayResponse)
                return object;
            var message = new $root.protos.DeleteRelayResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.DeleteRelayResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a DeleteRelayResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {protos.DeleteRelayResponse} message DeleteRelayResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteRelayResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this DeleteRelayResponse to JSON.
         * @function toJSON
         * @memberof protos.DeleteRelayResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteRelayResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteRelayResponse;
    })();

    protos.GetServerOptionsRequest = (function() {

        /**
         * Properties of a GetServerOptionsRequest.
         * @memberof protos
         * @interface IGetServerOptionsRequest
         * @property {protos.common.IAuth|null} [auth] GetServerOptionsRequest auth
         */

        /**
         * Constructs a new GetServerOptionsRequest.
         * @memberof protos
         * @classdesc Represents a GetServerOptionsRequest.
         * @implements IGetServerOptionsRequest
         * @constructor
         * @param {protos.IGetServerOptionsRequest=} [properties] Properties to set
         */
        function GetServerOptionsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetServerOptionsRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetServerOptionsRequest
         * @instance
         */
        GetServerOptionsRequest.prototype.auth = null;

        /**
         * Creates a new GetServerOptionsRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {protos.IGetServerOptionsRequest=} [properties] Properties to set
         * @returns {protos.GetServerOptionsRequest} GetServerOptionsRequest instance
         */
        GetServerOptionsRequest.create = function create(properties) {
            return new GetServerOptionsRequest(properties);
        };

        /**
         * Encodes the specified GetServerOptionsRequest message. Does not implicitly {@link protos.GetServerOptionsRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {protos.IGetServerOptionsRequest} message GetServerOptionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetServerOptionsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetServerOptionsRequest message, length delimited. Does not implicitly {@link protos.GetServerOptionsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {protos.IGetServerOptionsRequest} message GetServerOptionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetServerOptionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetServerOptionsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetServerOptionsRequest} GetServerOptionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetServerOptionsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetServerOptionsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetServerOptionsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetServerOptionsRequest} GetServerOptionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetServerOptionsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetServerOptionsRequest message.
         * @function verify
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetServerOptionsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };

        /**
         * Creates a GetServerOptionsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetServerOptionsRequest} GetServerOptionsRequest
         */
        GetServerOptionsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetServerOptionsRequest)
                return object;
            var message = new $root.protos.GetServerOptionsRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetServerOptionsRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetServerOptionsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {protos.GetServerOptionsRequest} message GetServerOptionsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetServerOptionsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.auth = null;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetServerOptionsRequest to JSON.
         * @function toJSON
         * @memberof protos.GetServerOptionsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetServerOptionsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetServerOptionsRequest;
    })();

    protos.GetServerOptionsResponse = (function() {

        /**
         * Properties of a GetServerOptionsResponse.
         * @memberof protos
         * @interface IGetServerOptionsResponse
         * @property {protos.opts.IServerOptions|null} [serverOptions] GetServerOptionsResponse serverOptions
         */

        /**
         * Constructs a new GetServerOptionsResponse.
         * @memberof protos
         * @classdesc Represents a GetServerOptionsResponse.
         * @implements IGetServerOptionsResponse
         * @constructor
         * @param {protos.IGetServerOptionsResponse=} [properties] Properties to set
         */
        function GetServerOptionsResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetServerOptionsResponse serverOptions.
         * @member {protos.opts.IServerOptions|null|undefined} serverOptions
         * @memberof protos.GetServerOptionsResponse
         * @instance
         */
        GetServerOptionsResponse.prototype.serverOptions = null;

        /**
         * Creates a new GetServerOptionsResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {protos.IGetServerOptionsResponse=} [properties] Properties to set
         * @returns {protos.GetServerOptionsResponse} GetServerOptionsResponse instance
         */
        GetServerOptionsResponse.create = function create(properties) {
            return new GetServerOptionsResponse(properties);
        };

        /**
         * Encodes the specified GetServerOptionsResponse message. Does not implicitly {@link protos.GetServerOptionsResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {protos.IGetServerOptionsResponse} message GetServerOptionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetServerOptionsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverOptions != null && Object.hasOwnProperty.call(message, "serverOptions"))
                $root.protos.opts.ServerOptions.encode(message.serverOptions, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetServerOptionsResponse message, length delimited. Does not implicitly {@link protos.GetServerOptionsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {protos.IGetServerOptionsResponse} message GetServerOptionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetServerOptionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetServerOptionsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetServerOptionsResponse} GetServerOptionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetServerOptionsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetServerOptionsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverOptions = $root.protos.opts.ServerOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetServerOptionsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetServerOptionsResponse} GetServerOptionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetServerOptionsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetServerOptionsResponse message.
         * @function verify
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetServerOptionsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverOptions != null && message.hasOwnProperty("serverOptions")) {
                var error = $root.protos.opts.ServerOptions.verify(message.serverOptions);
                if (error)
                    return "serverOptions." + error;
            }
            return null;
        };

        /**
         * Creates a GetServerOptionsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetServerOptionsResponse} GetServerOptionsResponse
         */
        GetServerOptionsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetServerOptionsResponse)
                return object;
            var message = new $root.protos.GetServerOptionsResponse();
            if (object.serverOptions != null) {
                if (typeof object.serverOptions !== "object")
                    throw TypeError(".protos.GetServerOptionsResponse.serverOptions: object expected");
                message.serverOptions = $root.protos.opts.ServerOptions.fromObject(object.serverOptions);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetServerOptionsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {protos.GetServerOptionsResponse} message GetServerOptionsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetServerOptionsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.serverOptions = null;
            if (message.serverOptions != null && message.hasOwnProperty("serverOptions"))
                object.serverOptions = $root.protos.opts.ServerOptions.toObject(message.serverOptions, options);
            return object;
        };

        /**
         * Converts this GetServerOptionsResponse to JSON.
         * @function toJSON
         * @memberof protos.GetServerOptionsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetServerOptionsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetServerOptionsResponse;
    })();

    protos.GetAllTunnelsRequest = (function() {

        /**
         * Properties of a GetAllTunnelsRequest.
         * @memberof protos
         * @interface IGetAllTunnelsRequest
         * @property {protos.common.IAuth|null} [auth] GetAllTunnelsRequest auth
         */

        /**
         * Constructs a new GetAllTunnelsRequest.
         * @memberof protos
         * @classdesc Represents a GetAllTunnelsRequest.
         * @implements IGetAllTunnelsRequest
         * @constructor
         * @param {protos.IGetAllTunnelsRequest=} [properties] Properties to set
         */
        function GetAllTunnelsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllTunnelsRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetAllTunnelsRequest
         * @instance
         */
        GetAllTunnelsRequest.prototype.auth = null;

        /**
         * Creates a new GetAllTunnelsRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetAllTunnelsRequest
         * @static
         * @param {protos.IGetAllTunnelsRequest=} [properties] Properties to set
         * @returns {protos.GetAllTunnelsRequest} GetAllTunnelsRequest instance
         */
        GetAllTunnelsRequest.create = function create(properties) {
            return new GetAllTunnelsRequest(properties);
        };

        /**
         * Encodes the specified GetAllTunnelsRequest message. Does not implicitly {@link protos.GetAllTunnelsRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllTunnelsRequest
         * @static
         * @param {protos.IGetAllTunnelsRequest} message GetAllTunnelsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllTunnelsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllTunnelsRequest message, length delimited. Does not implicitly {@link protos.GetAllTunnelsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllTunnelsRequest
         * @static
         * @param {protos.IGetAllTunnelsRequest} message GetAllTunnelsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllTunnelsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllTunnelsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllTunnelsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllTunnelsRequest} GetAllTunnelsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllTunnelsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllTunnelsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllTunnelsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllTunnelsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllTunnelsRequest} GetAllTunnelsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllTunnelsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllTunnelsRequest message.
         * @function verify
         * @memberof protos.GetAllTunnelsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllTunnelsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };

        /**
         * Creates a GetAllTunnelsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllTunnelsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllTunnelsRequest} GetAllTunnelsRequest
         */
        GetAllTunnelsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllTunnelsRequest)
                return object;
            var message = new $root.protos.GetAllTunnelsRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetAllTunnelsRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllTunnelsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllTunnelsRequest
         * @static
         * @param {protos.GetAllTunnelsRequest} message GetAllTunnelsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllTunnelsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.auth = null;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetAllTunnelsRequest to JSON.
         * @function toJSON
         * @memberof protos.GetAllTunnelsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllTunnelsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllTunnelsRequest;
    })();

    protos.GetAllTunnelsResponse = (function() {

        /**
         * Properties of a GetAllTunnelsResponse.
         * @memberof protos
         * @interface IGetAllTunnelsResponse
         * @property {protos.common.IStatus|null} [status] GetAllTunnelsResponse status
         * @property {Array.<protos.opts.ITunnelOptions>|null} [opts] GetAllTunnelsResponse opts
         */

        /**
         * Constructs a new GetAllTunnelsResponse.
         * @memberof protos
         * @classdesc Represents a GetAllTunnelsResponse.
         * @implements IGetAllTunnelsResponse
         * @constructor
         * @param {protos.IGetAllTunnelsResponse=} [properties] Properties to set
         */
        function GetAllTunnelsResponse(properties) {
            this.opts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllTunnelsResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.GetAllTunnelsResponse
         * @instance
         */
        GetAllTunnelsResponse.prototype.status = null;

        /**
         * GetAllTunnelsResponse opts.
         * @member {Array.<protos.opts.ITunnelOptions>} opts
         * @memberof protos.GetAllTunnelsResponse
         * @instance
         */
        GetAllTunnelsResponse.prototype.opts = $util.emptyArray;

        /**
         * Creates a new GetAllTunnelsResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetAllTunnelsResponse
         * @static
         * @param {protos.IGetAllTunnelsResponse=} [properties] Properties to set
         * @returns {protos.GetAllTunnelsResponse} GetAllTunnelsResponse instance
         */
        GetAllTunnelsResponse.create = function create(properties) {
            return new GetAllTunnelsResponse(properties);
        };

        /**
         * Encodes the specified GetAllTunnelsResponse message. Does not implicitly {@link protos.GetAllTunnelsResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllTunnelsResponse
         * @static
         * @param {protos.IGetAllTunnelsResponse} message GetAllTunnelsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllTunnelsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.opts != null && message.opts.length)
                for (var i = 0; i < message.opts.length; ++i)
                    $root.protos.opts.TunnelOptions.encode(message.opts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllTunnelsResponse message, length delimited. Does not implicitly {@link protos.GetAllTunnelsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllTunnelsResponse
         * @static
         * @param {protos.IGetAllTunnelsResponse} message GetAllTunnelsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllTunnelsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllTunnelsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllTunnelsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllTunnelsResponse} GetAllTunnelsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllTunnelsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllTunnelsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    if (!(message.opts && message.opts.length))
                        message.opts = [];
                    message.opts.push($root.protos.opts.TunnelOptions.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllTunnelsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllTunnelsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllTunnelsResponse} GetAllTunnelsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllTunnelsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllTunnelsResponse message.
         * @function verify
         * @memberof protos.GetAllTunnelsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllTunnelsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.opts != null && message.hasOwnProperty("opts")) {
                if (!Array.isArray(message.opts))
                    return "opts: array expected";
                for (var i = 0; i < message.opts.length; ++i) {
                    var error = $root.protos.opts.TunnelOptions.verify(message.opts[i]);
                    if (error)
                        return "opts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetAllTunnelsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllTunnelsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllTunnelsResponse} GetAllTunnelsResponse
         */
        GetAllTunnelsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllTunnelsResponse)
                return object;
            var message = new $root.protos.GetAllTunnelsResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.GetAllTunnelsResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.opts) {
                if (!Array.isArray(object.opts))
                    throw TypeError(".protos.GetAllTunnelsResponse.opts: array expected");
                message.opts = [];
                for (var i = 0; i < object.opts.length; ++i) {
                    if (typeof object.opts[i] !== "object")
                        throw TypeError(".protos.GetAllTunnelsResponse.opts: object expected");
                    message.opts[i] = $root.protos.opts.TunnelOptions.fromObject(object.opts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllTunnelsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllTunnelsResponse
         * @static
         * @param {protos.GetAllTunnelsResponse} message GetAllTunnelsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllTunnelsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.opts = [];
            if (options.defaults)
                object.status = null;
            if (message.opts && message.opts.length) {
                object.opts = [];
                for (var j = 0; j < message.opts.length; ++j)
                    object.opts[j] = $root.protos.opts.TunnelOptions.toObject(message.opts[j], options);
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this GetAllTunnelsResponse to JSON.
         * @function toJSON
         * @memberof protos.GetAllTunnelsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllTunnelsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllTunnelsResponse;
    })();

    protos.GetTunnelRequest = (function() {

        /**
         * Properties of a GetTunnelRequest.
         * @memberof protos
         * @interface IGetTunnelRequest
         * @property {protos.common.IAuth|null} [auth] GetTunnelRequest auth
         * @property {string|null} [tunnelId] GetTunnelRequest tunnelId
         */

        /**
         * Constructs a new GetTunnelRequest.
         * @memberof protos
         * @classdesc Represents a GetTunnelRequest.
         * @implements IGetTunnelRequest
         * @constructor
         * @param {protos.IGetTunnelRequest=} [properties] Properties to set
         */
        function GetTunnelRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTunnelRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetTunnelRequest
         * @instance
         */
        GetTunnelRequest.prototype.auth = null;

        /**
         * GetTunnelRequest tunnelId.
         * @member {string} tunnelId
         * @memberof protos.GetTunnelRequest
         * @instance
         */
        GetTunnelRequest.prototype.tunnelId = "";

        /**
         * Creates a new GetTunnelRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetTunnelRequest
         * @static
         * @param {protos.IGetTunnelRequest=} [properties] Properties to set
         * @returns {protos.GetTunnelRequest} GetTunnelRequest instance
         */
        GetTunnelRequest.create = function create(properties) {
            return new GetTunnelRequest(properties);
        };

        /**
         * Encodes the specified GetTunnelRequest message. Does not implicitly {@link protos.GetTunnelRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetTunnelRequest
         * @static
         * @param {protos.IGetTunnelRequest} message GetTunnelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTunnelRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tunnelId != null && Object.hasOwnProperty.call(message, "tunnelId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tunnelId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetTunnelRequest message, length delimited. Does not implicitly {@link protos.GetTunnelRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetTunnelRequest
         * @static
         * @param {protos.IGetTunnelRequest} message GetTunnelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTunnelRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTunnelRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetTunnelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetTunnelRequest} GetTunnelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTunnelRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetTunnelRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.tunnelId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTunnelRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetTunnelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetTunnelRequest} GetTunnelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTunnelRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTunnelRequest message.
         * @function verify
         * @memberof protos.GetTunnelRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTunnelRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.tunnelId != null && message.hasOwnProperty("tunnelId"))
                if (!$util.isString(message.tunnelId))
                    return "tunnelId: string expected";
            return null;
        };

        /**
         * Creates a GetTunnelRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetTunnelRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetTunnelRequest} GetTunnelRequest
         */
        GetTunnelRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetTunnelRequest)
                return object;
            var message = new $root.protos.GetTunnelRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetTunnelRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.tunnelId != null)
                message.tunnelId = String(object.tunnelId);
            return message;
        };

        /**
         * Creates a plain object from a GetTunnelRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetTunnelRequest
         * @static
         * @param {protos.GetTunnelRequest} message GetTunnelRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTunnelRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tunnelId = "";
                object.auth = null;
            }
            if (message.tunnelId != null && message.hasOwnProperty("tunnelId"))
                object.tunnelId = message.tunnelId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetTunnelRequest to JSON.
         * @function toJSON
         * @memberof protos.GetTunnelRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTunnelRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetTunnelRequest;
    })();

    protos.GetTunnelResponse = (function() {

        /**
         * Properties of a GetTunnelResponse.
         * @memberof protos
         * @interface IGetTunnelResponse
         * @property {protos.common.IStatus|null} [status] GetTunnelResponse status
         * @property {protos.opts.ITunnelOptions|null} [opts] GetTunnelResponse opts
         */

        /**
         * Constructs a new GetTunnelResponse.
         * @memberof protos
         * @classdesc Represents a GetTunnelResponse.
         * @implements IGetTunnelResponse
         * @constructor
         * @param {protos.IGetTunnelResponse=} [properties] Properties to set
         */
        function GetTunnelResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTunnelResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.GetTunnelResponse
         * @instance
         */
        GetTunnelResponse.prototype.status = null;

        /**
         * GetTunnelResponse opts.
         * @member {protos.opts.ITunnelOptions|null|undefined} opts
         * @memberof protos.GetTunnelResponse
         * @instance
         */
        GetTunnelResponse.prototype.opts = null;

        /**
         * Creates a new GetTunnelResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetTunnelResponse
         * @static
         * @param {protos.IGetTunnelResponse=} [properties] Properties to set
         * @returns {protos.GetTunnelResponse} GetTunnelResponse instance
         */
        GetTunnelResponse.create = function create(properties) {
            return new GetTunnelResponse(properties);
        };

        /**
         * Encodes the specified GetTunnelResponse message. Does not implicitly {@link protos.GetTunnelResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetTunnelResponse
         * @static
         * @param {protos.IGetTunnelResponse} message GetTunnelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTunnelResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.opts != null && Object.hasOwnProperty.call(message, "opts"))
                $root.protos.opts.TunnelOptions.encode(message.opts, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetTunnelResponse message, length delimited. Does not implicitly {@link protos.GetTunnelResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetTunnelResponse
         * @static
         * @param {protos.IGetTunnelResponse} message GetTunnelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTunnelResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTunnelResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetTunnelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetTunnelResponse} GetTunnelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTunnelResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetTunnelResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.opts = $root.protos.opts.TunnelOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTunnelResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetTunnelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetTunnelResponse} GetTunnelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTunnelResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTunnelResponse message.
         * @function verify
         * @memberof protos.GetTunnelResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTunnelResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.opts != null && message.hasOwnProperty("opts")) {
                var error = $root.protos.opts.TunnelOptions.verify(message.opts);
                if (error)
                    return "opts." + error;
            }
            return null;
        };

        /**
         * Creates a GetTunnelResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetTunnelResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetTunnelResponse} GetTunnelResponse
         */
        GetTunnelResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetTunnelResponse)
                return object;
            var message = new $root.protos.GetTunnelResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.GetTunnelResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.opts != null) {
                if (typeof object.opts !== "object")
                    throw TypeError(".protos.GetTunnelResponse.opts: object expected");
                message.opts = $root.protos.opts.TunnelOptions.fromObject(object.opts);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetTunnelResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetTunnelResponse
         * @static
         * @param {protos.GetTunnelResponse} message GetTunnelResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTunnelResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.opts = null;
                object.status = null;
            }
            if (message.opts != null && message.hasOwnProperty("opts"))
                object.opts = $root.protos.opts.TunnelOptions.toObject(message.opts, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this GetTunnelResponse to JSON.
         * @function toJSON
         * @memberof protos.GetTunnelResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTunnelResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetTunnelResponse;
    })();

    protos.CreateTunnelRequest = (function() {

        /**
         * Properties of a CreateTunnelRequest.
         * @memberof protos
         * @interface ICreateTunnelRequest
         * @property {protos.common.IAuth|null} [auth] CreateTunnelRequest auth
         * @property {protos.opts.ITunnelOptions|null} [opts] CreateTunnelRequest opts
         */

        /**
         * Constructs a new CreateTunnelRequest.
         * @memberof protos
         * @classdesc Represents a CreateTunnelRequest.
         * @implements ICreateTunnelRequest
         * @constructor
         * @param {protos.ICreateTunnelRequest=} [properties] Properties to set
         */
        function CreateTunnelRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateTunnelRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.CreateTunnelRequest
         * @instance
         */
        CreateTunnelRequest.prototype.auth = null;

        /**
         * CreateTunnelRequest opts.
         * @member {protos.opts.ITunnelOptions|null|undefined} opts
         * @memberof protos.CreateTunnelRequest
         * @instance
         */
        CreateTunnelRequest.prototype.opts = null;

        /**
         * Creates a new CreateTunnelRequest instance using the specified properties.
         * @function create
         * @memberof protos.CreateTunnelRequest
         * @static
         * @param {protos.ICreateTunnelRequest=} [properties] Properties to set
         * @returns {protos.CreateTunnelRequest} CreateTunnelRequest instance
         */
        CreateTunnelRequest.create = function create(properties) {
            return new CreateTunnelRequest(properties);
        };

        /**
         * Encodes the specified CreateTunnelRequest message. Does not implicitly {@link protos.CreateTunnelRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateTunnelRequest
         * @static
         * @param {protos.ICreateTunnelRequest} message CreateTunnelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateTunnelRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.opts != null && Object.hasOwnProperty.call(message, "opts"))
                $root.protos.opts.TunnelOptions.encode(message.opts, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateTunnelRequest message, length delimited. Does not implicitly {@link protos.CreateTunnelRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateTunnelRequest
         * @static
         * @param {protos.ICreateTunnelRequest} message CreateTunnelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateTunnelRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateTunnelRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateTunnelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateTunnelRequest} CreateTunnelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateTunnelRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateTunnelRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.opts = $root.protos.opts.TunnelOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateTunnelRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateTunnelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateTunnelRequest} CreateTunnelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateTunnelRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateTunnelRequest message.
         * @function verify
         * @memberof protos.CreateTunnelRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateTunnelRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.opts != null && message.hasOwnProperty("opts")) {
                var error = $root.protos.opts.TunnelOptions.verify(message.opts);
                if (error)
                    return "opts." + error;
            }
            return null;
        };

        /**
         * Creates a CreateTunnelRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateTunnelRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateTunnelRequest} CreateTunnelRequest
         */
        CreateTunnelRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateTunnelRequest)
                return object;
            var message = new $root.protos.CreateTunnelRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.CreateTunnelRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.opts != null) {
                if (typeof object.opts !== "object")
                    throw TypeError(".protos.CreateTunnelRequest.opts: object expected");
                message.opts = $root.protos.opts.TunnelOptions.fromObject(object.opts);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateTunnelRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateTunnelRequest
         * @static
         * @param {protos.CreateTunnelRequest} message CreateTunnelRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateTunnelRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.opts = null;
                object.auth = null;
            }
            if (message.opts != null && message.hasOwnProperty("opts"))
                object.opts = $root.protos.opts.TunnelOptions.toObject(message.opts, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this CreateTunnelRequest to JSON.
         * @function toJSON
         * @memberof protos.CreateTunnelRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateTunnelRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateTunnelRequest;
    })();

    protos.CreateTunnelResponse = (function() {

        /**
         * Properties of a CreateTunnelResponse.
         * @memberof protos
         * @interface ICreateTunnelResponse
         * @property {protos.common.IStatus|null} [status] CreateTunnelResponse status
         * @property {string|null} [tunnelId] CreateTunnelResponse tunnelId
         */

        /**
         * Constructs a new CreateTunnelResponse.
         * @memberof protos
         * @classdesc Represents a CreateTunnelResponse.
         * @implements ICreateTunnelResponse
         * @constructor
         * @param {protos.ICreateTunnelResponse=} [properties] Properties to set
         */
        function CreateTunnelResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateTunnelResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.CreateTunnelResponse
         * @instance
         */
        CreateTunnelResponse.prototype.status = null;

        /**
         * CreateTunnelResponse tunnelId.
         * @member {string} tunnelId
         * @memberof protos.CreateTunnelResponse
         * @instance
         */
        CreateTunnelResponse.prototype.tunnelId = "";

        /**
         * Creates a new CreateTunnelResponse instance using the specified properties.
         * @function create
         * @memberof protos.CreateTunnelResponse
         * @static
         * @param {protos.ICreateTunnelResponse=} [properties] Properties to set
         * @returns {protos.CreateTunnelResponse} CreateTunnelResponse instance
         */
        CreateTunnelResponse.create = function create(properties) {
            return new CreateTunnelResponse(properties);
        };

        /**
         * Encodes the specified CreateTunnelResponse message. Does not implicitly {@link protos.CreateTunnelResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateTunnelResponse
         * @static
         * @param {protos.ICreateTunnelResponse} message CreateTunnelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateTunnelResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tunnelId != null && Object.hasOwnProperty.call(message, "tunnelId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tunnelId);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateTunnelResponse message, length delimited. Does not implicitly {@link protos.CreateTunnelResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateTunnelResponse
         * @static
         * @param {protos.ICreateTunnelResponse} message CreateTunnelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateTunnelResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateTunnelResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateTunnelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateTunnelResponse} CreateTunnelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateTunnelResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateTunnelResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.tunnelId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateTunnelResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateTunnelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateTunnelResponse} CreateTunnelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateTunnelResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateTunnelResponse message.
         * @function verify
         * @memberof protos.CreateTunnelResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateTunnelResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.tunnelId != null && message.hasOwnProperty("tunnelId"))
                if (!$util.isString(message.tunnelId))
                    return "tunnelId: string expected";
            return null;
        };

        /**
         * Creates a CreateTunnelResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateTunnelResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateTunnelResponse} CreateTunnelResponse
         */
        CreateTunnelResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateTunnelResponse)
                return object;
            var message = new $root.protos.CreateTunnelResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.CreateTunnelResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.tunnelId != null)
                message.tunnelId = String(object.tunnelId);
            return message;
        };

        /**
         * Creates a plain object from a CreateTunnelResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateTunnelResponse
         * @static
         * @param {protos.CreateTunnelResponse} message CreateTunnelResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateTunnelResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tunnelId = "";
                object.status = null;
            }
            if (message.tunnelId != null && message.hasOwnProperty("tunnelId"))
                object.tunnelId = message.tunnelId;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this CreateTunnelResponse to JSON.
         * @function toJSON
         * @memberof protos.CreateTunnelResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateTunnelResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateTunnelResponse;
    })();

    protos.UpdateTunnelRequest = (function() {

        /**
         * Properties of an UpdateTunnelRequest.
         * @memberof protos
         * @interface IUpdateTunnelRequest
         * @property {protos.common.IAuth|null} [auth] UpdateTunnelRequest auth
         * @property {string|null} [tunnelId] UpdateTunnelRequest tunnelId
         * @property {protos.opts.ITunnelOptions|null} [opts] UpdateTunnelRequest opts
         */

        /**
         * Constructs a new UpdateTunnelRequest.
         * @memberof protos
         * @classdesc Represents an UpdateTunnelRequest.
         * @implements IUpdateTunnelRequest
         * @constructor
         * @param {protos.IUpdateTunnelRequest=} [properties] Properties to set
         */
        function UpdateTunnelRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateTunnelRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.UpdateTunnelRequest
         * @instance
         */
        UpdateTunnelRequest.prototype.auth = null;

        /**
         * UpdateTunnelRequest tunnelId.
         * @member {string} tunnelId
         * @memberof protos.UpdateTunnelRequest
         * @instance
         */
        UpdateTunnelRequest.prototype.tunnelId = "";

        /**
         * UpdateTunnelRequest opts.
         * @member {protos.opts.ITunnelOptions|null|undefined} opts
         * @memberof protos.UpdateTunnelRequest
         * @instance
         */
        UpdateTunnelRequest.prototype.opts = null;

        /**
         * Creates a new UpdateTunnelRequest instance using the specified properties.
         * @function create
         * @memberof protos.UpdateTunnelRequest
         * @static
         * @param {protos.IUpdateTunnelRequest=} [properties] Properties to set
         * @returns {protos.UpdateTunnelRequest} UpdateTunnelRequest instance
         */
        UpdateTunnelRequest.create = function create(properties) {
            return new UpdateTunnelRequest(properties);
        };

        /**
         * Encodes the specified UpdateTunnelRequest message. Does not implicitly {@link protos.UpdateTunnelRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateTunnelRequest
         * @static
         * @param {protos.IUpdateTunnelRequest} message UpdateTunnelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateTunnelRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tunnelId != null && Object.hasOwnProperty.call(message, "tunnelId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tunnelId);
            if (message.opts != null && Object.hasOwnProperty.call(message, "opts"))
                $root.protos.opts.TunnelOptions.encode(message.opts, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateTunnelRequest message, length delimited. Does not implicitly {@link protos.UpdateTunnelRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateTunnelRequest
         * @static
         * @param {protos.IUpdateTunnelRequest} message UpdateTunnelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateTunnelRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateTunnelRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateTunnelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateTunnelRequest} UpdateTunnelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateTunnelRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateTunnelRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.tunnelId = reader.string();
                    break;
                case 2:
                    message.opts = $root.protos.opts.TunnelOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateTunnelRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateTunnelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateTunnelRequest} UpdateTunnelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateTunnelRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateTunnelRequest message.
         * @function verify
         * @memberof protos.UpdateTunnelRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateTunnelRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.tunnelId != null && message.hasOwnProperty("tunnelId"))
                if (!$util.isString(message.tunnelId))
                    return "tunnelId: string expected";
            if (message.opts != null && message.hasOwnProperty("opts")) {
                var error = $root.protos.opts.TunnelOptions.verify(message.opts);
                if (error)
                    return "opts." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateTunnelRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateTunnelRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateTunnelRequest} UpdateTunnelRequest
         */
        UpdateTunnelRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateTunnelRequest)
                return object;
            var message = new $root.protos.UpdateTunnelRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.UpdateTunnelRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.tunnelId != null)
                message.tunnelId = String(object.tunnelId);
            if (object.opts != null) {
                if (typeof object.opts !== "object")
                    throw TypeError(".protos.UpdateTunnelRequest.opts: object expected");
                message.opts = $root.protos.opts.TunnelOptions.fromObject(object.opts);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateTunnelRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateTunnelRequest
         * @static
         * @param {protos.UpdateTunnelRequest} message UpdateTunnelRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateTunnelRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tunnelId = "";
                object.opts = null;
                object.auth = null;
            }
            if (message.tunnelId != null && message.hasOwnProperty("tunnelId"))
                object.tunnelId = message.tunnelId;
            if (message.opts != null && message.hasOwnProperty("opts"))
                object.opts = $root.protos.opts.TunnelOptions.toObject(message.opts, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this UpdateTunnelRequest to JSON.
         * @function toJSON
         * @memberof protos.UpdateTunnelRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateTunnelRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateTunnelRequest;
    })();

    protos.UpdateTunnelResponse = (function() {

        /**
         * Properties of an UpdateTunnelResponse.
         * @memberof protos
         * @interface IUpdateTunnelResponse
         * @property {protos.common.IStatus|null} [status] UpdateTunnelResponse status
         */

        /**
         * Constructs a new UpdateTunnelResponse.
         * @memberof protos
         * @classdesc Represents an UpdateTunnelResponse.
         * @implements IUpdateTunnelResponse
         * @constructor
         * @param {protos.IUpdateTunnelResponse=} [properties] Properties to set
         */
        function UpdateTunnelResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateTunnelResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.UpdateTunnelResponse
         * @instance
         */
        UpdateTunnelResponse.prototype.status = null;

        /**
         * Creates a new UpdateTunnelResponse instance using the specified properties.
         * @function create
         * @memberof protos.UpdateTunnelResponse
         * @static
         * @param {protos.IUpdateTunnelResponse=} [properties] Properties to set
         * @returns {protos.UpdateTunnelResponse} UpdateTunnelResponse instance
         */
        UpdateTunnelResponse.create = function create(properties) {
            return new UpdateTunnelResponse(properties);
        };

        /**
         * Encodes the specified UpdateTunnelResponse message. Does not implicitly {@link protos.UpdateTunnelResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateTunnelResponse
         * @static
         * @param {protos.IUpdateTunnelResponse} message UpdateTunnelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateTunnelResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateTunnelResponse message, length delimited. Does not implicitly {@link protos.UpdateTunnelResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateTunnelResponse
         * @static
         * @param {protos.IUpdateTunnelResponse} message UpdateTunnelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateTunnelResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateTunnelResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateTunnelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateTunnelResponse} UpdateTunnelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateTunnelResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateTunnelResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateTunnelResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateTunnelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateTunnelResponse} UpdateTunnelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateTunnelResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateTunnelResponse message.
         * @function verify
         * @memberof protos.UpdateTunnelResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateTunnelResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateTunnelResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateTunnelResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateTunnelResponse} UpdateTunnelResponse
         */
        UpdateTunnelResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateTunnelResponse)
                return object;
            var message = new $root.protos.UpdateTunnelResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.UpdateTunnelResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateTunnelResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateTunnelResponse
         * @static
         * @param {protos.UpdateTunnelResponse} message UpdateTunnelResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateTunnelResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this UpdateTunnelResponse to JSON.
         * @function toJSON
         * @memberof protos.UpdateTunnelResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateTunnelResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateTunnelResponse;
    })();

    protos.ResumeTunnelRequest = (function() {

        /**
         * Properties of a ResumeTunnelRequest.
         * @memberof protos
         * @interface IResumeTunnelRequest
         * @property {protos.common.IAuth|null} [auth] ResumeTunnelRequest auth
         * @property {string|null} [tunnelId] ResumeTunnelRequest tunnelId
         */

        /**
         * Constructs a new ResumeTunnelRequest.
         * @memberof protos
         * @classdesc Represents a ResumeTunnelRequest.
         * @implements IResumeTunnelRequest
         * @constructor
         * @param {protos.IResumeTunnelRequest=} [properties] Properties to set
         */
        function ResumeTunnelRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResumeTunnelRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.ResumeTunnelRequest
         * @instance
         */
        ResumeTunnelRequest.prototype.auth = null;

        /**
         * ResumeTunnelRequest tunnelId.
         * @member {string} tunnelId
         * @memberof protos.ResumeTunnelRequest
         * @instance
         */
        ResumeTunnelRequest.prototype.tunnelId = "";

        /**
         * Creates a new ResumeTunnelRequest instance using the specified properties.
         * @function create
         * @memberof protos.ResumeTunnelRequest
         * @static
         * @param {protos.IResumeTunnelRequest=} [properties] Properties to set
         * @returns {protos.ResumeTunnelRequest} ResumeTunnelRequest instance
         */
        ResumeTunnelRequest.create = function create(properties) {
            return new ResumeTunnelRequest(properties);
        };

        /**
         * Encodes the specified ResumeTunnelRequest message. Does not implicitly {@link protos.ResumeTunnelRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.ResumeTunnelRequest
         * @static
         * @param {protos.IResumeTunnelRequest} message ResumeTunnelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeTunnelRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tunnelId != null && Object.hasOwnProperty.call(message, "tunnelId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tunnelId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResumeTunnelRequest message, length delimited. Does not implicitly {@link protos.ResumeTunnelRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ResumeTunnelRequest
         * @static
         * @param {protos.IResumeTunnelRequest} message ResumeTunnelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeTunnelRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResumeTunnelRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ResumeTunnelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ResumeTunnelRequest} ResumeTunnelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeTunnelRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ResumeTunnelRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.tunnelId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResumeTunnelRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ResumeTunnelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ResumeTunnelRequest} ResumeTunnelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeTunnelRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResumeTunnelRequest message.
         * @function verify
         * @memberof protos.ResumeTunnelRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResumeTunnelRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.tunnelId != null && message.hasOwnProperty("tunnelId"))
                if (!$util.isString(message.tunnelId))
                    return "tunnelId: string expected";
            return null;
        };

        /**
         * Creates a ResumeTunnelRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ResumeTunnelRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ResumeTunnelRequest} ResumeTunnelRequest
         */
        ResumeTunnelRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ResumeTunnelRequest)
                return object;
            var message = new $root.protos.ResumeTunnelRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.ResumeTunnelRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.tunnelId != null)
                message.tunnelId = String(object.tunnelId);
            return message;
        };

        /**
         * Creates a plain object from a ResumeTunnelRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ResumeTunnelRequest
         * @static
         * @param {protos.ResumeTunnelRequest} message ResumeTunnelRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResumeTunnelRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tunnelId = "";
                object.auth = null;
            }
            if (message.tunnelId != null && message.hasOwnProperty("tunnelId"))
                object.tunnelId = message.tunnelId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this ResumeTunnelRequest to JSON.
         * @function toJSON
         * @memberof protos.ResumeTunnelRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResumeTunnelRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResumeTunnelRequest;
    })();

    protos.ResumeTunnelResponse = (function() {

        /**
         * Properties of a ResumeTunnelResponse.
         * @memberof protos
         * @interface IResumeTunnelResponse
         * @property {protos.common.IStatus|null} [status] ResumeTunnelResponse status
         */

        /**
         * Constructs a new ResumeTunnelResponse.
         * @memberof protos
         * @classdesc Represents a ResumeTunnelResponse.
         * @implements IResumeTunnelResponse
         * @constructor
         * @param {protos.IResumeTunnelResponse=} [properties] Properties to set
         */
        function ResumeTunnelResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResumeTunnelResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.ResumeTunnelResponse
         * @instance
         */
        ResumeTunnelResponse.prototype.status = null;

        /**
         * Creates a new ResumeTunnelResponse instance using the specified properties.
         * @function create
         * @memberof protos.ResumeTunnelResponse
         * @static
         * @param {protos.IResumeTunnelResponse=} [properties] Properties to set
         * @returns {protos.ResumeTunnelResponse} ResumeTunnelResponse instance
         */
        ResumeTunnelResponse.create = function create(properties) {
            return new ResumeTunnelResponse(properties);
        };

        /**
         * Encodes the specified ResumeTunnelResponse message. Does not implicitly {@link protos.ResumeTunnelResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.ResumeTunnelResponse
         * @static
         * @param {protos.IResumeTunnelResponse} message ResumeTunnelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeTunnelResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResumeTunnelResponse message, length delimited. Does not implicitly {@link protos.ResumeTunnelResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ResumeTunnelResponse
         * @static
         * @param {protos.IResumeTunnelResponse} message ResumeTunnelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeTunnelResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResumeTunnelResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ResumeTunnelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ResumeTunnelResponse} ResumeTunnelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeTunnelResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ResumeTunnelResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResumeTunnelResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ResumeTunnelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ResumeTunnelResponse} ResumeTunnelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeTunnelResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResumeTunnelResponse message.
         * @function verify
         * @memberof protos.ResumeTunnelResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResumeTunnelResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a ResumeTunnelResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ResumeTunnelResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ResumeTunnelResponse} ResumeTunnelResponse
         */
        ResumeTunnelResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ResumeTunnelResponse)
                return object;
            var message = new $root.protos.ResumeTunnelResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.ResumeTunnelResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a ResumeTunnelResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ResumeTunnelResponse
         * @static
         * @param {protos.ResumeTunnelResponse} message ResumeTunnelResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResumeTunnelResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this ResumeTunnelResponse to JSON.
         * @function toJSON
         * @memberof protos.ResumeTunnelResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResumeTunnelResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResumeTunnelResponse;
    })();

    protos.StopTunnelRequest = (function() {

        /**
         * Properties of a StopTunnelRequest.
         * @memberof protos
         * @interface IStopTunnelRequest
         * @property {protos.common.IAuth|null} [auth] StopTunnelRequest auth
         * @property {string|null} [tunnelId] StopTunnelRequest tunnelId
         */

        /**
         * Constructs a new StopTunnelRequest.
         * @memberof protos
         * @classdesc Represents a StopTunnelRequest.
         * @implements IStopTunnelRequest
         * @constructor
         * @param {protos.IStopTunnelRequest=} [properties] Properties to set
         */
        function StopTunnelRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StopTunnelRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.StopTunnelRequest
         * @instance
         */
        StopTunnelRequest.prototype.auth = null;

        /**
         * StopTunnelRequest tunnelId.
         * @member {string} tunnelId
         * @memberof protos.StopTunnelRequest
         * @instance
         */
        StopTunnelRequest.prototype.tunnelId = "";

        /**
         * Creates a new StopTunnelRequest instance using the specified properties.
         * @function create
         * @memberof protos.StopTunnelRequest
         * @static
         * @param {protos.IStopTunnelRequest=} [properties] Properties to set
         * @returns {protos.StopTunnelRequest} StopTunnelRequest instance
         */
        StopTunnelRequest.create = function create(properties) {
            return new StopTunnelRequest(properties);
        };

        /**
         * Encodes the specified StopTunnelRequest message. Does not implicitly {@link protos.StopTunnelRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.StopTunnelRequest
         * @static
         * @param {protos.IStopTunnelRequest} message StopTunnelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopTunnelRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tunnelId != null && Object.hasOwnProperty.call(message, "tunnelId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tunnelId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StopTunnelRequest message, length delimited. Does not implicitly {@link protos.StopTunnelRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.StopTunnelRequest
         * @static
         * @param {protos.IStopTunnelRequest} message StopTunnelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopTunnelRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopTunnelRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.StopTunnelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.StopTunnelRequest} StopTunnelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopTunnelRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.StopTunnelRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.tunnelId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopTunnelRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.StopTunnelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.StopTunnelRequest} StopTunnelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopTunnelRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopTunnelRequest message.
         * @function verify
         * @memberof protos.StopTunnelRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopTunnelRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.tunnelId != null && message.hasOwnProperty("tunnelId"))
                if (!$util.isString(message.tunnelId))
                    return "tunnelId: string expected";
            return null;
        };

        /**
         * Creates a StopTunnelRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.StopTunnelRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.StopTunnelRequest} StopTunnelRequest
         */
        StopTunnelRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.StopTunnelRequest)
                return object;
            var message = new $root.protos.StopTunnelRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.StopTunnelRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.tunnelId != null)
                message.tunnelId = String(object.tunnelId);
            return message;
        };

        /**
         * Creates a plain object from a StopTunnelRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.StopTunnelRequest
         * @static
         * @param {protos.StopTunnelRequest} message StopTunnelRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopTunnelRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tunnelId = "";
                object.auth = null;
            }
            if (message.tunnelId != null && message.hasOwnProperty("tunnelId"))
                object.tunnelId = message.tunnelId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this StopTunnelRequest to JSON.
         * @function toJSON
         * @memberof protos.StopTunnelRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopTunnelRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopTunnelRequest;
    })();

    protos.StopTunnelResponse = (function() {

        /**
         * Properties of a StopTunnelResponse.
         * @memberof protos
         * @interface IStopTunnelResponse
         * @property {protos.common.IStatus|null} [status] StopTunnelResponse status
         */

        /**
         * Constructs a new StopTunnelResponse.
         * @memberof protos
         * @classdesc Represents a StopTunnelResponse.
         * @implements IStopTunnelResponse
         * @constructor
         * @param {protos.IStopTunnelResponse=} [properties] Properties to set
         */
        function StopTunnelResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StopTunnelResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.StopTunnelResponse
         * @instance
         */
        StopTunnelResponse.prototype.status = null;

        /**
         * Creates a new StopTunnelResponse instance using the specified properties.
         * @function create
         * @memberof protos.StopTunnelResponse
         * @static
         * @param {protos.IStopTunnelResponse=} [properties] Properties to set
         * @returns {protos.StopTunnelResponse} StopTunnelResponse instance
         */
        StopTunnelResponse.create = function create(properties) {
            return new StopTunnelResponse(properties);
        };

        /**
         * Encodes the specified StopTunnelResponse message. Does not implicitly {@link protos.StopTunnelResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.StopTunnelResponse
         * @static
         * @param {protos.IStopTunnelResponse} message StopTunnelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopTunnelResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StopTunnelResponse message, length delimited. Does not implicitly {@link protos.StopTunnelResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.StopTunnelResponse
         * @static
         * @param {protos.IStopTunnelResponse} message StopTunnelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopTunnelResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopTunnelResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.StopTunnelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.StopTunnelResponse} StopTunnelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopTunnelResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.StopTunnelResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopTunnelResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.StopTunnelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.StopTunnelResponse} StopTunnelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopTunnelResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopTunnelResponse message.
         * @function verify
         * @memberof protos.StopTunnelResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopTunnelResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a StopTunnelResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.StopTunnelResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.StopTunnelResponse} StopTunnelResponse
         */
        StopTunnelResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.StopTunnelResponse)
                return object;
            var message = new $root.protos.StopTunnelResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.StopTunnelResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a StopTunnelResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.StopTunnelResponse
         * @static
         * @param {protos.StopTunnelResponse} message StopTunnelResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopTunnelResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this StopTunnelResponse to JSON.
         * @function toJSON
         * @memberof protos.StopTunnelResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopTunnelResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopTunnelResponse;
    })();

    protos.DeleteTunnelRequest = (function() {

        /**
         * Properties of a DeleteTunnelRequest.
         * @memberof protos
         * @interface IDeleteTunnelRequest
         * @property {protos.common.IAuth|null} [auth] DeleteTunnelRequest auth
         * @property {string|null} [tunnelId] DeleteTunnelRequest tunnelId
         */

        /**
         * Constructs a new DeleteTunnelRequest.
         * @memberof protos
         * @classdesc Represents a DeleteTunnelRequest.
         * @implements IDeleteTunnelRequest
         * @constructor
         * @param {protos.IDeleteTunnelRequest=} [properties] Properties to set
         */
        function DeleteTunnelRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteTunnelRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.DeleteTunnelRequest
         * @instance
         */
        DeleteTunnelRequest.prototype.auth = null;

        /**
         * DeleteTunnelRequest tunnelId.
         * @member {string} tunnelId
         * @memberof protos.DeleteTunnelRequest
         * @instance
         */
        DeleteTunnelRequest.prototype.tunnelId = "";

        /**
         * Creates a new DeleteTunnelRequest instance using the specified properties.
         * @function create
         * @memberof protos.DeleteTunnelRequest
         * @static
         * @param {protos.IDeleteTunnelRequest=} [properties] Properties to set
         * @returns {protos.DeleteTunnelRequest} DeleteTunnelRequest instance
         */
        DeleteTunnelRequest.create = function create(properties) {
            return new DeleteTunnelRequest(properties);
        };

        /**
         * Encodes the specified DeleteTunnelRequest message. Does not implicitly {@link protos.DeleteTunnelRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteTunnelRequest
         * @static
         * @param {protos.IDeleteTunnelRequest} message DeleteTunnelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteTunnelRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tunnelId != null && Object.hasOwnProperty.call(message, "tunnelId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tunnelId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteTunnelRequest message, length delimited. Does not implicitly {@link protos.DeleteTunnelRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteTunnelRequest
         * @static
         * @param {protos.IDeleteTunnelRequest} message DeleteTunnelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteTunnelRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteTunnelRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteTunnelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteTunnelRequest} DeleteTunnelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteTunnelRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteTunnelRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.tunnelId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteTunnelRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteTunnelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteTunnelRequest} DeleteTunnelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteTunnelRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteTunnelRequest message.
         * @function verify
         * @memberof protos.DeleteTunnelRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteTunnelRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.tunnelId != null && message.hasOwnProperty("tunnelId"))
                if (!$util.isString(message.tunnelId))
                    return "tunnelId: string expected";
            return null;
        };

        /**
         * Creates a DeleteTunnelRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteTunnelRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteTunnelRequest} DeleteTunnelRequest
         */
        DeleteTunnelRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteTunnelRequest)
                return object;
            var message = new $root.protos.DeleteTunnelRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.DeleteTunnelRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.tunnelId != null)
                message.tunnelId = String(object.tunnelId);
            return message;
        };

        /**
         * Creates a plain object from a DeleteTunnelRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteTunnelRequest
         * @static
         * @param {protos.DeleteTunnelRequest} message DeleteTunnelRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteTunnelRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tunnelId = "";
                object.auth = null;
            }
            if (message.tunnelId != null && message.hasOwnProperty("tunnelId"))
                object.tunnelId = message.tunnelId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this DeleteTunnelRequest to JSON.
         * @function toJSON
         * @memberof protos.DeleteTunnelRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteTunnelRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteTunnelRequest;
    })();

    protos.DeleteTunnelResponse = (function() {

        /**
         * Properties of a DeleteTunnelResponse.
         * @memberof protos
         * @interface IDeleteTunnelResponse
         * @property {protos.common.IStatus|null} [status] DeleteTunnelResponse status
         */

        /**
         * Constructs a new DeleteTunnelResponse.
         * @memberof protos
         * @classdesc Represents a DeleteTunnelResponse.
         * @implements IDeleteTunnelResponse
         * @constructor
         * @param {protos.IDeleteTunnelResponse=} [properties] Properties to set
         */
        function DeleteTunnelResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteTunnelResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.DeleteTunnelResponse
         * @instance
         */
        DeleteTunnelResponse.prototype.status = null;

        /**
         * Creates a new DeleteTunnelResponse instance using the specified properties.
         * @function create
         * @memberof protos.DeleteTunnelResponse
         * @static
         * @param {protos.IDeleteTunnelResponse=} [properties] Properties to set
         * @returns {protos.DeleteTunnelResponse} DeleteTunnelResponse instance
         */
        DeleteTunnelResponse.create = function create(properties) {
            return new DeleteTunnelResponse(properties);
        };

        /**
         * Encodes the specified DeleteTunnelResponse message. Does not implicitly {@link protos.DeleteTunnelResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteTunnelResponse
         * @static
         * @param {protos.IDeleteTunnelResponse} message DeleteTunnelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteTunnelResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteTunnelResponse message, length delimited. Does not implicitly {@link protos.DeleteTunnelResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteTunnelResponse
         * @static
         * @param {protos.IDeleteTunnelResponse} message DeleteTunnelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteTunnelResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteTunnelResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteTunnelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteTunnelResponse} DeleteTunnelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteTunnelResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteTunnelResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteTunnelResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteTunnelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteTunnelResponse} DeleteTunnelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteTunnelResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteTunnelResponse message.
         * @function verify
         * @memberof protos.DeleteTunnelResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteTunnelResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a DeleteTunnelResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteTunnelResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteTunnelResponse} DeleteTunnelResponse
         */
        DeleteTunnelResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteTunnelResponse)
                return object;
            var message = new $root.protos.DeleteTunnelResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.DeleteTunnelResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a DeleteTunnelResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteTunnelResponse
         * @static
         * @param {protos.DeleteTunnelResponse} message DeleteTunnelResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteTunnelResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this DeleteTunnelResponse to JSON.
         * @function toJSON
         * @memberof protos.DeleteTunnelResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteTunnelResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteTunnelResponse;
    })();

    protos.ForemanClient = (function() {

        /**
         * Constructs a new ForemanClient service.
         * @memberof protos
         * @classdesc Represents a ForemanClient
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function ForemanClient(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (ForemanClient.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ForemanClient;

        /**
         * Creates new ForemanClient service using the specified rpc implementation.
         * @function create
         * @memberof protos.ForemanClient
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {ForemanClient} RPC service. Useful where requests and/or responses are streamed.
         */
        ForemanClient.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link protos.ForemanClient#register}.
         * @memberof protos.ForemanClient
         * @typedef RegisterCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.RegisterResponse} [response] RegisterResponse
         */

        /**
         * Calls Register.
         * @function register
         * @memberof protos.ForemanClient
         * @instance
         * @param {protos.IRegisterRequest} request RegisterRequest message or plain object
         * @param {protos.ForemanClient.RegisterCallback} callback Node-style callback called with the error, if any, and RegisterResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanClient.prototype.register = function register(request, callback) {
            return this.rpcCall(register, $root.protos.RegisterRequest, $root.protos.RegisterResponse, request, callback);
        }, "name", { value: "Register" });

        /**
         * Calls Register.
         * @function register
         * @memberof protos.ForemanClient
         * @instance
         * @param {protos.IRegisterRequest} request RegisterRequest message or plain object
         * @returns {Promise<protos.RegisterResponse>} Promise
         * @variation 2
         */

        return ForemanClient;
    })();

    protos.RegisterRequest = (function() {

        /**
         * Properties of a RegisterRequest.
         * @memberof protos
         * @interface IRegisterRequest
         * @property {string|null} [apiToken] RegisterRequest apiToken
         * @property {string|null} [clusterId] RegisterRequest clusterId
         * @property {string|null} [plumberToken] RegisterRequest plumberToken
         * @property {string|null} [nodeId] RegisterRequest nodeId
         */

        /**
         * Constructs a new RegisterRequest.
         * @memberof protos
         * @classdesc Represents a RegisterRequest.
         * @implements IRegisterRequest
         * @constructor
         * @param {protos.IRegisterRequest=} [properties] Properties to set
         */
        function RegisterRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterRequest apiToken.
         * @member {string} apiToken
         * @memberof protos.RegisterRequest
         * @instance
         */
        RegisterRequest.prototype.apiToken = "";

        /**
         * RegisterRequest clusterId.
         * @member {string} clusterId
         * @memberof protos.RegisterRequest
         * @instance
         */
        RegisterRequest.prototype.clusterId = "";

        /**
         * RegisterRequest plumberToken.
         * @member {string} plumberToken
         * @memberof protos.RegisterRequest
         * @instance
         */
        RegisterRequest.prototype.plumberToken = "";

        /**
         * RegisterRequest nodeId.
         * @member {string} nodeId
         * @memberof protos.RegisterRequest
         * @instance
         */
        RegisterRequest.prototype.nodeId = "";

        /**
         * Creates a new RegisterRequest instance using the specified properties.
         * @function create
         * @memberof protos.RegisterRequest
         * @static
         * @param {protos.IRegisterRequest=} [properties] Properties to set
         * @returns {protos.RegisterRequest} RegisterRequest instance
         */
        RegisterRequest.create = function create(properties) {
            return new RegisterRequest(properties);
        };

        /**
         * Encodes the specified RegisterRequest message. Does not implicitly {@link protos.RegisterRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.RegisterRequest
         * @static
         * @param {protos.IRegisterRequest} message RegisterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.apiToken != null && Object.hasOwnProperty.call(message, "apiToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.apiToken);
            if (message.clusterId != null && Object.hasOwnProperty.call(message, "clusterId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.clusterId);
            if (message.plumberToken != null && Object.hasOwnProperty.call(message, "plumberToken"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.plumberToken);
            if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.nodeId);
            return writer;
        };

        /**
         * Encodes the specified RegisterRequest message, length delimited. Does not implicitly {@link protos.RegisterRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.RegisterRequest
         * @static
         * @param {protos.IRegisterRequest} message RegisterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.RegisterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.RegisterRequest} RegisterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.RegisterRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.apiToken = reader.string();
                    break;
                case 2:
                    message.clusterId = reader.string();
                    break;
                case 3:
                    message.plumberToken = reader.string();
                    break;
                case 4:
                    message.nodeId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.RegisterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.RegisterRequest} RegisterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterRequest message.
         * @function verify
         * @memberof protos.RegisterRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.apiToken != null && message.hasOwnProperty("apiToken"))
                if (!$util.isString(message.apiToken))
                    return "apiToken: string expected";
            if (message.clusterId != null && message.hasOwnProperty("clusterId"))
                if (!$util.isString(message.clusterId))
                    return "clusterId: string expected";
            if (message.plumberToken != null && message.hasOwnProperty("plumberToken"))
                if (!$util.isString(message.plumberToken))
                    return "plumberToken: string expected";
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                if (!$util.isString(message.nodeId))
                    return "nodeId: string expected";
            return null;
        };

        /**
         * Creates a RegisterRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.RegisterRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.RegisterRequest} RegisterRequest
         */
        RegisterRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.RegisterRequest)
                return object;
            var message = new $root.protos.RegisterRequest();
            if (object.apiToken != null)
                message.apiToken = String(object.apiToken);
            if (object.clusterId != null)
                message.clusterId = String(object.clusterId);
            if (object.plumberToken != null)
                message.plumberToken = String(object.plumberToken);
            if (object.nodeId != null)
                message.nodeId = String(object.nodeId);
            return message;
        };

        /**
         * Creates a plain object from a RegisterRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.RegisterRequest
         * @static
         * @param {protos.RegisterRequest} message RegisterRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.apiToken = "";
                object.clusterId = "";
                object.plumberToken = "";
                object.nodeId = "";
            }
            if (message.apiToken != null && message.hasOwnProperty("apiToken"))
                object.apiToken = message.apiToken;
            if (message.clusterId != null && message.hasOwnProperty("clusterId"))
                object.clusterId = message.clusterId;
            if (message.plumberToken != null && message.hasOwnProperty("plumberToken"))
                object.plumberToken = message.plumberToken;
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                object.nodeId = message.nodeId;
            return object;
        };

        /**
         * Converts this RegisterRequest to JSON.
         * @function toJSON
         * @memberof protos.RegisterRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterRequest;
    })();

    protos.RegisterResponse = (function() {

        /**
         * Properties of a RegisterResponse.
         * @memberof protos
         * @interface IRegisterResponse
         * @property {boolean|null} [success] RegisterResponse success
         * @property {string|null} [message] RegisterResponse message
         */

        /**
         * Constructs a new RegisterResponse.
         * @memberof protos
         * @classdesc Represents a RegisterResponse.
         * @implements IRegisterResponse
         * @constructor
         * @param {protos.IRegisterResponse=} [properties] Properties to set
         */
        function RegisterResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterResponse success.
         * @member {boolean} success
         * @memberof protos.RegisterResponse
         * @instance
         */
        RegisterResponse.prototype.success = false;

        /**
         * RegisterResponse message.
         * @member {string} message
         * @memberof protos.RegisterResponse
         * @instance
         */
        RegisterResponse.prototype.message = "";

        /**
         * Creates a new RegisterResponse instance using the specified properties.
         * @function create
         * @memberof protos.RegisterResponse
         * @static
         * @param {protos.IRegisterResponse=} [properties] Properties to set
         * @returns {protos.RegisterResponse} RegisterResponse instance
         */
        RegisterResponse.create = function create(properties) {
            return new RegisterResponse(properties);
        };

        /**
         * Encodes the specified RegisterResponse message. Does not implicitly {@link protos.RegisterResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.RegisterResponse
         * @static
         * @param {protos.IRegisterResponse} message RegisterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.success != null && Object.hasOwnProperty.call(message, "success"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.success);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            return writer;
        };

        /**
         * Encodes the specified RegisterResponse message, length delimited. Does not implicitly {@link protos.RegisterResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.RegisterResponse
         * @static
         * @param {protos.IRegisterResponse} message RegisterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.RegisterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.RegisterResponse} RegisterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.RegisterResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.success = reader.bool();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.RegisterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.RegisterResponse} RegisterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterResponse message.
         * @function verify
         * @memberof protos.RegisterResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.success != null && message.hasOwnProperty("success"))
                if (typeof message.success !== "boolean")
                    return "success: boolean expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };

        /**
         * Creates a RegisterResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.RegisterResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.RegisterResponse} RegisterResponse
         */
        RegisterResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.RegisterResponse)
                return object;
            var message = new $root.protos.RegisterResponse();
            if (object.success != null)
                message.success = Boolean(object.success);
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };

        /**
         * Creates a plain object from a RegisterResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.RegisterResponse
         * @static
         * @param {protos.RegisterResponse} message RegisterResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.success = false;
                object.message = "";
            }
            if (message.success != null && message.hasOwnProperty("success"))
                object.success = message.success;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };

        /**
         * Converts this RegisterResponse to JSON.
         * @function toJSON
         * @memberof protos.RegisterResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterResponse;
    })();

    protos.ForemanServer = (function() {

        /**
         * Constructs a new ForemanServer service.
         * @memberof protos
         * @classdesc Represents a ForemanServer
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function ForemanServer(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (ForemanServer.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ForemanServer;

        /**
         * Creates new ForemanServer service using the specified rpc implementation.
         * @function create
         * @memberof protos.ForemanServer
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {ForemanServer} RPC service. Useful where requests and/or responses are streamed.
         */
        ForemanServer.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link protos.ForemanServer#listPlumbers}.
         * @memberof protos.ForemanServer
         * @typedef ListPlumbersCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.ListPlumbersResponse} [response] ListPlumbersResponse
         */

        /**
         * Calls ListPlumbers.
         * @function listPlumbers
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IListPlumbersRequest} request ListPlumbersRequest message or plain object
         * @param {protos.ForemanServer.ListPlumbersCallback} callback Node-style callback called with the error, if any, and ListPlumbersResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.listPlumbers = function listPlumbers(request, callback) {
            return this.rpcCall(listPlumbers, $root.protos.ListPlumbersRequest, $root.protos.ListPlumbersResponse, request, callback);
        }, "name", { value: "ListPlumbers" });

        /**
         * Calls ListPlumbers.
         * @function listPlumbers
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IListPlumbersRequest} request ListPlumbersRequest message or plain object
         * @returns {Promise<protos.ListPlumbersResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.ForemanServer#getAllConnections}.
         * @memberof protos.ForemanServer
         * @typedef GetAllConnectionsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetAllConnectionsResponse} [response] GetAllConnectionsResponse
         */

        /**
         * Calls GetAllConnections.
         * @function getAllConnections
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IGetAllConnectionsRequest} request GetAllConnectionsRequest message or plain object
         * @param {protos.ForemanServer.GetAllConnectionsCallback} callback Node-style callback called with the error, if any, and GetAllConnectionsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.getAllConnections = function getAllConnections(request, callback) {
            return this.rpcCall(getAllConnections, $root.protos.GetAllConnectionsRequest, $root.protos.GetAllConnectionsResponse, request, callback);
        }, "name", { value: "GetAllConnections" });

        /**
         * Calls GetAllConnections.
         * @function getAllConnections
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IGetAllConnectionsRequest} request GetAllConnectionsRequest message or plain object
         * @returns {Promise<protos.GetAllConnectionsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.ForemanServer#getConnection}.
         * @memberof protos.ForemanServer
         * @typedef GetConnectionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetConnectionResponse} [response] GetConnectionResponse
         */

        /**
         * Calls GetConnection.
         * @function getConnection
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IGetConnectionRequest} request GetConnectionRequest message or plain object
         * @param {protos.ForemanServer.GetConnectionCallback} callback Node-style callback called with the error, if any, and GetConnectionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.getConnection = function getConnection(request, callback) {
            return this.rpcCall(getConnection, $root.protos.GetConnectionRequest, $root.protos.GetConnectionResponse, request, callback);
        }, "name", { value: "GetConnection" });

        /**
         * Calls GetConnection.
         * @function getConnection
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IGetConnectionRequest} request GetConnectionRequest message or plain object
         * @returns {Promise<protos.GetConnectionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.ForemanServer#createConnection}.
         * @memberof protos.ForemanServer
         * @typedef CreateConnectionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.CreateConnectionResponse} [response] CreateConnectionResponse
         */

        /**
         * Calls CreateConnection.
         * @function createConnection
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.ICreateConnectionRequest} request CreateConnectionRequest message or plain object
         * @param {protos.ForemanServer.CreateConnectionCallback} callback Node-style callback called with the error, if any, and CreateConnectionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.createConnection = function createConnection(request, callback) {
            return this.rpcCall(createConnection, $root.protos.CreateConnectionRequest, $root.protos.CreateConnectionResponse, request, callback);
        }, "name", { value: "CreateConnection" });

        /**
         * Calls CreateConnection.
         * @function createConnection
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.ICreateConnectionRequest} request CreateConnectionRequest message or plain object
         * @returns {Promise<protos.CreateConnectionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.ForemanServer#testConnection}.
         * @memberof protos.ForemanServer
         * @typedef TestConnectionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.TestConnectionResponse} [response] TestConnectionResponse
         */

        /**
         * Calls TestConnection.
         * @function testConnection
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.ITestConnectionRequest} request TestConnectionRequest message or plain object
         * @param {protos.ForemanServer.TestConnectionCallback} callback Node-style callback called with the error, if any, and TestConnectionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.testConnection = function testConnection(request, callback) {
            return this.rpcCall(testConnection, $root.protos.TestConnectionRequest, $root.protos.TestConnectionResponse, request, callback);
        }, "name", { value: "TestConnection" });

        /**
         * Calls TestConnection.
         * @function testConnection
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.ITestConnectionRequest} request TestConnectionRequest message or plain object
         * @returns {Promise<protos.TestConnectionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.ForemanServer#updateConnection}.
         * @memberof protos.ForemanServer
         * @typedef UpdateConnectionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.UpdateConnectionResponse} [response] UpdateConnectionResponse
         */

        /**
         * Calls UpdateConnection.
         * @function updateConnection
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IUpdateConnectionRequest} request UpdateConnectionRequest message or plain object
         * @param {protos.ForemanServer.UpdateConnectionCallback} callback Node-style callback called with the error, if any, and UpdateConnectionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.updateConnection = function updateConnection(request, callback) {
            return this.rpcCall(updateConnection, $root.protos.UpdateConnectionRequest, $root.protos.UpdateConnectionResponse, request, callback);
        }, "name", { value: "UpdateConnection" });

        /**
         * Calls UpdateConnection.
         * @function updateConnection
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IUpdateConnectionRequest} request UpdateConnectionRequest message or plain object
         * @returns {Promise<protos.UpdateConnectionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.ForemanServer#deleteConnection}.
         * @memberof protos.ForemanServer
         * @typedef DeleteConnectionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.DeleteConnectionResponse} [response] DeleteConnectionResponse
         */

        /**
         * Calls DeleteConnection.
         * @function deleteConnection
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IDeleteConnectionRequest} request DeleteConnectionRequest message or plain object
         * @param {protos.ForemanServer.DeleteConnectionCallback} callback Node-style callback called with the error, if any, and DeleteConnectionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.deleteConnection = function deleteConnection(request, callback) {
            return this.rpcCall(deleteConnection, $root.protos.DeleteConnectionRequest, $root.protos.DeleteConnectionResponse, request, callback);
        }, "name", { value: "DeleteConnection" });

        /**
         * Calls DeleteConnection.
         * @function deleteConnection
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IDeleteConnectionRequest} request DeleteConnectionRequest message or plain object
         * @returns {Promise<protos.DeleteConnectionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.ForemanServer#getAllRelays}.
         * @memberof protos.ForemanServer
         * @typedef GetAllRelaysCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetAllRelaysResponse} [response] GetAllRelaysResponse
         */

        /**
         * Calls GetAllRelays.
         * @function getAllRelays
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IGetAllRelaysRequest} request GetAllRelaysRequest message or plain object
         * @param {protos.ForemanServer.GetAllRelaysCallback} callback Node-style callback called with the error, if any, and GetAllRelaysResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.getAllRelays = function getAllRelays(request, callback) {
            return this.rpcCall(getAllRelays, $root.protos.GetAllRelaysRequest, $root.protos.GetAllRelaysResponse, request, callback);
        }, "name", { value: "GetAllRelays" });

        /**
         * Calls GetAllRelays.
         * @function getAllRelays
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IGetAllRelaysRequest} request GetAllRelaysRequest message or plain object
         * @returns {Promise<protos.GetAllRelaysResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.ForemanServer#getRelay}.
         * @memberof protos.ForemanServer
         * @typedef GetRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetRelayResponse} [response] GetRelayResponse
         */

        /**
         * Calls GetRelay.
         * @function getRelay
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IGetRelayRequest} request GetRelayRequest message or plain object
         * @param {protos.ForemanServer.GetRelayCallback} callback Node-style callback called with the error, if any, and GetRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.getRelay = function getRelay(request, callback) {
            return this.rpcCall(getRelay, $root.protos.GetRelayRequest, $root.protos.GetRelayResponse, request, callback);
        }, "name", { value: "GetRelay" });

        /**
         * Calls GetRelay.
         * @function getRelay
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IGetRelayRequest} request GetRelayRequest message or plain object
         * @returns {Promise<protos.GetRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.ForemanServer#createRelay}.
         * @memberof protos.ForemanServer
         * @typedef CreateRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.CreateRelayResponse} [response] CreateRelayResponse
         */

        /**
         * Calls CreateRelay.
         * @function createRelay
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.ICreateRelayRequest} request CreateRelayRequest message or plain object
         * @param {protos.ForemanServer.CreateRelayCallback} callback Node-style callback called with the error, if any, and CreateRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.createRelay = function createRelay(request, callback) {
            return this.rpcCall(createRelay, $root.protos.CreateRelayRequest, $root.protos.CreateRelayResponse, request, callback);
        }, "name", { value: "CreateRelay" });

        /**
         * Calls CreateRelay.
         * @function createRelay
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.ICreateRelayRequest} request CreateRelayRequest message or plain object
         * @returns {Promise<protos.CreateRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.ForemanServer#updateRelay}.
         * @memberof protos.ForemanServer
         * @typedef UpdateRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.UpdateRelayResponse} [response] UpdateRelayResponse
         */

        /**
         * Calls UpdateRelay.
         * @function updateRelay
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IUpdateRelayRequest} request UpdateRelayRequest message or plain object
         * @param {protos.ForemanServer.UpdateRelayCallback} callback Node-style callback called with the error, if any, and UpdateRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.updateRelay = function updateRelay(request, callback) {
            return this.rpcCall(updateRelay, $root.protos.UpdateRelayRequest, $root.protos.UpdateRelayResponse, request, callback);
        }, "name", { value: "UpdateRelay" });

        /**
         * Calls UpdateRelay.
         * @function updateRelay
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IUpdateRelayRequest} request UpdateRelayRequest message or plain object
         * @returns {Promise<protos.UpdateRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.ForemanServer#resumeRelay}.
         * @memberof protos.ForemanServer
         * @typedef ResumeRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.ResumeRelayResponse} [response] ResumeRelayResponse
         */

        /**
         * Calls ResumeRelay.
         * @function resumeRelay
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IResumeRelayRequest} request ResumeRelayRequest message or plain object
         * @param {protos.ForemanServer.ResumeRelayCallback} callback Node-style callback called with the error, if any, and ResumeRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.resumeRelay = function resumeRelay(request, callback) {
            return this.rpcCall(resumeRelay, $root.protos.ResumeRelayRequest, $root.protos.ResumeRelayResponse, request, callback);
        }, "name", { value: "ResumeRelay" });

        /**
         * Calls ResumeRelay.
         * @function resumeRelay
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IResumeRelayRequest} request ResumeRelayRequest message or plain object
         * @returns {Promise<protos.ResumeRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.ForemanServer#stopRelay}.
         * @memberof protos.ForemanServer
         * @typedef StopRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.StopRelayResponse} [response] StopRelayResponse
         */

        /**
         * Calls StopRelay.
         * @function stopRelay
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IStopRelayRequest} request StopRelayRequest message or plain object
         * @param {protos.ForemanServer.StopRelayCallback} callback Node-style callback called with the error, if any, and StopRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.stopRelay = function stopRelay(request, callback) {
            return this.rpcCall(stopRelay, $root.protos.StopRelayRequest, $root.protos.StopRelayResponse, request, callback);
        }, "name", { value: "StopRelay" });

        /**
         * Calls StopRelay.
         * @function stopRelay
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IStopRelayRequest} request StopRelayRequest message or plain object
         * @returns {Promise<protos.StopRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.ForemanServer#deleteRelay}.
         * @memberof protos.ForemanServer
         * @typedef DeleteRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.DeleteRelayResponse} [response] DeleteRelayResponse
         */

        /**
         * Calls DeleteRelay.
         * @function deleteRelay
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IDeleteRelayRequest} request DeleteRelayRequest message or plain object
         * @param {protos.ForemanServer.DeleteRelayCallback} callback Node-style callback called with the error, if any, and DeleteRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.deleteRelay = function deleteRelay(request, callback) {
            return this.rpcCall(deleteRelay, $root.protos.DeleteRelayRequest, $root.protos.DeleteRelayResponse, request, callback);
        }, "name", { value: "DeleteRelay" });

        /**
         * Calls DeleteRelay.
         * @function deleteRelay
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IDeleteRelayRequest} request DeleteRelayRequest message or plain object
         * @returns {Promise<protos.DeleteRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.ForemanServer#getTunnel}.
         * @memberof protos.ForemanServer
         * @typedef GetTunnelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetTunnelResponse} [response] GetTunnelResponse
         */

        /**
         * Calls GetTunnel.
         * @function getTunnel
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IGetTunnelRequest} request GetTunnelRequest message or plain object
         * @param {protos.ForemanServer.GetTunnelCallback} callback Node-style callback called with the error, if any, and GetTunnelResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.getTunnel = function getTunnel(request, callback) {
            return this.rpcCall(getTunnel, $root.protos.GetTunnelRequest, $root.protos.GetTunnelResponse, request, callback);
        }, "name", { value: "GetTunnel" });

        /**
         * Calls GetTunnel.
         * @function getTunnel
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IGetTunnelRequest} request GetTunnelRequest message or plain object
         * @returns {Promise<protos.GetTunnelResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.ForemanServer#getAllTunnels}.
         * @memberof protos.ForemanServer
         * @typedef GetAllTunnelsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetAllTunnelsResponse} [response] GetAllTunnelsResponse
         */

        /**
         * Calls GetAllTunnels.
         * @function getAllTunnels
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IGetAllTunnelsRequest} request GetAllTunnelsRequest message or plain object
         * @param {protos.ForemanServer.GetAllTunnelsCallback} callback Node-style callback called with the error, if any, and GetAllTunnelsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.getAllTunnels = function getAllTunnels(request, callback) {
            return this.rpcCall(getAllTunnels, $root.protos.GetAllTunnelsRequest, $root.protos.GetAllTunnelsResponse, request, callback);
        }, "name", { value: "GetAllTunnels" });

        /**
         * Calls GetAllTunnels.
         * @function getAllTunnels
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IGetAllTunnelsRequest} request GetAllTunnelsRequest message or plain object
         * @returns {Promise<protos.GetAllTunnelsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.ForemanServer#createTunnel}.
         * @memberof protos.ForemanServer
         * @typedef CreateTunnelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.CreateTunnelResponse} [response] CreateTunnelResponse
         */

        /**
         * Calls CreateTunnel.
         * @function createTunnel
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.ICreateTunnelRequest} request CreateTunnelRequest message or plain object
         * @param {protos.ForemanServer.CreateTunnelCallback} callback Node-style callback called with the error, if any, and CreateTunnelResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.createTunnel = function createTunnel(request, callback) {
            return this.rpcCall(createTunnel, $root.protos.CreateTunnelRequest, $root.protos.CreateTunnelResponse, request, callback);
        }, "name", { value: "CreateTunnel" });

        /**
         * Calls CreateTunnel.
         * @function createTunnel
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.ICreateTunnelRequest} request CreateTunnelRequest message or plain object
         * @returns {Promise<protos.CreateTunnelResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.ForemanServer#stopTunnel}.
         * @memberof protos.ForemanServer
         * @typedef StopTunnelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.StopTunnelResponse} [response] StopTunnelResponse
         */

        /**
         * Calls StopTunnel.
         * @function stopTunnel
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IStopTunnelRequest} request StopTunnelRequest message or plain object
         * @param {protos.ForemanServer.StopTunnelCallback} callback Node-style callback called with the error, if any, and StopTunnelResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.stopTunnel = function stopTunnel(request, callback) {
            return this.rpcCall(stopTunnel, $root.protos.StopTunnelRequest, $root.protos.StopTunnelResponse, request, callback);
        }, "name", { value: "StopTunnel" });

        /**
         * Calls StopTunnel.
         * @function stopTunnel
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IStopTunnelRequest} request StopTunnelRequest message or plain object
         * @returns {Promise<protos.StopTunnelResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.ForemanServer#resumeTunnel}.
         * @memberof protos.ForemanServer
         * @typedef ResumeTunnelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.ResumeTunnelResponse} [response] ResumeTunnelResponse
         */

        /**
         * Calls ResumeTunnel.
         * @function resumeTunnel
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IResumeTunnelRequest} request ResumeTunnelRequest message or plain object
         * @param {protos.ForemanServer.ResumeTunnelCallback} callback Node-style callback called with the error, if any, and ResumeTunnelResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.resumeTunnel = function resumeTunnel(request, callback) {
            return this.rpcCall(resumeTunnel, $root.protos.ResumeTunnelRequest, $root.protos.ResumeTunnelResponse, request, callback);
        }, "name", { value: "ResumeTunnel" });

        /**
         * Calls ResumeTunnel.
         * @function resumeTunnel
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IResumeTunnelRequest} request ResumeTunnelRequest message or plain object
         * @returns {Promise<protos.ResumeTunnelResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.ForemanServer#updateTunnel}.
         * @memberof protos.ForemanServer
         * @typedef UpdateTunnelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.UpdateTunnelResponse} [response] UpdateTunnelResponse
         */

        /**
         * Calls UpdateTunnel.
         * @function updateTunnel
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IUpdateTunnelRequest} request UpdateTunnelRequest message or plain object
         * @param {protos.ForemanServer.UpdateTunnelCallback} callback Node-style callback called with the error, if any, and UpdateTunnelResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.updateTunnel = function updateTunnel(request, callback) {
            return this.rpcCall(updateTunnel, $root.protos.UpdateTunnelRequest, $root.protos.UpdateTunnelResponse, request, callback);
        }, "name", { value: "UpdateTunnel" });

        /**
         * Calls UpdateTunnel.
         * @function updateTunnel
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IUpdateTunnelRequest} request UpdateTunnelRequest message or plain object
         * @returns {Promise<protos.UpdateTunnelResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.ForemanServer#deleteTunnel}.
         * @memberof protos.ForemanServer
         * @typedef DeleteTunnelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.DeleteTunnelResponse} [response] DeleteTunnelResponse
         */

        /**
         * Calls DeleteTunnel.
         * @function deleteTunnel
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IDeleteTunnelRequest} request DeleteTunnelRequest message or plain object
         * @param {protos.ForemanServer.DeleteTunnelCallback} callback Node-style callback called with the error, if any, and DeleteTunnelResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.deleteTunnel = function deleteTunnel(request, callback) {
            return this.rpcCall(deleteTunnel, $root.protos.DeleteTunnelRequest, $root.protos.DeleteTunnelResponse, request, callback);
        }, "name", { value: "DeleteTunnel" });

        /**
         * Calls DeleteTunnel.
         * @function deleteTunnel
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IDeleteTunnelRequest} request DeleteTunnelRequest message or plain object
         * @returns {Promise<protos.DeleteTunnelResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.ForemanServer#getServerOptions}.
         * @memberof protos.ForemanServer
         * @typedef GetServerOptionsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetServerOptionsResponse} [response] GetServerOptionsResponse
         */

        /**
         * Calls GetServerOptions.
         * @function getServerOptions
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IGetServerOptionsRequest} request GetServerOptionsRequest message or plain object
         * @param {protos.ForemanServer.GetServerOptionsCallback} callback Node-style callback called with the error, if any, and GetServerOptionsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ForemanServer.prototype.getServerOptions = function getServerOptions(request, callback) {
            return this.rpcCall(getServerOptions, $root.protos.GetServerOptionsRequest, $root.protos.GetServerOptionsResponse, request, callback);
        }, "name", { value: "GetServerOptions" });

        /**
         * Calls GetServerOptions.
         * @function getServerOptions
         * @memberof protos.ForemanServer
         * @instance
         * @param {protos.IGetServerOptionsRequest} request GetServerOptionsRequest message or plain object
         * @returns {Promise<protos.GetServerOptionsResponse>} Promise
         * @variation 2
         */

        return ForemanServer;
    })();

    protos.PlumberInfo = (function() {

        /**
         * Properties of a PlumberInfo.
         * @memberof protos
         * @interface IPlumberInfo
         * @property {string|null} [teamId] PlumberInfo teamId
         * @property {string|null} [clusterId] PlumberInfo clusterId
         */

        /**
         * Constructs a new PlumberInfo.
         * @memberof protos
         * @classdesc Represents a PlumberInfo.
         * @implements IPlumberInfo
         * @constructor
         * @param {protos.IPlumberInfo=} [properties] Properties to set
         */
        function PlumberInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlumberInfo teamId.
         * @member {string} teamId
         * @memberof protos.PlumberInfo
         * @instance
         */
        PlumberInfo.prototype.teamId = "";

        /**
         * PlumberInfo clusterId.
         * @member {string} clusterId
         * @memberof protos.PlumberInfo
         * @instance
         */
        PlumberInfo.prototype.clusterId = "";

        /**
         * Creates a new PlumberInfo instance using the specified properties.
         * @function create
         * @memberof protos.PlumberInfo
         * @static
         * @param {protos.IPlumberInfo=} [properties] Properties to set
         * @returns {protos.PlumberInfo} PlumberInfo instance
         */
        PlumberInfo.create = function create(properties) {
            return new PlumberInfo(properties);
        };

        /**
         * Encodes the specified PlumberInfo message. Does not implicitly {@link protos.PlumberInfo.verify|verify} messages.
         * @function encode
         * @memberof protos.PlumberInfo
         * @static
         * @param {protos.IPlumberInfo} message PlumberInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlumberInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.teamId != null && Object.hasOwnProperty.call(message, "teamId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.teamId);
            if (message.clusterId != null && Object.hasOwnProperty.call(message, "clusterId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.clusterId);
            return writer;
        };

        /**
         * Encodes the specified PlumberInfo message, length delimited. Does not implicitly {@link protos.PlumberInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.PlumberInfo
         * @static
         * @param {protos.IPlumberInfo} message PlumberInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlumberInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlumberInfo message from the specified reader or buffer.
         * @function decode
         * @memberof protos.PlumberInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.PlumberInfo} PlumberInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlumberInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.PlumberInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.teamId = reader.string();
                    break;
                case 2:
                    message.clusterId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlumberInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.PlumberInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.PlumberInfo} PlumberInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlumberInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlumberInfo message.
         * @function verify
         * @memberof protos.PlumberInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlumberInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.teamId != null && message.hasOwnProperty("teamId"))
                if (!$util.isString(message.teamId))
                    return "teamId: string expected";
            if (message.clusterId != null && message.hasOwnProperty("clusterId"))
                if (!$util.isString(message.clusterId))
                    return "clusterId: string expected";
            return null;
        };

        /**
         * Creates a PlumberInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.PlumberInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.PlumberInfo} PlumberInfo
         */
        PlumberInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.PlumberInfo)
                return object;
            var message = new $root.protos.PlumberInfo();
            if (object.teamId != null)
                message.teamId = String(object.teamId);
            if (object.clusterId != null)
                message.clusterId = String(object.clusterId);
            return message;
        };

        /**
         * Creates a plain object from a PlumberInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.PlumberInfo
         * @static
         * @param {protos.PlumberInfo} message PlumberInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlumberInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.teamId = "";
                object.clusterId = "";
            }
            if (message.teamId != null && message.hasOwnProperty("teamId"))
                object.teamId = message.teamId;
            if (message.clusterId != null && message.hasOwnProperty("clusterId"))
                object.clusterId = message.clusterId;
            return object;
        };

        /**
         * Converts this PlumberInfo to JSON.
         * @function toJSON
         * @memberof protos.PlumberInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlumberInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlumberInfo;
    })();

    protos.ListPlumbersRequest = (function() {

        /**
         * Properties of a ListPlumbersRequest.
         * @memberof protos
         * @interface IListPlumbersRequest
         * @property {string|null} [authToken] ListPlumbersRequest authToken
         * @property {string|null} [teamId] ListPlumbersRequest teamId
         */

        /**
         * Constructs a new ListPlumbersRequest.
         * @memberof protos
         * @classdesc Represents a ListPlumbersRequest.
         * @implements IListPlumbersRequest
         * @constructor
         * @param {protos.IListPlumbersRequest=} [properties] Properties to set
         */
        function ListPlumbersRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListPlumbersRequest authToken.
         * @member {string} authToken
         * @memberof protos.ListPlumbersRequest
         * @instance
         */
        ListPlumbersRequest.prototype.authToken = "";

        /**
         * ListPlumbersRequest teamId.
         * @member {string} teamId
         * @memberof protos.ListPlumbersRequest
         * @instance
         */
        ListPlumbersRequest.prototype.teamId = "";

        /**
         * Creates a new ListPlumbersRequest instance using the specified properties.
         * @function create
         * @memberof protos.ListPlumbersRequest
         * @static
         * @param {protos.IListPlumbersRequest=} [properties] Properties to set
         * @returns {protos.ListPlumbersRequest} ListPlumbersRequest instance
         */
        ListPlumbersRequest.create = function create(properties) {
            return new ListPlumbersRequest(properties);
        };

        /**
         * Encodes the specified ListPlumbersRequest message. Does not implicitly {@link protos.ListPlumbersRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.ListPlumbersRequest
         * @static
         * @param {protos.IListPlumbersRequest} message ListPlumbersRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPlumbersRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.authToken != null && Object.hasOwnProperty.call(message, "authToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.authToken);
            if (message.teamId != null && Object.hasOwnProperty.call(message, "teamId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.teamId);
            return writer;
        };

        /**
         * Encodes the specified ListPlumbersRequest message, length delimited. Does not implicitly {@link protos.ListPlumbersRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ListPlumbersRequest
         * @static
         * @param {protos.IListPlumbersRequest} message ListPlumbersRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPlumbersRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListPlumbersRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ListPlumbersRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ListPlumbersRequest} ListPlumbersRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPlumbersRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ListPlumbersRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.authToken = reader.string();
                    break;
                case 2:
                    message.teamId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListPlumbersRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ListPlumbersRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ListPlumbersRequest} ListPlumbersRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPlumbersRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListPlumbersRequest message.
         * @function verify
         * @memberof protos.ListPlumbersRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListPlumbersRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.authToken != null && message.hasOwnProperty("authToken"))
                if (!$util.isString(message.authToken))
                    return "authToken: string expected";
            if (message.teamId != null && message.hasOwnProperty("teamId"))
                if (!$util.isString(message.teamId))
                    return "teamId: string expected";
            return null;
        };

        /**
         * Creates a ListPlumbersRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ListPlumbersRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ListPlumbersRequest} ListPlumbersRequest
         */
        ListPlumbersRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ListPlumbersRequest)
                return object;
            var message = new $root.protos.ListPlumbersRequest();
            if (object.authToken != null)
                message.authToken = String(object.authToken);
            if (object.teamId != null)
                message.teamId = String(object.teamId);
            return message;
        };

        /**
         * Creates a plain object from a ListPlumbersRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ListPlumbersRequest
         * @static
         * @param {protos.ListPlumbersRequest} message ListPlumbersRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListPlumbersRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.authToken = "";
                object.teamId = "";
            }
            if (message.authToken != null && message.hasOwnProperty("authToken"))
                object.authToken = message.authToken;
            if (message.teamId != null && message.hasOwnProperty("teamId"))
                object.teamId = message.teamId;
            return object;
        };

        /**
         * Converts this ListPlumbersRequest to JSON.
         * @function toJSON
         * @memberof protos.ListPlumbersRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListPlumbersRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListPlumbersRequest;
    })();

    protos.ListPlumbersResponse = (function() {

        /**
         * Properties of a ListPlumbersResponse.
         * @memberof protos
         * @interface IListPlumbersResponse
         * @property {Array.<protos.IPlumberInfo>|null} [plumbers] ListPlumbersResponse plumbers
         */

        /**
         * Constructs a new ListPlumbersResponse.
         * @memberof protos
         * @classdesc Represents a ListPlumbersResponse.
         * @implements IListPlumbersResponse
         * @constructor
         * @param {protos.IListPlumbersResponse=} [properties] Properties to set
         */
        function ListPlumbersResponse(properties) {
            this.plumbers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListPlumbersResponse plumbers.
         * @member {Array.<protos.IPlumberInfo>} plumbers
         * @memberof protos.ListPlumbersResponse
         * @instance
         */
        ListPlumbersResponse.prototype.plumbers = $util.emptyArray;

        /**
         * Creates a new ListPlumbersResponse instance using the specified properties.
         * @function create
         * @memberof protos.ListPlumbersResponse
         * @static
         * @param {protos.IListPlumbersResponse=} [properties] Properties to set
         * @returns {protos.ListPlumbersResponse} ListPlumbersResponse instance
         */
        ListPlumbersResponse.create = function create(properties) {
            return new ListPlumbersResponse(properties);
        };

        /**
         * Encodes the specified ListPlumbersResponse message. Does not implicitly {@link protos.ListPlumbersResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.ListPlumbersResponse
         * @static
         * @param {protos.IListPlumbersResponse} message ListPlumbersResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPlumbersResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.plumbers != null && message.plumbers.length)
                for (var i = 0; i < message.plumbers.length; ++i)
                    $root.protos.PlumberInfo.encode(message.plumbers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ListPlumbersResponse message, length delimited. Does not implicitly {@link protos.ListPlumbersResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ListPlumbersResponse
         * @static
         * @param {protos.IListPlumbersResponse} message ListPlumbersResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPlumbersResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListPlumbersResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ListPlumbersResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ListPlumbersResponse} ListPlumbersResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPlumbersResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ListPlumbersResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.plumbers && message.plumbers.length))
                        message.plumbers = [];
                    message.plumbers.push($root.protos.PlumberInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListPlumbersResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ListPlumbersResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ListPlumbersResponse} ListPlumbersResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPlumbersResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListPlumbersResponse message.
         * @function verify
         * @memberof protos.ListPlumbersResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListPlumbersResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.plumbers != null && message.hasOwnProperty("plumbers")) {
                if (!Array.isArray(message.plumbers))
                    return "plumbers: array expected";
                for (var i = 0; i < message.plumbers.length; ++i) {
                    var error = $root.protos.PlumberInfo.verify(message.plumbers[i]);
                    if (error)
                        return "plumbers." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ListPlumbersResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ListPlumbersResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ListPlumbersResponse} ListPlumbersResponse
         */
        ListPlumbersResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ListPlumbersResponse)
                return object;
            var message = new $root.protos.ListPlumbersResponse();
            if (object.plumbers) {
                if (!Array.isArray(object.plumbers))
                    throw TypeError(".protos.ListPlumbersResponse.plumbers: array expected");
                message.plumbers = [];
                for (var i = 0; i < object.plumbers.length; ++i) {
                    if (typeof object.plumbers[i] !== "object")
                        throw TypeError(".protos.ListPlumbersResponse.plumbers: object expected");
                    message.plumbers[i] = $root.protos.PlumberInfo.fromObject(object.plumbers[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ListPlumbersResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ListPlumbersResponse
         * @static
         * @param {protos.ListPlumbersResponse} message ListPlumbersResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListPlumbersResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.plumbers = [];
            if (message.plumbers && message.plumbers.length) {
                object.plumbers = [];
                for (var j = 0; j < message.plumbers.length; ++j)
                    object.plumbers[j] = $root.protos.PlumberInfo.toObject(message.plumbers[j], options);
            }
            return object;
        };

        /**
         * Converts this ListPlumbersResponse to JSON.
         * @function toJSON
         * @memberof protos.ListPlumbersResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListPlumbersResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListPlumbersResponse;
    })();

    protos.encoding = (function() {

        /**
         * Namespace encoding.
         * @memberof protos
         * @namespace
         */
        var encoding = {};

        /**
         * EncodeType enum.
         * @name protos.encoding.EncodeType
         * @enum {number}
         * @property {number} ENCODE_TYPE_UNSET=0 ENCODE_TYPE_UNSET value
         * @property {number} ENCODE_TYPE_JSONPB=1 ENCODE_TYPE_JSONPB value
         * @property {number} ENCODE_TYPE_AVRO=2 ENCODE_TYPE_AVRO value
         * @property {number} ENCODE_TYPE_CLOUDEVENT=3 ENCODE_TYPE_CLOUDEVENT value
         */
        encoding.EncodeType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ENCODE_TYPE_UNSET"] = 0;
            values[valuesById[1] = "ENCODE_TYPE_JSONPB"] = 1;
            values[valuesById[2] = "ENCODE_TYPE_AVRO"] = 2;
            values[valuesById[3] = "ENCODE_TYPE_CLOUDEVENT"] = 3;
            return values;
        })();

        /**
         * DecodeType enum.
         * @name protos.encoding.DecodeType
         * @enum {number}
         * @property {number} DECODE_TYPE_UNSET=0 DECODE_TYPE_UNSET value
         * @property {number} DECODE_TYPE_PROTOBUF=1 DECODE_TYPE_PROTOBUF value
         * @property {number} DECODE_TYPE_AVRO=2 DECODE_TYPE_AVRO value
         * @property {number} DECODE_TYPE_THRIFT=3 DECODE_TYPE_THRIFT value
         * @property {number} DECODE_TYPE_FLATBUFFER=4 DECODE_TYPE_FLATBUFFER value
         */
        encoding.DecodeType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DECODE_TYPE_UNSET"] = 0;
            values[valuesById[1] = "DECODE_TYPE_PROTOBUF"] = 1;
            values[valuesById[2] = "DECODE_TYPE_AVRO"] = 2;
            values[valuesById[3] = "DECODE_TYPE_THRIFT"] = 3;
            values[valuesById[4] = "DECODE_TYPE_FLATBUFFER"] = 4;
            return values;
        })();

        /**
         * EnvelopeType enum.
         * @name protos.encoding.EnvelopeType
         * @enum {number}
         * @property {number} ENVELOPE_TYPE_UNSET=0 ENVELOPE_TYPE_UNSET value
         * @property {number} ENVELOPE_TYPE_DEEP=1 ENVELOPE_TYPE_DEEP value
         * @property {number} ENVELOPE_TYPE_SHALLOW=2 ENVELOPE_TYPE_SHALLOW value
         */
        encoding.EnvelopeType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ENVELOPE_TYPE_UNSET"] = 0;
            values[valuesById[1] = "ENVELOPE_TYPE_DEEP"] = 1;
            values[valuesById[2] = "ENVELOPE_TYPE_SHALLOW"] = 2;
            return values;
        })();

        encoding.ProtobufSettings = (function() {

            /**
             * Properties of a ProtobufSettings.
             * @memberof protos.encoding
             * @interface IProtobufSettings
             * @property {string|null} [protobufRootMessage] ProtobufSettings protobufRootMessage
             * @property {Array.<string>|null} [protobufDirs] ProtobufSettings protobufDirs
             * @property {string|null} [_protobufRootDir] ProtobufSettings _protobufRootDir
             * @property {Uint8Array|null} [archive] ProtobufSettings archive
             * @property {Uint8Array|null} [_messageDescriptor] ProtobufSettings _messageDescriptor
             * @property {protos.encoding.EnvelopeType|null} [protobufEnvelopeType] ProtobufSettings protobufEnvelopeType
             * @property {string|null} [shallowEnvelopeMessage] ProtobufSettings shallowEnvelopeMessage
             * @property {number|null} [shallowEnvelopeFieldNumber] ProtobufSettings shallowEnvelopeFieldNumber
             * @property {Uint8Array|null} [_shallowEnvelopeMessageDescriptor] ProtobufSettings _shallowEnvelopeMessageDescriptor
             * @property {string|null} [protobufDescriptorSet] ProtobufSettings protobufDescriptorSet
             */

            /**
             * Constructs a new ProtobufSettings.
             * @memberof protos.encoding
             * @classdesc Represents a ProtobufSettings.
             * @implements IProtobufSettings
             * @constructor
             * @param {protos.encoding.IProtobufSettings=} [properties] Properties to set
             */
            function ProtobufSettings(properties) {
                this.protobufDirs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProtobufSettings protobufRootMessage.
             * @member {string} protobufRootMessage
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype.protobufRootMessage = "";

            /**
             * ProtobufSettings protobufDirs.
             * @member {Array.<string>} protobufDirs
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype.protobufDirs = $util.emptyArray;

            /**
             * ProtobufSettings _protobufRootDir.
             * @member {string} _protobufRootDir
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype._protobufRootDir = "";

            /**
             * ProtobufSettings archive.
             * @member {Uint8Array} archive
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype.archive = $util.newBuffer([]);

            /**
             * ProtobufSettings _messageDescriptor.
             * @member {Uint8Array} _messageDescriptor
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype._messageDescriptor = $util.newBuffer([]);

            /**
             * ProtobufSettings protobufEnvelopeType.
             * @member {protos.encoding.EnvelopeType} protobufEnvelopeType
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype.protobufEnvelopeType = 0;

            /**
             * ProtobufSettings shallowEnvelopeMessage.
             * @member {string} shallowEnvelopeMessage
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype.shallowEnvelopeMessage = "";

            /**
             * ProtobufSettings shallowEnvelopeFieldNumber.
             * @member {number} shallowEnvelopeFieldNumber
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype.shallowEnvelopeFieldNumber = 0;

            /**
             * ProtobufSettings _shallowEnvelopeMessageDescriptor.
             * @member {Uint8Array} _shallowEnvelopeMessageDescriptor
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype._shallowEnvelopeMessageDescriptor = $util.newBuffer([]);

            /**
             * ProtobufSettings protobufDescriptorSet.
             * @member {string} protobufDescriptorSet
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype.protobufDescriptorSet = "";

            /**
             * Creates a new ProtobufSettings instance using the specified properties.
             * @function create
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {protos.encoding.IProtobufSettings=} [properties] Properties to set
             * @returns {protos.encoding.ProtobufSettings} ProtobufSettings instance
             */
            ProtobufSettings.create = function create(properties) {
                return new ProtobufSettings(properties);
            };

            /**
             * Encodes the specified ProtobufSettings message. Does not implicitly {@link protos.encoding.ProtobufSettings.verify|verify} messages.
             * @function encode
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {protos.encoding.IProtobufSettings} message ProtobufSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtobufSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.protobufRootMessage != null && Object.hasOwnProperty.call(message, "protobufRootMessage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.protobufRootMessage);
                if (message.protobufDirs != null && message.protobufDirs.length)
                    for (var i = 0; i < message.protobufDirs.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.protobufDirs[i]);
                if (message._protobufRootDir != null && Object.hasOwnProperty.call(message, "_protobufRootDir"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message._protobufRootDir);
                if (message.archive != null && Object.hasOwnProperty.call(message, "archive"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.archive);
                if (message._messageDescriptor != null && Object.hasOwnProperty.call(message, "_messageDescriptor"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message._messageDescriptor);
                if (message.protobufEnvelopeType != null && Object.hasOwnProperty.call(message, "protobufEnvelopeType"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.protobufEnvelopeType);
                if (message.shallowEnvelopeMessage != null && Object.hasOwnProperty.call(message, "shallowEnvelopeMessage"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.shallowEnvelopeMessage);
                if (message.shallowEnvelopeFieldNumber != null && Object.hasOwnProperty.call(message, "shallowEnvelopeFieldNumber"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.shallowEnvelopeFieldNumber);
                if (message._shallowEnvelopeMessageDescriptor != null && Object.hasOwnProperty.call(message, "_shallowEnvelopeMessageDescriptor"))
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message._shallowEnvelopeMessageDescriptor);
                if (message.protobufDescriptorSet != null && Object.hasOwnProperty.call(message, "protobufDescriptorSet"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.protobufDescriptorSet);
                return writer;
            };

            /**
             * Encodes the specified ProtobufSettings message, length delimited. Does not implicitly {@link protos.encoding.ProtobufSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {protos.encoding.IProtobufSettings} message ProtobufSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtobufSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtobufSettings message from the specified reader or buffer.
             * @function decode
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.encoding.ProtobufSettings} ProtobufSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtobufSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.encoding.ProtobufSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.protobufRootMessage = reader.string();
                        break;
                    case 2:
                        if (!(message.protobufDirs && message.protobufDirs.length))
                            message.protobufDirs = [];
                        message.protobufDirs.push(reader.string());
                        break;
                    case 3:
                        message._protobufRootDir = reader.string();
                        break;
                    case 4:
                        message.archive = reader.bytes();
                        break;
                    case 5:
                        message._messageDescriptor = reader.bytes();
                        break;
                    case 6:
                        message.protobufEnvelopeType = reader.int32();
                        break;
                    case 7:
                        message.shallowEnvelopeMessage = reader.string();
                        break;
                    case 8:
                        message.shallowEnvelopeFieldNumber = reader.int32();
                        break;
                    case 9:
                        message._shallowEnvelopeMessageDescriptor = reader.bytes();
                        break;
                    case 10:
                        message.protobufDescriptorSet = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtobufSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.encoding.ProtobufSettings} ProtobufSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtobufSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtobufSettings message.
             * @function verify
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtobufSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.protobufRootMessage != null && message.hasOwnProperty("protobufRootMessage"))
                    if (!$util.isString(message.protobufRootMessage))
                        return "protobufRootMessage: string expected";
                if (message.protobufDirs != null && message.hasOwnProperty("protobufDirs")) {
                    if (!Array.isArray(message.protobufDirs))
                        return "protobufDirs: array expected";
                    for (var i = 0; i < message.protobufDirs.length; ++i)
                        if (!$util.isString(message.protobufDirs[i]))
                            return "protobufDirs: string[] expected";
                }
                if (message._protobufRootDir != null && message.hasOwnProperty("_protobufRootDir"))
                    if (!$util.isString(message._protobufRootDir))
                        return "_protobufRootDir: string expected";
                if (message.archive != null && message.hasOwnProperty("archive"))
                    if (!(message.archive && typeof message.archive.length === "number" || $util.isString(message.archive)))
                        return "archive: buffer expected";
                if (message._messageDescriptor != null && message.hasOwnProperty("_messageDescriptor"))
                    if (!(message._messageDescriptor && typeof message._messageDescriptor.length === "number" || $util.isString(message._messageDescriptor)))
                        return "_messageDescriptor: buffer expected";
                if (message.protobufEnvelopeType != null && message.hasOwnProperty("protobufEnvelopeType"))
                    switch (message.protobufEnvelopeType) {
                    default:
                        return "protobufEnvelopeType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.shallowEnvelopeMessage != null && message.hasOwnProperty("shallowEnvelopeMessage"))
                    if (!$util.isString(message.shallowEnvelopeMessage))
                        return "shallowEnvelopeMessage: string expected";
                if (message.shallowEnvelopeFieldNumber != null && message.hasOwnProperty("shallowEnvelopeFieldNumber"))
                    if (!$util.isInteger(message.shallowEnvelopeFieldNumber))
                        return "shallowEnvelopeFieldNumber: integer expected";
                if (message._shallowEnvelopeMessageDescriptor != null && message.hasOwnProperty("_shallowEnvelopeMessageDescriptor"))
                    if (!(message._shallowEnvelopeMessageDescriptor && typeof message._shallowEnvelopeMessageDescriptor.length === "number" || $util.isString(message._shallowEnvelopeMessageDescriptor)))
                        return "_shallowEnvelopeMessageDescriptor: buffer expected";
                if (message.protobufDescriptorSet != null && message.hasOwnProperty("protobufDescriptorSet"))
                    if (!$util.isString(message.protobufDescriptorSet))
                        return "protobufDescriptorSet: string expected";
                return null;
            };

            /**
             * Creates a ProtobufSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.encoding.ProtobufSettings} ProtobufSettings
             */
            ProtobufSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.encoding.ProtobufSettings)
                    return object;
                var message = new $root.protos.encoding.ProtobufSettings();
                if (object.protobufRootMessage != null)
                    message.protobufRootMessage = String(object.protobufRootMessage);
                if (object.protobufDirs) {
                    if (!Array.isArray(object.protobufDirs))
                        throw TypeError(".protos.encoding.ProtobufSettings.protobufDirs: array expected");
                    message.protobufDirs = [];
                    for (var i = 0; i < object.protobufDirs.length; ++i)
                        message.protobufDirs[i] = String(object.protobufDirs[i]);
                }
                if (object._protobufRootDir != null)
                    message._protobufRootDir = String(object._protobufRootDir);
                if (object.archive != null)
                    if (typeof object.archive === "string")
                        $util.base64.decode(object.archive, message.archive = $util.newBuffer($util.base64.length(object.archive)), 0);
                    else if (object.archive.length)
                        message.archive = object.archive;
                if (object._messageDescriptor != null)
                    if (typeof object._messageDescriptor === "string")
                        $util.base64.decode(object._messageDescriptor, message._messageDescriptor = $util.newBuffer($util.base64.length(object._messageDescriptor)), 0);
                    else if (object._messageDescriptor.length)
                        message._messageDescriptor = object._messageDescriptor;
                switch (object.protobufEnvelopeType) {
                case "ENVELOPE_TYPE_UNSET":
                case 0:
                    message.protobufEnvelopeType = 0;
                    break;
                case "ENVELOPE_TYPE_DEEP":
                case 1:
                    message.protobufEnvelopeType = 1;
                    break;
                case "ENVELOPE_TYPE_SHALLOW":
                case 2:
                    message.protobufEnvelopeType = 2;
                    break;
                }
                if (object.shallowEnvelopeMessage != null)
                    message.shallowEnvelopeMessage = String(object.shallowEnvelopeMessage);
                if (object.shallowEnvelopeFieldNumber != null)
                    message.shallowEnvelopeFieldNumber = object.shallowEnvelopeFieldNumber | 0;
                if (object._shallowEnvelopeMessageDescriptor != null)
                    if (typeof object._shallowEnvelopeMessageDescriptor === "string")
                        $util.base64.decode(object._shallowEnvelopeMessageDescriptor, message._shallowEnvelopeMessageDescriptor = $util.newBuffer($util.base64.length(object._shallowEnvelopeMessageDescriptor)), 0);
                    else if (object._shallowEnvelopeMessageDescriptor.length)
                        message._shallowEnvelopeMessageDescriptor = object._shallowEnvelopeMessageDescriptor;
                if (object.protobufDescriptorSet != null)
                    message.protobufDescriptorSet = String(object.protobufDescriptorSet);
                return message;
            };

            /**
             * Creates a plain object from a ProtobufSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {protos.encoding.ProtobufSettings} message ProtobufSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtobufSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.protobufDirs = [];
                if (options.defaults) {
                    object.protobufRootMessage = "";
                    object._protobufRootDir = "";
                    if (options.bytes === String)
                        object.archive = "";
                    else {
                        object.archive = [];
                        if (options.bytes !== Array)
                            object.archive = $util.newBuffer(object.archive);
                    }
                    if (options.bytes === String)
                        object._messageDescriptor = "";
                    else {
                        object._messageDescriptor = [];
                        if (options.bytes !== Array)
                            object._messageDescriptor = $util.newBuffer(object._messageDescriptor);
                    }
                    object.protobufEnvelopeType = options.enums === String ? "ENVELOPE_TYPE_UNSET" : 0;
                    object.shallowEnvelopeMessage = "";
                    object.shallowEnvelopeFieldNumber = 0;
                    if (options.bytes === String)
                        object._shallowEnvelopeMessageDescriptor = "";
                    else {
                        object._shallowEnvelopeMessageDescriptor = [];
                        if (options.bytes !== Array)
                            object._shallowEnvelopeMessageDescriptor = $util.newBuffer(object._shallowEnvelopeMessageDescriptor);
                    }
                    object.protobufDescriptorSet = "";
                }
                if (message.protobufRootMessage != null && message.hasOwnProperty("protobufRootMessage"))
                    object.protobufRootMessage = message.protobufRootMessage;
                if (message.protobufDirs && message.protobufDirs.length) {
                    object.protobufDirs = [];
                    for (var j = 0; j < message.protobufDirs.length; ++j)
                        object.protobufDirs[j] = message.protobufDirs[j];
                }
                if (message._protobufRootDir != null && message.hasOwnProperty("_protobufRootDir"))
                    object._protobufRootDir = message._protobufRootDir;
                if (message.archive != null && message.hasOwnProperty("archive"))
                    object.archive = options.bytes === String ? $util.base64.encode(message.archive, 0, message.archive.length) : options.bytes === Array ? Array.prototype.slice.call(message.archive) : message.archive;
                if (message._messageDescriptor != null && message.hasOwnProperty("_messageDescriptor"))
                    object._messageDescriptor = options.bytes === String ? $util.base64.encode(message._messageDescriptor, 0, message._messageDescriptor.length) : options.bytes === Array ? Array.prototype.slice.call(message._messageDescriptor) : message._messageDescriptor;
                if (message.protobufEnvelopeType != null && message.hasOwnProperty("protobufEnvelopeType"))
                    object.protobufEnvelopeType = options.enums === String ? $root.protos.encoding.EnvelopeType[message.protobufEnvelopeType] : message.protobufEnvelopeType;
                if (message.shallowEnvelopeMessage != null && message.hasOwnProperty("shallowEnvelopeMessage"))
                    object.shallowEnvelopeMessage = message.shallowEnvelopeMessage;
                if (message.shallowEnvelopeFieldNumber != null && message.hasOwnProperty("shallowEnvelopeFieldNumber"))
                    object.shallowEnvelopeFieldNumber = message.shallowEnvelopeFieldNumber;
                if (message._shallowEnvelopeMessageDescriptor != null && message.hasOwnProperty("_shallowEnvelopeMessageDescriptor"))
                    object._shallowEnvelopeMessageDescriptor = options.bytes === String ? $util.base64.encode(message._shallowEnvelopeMessageDescriptor, 0, message._shallowEnvelopeMessageDescriptor.length) : options.bytes === Array ? Array.prototype.slice.call(message._shallowEnvelopeMessageDescriptor) : message._shallowEnvelopeMessageDescriptor;
                if (message.protobufDescriptorSet != null && message.hasOwnProperty("protobufDescriptorSet"))
                    object.protobufDescriptorSet = message.protobufDescriptorSet;
                return object;
            };

            /**
             * Converts this ProtobufSettings to JSON.
             * @function toJSON
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtobufSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ProtobufSettings;
        })();

        encoding.AvroSettings = (function() {

            /**
             * Properties of an AvroSettings.
             * @memberof protos.encoding
             * @interface IAvroSettings
             * @property {string|null} [avroSchemaFile] AvroSettings avroSchemaFile
             * @property {Uint8Array|null} [schema] AvroSettings schema
             */

            /**
             * Constructs a new AvroSettings.
             * @memberof protos.encoding
             * @classdesc Represents an AvroSettings.
             * @implements IAvroSettings
             * @constructor
             * @param {protos.encoding.IAvroSettings=} [properties] Properties to set
             */
            function AvroSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AvroSettings avroSchemaFile.
             * @member {string} avroSchemaFile
             * @memberof protos.encoding.AvroSettings
             * @instance
             */
            AvroSettings.prototype.avroSchemaFile = "";

            /**
             * AvroSettings schema.
             * @member {Uint8Array} schema
             * @memberof protos.encoding.AvroSettings
             * @instance
             */
            AvroSettings.prototype.schema = $util.newBuffer([]);

            /**
             * Creates a new AvroSettings instance using the specified properties.
             * @function create
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {protos.encoding.IAvroSettings=} [properties] Properties to set
             * @returns {protos.encoding.AvroSettings} AvroSettings instance
             */
            AvroSettings.create = function create(properties) {
                return new AvroSettings(properties);
            };

            /**
             * Encodes the specified AvroSettings message. Does not implicitly {@link protos.encoding.AvroSettings.verify|verify} messages.
             * @function encode
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {protos.encoding.IAvroSettings} message AvroSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AvroSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.avroSchemaFile != null && Object.hasOwnProperty.call(message, "avroSchemaFile"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.avroSchemaFile);
                if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.schema);
                return writer;
            };

            /**
             * Encodes the specified AvroSettings message, length delimited. Does not implicitly {@link protos.encoding.AvroSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {protos.encoding.IAvroSettings} message AvroSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AvroSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AvroSettings message from the specified reader or buffer.
             * @function decode
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.encoding.AvroSettings} AvroSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AvroSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.encoding.AvroSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.avroSchemaFile = reader.string();
                        break;
                    case 2:
                        message.schema = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AvroSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.encoding.AvroSettings} AvroSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AvroSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AvroSettings message.
             * @function verify
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AvroSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.avroSchemaFile != null && message.hasOwnProperty("avroSchemaFile"))
                    if (!$util.isString(message.avroSchemaFile))
                        return "avroSchemaFile: string expected";
                if (message.schema != null && message.hasOwnProperty("schema"))
                    if (!(message.schema && typeof message.schema.length === "number" || $util.isString(message.schema)))
                        return "schema: buffer expected";
                return null;
            };

            /**
             * Creates an AvroSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.encoding.AvroSettings} AvroSettings
             */
            AvroSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.encoding.AvroSettings)
                    return object;
                var message = new $root.protos.encoding.AvroSettings();
                if (object.avroSchemaFile != null)
                    message.avroSchemaFile = String(object.avroSchemaFile);
                if (object.schema != null)
                    if (typeof object.schema === "string")
                        $util.base64.decode(object.schema, message.schema = $util.newBuffer($util.base64.length(object.schema)), 0);
                    else if (object.schema.length)
                        message.schema = object.schema;
                return message;
            };

            /**
             * Creates a plain object from an AvroSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {protos.encoding.AvroSettings} message AvroSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AvroSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.avroSchemaFile = "";
                    if (options.bytes === String)
                        object.schema = "";
                    else {
                        object.schema = [];
                        if (options.bytes !== Array)
                            object.schema = $util.newBuffer(object.schema);
                    }
                }
                if (message.avroSchemaFile != null && message.hasOwnProperty("avroSchemaFile"))
                    object.avroSchemaFile = message.avroSchemaFile;
                if (message.schema != null && message.hasOwnProperty("schema"))
                    object.schema = options.bytes === String ? $util.base64.encode(message.schema, 0, message.schema.length) : options.bytes === Array ? Array.prototype.slice.call(message.schema) : message.schema;
                return object;
            };

            /**
             * Converts this AvroSettings to JSON.
             * @function toJSON
             * @memberof protos.encoding.AvroSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AvroSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AvroSettings;
        })();

        encoding.ThriftSettings = (function() {

            /**
             * Properties of a ThriftSettings.
             * @memberof protos.encoding
             * @interface IThriftSettings
             * @property {Array.<string>|null} [thriftDirs] ThriftSettings thriftDirs
             * @property {string|null} [thriftStruct] ThriftSettings thriftStruct
             */

            /**
             * Constructs a new ThriftSettings.
             * @memberof protos.encoding
             * @classdesc Represents a ThriftSettings.
             * @implements IThriftSettings
             * @constructor
             * @param {protos.encoding.IThriftSettings=} [properties] Properties to set
             */
            function ThriftSettings(properties) {
                this.thriftDirs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ThriftSettings thriftDirs.
             * @member {Array.<string>} thriftDirs
             * @memberof protos.encoding.ThriftSettings
             * @instance
             */
            ThriftSettings.prototype.thriftDirs = $util.emptyArray;

            /**
             * ThriftSettings thriftStruct.
             * @member {string} thriftStruct
             * @memberof protos.encoding.ThriftSettings
             * @instance
             */
            ThriftSettings.prototype.thriftStruct = "";

            /**
             * Creates a new ThriftSettings instance using the specified properties.
             * @function create
             * @memberof protos.encoding.ThriftSettings
             * @static
             * @param {protos.encoding.IThriftSettings=} [properties] Properties to set
             * @returns {protos.encoding.ThriftSettings} ThriftSettings instance
             */
            ThriftSettings.create = function create(properties) {
                return new ThriftSettings(properties);
            };

            /**
             * Encodes the specified ThriftSettings message. Does not implicitly {@link protos.encoding.ThriftSettings.verify|verify} messages.
             * @function encode
             * @memberof protos.encoding.ThriftSettings
             * @static
             * @param {protos.encoding.IThriftSettings} message ThriftSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ThriftSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.thriftDirs != null && message.thriftDirs.length)
                    for (var i = 0; i < message.thriftDirs.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.thriftDirs[i]);
                if (message.thriftStruct != null && Object.hasOwnProperty.call(message, "thriftStruct"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.thriftStruct);
                return writer;
            };

            /**
             * Encodes the specified ThriftSettings message, length delimited. Does not implicitly {@link protos.encoding.ThriftSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.encoding.ThriftSettings
             * @static
             * @param {protos.encoding.IThriftSettings} message ThriftSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ThriftSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ThriftSettings message from the specified reader or buffer.
             * @function decode
             * @memberof protos.encoding.ThriftSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.encoding.ThriftSettings} ThriftSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ThriftSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.encoding.ThriftSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.thriftDirs && message.thriftDirs.length))
                            message.thriftDirs = [];
                        message.thriftDirs.push(reader.string());
                        break;
                    case 2:
                        message.thriftStruct = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ThriftSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.encoding.ThriftSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.encoding.ThriftSettings} ThriftSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ThriftSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ThriftSettings message.
             * @function verify
             * @memberof protos.encoding.ThriftSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ThriftSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.thriftDirs != null && message.hasOwnProperty("thriftDirs")) {
                    if (!Array.isArray(message.thriftDirs))
                        return "thriftDirs: array expected";
                    for (var i = 0; i < message.thriftDirs.length; ++i)
                        if (!$util.isString(message.thriftDirs[i]))
                            return "thriftDirs: string[] expected";
                }
                if (message.thriftStruct != null && message.hasOwnProperty("thriftStruct"))
                    if (!$util.isString(message.thriftStruct))
                        return "thriftStruct: string expected";
                return null;
            };

            /**
             * Creates a ThriftSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.encoding.ThriftSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.encoding.ThriftSettings} ThriftSettings
             */
            ThriftSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.encoding.ThriftSettings)
                    return object;
                var message = new $root.protos.encoding.ThriftSettings();
                if (object.thriftDirs) {
                    if (!Array.isArray(object.thriftDirs))
                        throw TypeError(".protos.encoding.ThriftSettings.thriftDirs: array expected");
                    message.thriftDirs = [];
                    for (var i = 0; i < object.thriftDirs.length; ++i)
                        message.thriftDirs[i] = String(object.thriftDirs[i]);
                }
                if (object.thriftStruct != null)
                    message.thriftStruct = String(object.thriftStruct);
                return message;
            };

            /**
             * Creates a plain object from a ThriftSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.encoding.ThriftSettings
             * @static
             * @param {protos.encoding.ThriftSettings} message ThriftSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ThriftSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.thriftDirs = [];
                if (options.defaults)
                    object.thriftStruct = "";
                if (message.thriftDirs && message.thriftDirs.length) {
                    object.thriftDirs = [];
                    for (var j = 0; j < message.thriftDirs.length; ++j)
                        object.thriftDirs[j] = message.thriftDirs[j];
                }
                if (message.thriftStruct != null && message.hasOwnProperty("thriftStruct"))
                    object.thriftStruct = message.thriftStruct;
                return object;
            };

            /**
             * Converts this ThriftSettings to JSON.
             * @function toJSON
             * @memberof protos.encoding.ThriftSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ThriftSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ThriftSettings;
        })();

        encoding.JSONSchemaSettings = (function() {

            /**
             * Properties of a JSONSchemaSettings.
             * @memberof protos.encoding
             * @interface IJSONSchemaSettings
             * @property {Uint8Array|null} [schema] JSONSchemaSettings schema
             */

            /**
             * Constructs a new JSONSchemaSettings.
             * @memberof protos.encoding
             * @classdesc Represents a JSONSchemaSettings.
             * @implements IJSONSchemaSettings
             * @constructor
             * @param {protos.encoding.IJSONSchemaSettings=} [properties] Properties to set
             */
            function JSONSchemaSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JSONSchemaSettings schema.
             * @member {Uint8Array} schema
             * @memberof protos.encoding.JSONSchemaSettings
             * @instance
             */
            JSONSchemaSettings.prototype.schema = $util.newBuffer([]);

            /**
             * Creates a new JSONSchemaSettings instance using the specified properties.
             * @function create
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {protos.encoding.IJSONSchemaSettings=} [properties] Properties to set
             * @returns {protos.encoding.JSONSchemaSettings} JSONSchemaSettings instance
             */
            JSONSchemaSettings.create = function create(properties) {
                return new JSONSchemaSettings(properties);
            };

            /**
             * Encodes the specified JSONSchemaSettings message. Does not implicitly {@link protos.encoding.JSONSchemaSettings.verify|verify} messages.
             * @function encode
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {protos.encoding.IJSONSchemaSettings} message JSONSchemaSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JSONSchemaSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.schema);
                return writer;
            };

            /**
             * Encodes the specified JSONSchemaSettings message, length delimited. Does not implicitly {@link protos.encoding.JSONSchemaSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {protos.encoding.IJSONSchemaSettings} message JSONSchemaSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JSONSchemaSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JSONSchemaSettings message from the specified reader or buffer.
             * @function decode
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.encoding.JSONSchemaSettings} JSONSchemaSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JSONSchemaSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.encoding.JSONSchemaSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.schema = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JSONSchemaSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.encoding.JSONSchemaSettings} JSONSchemaSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JSONSchemaSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JSONSchemaSettings message.
             * @function verify
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JSONSchemaSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.schema != null && message.hasOwnProperty("schema"))
                    if (!(message.schema && typeof message.schema.length === "number" || $util.isString(message.schema)))
                        return "schema: buffer expected";
                return null;
            };

            /**
             * Creates a JSONSchemaSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.encoding.JSONSchemaSettings} JSONSchemaSettings
             */
            JSONSchemaSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.encoding.JSONSchemaSettings)
                    return object;
                var message = new $root.protos.encoding.JSONSchemaSettings();
                if (object.schema != null)
                    if (typeof object.schema === "string")
                        $util.base64.decode(object.schema, message.schema = $util.newBuffer($util.base64.length(object.schema)), 0);
                    else if (object.schema.length)
                        message.schema = object.schema;
                return message;
            };

            /**
             * Creates a plain object from a JSONSchemaSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {protos.encoding.JSONSchemaSettings} message JSONSchemaSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            JSONSchemaSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.schema = "";
                    else {
                        object.schema = [];
                        if (options.bytes !== Array)
                            object.schema = $util.newBuffer(object.schema);
                    }
                if (message.schema != null && message.hasOwnProperty("schema"))
                    object.schema = options.bytes === String ? $util.base64.encode(message.schema, 0, message.schema.length) : options.bytes === Array ? Array.prototype.slice.call(message.schema) : message.schema;
                return object;
            };

            /**
             * Converts this JSONSchemaSettings to JSON.
             * @function toJSON
             * @memberof protos.encoding.JSONSchemaSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            JSONSchemaSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return JSONSchemaSettings;
        })();

        encoding.CloudEventSettings = (function() {

            /**
             * Properties of a CloudEventSettings.
             * @memberof protos.encoding
             * @interface ICloudEventSettings
             * @property {string|null} [ceId] CloudEventSettings ceId
             * @property {string|null} [ceSource] CloudEventSettings ceSource
             * @property {string|null} [ceType] CloudEventSettings ceType
             * @property {string|null} [ceSubject] CloudEventSettings ceSubject
             * @property {string|null} [ceSpecVersion] CloudEventSettings ceSpecVersion
             * @property {string|null} [ceDataContentType] CloudEventSettings ceDataContentType
             * @property {string|null} [ceDataSchema] CloudEventSettings ceDataSchema
             */

            /**
             * Constructs a new CloudEventSettings.
             * @memberof protos.encoding
             * @classdesc Represents a CloudEventSettings.
             * @implements ICloudEventSettings
             * @constructor
             * @param {protos.encoding.ICloudEventSettings=} [properties] Properties to set
             */
            function CloudEventSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CloudEventSettings ceId.
             * @member {string} ceId
             * @memberof protos.encoding.CloudEventSettings
             * @instance
             */
            CloudEventSettings.prototype.ceId = "";

            /**
             * CloudEventSettings ceSource.
             * @member {string} ceSource
             * @memberof protos.encoding.CloudEventSettings
             * @instance
             */
            CloudEventSettings.prototype.ceSource = "";

            /**
             * CloudEventSettings ceType.
             * @member {string} ceType
             * @memberof protos.encoding.CloudEventSettings
             * @instance
             */
            CloudEventSettings.prototype.ceType = "";

            /**
             * CloudEventSettings ceSubject.
             * @member {string} ceSubject
             * @memberof protos.encoding.CloudEventSettings
             * @instance
             */
            CloudEventSettings.prototype.ceSubject = "";

            /**
             * CloudEventSettings ceSpecVersion.
             * @member {string} ceSpecVersion
             * @memberof protos.encoding.CloudEventSettings
             * @instance
             */
            CloudEventSettings.prototype.ceSpecVersion = "";

            /**
             * CloudEventSettings ceDataContentType.
             * @member {string} ceDataContentType
             * @memberof protos.encoding.CloudEventSettings
             * @instance
             */
            CloudEventSettings.prototype.ceDataContentType = "";

            /**
             * CloudEventSettings ceDataSchema.
             * @member {string} ceDataSchema
             * @memberof protos.encoding.CloudEventSettings
             * @instance
             */
            CloudEventSettings.prototype.ceDataSchema = "";

            /**
             * Creates a new CloudEventSettings instance using the specified properties.
             * @function create
             * @memberof protos.encoding.CloudEventSettings
             * @static
             * @param {protos.encoding.ICloudEventSettings=} [properties] Properties to set
             * @returns {protos.encoding.CloudEventSettings} CloudEventSettings instance
             */
            CloudEventSettings.create = function create(properties) {
                return new CloudEventSettings(properties);
            };

            /**
             * Encodes the specified CloudEventSettings message. Does not implicitly {@link protos.encoding.CloudEventSettings.verify|verify} messages.
             * @function encode
             * @memberof protos.encoding.CloudEventSettings
             * @static
             * @param {protos.encoding.ICloudEventSettings} message CloudEventSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CloudEventSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ceId != null && Object.hasOwnProperty.call(message, "ceId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.ceId);
                if (message.ceSource != null && Object.hasOwnProperty.call(message, "ceSource"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.ceSource);
                if (message.ceType != null && Object.hasOwnProperty.call(message, "ceType"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.ceType);
                if (message.ceSubject != null && Object.hasOwnProperty.call(message, "ceSubject"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.ceSubject);
                if (message.ceSpecVersion != null && Object.hasOwnProperty.call(message, "ceSpecVersion"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.ceSpecVersion);
                if (message.ceDataContentType != null && Object.hasOwnProperty.call(message, "ceDataContentType"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.ceDataContentType);
                if (message.ceDataSchema != null && Object.hasOwnProperty.call(message, "ceDataSchema"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.ceDataSchema);
                return writer;
            };

            /**
             * Encodes the specified CloudEventSettings message, length delimited. Does not implicitly {@link protos.encoding.CloudEventSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.encoding.CloudEventSettings
             * @static
             * @param {protos.encoding.ICloudEventSettings} message CloudEventSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CloudEventSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CloudEventSettings message from the specified reader or buffer.
             * @function decode
             * @memberof protos.encoding.CloudEventSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.encoding.CloudEventSettings} CloudEventSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CloudEventSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.encoding.CloudEventSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ceId = reader.string();
                        break;
                    case 2:
                        message.ceSource = reader.string();
                        break;
                    case 3:
                        message.ceType = reader.string();
                        break;
                    case 4:
                        message.ceSubject = reader.string();
                        break;
                    case 5:
                        message.ceSpecVersion = reader.string();
                        break;
                    case 6:
                        message.ceDataContentType = reader.string();
                        break;
                    case 7:
                        message.ceDataSchema = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CloudEventSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.encoding.CloudEventSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.encoding.CloudEventSettings} CloudEventSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CloudEventSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CloudEventSettings message.
             * @function verify
             * @memberof protos.encoding.CloudEventSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CloudEventSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ceId != null && message.hasOwnProperty("ceId"))
                    if (!$util.isString(message.ceId))
                        return "ceId: string expected";
                if (message.ceSource != null && message.hasOwnProperty("ceSource"))
                    if (!$util.isString(message.ceSource))
                        return "ceSource: string expected";
                if (message.ceType != null && message.hasOwnProperty("ceType"))
                    if (!$util.isString(message.ceType))
                        return "ceType: string expected";
                if (message.ceSubject != null && message.hasOwnProperty("ceSubject"))
                    if (!$util.isString(message.ceSubject))
                        return "ceSubject: string expected";
                if (message.ceSpecVersion != null && message.hasOwnProperty("ceSpecVersion"))
                    if (!$util.isString(message.ceSpecVersion))
                        return "ceSpecVersion: string expected";
                if (message.ceDataContentType != null && message.hasOwnProperty("ceDataContentType"))
                    if (!$util.isString(message.ceDataContentType))
                        return "ceDataContentType: string expected";
                if (message.ceDataSchema != null && message.hasOwnProperty("ceDataSchema"))
                    if (!$util.isString(message.ceDataSchema))
                        return "ceDataSchema: string expected";
                return null;
            };

            /**
             * Creates a CloudEventSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.encoding.CloudEventSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.encoding.CloudEventSettings} CloudEventSettings
             */
            CloudEventSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.encoding.CloudEventSettings)
                    return object;
                var message = new $root.protos.encoding.CloudEventSettings();
                if (object.ceId != null)
                    message.ceId = String(object.ceId);
                if (object.ceSource != null)
                    message.ceSource = String(object.ceSource);
                if (object.ceType != null)
                    message.ceType = String(object.ceType);
                if (object.ceSubject != null)
                    message.ceSubject = String(object.ceSubject);
                if (object.ceSpecVersion != null)
                    message.ceSpecVersion = String(object.ceSpecVersion);
                if (object.ceDataContentType != null)
                    message.ceDataContentType = String(object.ceDataContentType);
                if (object.ceDataSchema != null)
                    message.ceDataSchema = String(object.ceDataSchema);
                return message;
            };

            /**
             * Creates a plain object from a CloudEventSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.encoding.CloudEventSettings
             * @static
             * @param {protos.encoding.CloudEventSettings} message CloudEventSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CloudEventSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.ceId = "";
                    object.ceSource = "";
                    object.ceType = "";
                    object.ceSubject = "";
                    object.ceSpecVersion = "";
                    object.ceDataContentType = "";
                    object.ceDataSchema = "";
                }
                if (message.ceId != null && message.hasOwnProperty("ceId"))
                    object.ceId = message.ceId;
                if (message.ceSource != null && message.hasOwnProperty("ceSource"))
                    object.ceSource = message.ceSource;
                if (message.ceType != null && message.hasOwnProperty("ceType"))
                    object.ceType = message.ceType;
                if (message.ceSubject != null && message.hasOwnProperty("ceSubject"))
                    object.ceSubject = message.ceSubject;
                if (message.ceSpecVersion != null && message.hasOwnProperty("ceSpecVersion"))
                    object.ceSpecVersion = message.ceSpecVersion;
                if (message.ceDataContentType != null && message.hasOwnProperty("ceDataContentType"))
                    object.ceDataContentType = message.ceDataContentType;
                if (message.ceDataSchema != null && message.hasOwnProperty("ceDataSchema"))
                    object.ceDataSchema = message.ceDataSchema;
                return object;
            };

            /**
             * Converts this CloudEventSettings to JSON.
             * @function toJSON
             * @memberof protos.encoding.CloudEventSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CloudEventSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CloudEventSettings;
        })();

        encoding.EncodeOptions = (function() {

            /**
             * Properties of an EncodeOptions.
             * @memberof protos.encoding
             * @interface IEncodeOptions
             * @property {string|null} [schemaId] EncodeOptions schemaId
             * @property {protos.encoding.EncodeType|null} [encodeType] EncodeOptions encodeType
             * @property {protos.encoding.IProtobufSettings|null} [protobufSettings] EncodeOptions protobufSettings
             * @property {protos.encoding.IAvroSettings|null} [avroSettings] EncodeOptions avroSettings
             * @property {protos.encoding.ICloudEventSettings|null} [cloudeventSettings] EncodeOptions cloudeventSettings
             */

            /**
             * Constructs a new EncodeOptions.
             * @memberof protos.encoding
             * @classdesc Represents an EncodeOptions.
             * @implements IEncodeOptions
             * @constructor
             * @param {protos.encoding.IEncodeOptions=} [properties] Properties to set
             */
            function EncodeOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EncodeOptions schemaId.
             * @member {string} schemaId
             * @memberof protos.encoding.EncodeOptions
             * @instance
             */
            EncodeOptions.prototype.schemaId = "";

            /**
             * EncodeOptions encodeType.
             * @member {protos.encoding.EncodeType} encodeType
             * @memberof protos.encoding.EncodeOptions
             * @instance
             */
            EncodeOptions.prototype.encodeType = 0;

            /**
             * EncodeOptions protobufSettings.
             * @member {protos.encoding.IProtobufSettings|null|undefined} protobufSettings
             * @memberof protos.encoding.EncodeOptions
             * @instance
             */
            EncodeOptions.prototype.protobufSettings = null;

            /**
             * EncodeOptions avroSettings.
             * @member {protos.encoding.IAvroSettings|null|undefined} avroSettings
             * @memberof protos.encoding.EncodeOptions
             * @instance
             */
            EncodeOptions.prototype.avroSettings = null;

            /**
             * EncodeOptions cloudeventSettings.
             * @member {protos.encoding.ICloudEventSettings|null|undefined} cloudeventSettings
             * @memberof protos.encoding.EncodeOptions
             * @instance
             */
            EncodeOptions.prototype.cloudeventSettings = null;

            /**
             * Creates a new EncodeOptions instance using the specified properties.
             * @function create
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {protos.encoding.IEncodeOptions=} [properties] Properties to set
             * @returns {protos.encoding.EncodeOptions} EncodeOptions instance
             */
            EncodeOptions.create = function create(properties) {
                return new EncodeOptions(properties);
            };

            /**
             * Encodes the specified EncodeOptions message. Does not implicitly {@link protos.encoding.EncodeOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {protos.encoding.IEncodeOptions} message EncodeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EncodeOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.schemaId != null && Object.hasOwnProperty.call(message, "schemaId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.schemaId);
                if (message.encodeType != null && Object.hasOwnProperty.call(message, "encodeType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.encodeType);
                if (message.protobufSettings != null && Object.hasOwnProperty.call(message, "protobufSettings"))
                    $root.protos.encoding.ProtobufSettings.encode(message.protobufSettings, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.avroSettings != null && Object.hasOwnProperty.call(message, "avroSettings"))
                    $root.protos.encoding.AvroSettings.encode(message.avroSettings, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.cloudeventSettings != null && Object.hasOwnProperty.call(message, "cloudeventSettings"))
                    $root.protos.encoding.CloudEventSettings.encode(message.cloudeventSettings, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EncodeOptions message, length delimited. Does not implicitly {@link protos.encoding.EncodeOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {protos.encoding.IEncodeOptions} message EncodeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EncodeOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EncodeOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.encoding.EncodeOptions} EncodeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EncodeOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.encoding.EncodeOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.schemaId = reader.string();
                        break;
                    case 2:
                        message.encodeType = reader.int32();
                        break;
                    case 3:
                        message.protobufSettings = $root.protos.encoding.ProtobufSettings.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.avroSettings = $root.protos.encoding.AvroSettings.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.cloudeventSettings = $root.protos.encoding.CloudEventSettings.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EncodeOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.encoding.EncodeOptions} EncodeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EncodeOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EncodeOptions message.
             * @function verify
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EncodeOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    if (!$util.isString(message.schemaId))
                        return "schemaId: string expected";
                if (message.encodeType != null && message.hasOwnProperty("encodeType"))
                    switch (message.encodeType) {
                    default:
                        return "encodeType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings")) {
                    var error = $root.protos.encoding.ProtobufSettings.verify(message.protobufSettings);
                    if (error)
                        return "protobufSettings." + error;
                }
                if (message.avroSettings != null && message.hasOwnProperty("avroSettings")) {
                    var error = $root.protos.encoding.AvroSettings.verify(message.avroSettings);
                    if (error)
                        return "avroSettings." + error;
                }
                if (message.cloudeventSettings != null && message.hasOwnProperty("cloudeventSettings")) {
                    var error = $root.protos.encoding.CloudEventSettings.verify(message.cloudeventSettings);
                    if (error)
                        return "cloudeventSettings." + error;
                }
                return null;
            };

            /**
             * Creates an EncodeOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.encoding.EncodeOptions} EncodeOptions
             */
            EncodeOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.encoding.EncodeOptions)
                    return object;
                var message = new $root.protos.encoding.EncodeOptions();
                if (object.schemaId != null)
                    message.schemaId = String(object.schemaId);
                switch (object.encodeType) {
                case "ENCODE_TYPE_UNSET":
                case 0:
                    message.encodeType = 0;
                    break;
                case "ENCODE_TYPE_JSONPB":
                case 1:
                    message.encodeType = 1;
                    break;
                case "ENCODE_TYPE_AVRO":
                case 2:
                    message.encodeType = 2;
                    break;
                case "ENCODE_TYPE_CLOUDEVENT":
                case 3:
                    message.encodeType = 3;
                    break;
                }
                if (object.protobufSettings != null) {
                    if (typeof object.protobufSettings !== "object")
                        throw TypeError(".protos.encoding.EncodeOptions.protobufSettings: object expected");
                    message.protobufSettings = $root.protos.encoding.ProtobufSettings.fromObject(object.protobufSettings);
                }
                if (object.avroSettings != null) {
                    if (typeof object.avroSettings !== "object")
                        throw TypeError(".protos.encoding.EncodeOptions.avroSettings: object expected");
                    message.avroSettings = $root.protos.encoding.AvroSettings.fromObject(object.avroSettings);
                }
                if (object.cloudeventSettings != null) {
                    if (typeof object.cloudeventSettings !== "object")
                        throw TypeError(".protos.encoding.EncodeOptions.cloudeventSettings: object expected");
                    message.cloudeventSettings = $root.protos.encoding.CloudEventSettings.fromObject(object.cloudeventSettings);
                }
                return message;
            };

            /**
             * Creates a plain object from an EncodeOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {protos.encoding.EncodeOptions} message EncodeOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EncodeOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.schemaId = "";
                    object.encodeType = options.enums === String ? "ENCODE_TYPE_UNSET" : 0;
                    object.protobufSettings = null;
                    object.avroSettings = null;
                    object.cloudeventSettings = null;
                }
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    object.schemaId = message.schemaId;
                if (message.encodeType != null && message.hasOwnProperty("encodeType"))
                    object.encodeType = options.enums === String ? $root.protos.encoding.EncodeType[message.encodeType] : message.encodeType;
                if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings"))
                    object.protobufSettings = $root.protos.encoding.ProtobufSettings.toObject(message.protobufSettings, options);
                if (message.avroSettings != null && message.hasOwnProperty("avroSettings"))
                    object.avroSettings = $root.protos.encoding.AvroSettings.toObject(message.avroSettings, options);
                if (message.cloudeventSettings != null && message.hasOwnProperty("cloudeventSettings"))
                    object.cloudeventSettings = $root.protos.encoding.CloudEventSettings.toObject(message.cloudeventSettings, options);
                return object;
            };

            /**
             * Converts this EncodeOptions to JSON.
             * @function toJSON
             * @memberof protos.encoding.EncodeOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EncodeOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EncodeOptions;
        })();

        encoding.DecodeOptions = (function() {

            /**
             * Properties of a DecodeOptions.
             * @memberof protos.encoding
             * @interface IDecodeOptions
             * @property {string|null} [schemaId] DecodeOptions schemaId
             * @property {protos.encoding.DecodeType|null} [decodeType] DecodeOptions decodeType
             * @property {protos.encoding.IProtobufSettings|null} [protobufSettings] DecodeOptions protobufSettings
             * @property {protos.encoding.IAvroSettings|null} [avroSettings] DecodeOptions avroSettings
             * @property {protos.encoding.IThriftSettings|null} [thriftSettings] DecodeOptions thriftSettings
             */

            /**
             * Constructs a new DecodeOptions.
             * @memberof protos.encoding
             * @classdesc Represents a DecodeOptions.
             * @implements IDecodeOptions
             * @constructor
             * @param {protos.encoding.IDecodeOptions=} [properties] Properties to set
             */
            function DecodeOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DecodeOptions schemaId.
             * @member {string} schemaId
             * @memberof protos.encoding.DecodeOptions
             * @instance
             */
            DecodeOptions.prototype.schemaId = "";

            /**
             * DecodeOptions decodeType.
             * @member {protos.encoding.DecodeType} decodeType
             * @memberof protos.encoding.DecodeOptions
             * @instance
             */
            DecodeOptions.prototype.decodeType = 0;

            /**
             * DecodeOptions protobufSettings.
             * @member {protos.encoding.IProtobufSettings|null|undefined} protobufSettings
             * @memberof protos.encoding.DecodeOptions
             * @instance
             */
            DecodeOptions.prototype.protobufSettings = null;

            /**
             * DecodeOptions avroSettings.
             * @member {protos.encoding.IAvroSettings|null|undefined} avroSettings
             * @memberof protos.encoding.DecodeOptions
             * @instance
             */
            DecodeOptions.prototype.avroSettings = null;

            /**
             * DecodeOptions thriftSettings.
             * @member {protos.encoding.IThriftSettings|null|undefined} thriftSettings
             * @memberof protos.encoding.DecodeOptions
             * @instance
             */
            DecodeOptions.prototype.thriftSettings = null;

            /**
             * Creates a new DecodeOptions instance using the specified properties.
             * @function create
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {protos.encoding.IDecodeOptions=} [properties] Properties to set
             * @returns {protos.encoding.DecodeOptions} DecodeOptions instance
             */
            DecodeOptions.create = function create(properties) {
                return new DecodeOptions(properties);
            };

            /**
             * Encodes the specified DecodeOptions message. Does not implicitly {@link protos.encoding.DecodeOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {protos.encoding.IDecodeOptions} message DecodeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DecodeOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.schemaId != null && Object.hasOwnProperty.call(message, "schemaId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.schemaId);
                if (message.decodeType != null && Object.hasOwnProperty.call(message, "decodeType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.decodeType);
                if (message.protobufSettings != null && Object.hasOwnProperty.call(message, "protobufSettings"))
                    $root.protos.encoding.ProtobufSettings.encode(message.protobufSettings, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.avroSettings != null && Object.hasOwnProperty.call(message, "avroSettings"))
                    $root.protos.encoding.AvroSettings.encode(message.avroSettings, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.thriftSettings != null && Object.hasOwnProperty.call(message, "thriftSettings"))
                    $root.protos.encoding.ThriftSettings.encode(message.thriftSettings, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DecodeOptions message, length delimited. Does not implicitly {@link protos.encoding.DecodeOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {protos.encoding.IDecodeOptions} message DecodeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DecodeOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DecodeOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.encoding.DecodeOptions} DecodeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DecodeOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.encoding.DecodeOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.schemaId = reader.string();
                        break;
                    case 2:
                        message.decodeType = reader.int32();
                        break;
                    case 3:
                        message.protobufSettings = $root.protos.encoding.ProtobufSettings.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.avroSettings = $root.protos.encoding.AvroSettings.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.thriftSettings = $root.protos.encoding.ThriftSettings.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DecodeOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.encoding.DecodeOptions} DecodeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DecodeOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DecodeOptions message.
             * @function verify
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DecodeOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    if (!$util.isString(message.schemaId))
                        return "schemaId: string expected";
                if (message.decodeType != null && message.hasOwnProperty("decodeType"))
                    switch (message.decodeType) {
                    default:
                        return "decodeType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings")) {
                    var error = $root.protos.encoding.ProtobufSettings.verify(message.protobufSettings);
                    if (error)
                        return "protobufSettings." + error;
                }
                if (message.avroSettings != null && message.hasOwnProperty("avroSettings")) {
                    var error = $root.protos.encoding.AvroSettings.verify(message.avroSettings);
                    if (error)
                        return "avroSettings." + error;
                }
                if (message.thriftSettings != null && message.hasOwnProperty("thriftSettings")) {
                    var error = $root.protos.encoding.ThriftSettings.verify(message.thriftSettings);
                    if (error)
                        return "thriftSettings." + error;
                }
                return null;
            };

            /**
             * Creates a DecodeOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.encoding.DecodeOptions} DecodeOptions
             */
            DecodeOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.encoding.DecodeOptions)
                    return object;
                var message = new $root.protos.encoding.DecodeOptions();
                if (object.schemaId != null)
                    message.schemaId = String(object.schemaId);
                switch (object.decodeType) {
                case "DECODE_TYPE_UNSET":
                case 0:
                    message.decodeType = 0;
                    break;
                case "DECODE_TYPE_PROTOBUF":
                case 1:
                    message.decodeType = 1;
                    break;
                case "DECODE_TYPE_AVRO":
                case 2:
                    message.decodeType = 2;
                    break;
                case "DECODE_TYPE_THRIFT":
                case 3:
                    message.decodeType = 3;
                    break;
                case "DECODE_TYPE_FLATBUFFER":
                case 4:
                    message.decodeType = 4;
                    break;
                }
                if (object.protobufSettings != null) {
                    if (typeof object.protobufSettings !== "object")
                        throw TypeError(".protos.encoding.DecodeOptions.protobufSettings: object expected");
                    message.protobufSettings = $root.protos.encoding.ProtobufSettings.fromObject(object.protobufSettings);
                }
                if (object.avroSettings != null) {
                    if (typeof object.avroSettings !== "object")
                        throw TypeError(".protos.encoding.DecodeOptions.avroSettings: object expected");
                    message.avroSettings = $root.protos.encoding.AvroSettings.fromObject(object.avroSettings);
                }
                if (object.thriftSettings != null) {
                    if (typeof object.thriftSettings !== "object")
                        throw TypeError(".protos.encoding.DecodeOptions.thriftSettings: object expected");
                    message.thriftSettings = $root.protos.encoding.ThriftSettings.fromObject(object.thriftSettings);
                }
                return message;
            };

            /**
             * Creates a plain object from a DecodeOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {protos.encoding.DecodeOptions} message DecodeOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DecodeOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.schemaId = "";
                    object.decodeType = options.enums === String ? "DECODE_TYPE_UNSET" : 0;
                    object.protobufSettings = null;
                    object.avroSettings = null;
                    object.thriftSettings = null;
                }
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    object.schemaId = message.schemaId;
                if (message.decodeType != null && message.hasOwnProperty("decodeType"))
                    object.decodeType = options.enums === String ? $root.protos.encoding.DecodeType[message.decodeType] : message.decodeType;
                if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings"))
                    object.protobufSettings = $root.protos.encoding.ProtobufSettings.toObject(message.protobufSettings, options);
                if (message.avroSettings != null && message.hasOwnProperty("avroSettings"))
                    object.avroSettings = $root.protos.encoding.AvroSettings.toObject(message.avroSettings, options);
                if (message.thriftSettings != null && message.hasOwnProperty("thriftSettings"))
                    object.thriftSettings = $root.protos.encoding.ThriftSettings.toObject(message.thriftSettings, options);
                return object;
            };

            /**
             * Converts this DecodeOptions to JSON.
             * @function toJSON
             * @memberof protos.encoding.DecodeOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DecodeOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DecodeOptions;
        })();

        return encoding;
    })();

    protos.records = (function() {

        /**
         * Namespace records.
         * @memberof protos
         * @namespace
         */
        var records = {};

        records.ReadRecord = (function() {

            /**
             * Properties of a ReadRecord.
             * @memberof protos.records
             * @interface IReadRecord
             * @property {string|null} [messageId] ReadRecord messageId
             * @property {number|Long|null} [num] ReadRecord num
             * @property {Object.<string,string>|null} [metadata] ReadRecord metadata
             * @property {number|Long|null} [receivedAtUnixTsUtc] ReadRecord receivedAtUnixTsUtc
             * @property {Uint8Array|null} [payload] ReadRecord payload
             * @property {protos.records.IKafka|null} [kafka] ReadRecord kafka
             * @property {protos.records.IRabbit|null} [rabbit] ReadRecord rabbit
             * @property {protos.records.IActiveMQ|null} [activemq] ReadRecord activemq
             * @property {protos.records.IAWSSQS|null} [awsSqs] ReadRecord awsSqs
             * @property {protos.records.IAzureEventHub|null} [azureEventHub] ReadRecord azureEventHub
             * @property {protos.records.IAzureServiceBus|null} [azureServiceBus] ReadRecord azureServiceBus
             * @property {protos.records.IGCPPubSub|null} [gcpPubsub] ReadRecord gcpPubsub
             * @property {protos.records.IKubeMQ|null} [kubemq] ReadRecord kubemq
             * @property {protos.records.IMongo|null} [mongo] ReadRecord mongo
             * @property {protos.records.IMQTT|null} [mqtt] ReadRecord mqtt
             * @property {protos.records.INats|null} [nats] ReadRecord nats
             * @property {protos.records.INatsStreaming|null} [natsStreaming] ReadRecord natsStreaming
             * @property {protos.records.INSQ|null} [nsq] ReadRecord nsq
             * @property {protos.records.IPostgres|null} [postgres] ReadRecord postgres
             * @property {protos.records.IPulsar|null} [pulsar] ReadRecord pulsar
             * @property {protos.records.IRabbitStreams|null} [rabbitStreams] ReadRecord rabbitStreams
             * @property {protos.records.IRedisPubsub|null} [redisPubsub] ReadRecord redisPubsub
             * @property {protos.records.IRedisStreams|null} [redisStreams] ReadRecord redisStreams
             * @property {protos.records.INatsJetstream|null} [natsJetstream] ReadRecord natsJetstream
             * @property {protos.records.IAWSKinesis|null} [awsKinesis] ReadRecord awsKinesis
             * @property {protos.records.IMemphis|null} [memphis] ReadRecord memphis
             * @property {Uint8Array|null} [_raw] ReadRecord _raw
             * @property {string|null} [_plumberId] ReadRecord _plumberId
             */

            /**
             * Constructs a new ReadRecord.
             * @memberof protos.records
             * @classdesc Represents a ReadRecord.
             * @implements IReadRecord
             * @constructor
             * @param {protos.records.IReadRecord=} [properties] Properties to set
             */
            function ReadRecord(properties) {
                this.metadata = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadRecord messageId.
             * @member {string} messageId
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.messageId = "";

            /**
             * ReadRecord num.
             * @member {number|Long} num
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.num = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ReadRecord metadata.
             * @member {Object.<string,string>} metadata
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.metadata = $util.emptyObject;

            /**
             * ReadRecord receivedAtUnixTsUtc.
             * @member {number|Long} receivedAtUnixTsUtc
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.receivedAtUnixTsUtc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ReadRecord payload.
             * @member {Uint8Array} payload
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.payload = $util.newBuffer([]);

            /**
             * ReadRecord kafka.
             * @member {protos.records.IKafka|null|undefined} kafka
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.kafka = null;

            /**
             * ReadRecord rabbit.
             * @member {protos.records.IRabbit|null|undefined} rabbit
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.rabbit = null;

            /**
             * ReadRecord activemq.
             * @member {protos.records.IActiveMQ|null|undefined} activemq
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.activemq = null;

            /**
             * ReadRecord awsSqs.
             * @member {protos.records.IAWSSQS|null|undefined} awsSqs
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.awsSqs = null;

            /**
             * ReadRecord azureEventHub.
             * @member {protos.records.IAzureEventHub|null|undefined} azureEventHub
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.azureEventHub = null;

            /**
             * ReadRecord azureServiceBus.
             * @member {protos.records.IAzureServiceBus|null|undefined} azureServiceBus
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.azureServiceBus = null;

            /**
             * ReadRecord gcpPubsub.
             * @member {protos.records.IGCPPubSub|null|undefined} gcpPubsub
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.gcpPubsub = null;

            /**
             * ReadRecord kubemq.
             * @member {protos.records.IKubeMQ|null|undefined} kubemq
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.kubemq = null;

            /**
             * ReadRecord mongo.
             * @member {protos.records.IMongo|null|undefined} mongo
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.mongo = null;

            /**
             * ReadRecord mqtt.
             * @member {protos.records.IMQTT|null|undefined} mqtt
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.mqtt = null;

            /**
             * ReadRecord nats.
             * @member {protos.records.INats|null|undefined} nats
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.nats = null;

            /**
             * ReadRecord natsStreaming.
             * @member {protos.records.INatsStreaming|null|undefined} natsStreaming
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.natsStreaming = null;

            /**
             * ReadRecord nsq.
             * @member {protos.records.INSQ|null|undefined} nsq
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.nsq = null;

            /**
             * ReadRecord postgres.
             * @member {protos.records.IPostgres|null|undefined} postgres
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.postgres = null;

            /**
             * ReadRecord pulsar.
             * @member {protos.records.IPulsar|null|undefined} pulsar
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.pulsar = null;

            /**
             * ReadRecord rabbitStreams.
             * @member {protos.records.IRabbitStreams|null|undefined} rabbitStreams
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.rabbitStreams = null;

            /**
             * ReadRecord redisPubsub.
             * @member {protos.records.IRedisPubsub|null|undefined} redisPubsub
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.redisPubsub = null;

            /**
             * ReadRecord redisStreams.
             * @member {protos.records.IRedisStreams|null|undefined} redisStreams
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.redisStreams = null;

            /**
             * ReadRecord natsJetstream.
             * @member {protos.records.INatsJetstream|null|undefined} natsJetstream
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.natsJetstream = null;

            /**
             * ReadRecord awsKinesis.
             * @member {protos.records.IAWSKinesis|null|undefined} awsKinesis
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.awsKinesis = null;

            /**
             * ReadRecord memphis.
             * @member {protos.records.IMemphis|null|undefined} memphis
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.memphis = null;

            /**
             * ReadRecord _raw.
             * @member {Uint8Array} _raw
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype._raw = $util.newBuffer([]);

            /**
             * ReadRecord _plumberId.
             * @member {string} _plumberId
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype._plumberId = "";

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * ReadRecord Record.
             * @member {"kafka"|"rabbit"|"activemq"|"awsSqs"|"azureEventHub"|"azureServiceBus"|"gcpPubsub"|"kubemq"|"mongo"|"mqtt"|"nats"|"natsStreaming"|"nsq"|"postgres"|"pulsar"|"rabbitStreams"|"redisPubsub"|"redisStreams"|"natsJetstream"|"awsKinesis"|"memphis"|undefined} Record
             * @memberof protos.records.ReadRecord
             * @instance
             */
            Object.defineProperty(ReadRecord.prototype, "Record", {
                get: $util.oneOfGetter($oneOfFields = ["kafka", "rabbit", "activemq", "awsSqs", "azureEventHub", "azureServiceBus", "gcpPubsub", "kubemq", "mongo", "mqtt", "nats", "natsStreaming", "nsq", "postgres", "pulsar", "rabbitStreams", "redisPubsub", "redisStreams", "natsJetstream", "awsKinesis", "memphis"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ReadRecord instance using the specified properties.
             * @function create
             * @memberof protos.records.ReadRecord
             * @static
             * @param {protos.records.IReadRecord=} [properties] Properties to set
             * @returns {protos.records.ReadRecord} ReadRecord instance
             */
            ReadRecord.create = function create(properties) {
                return new ReadRecord(properties);
            };

            /**
             * Encodes the specified ReadRecord message. Does not implicitly {@link protos.records.ReadRecord.verify|verify} messages.
             * @function encode
             * @memberof protos.records.ReadRecord
             * @static
             * @param {protos.records.IReadRecord} message ReadRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadRecord.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.messageId);
                if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.num);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    for (var keys = Object.keys(message.metadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.metadata[keys[i]]).ldelim();
                if (message.receivedAtUnixTsUtc != null && Object.hasOwnProperty.call(message, "receivedAtUnixTsUtc"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.receivedAtUnixTsUtc);
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 99, wireType 2 =*/794).bytes(message.payload);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.records.Kafka.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.records.Rabbit.encode(message.rabbit, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.activemq != null && Object.hasOwnProperty.call(message, "activemq"))
                    $root.protos.records.ActiveMQ.encode(message.activemq, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.awsSqs != null && Object.hasOwnProperty.call(message, "awsSqs"))
                    $root.protos.records.AWSSQS.encode(message.awsSqs, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.azureEventHub != null && Object.hasOwnProperty.call(message, "azureEventHub"))
                    $root.protos.records.AzureEventHub.encode(message.azureEventHub, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.records.AzureServiceBus.encode(message.azureServiceBus, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.records.GCPPubSub.encode(message.gcpPubsub, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.kubemq != null && Object.hasOwnProperty.call(message, "kubemq"))
                    $root.protos.records.KubeMQ.encode(message.kubemq, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.mongo != null && Object.hasOwnProperty.call(message, "mongo"))
                    $root.protos.records.Mongo.encode(message.mongo, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.records.MQTT.encode(message.mqtt, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.records.Nats.encode(message.nats, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.records.NatsStreaming.encode(message.natsStreaming, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.records.NSQ.encode(message.nsq, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.postgres != null && Object.hasOwnProperty.call(message, "postgres"))
                    $root.protos.records.Postgres.encode(message.postgres, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.pulsar != null && Object.hasOwnProperty.call(message, "pulsar"))
                    $root.protos.records.Pulsar.encode(message.pulsar, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.rabbitStreams != null && Object.hasOwnProperty.call(message, "rabbitStreams"))
                    $root.protos.records.RabbitStreams.encode(message.rabbitStreams, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.records.RedisPubsub.encode(message.redisPubsub, writer.uint32(/* id 116, wireType 2 =*/930).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.records.RedisStreams.encode(message.redisStreams, writer.uint32(/* id 117, wireType 2 =*/938).fork()).ldelim();
                if (message.natsJetstream != null && Object.hasOwnProperty.call(message, "natsJetstream"))
                    $root.protos.records.NatsJetstream.encode(message.natsJetstream, writer.uint32(/* id 118, wireType 2 =*/946).fork()).ldelim();
                if (message.awsKinesis != null && Object.hasOwnProperty.call(message, "awsKinesis"))
                    $root.protos.records.AWSKinesis.encode(message.awsKinesis, writer.uint32(/* id 119, wireType 2 =*/954).fork()).ldelim();
                if (message.memphis != null && Object.hasOwnProperty.call(message, "memphis"))
                    $root.protos.records.Memphis.encode(message.memphis, writer.uint32(/* id 120, wireType 2 =*/962).fork()).ldelim();
                if (message._raw != null && Object.hasOwnProperty.call(message, "_raw"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).bytes(message._raw);
                if (message._plumberId != null && Object.hasOwnProperty.call(message, "_plumberId"))
                    writer.uint32(/* id 1001, wireType 2 =*/8010).string(message._plumberId);
                return writer;
            };

            /**
             * Encodes the specified ReadRecord message, length delimited. Does not implicitly {@link protos.records.ReadRecord.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.ReadRecord
             * @static
             * @param {protos.records.IReadRecord} message ReadRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadRecord.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadRecord message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.ReadRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.ReadRecord} ReadRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadRecord.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.ReadRecord(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageId = reader.string();
                        break;
                    case 3:
                        message.num = reader.int64();
                        break;
                    case 4:
                        if (message.metadata === $util.emptyObject)
                            message.metadata = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.metadata[key] = value;
                        break;
                    case 6:
                        message.receivedAtUnixTsUtc = reader.int64();
                        break;
                    case 99:
                        message.payload = reader.bytes();
                        break;
                    case 100:
                        message.kafka = $root.protos.records.Kafka.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.rabbit = $root.protos.records.Rabbit.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.activemq = $root.protos.records.ActiveMQ.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.awsSqs = $root.protos.records.AWSSQS.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.azureEventHub = $root.protos.records.AzureEventHub.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.azureServiceBus = $root.protos.records.AzureServiceBus.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.gcpPubsub = $root.protos.records.GCPPubSub.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.kubemq = $root.protos.records.KubeMQ.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.mongo = $root.protos.records.Mongo.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.mqtt = $root.protos.records.MQTT.decode(reader, reader.uint32());
                        break;
                    case 110:
                        message.nats = $root.protos.records.Nats.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.natsStreaming = $root.protos.records.NatsStreaming.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.nsq = $root.protos.records.NSQ.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.postgres = $root.protos.records.Postgres.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.pulsar = $root.protos.records.Pulsar.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.rabbitStreams = $root.protos.records.RabbitStreams.decode(reader, reader.uint32());
                        break;
                    case 116:
                        message.redisPubsub = $root.protos.records.RedisPubsub.decode(reader, reader.uint32());
                        break;
                    case 117:
                        message.redisStreams = $root.protos.records.RedisStreams.decode(reader, reader.uint32());
                        break;
                    case 118:
                        message.natsJetstream = $root.protos.records.NatsJetstream.decode(reader, reader.uint32());
                        break;
                    case 119:
                        message.awsKinesis = $root.protos.records.AWSKinesis.decode(reader, reader.uint32());
                        break;
                    case 120:
                        message.memphis = $root.protos.records.Memphis.decode(reader, reader.uint32());
                        break;
                    case 1000:
                        message._raw = reader.bytes();
                        break;
                    case 1001:
                        message._plumberId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadRecord message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.ReadRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.ReadRecord} ReadRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadRecord.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadRecord message.
             * @function verify
             * @memberof protos.records.ReadRecord
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadRecord.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                if (message.num != null && message.hasOwnProperty("num"))
                    if (!$util.isInteger(message.num) && !(message.num && $util.isInteger(message.num.low) && $util.isInteger(message.num.high)))
                        return "num: integer|Long expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    if (!$util.isObject(message.metadata))
                        return "metadata: object expected";
                    var key = Object.keys(message.metadata);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.metadata[key[i]]))
                            return "metadata: string{k:string} expected";
                }
                if (message.receivedAtUnixTsUtc != null && message.hasOwnProperty("receivedAtUnixTsUtc"))
                    if (!$util.isInteger(message.receivedAtUnixTsUtc) && !(message.receivedAtUnixTsUtc && $util.isInteger(message.receivedAtUnixTsUtc.low) && $util.isInteger(message.receivedAtUnixTsUtc.high)))
                        return "receivedAtUnixTsUtc: integer|Long expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.Kafka.verify(message.kafka);
                        if (error)
                            return "kafka." + error;
                    }
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.Rabbit.verify(message.rabbit);
                        if (error)
                            return "rabbit." + error;
                    }
                }
                if (message.activemq != null && message.hasOwnProperty("activemq")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.ActiveMQ.verify(message.activemq);
                        if (error)
                            return "activemq." + error;
                    }
                }
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.AWSSQS.verify(message.awsSqs);
                        if (error)
                            return "awsSqs." + error;
                    }
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.AzureEventHub.verify(message.azureEventHub);
                        if (error)
                            return "azureEventHub." + error;
                    }
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.AzureServiceBus.verify(message.azureServiceBus);
                        if (error)
                            return "azureServiceBus." + error;
                    }
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.GCPPubSub.verify(message.gcpPubsub);
                        if (error)
                            return "gcpPubsub." + error;
                    }
                }
                if (message.kubemq != null && message.hasOwnProperty("kubemq")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.KubeMQ.verify(message.kubemq);
                        if (error)
                            return "kubemq." + error;
                    }
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.Mongo.verify(message.mongo);
                        if (error)
                            return "mongo." + error;
                    }
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.MQTT.verify(message.mqtt);
                        if (error)
                            return "mqtt." + error;
                    }
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.Nats.verify(message.nats);
                        if (error)
                            return "nats." + error;
                    }
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.NatsStreaming.verify(message.natsStreaming);
                        if (error)
                            return "natsStreaming." + error;
                    }
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.NSQ.verify(message.nsq);
                        if (error)
                            return "nsq." + error;
                    }
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.Postgres.verify(message.postgres);
                        if (error)
                            return "postgres." + error;
                    }
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.Pulsar.verify(message.pulsar);
                        if (error)
                            return "pulsar." + error;
                    }
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.RabbitStreams.verify(message.rabbitStreams);
                        if (error)
                            return "rabbitStreams." + error;
                    }
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.RedisPubsub.verify(message.redisPubsub);
                        if (error)
                            return "redisPubsub." + error;
                    }
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.RedisStreams.verify(message.redisStreams);
                        if (error)
                            return "redisStreams." + error;
                    }
                }
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.NatsJetstream.verify(message.natsJetstream);
                        if (error)
                            return "natsJetstream." + error;
                    }
                }
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.AWSKinesis.verify(message.awsKinesis);
                        if (error)
                            return "awsKinesis." + error;
                    }
                }
                if (message.memphis != null && message.hasOwnProperty("memphis")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.Memphis.verify(message.memphis);
                        if (error)
                            return "memphis." + error;
                    }
                }
                if (message._raw != null && message.hasOwnProperty("_raw"))
                    if (!(message._raw && typeof message._raw.length === "number" || $util.isString(message._raw)))
                        return "_raw: buffer expected";
                if (message._plumberId != null && message.hasOwnProperty("_plumberId"))
                    if (!$util.isString(message._plumberId))
                        return "_plumberId: string expected";
                return null;
            };

            /**
             * Creates a ReadRecord message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.ReadRecord
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.ReadRecord} ReadRecord
             */
            ReadRecord.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.ReadRecord)
                    return object;
                var message = new $root.protos.records.ReadRecord();
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.num != null)
                    if ($util.Long)
                        (message.num = $util.Long.fromValue(object.num)).unsigned = false;
                    else if (typeof object.num === "string")
                        message.num = parseInt(object.num, 10);
                    else if (typeof object.num === "number")
                        message.num = object.num;
                    else if (typeof object.num === "object")
                        message.num = new $util.LongBits(object.num.low >>> 0, object.num.high >>> 0).toNumber();
                if (object.metadata) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".protos.records.ReadRecord.metadata: object expected");
                    message.metadata = {};
                    for (var keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i)
                        message.metadata[keys[i]] = String(object.metadata[keys[i]]);
                }
                if (object.receivedAtUnixTsUtc != null)
                    if ($util.Long)
                        (message.receivedAtUnixTsUtc = $util.Long.fromValue(object.receivedAtUnixTsUtc)).unsigned = false;
                    else if (typeof object.receivedAtUnixTsUtc === "string")
                        message.receivedAtUnixTsUtc = parseInt(object.receivedAtUnixTsUtc, 10);
                    else if (typeof object.receivedAtUnixTsUtc === "number")
                        message.receivedAtUnixTsUtc = object.receivedAtUnixTsUtc;
                    else if (typeof object.receivedAtUnixTsUtc === "object")
                        message.receivedAtUnixTsUtc = new $util.LongBits(object.receivedAtUnixTsUtc.low >>> 0, object.receivedAtUnixTsUtc.high >>> 0).toNumber();
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.records.ReadRecord.kafka: object expected");
                    message.kafka = $root.protos.records.Kafka.fromObject(object.kafka);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.records.ReadRecord.rabbit: object expected");
                    message.rabbit = $root.protos.records.Rabbit.fromObject(object.rabbit);
                }
                if (object.activemq != null) {
                    if (typeof object.activemq !== "object")
                        throw TypeError(".protos.records.ReadRecord.activemq: object expected");
                    message.activemq = $root.protos.records.ActiveMQ.fromObject(object.activemq);
                }
                if (object.awsSqs != null) {
                    if (typeof object.awsSqs !== "object")
                        throw TypeError(".protos.records.ReadRecord.awsSqs: object expected");
                    message.awsSqs = $root.protos.records.AWSSQS.fromObject(object.awsSqs);
                }
                if (object.azureEventHub != null) {
                    if (typeof object.azureEventHub !== "object")
                        throw TypeError(".protos.records.ReadRecord.azureEventHub: object expected");
                    message.azureEventHub = $root.protos.records.AzureEventHub.fromObject(object.azureEventHub);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.records.ReadRecord.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.records.AzureServiceBus.fromObject(object.azureServiceBus);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.records.ReadRecord.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.records.GCPPubSub.fromObject(object.gcpPubsub);
                }
                if (object.kubemq != null) {
                    if (typeof object.kubemq !== "object")
                        throw TypeError(".protos.records.ReadRecord.kubemq: object expected");
                    message.kubemq = $root.protos.records.KubeMQ.fromObject(object.kubemq);
                }
                if (object.mongo != null) {
                    if (typeof object.mongo !== "object")
                        throw TypeError(".protos.records.ReadRecord.mongo: object expected");
                    message.mongo = $root.protos.records.Mongo.fromObject(object.mongo);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.records.ReadRecord.mqtt: object expected");
                    message.mqtt = $root.protos.records.MQTT.fromObject(object.mqtt);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.records.ReadRecord.nats: object expected");
                    message.nats = $root.protos.records.Nats.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.records.ReadRecord.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.records.NatsStreaming.fromObject(object.natsStreaming);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.records.ReadRecord.nsq: object expected");
                    message.nsq = $root.protos.records.NSQ.fromObject(object.nsq);
                }
                if (object.postgres != null) {
                    if (typeof object.postgres !== "object")
                        throw TypeError(".protos.records.ReadRecord.postgres: object expected");
                    message.postgres = $root.protos.records.Postgres.fromObject(object.postgres);
                }
                if (object.pulsar != null) {
                    if (typeof object.pulsar !== "object")
                        throw TypeError(".protos.records.ReadRecord.pulsar: object expected");
                    message.pulsar = $root.protos.records.Pulsar.fromObject(object.pulsar);
                }
                if (object.rabbitStreams != null) {
                    if (typeof object.rabbitStreams !== "object")
                        throw TypeError(".protos.records.ReadRecord.rabbitStreams: object expected");
                    message.rabbitStreams = $root.protos.records.RabbitStreams.fromObject(object.rabbitStreams);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.records.ReadRecord.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.records.RedisPubsub.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.records.ReadRecord.redisStreams: object expected");
                    message.redisStreams = $root.protos.records.RedisStreams.fromObject(object.redisStreams);
                }
                if (object.natsJetstream != null) {
                    if (typeof object.natsJetstream !== "object")
                        throw TypeError(".protos.records.ReadRecord.natsJetstream: object expected");
                    message.natsJetstream = $root.protos.records.NatsJetstream.fromObject(object.natsJetstream);
                }
                if (object.awsKinesis != null) {
                    if (typeof object.awsKinesis !== "object")
                        throw TypeError(".protos.records.ReadRecord.awsKinesis: object expected");
                    message.awsKinesis = $root.protos.records.AWSKinesis.fromObject(object.awsKinesis);
                }
                if (object.memphis != null) {
                    if (typeof object.memphis !== "object")
                        throw TypeError(".protos.records.ReadRecord.memphis: object expected");
                    message.memphis = $root.protos.records.Memphis.fromObject(object.memphis);
                }
                if (object._raw != null)
                    if (typeof object._raw === "string")
                        $util.base64.decode(object._raw, message._raw = $util.newBuffer($util.base64.length(object._raw)), 0);
                    else if (object._raw.length)
                        message._raw = object._raw;
                if (object._plumberId != null)
                    message._plumberId = String(object._plumberId);
                return message;
            };

            /**
             * Creates a plain object from a ReadRecord message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.ReadRecord
             * @static
             * @param {protos.records.ReadRecord} message ReadRecord
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadRecord.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.metadata = {};
                if (options.defaults) {
                    object.messageId = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.num = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.receivedAtUnixTsUtc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.receivedAtUnixTsUtc = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    if (options.bytes === String)
                        object._raw = "";
                    else {
                        object._raw = [];
                        if (options.bytes !== Array)
                            object._raw = $util.newBuffer(object._raw);
                    }
                    object._plumberId = "";
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                if (message.num != null && message.hasOwnProperty("num"))
                    if (typeof message.num === "number")
                        object.num = options.longs === String ? String(message.num) : message.num;
                    else
                        object.num = options.longs === String ? $util.Long.prototype.toString.call(message.num) : options.longs === Number ? new $util.LongBits(message.num.low >>> 0, message.num.high >>> 0).toNumber() : message.num;
                var keys2;
                if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                    object.metadata = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.metadata[keys2[j]] = message.metadata[keys2[j]];
                }
                if (message.receivedAtUnixTsUtc != null && message.hasOwnProperty("receivedAtUnixTsUtc"))
                    if (typeof message.receivedAtUnixTsUtc === "number")
                        object.receivedAtUnixTsUtc = options.longs === String ? String(message.receivedAtUnixTsUtc) : message.receivedAtUnixTsUtc;
                    else
                        object.receivedAtUnixTsUtc = options.longs === String ? $util.Long.prototype.toString.call(message.receivedAtUnixTsUtc) : options.longs === Number ? new $util.LongBits(message.receivedAtUnixTsUtc.low >>> 0, message.receivedAtUnixTsUtc.high >>> 0).toNumber() : message.receivedAtUnixTsUtc;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    object.kafka = $root.protos.records.Kafka.toObject(message.kafka, options);
                    if (options.oneofs)
                        object.Record = "kafka";
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    object.rabbit = $root.protos.records.Rabbit.toObject(message.rabbit, options);
                    if (options.oneofs)
                        object.Record = "rabbit";
                }
                if (message.activemq != null && message.hasOwnProperty("activemq")) {
                    object.activemq = $root.protos.records.ActiveMQ.toObject(message.activemq, options);
                    if (options.oneofs)
                        object.Record = "activemq";
                }
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs")) {
                    object.awsSqs = $root.protos.records.AWSSQS.toObject(message.awsSqs, options);
                    if (options.oneofs)
                        object.Record = "awsSqs";
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    object.azureEventHub = $root.protos.records.AzureEventHub.toObject(message.azureEventHub, options);
                    if (options.oneofs)
                        object.Record = "azureEventHub";
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    object.azureServiceBus = $root.protos.records.AzureServiceBus.toObject(message.azureServiceBus, options);
                    if (options.oneofs)
                        object.Record = "azureServiceBus";
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    object.gcpPubsub = $root.protos.records.GCPPubSub.toObject(message.gcpPubsub, options);
                    if (options.oneofs)
                        object.Record = "gcpPubsub";
                }
                if (message.kubemq != null && message.hasOwnProperty("kubemq")) {
                    object.kubemq = $root.protos.records.KubeMQ.toObject(message.kubemq, options);
                    if (options.oneofs)
                        object.Record = "kubemq";
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    object.mongo = $root.protos.records.Mongo.toObject(message.mongo, options);
                    if (options.oneofs)
                        object.Record = "mongo";
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    object.mqtt = $root.protos.records.MQTT.toObject(message.mqtt, options);
                    if (options.oneofs)
                        object.Record = "mqtt";
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    object.nats = $root.protos.records.Nats.toObject(message.nats, options);
                    if (options.oneofs)
                        object.Record = "nats";
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    object.natsStreaming = $root.protos.records.NatsStreaming.toObject(message.natsStreaming, options);
                    if (options.oneofs)
                        object.Record = "natsStreaming";
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    object.nsq = $root.protos.records.NSQ.toObject(message.nsq, options);
                    if (options.oneofs)
                        object.Record = "nsq";
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    object.postgres = $root.protos.records.Postgres.toObject(message.postgres, options);
                    if (options.oneofs)
                        object.Record = "postgres";
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    object.pulsar = $root.protos.records.Pulsar.toObject(message.pulsar, options);
                    if (options.oneofs)
                        object.Record = "pulsar";
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    object.rabbitStreams = $root.protos.records.RabbitStreams.toObject(message.rabbitStreams, options);
                    if (options.oneofs)
                        object.Record = "rabbitStreams";
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    object.redisPubsub = $root.protos.records.RedisPubsub.toObject(message.redisPubsub, options);
                    if (options.oneofs)
                        object.Record = "redisPubsub";
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    object.redisStreams = $root.protos.records.RedisStreams.toObject(message.redisStreams, options);
                    if (options.oneofs)
                        object.Record = "redisStreams";
                }
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream")) {
                    object.natsJetstream = $root.protos.records.NatsJetstream.toObject(message.natsJetstream, options);
                    if (options.oneofs)
                        object.Record = "natsJetstream";
                }
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis")) {
                    object.awsKinesis = $root.protos.records.AWSKinesis.toObject(message.awsKinesis, options);
                    if (options.oneofs)
                        object.Record = "awsKinesis";
                }
                if (message.memphis != null && message.hasOwnProperty("memphis")) {
                    object.memphis = $root.protos.records.Memphis.toObject(message.memphis, options);
                    if (options.oneofs)
                        object.Record = "memphis";
                }
                if (message._raw != null && message.hasOwnProperty("_raw"))
                    object._raw = options.bytes === String ? $util.base64.encode(message._raw, 0, message._raw.length) : options.bytes === Array ? Array.prototype.slice.call(message._raw) : message._raw;
                if (message._plumberId != null && message.hasOwnProperty("_plumberId"))
                    object._plumberId = message._plumberId;
                return object;
            };

            /**
             * Converts this ReadRecord to JSON.
             * @function toJSON
             * @memberof protos.records.ReadRecord
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadRecord.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadRecord;
        })();

        records.WriteRecord = (function() {

            /**
             * Properties of a WriteRecord.
             * @memberof protos.records
             * @interface IWriteRecord
             * @property {string|null} [input] WriteRecord input
             * @property {Object.<string,string>|null} [inputMetadata] WriteRecord inputMetadata
             */

            /**
             * Constructs a new WriteRecord.
             * @memberof protos.records
             * @classdesc Represents a WriteRecord.
             * @implements IWriteRecord
             * @constructor
             * @param {protos.records.IWriteRecord=} [properties] Properties to set
             */
            function WriteRecord(properties) {
                this.inputMetadata = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteRecord input.
             * @member {string} input
             * @memberof protos.records.WriteRecord
             * @instance
             */
            WriteRecord.prototype.input = "";

            /**
             * WriteRecord inputMetadata.
             * @member {Object.<string,string>} inputMetadata
             * @memberof protos.records.WriteRecord
             * @instance
             */
            WriteRecord.prototype.inputMetadata = $util.emptyObject;

            /**
             * Creates a new WriteRecord instance using the specified properties.
             * @function create
             * @memberof protos.records.WriteRecord
             * @static
             * @param {protos.records.IWriteRecord=} [properties] Properties to set
             * @returns {protos.records.WriteRecord} WriteRecord instance
             */
            WriteRecord.create = function create(properties) {
                return new WriteRecord(properties);
            };

            /**
             * Encodes the specified WriteRecord message. Does not implicitly {@link protos.records.WriteRecord.verify|verify} messages.
             * @function encode
             * @memberof protos.records.WriteRecord
             * @static
             * @param {protos.records.IWriteRecord} message WriteRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteRecord.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.input != null && Object.hasOwnProperty.call(message, "input"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.input);
                if (message.inputMetadata != null && Object.hasOwnProperty.call(message, "inputMetadata"))
                    for (var keys = Object.keys(message.inputMetadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.inputMetadata[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteRecord message, length delimited. Does not implicitly {@link protos.records.WriteRecord.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.WriteRecord
             * @static
             * @param {protos.records.IWriteRecord} message WriteRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteRecord.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteRecord message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.WriteRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.WriteRecord} WriteRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteRecord.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.WriteRecord(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.input = reader.string();
                        break;
                    case 2:
                        if (message.inputMetadata === $util.emptyObject)
                            message.inputMetadata = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.inputMetadata[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteRecord message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.WriteRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.WriteRecord} WriteRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteRecord.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteRecord message.
             * @function verify
             * @memberof protos.records.WriteRecord
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteRecord.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.input != null && message.hasOwnProperty("input"))
                    if (!$util.isString(message.input))
                        return "input: string expected";
                if (message.inputMetadata != null && message.hasOwnProperty("inputMetadata")) {
                    if (!$util.isObject(message.inputMetadata))
                        return "inputMetadata: object expected";
                    var key = Object.keys(message.inputMetadata);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.inputMetadata[key[i]]))
                            return "inputMetadata: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a WriteRecord message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.WriteRecord
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.WriteRecord} WriteRecord
             */
            WriteRecord.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.WriteRecord)
                    return object;
                var message = new $root.protos.records.WriteRecord();
                if (object.input != null)
                    message.input = String(object.input);
                if (object.inputMetadata) {
                    if (typeof object.inputMetadata !== "object")
                        throw TypeError(".protos.records.WriteRecord.inputMetadata: object expected");
                    message.inputMetadata = {};
                    for (var keys = Object.keys(object.inputMetadata), i = 0; i < keys.length; ++i)
                        message.inputMetadata[keys[i]] = String(object.inputMetadata[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteRecord message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.WriteRecord
             * @static
             * @param {protos.records.WriteRecord} message WriteRecord
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteRecord.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.inputMetadata = {};
                if (options.defaults)
                    object.input = "";
                if (message.input != null && message.hasOwnProperty("input"))
                    object.input = message.input;
                var keys2;
                if (message.inputMetadata && (keys2 = Object.keys(message.inputMetadata)).length) {
                    object.inputMetadata = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.inputMetadata[keys2[j]] = message.inputMetadata[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this WriteRecord to JSON.
             * @function toJSON
             * @memberof protos.records.WriteRecord
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteRecord.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteRecord;
        })();

        records.ErrorRecord = (function() {

            /**
             * Properties of an ErrorRecord.
             * @memberof protos.records
             * @interface IErrorRecord
             * @property {number|Long|null} [occurredAtUnixTsUtc] ErrorRecord occurredAtUnixTsUtc
             * @property {string|null} [error] ErrorRecord error
             * @property {Object.<string,Uint8Array>|null} [metadata] ErrorRecord metadata
             */

            /**
             * Constructs a new ErrorRecord.
             * @memberof protos.records
             * @classdesc Represents an ErrorRecord.
             * @implements IErrorRecord
             * @constructor
             * @param {protos.records.IErrorRecord=} [properties] Properties to set
             */
            function ErrorRecord(properties) {
                this.metadata = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ErrorRecord occurredAtUnixTsUtc.
             * @member {number|Long} occurredAtUnixTsUtc
             * @memberof protos.records.ErrorRecord
             * @instance
             */
            ErrorRecord.prototype.occurredAtUnixTsUtc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ErrorRecord error.
             * @member {string} error
             * @memberof protos.records.ErrorRecord
             * @instance
             */
            ErrorRecord.prototype.error = "";

            /**
             * ErrorRecord metadata.
             * @member {Object.<string,Uint8Array>} metadata
             * @memberof protos.records.ErrorRecord
             * @instance
             */
            ErrorRecord.prototype.metadata = $util.emptyObject;

            /**
             * Creates a new ErrorRecord instance using the specified properties.
             * @function create
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {protos.records.IErrorRecord=} [properties] Properties to set
             * @returns {protos.records.ErrorRecord} ErrorRecord instance
             */
            ErrorRecord.create = function create(properties) {
                return new ErrorRecord(properties);
            };

            /**
             * Encodes the specified ErrorRecord message. Does not implicitly {@link protos.records.ErrorRecord.verify|verify} messages.
             * @function encode
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {protos.records.IErrorRecord} message ErrorRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorRecord.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.occurredAtUnixTsUtc != null && Object.hasOwnProperty.call(message, "occurredAtUnixTsUtc"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.occurredAtUnixTsUtc);
                if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.error);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    for (var keys = Object.keys(message.metadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).bytes(message.metadata[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ErrorRecord message, length delimited. Does not implicitly {@link protos.records.ErrorRecord.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {protos.records.IErrorRecord} message ErrorRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorRecord.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ErrorRecord message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.ErrorRecord} ErrorRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorRecord.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.ErrorRecord(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.occurredAtUnixTsUtc = reader.int64();
                        break;
                    case 2:
                        message.error = reader.string();
                        break;
                    case 3:
                        if (message.metadata === $util.emptyObject)
                            message.metadata = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = [];
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.metadata[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ErrorRecord message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.ErrorRecord} ErrorRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorRecord.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ErrorRecord message.
             * @function verify
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ErrorRecord.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.occurredAtUnixTsUtc != null && message.hasOwnProperty("occurredAtUnixTsUtc"))
                    if (!$util.isInteger(message.occurredAtUnixTsUtc) && !(message.occurredAtUnixTsUtc && $util.isInteger(message.occurredAtUnixTsUtc.low) && $util.isInteger(message.occurredAtUnixTsUtc.high)))
                        return "occurredAtUnixTsUtc: integer|Long expected";
                if (message.error != null && message.hasOwnProperty("error"))
                    if (!$util.isString(message.error))
                        return "error: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    if (!$util.isObject(message.metadata))
                        return "metadata: object expected";
                    var key = Object.keys(message.metadata);
                    for (var i = 0; i < key.length; ++i)
                        if (!(message.metadata[key[i]] && typeof message.metadata[key[i]].length === "number" || $util.isString(message.metadata[key[i]])))
                            return "metadata: buffer{k:string} expected";
                }
                return null;
            };

            /**
             * Creates an ErrorRecord message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.ErrorRecord} ErrorRecord
             */
            ErrorRecord.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.ErrorRecord)
                    return object;
                var message = new $root.protos.records.ErrorRecord();
                if (object.occurredAtUnixTsUtc != null)
                    if ($util.Long)
                        (message.occurredAtUnixTsUtc = $util.Long.fromValue(object.occurredAtUnixTsUtc)).unsigned = false;
                    else if (typeof object.occurredAtUnixTsUtc === "string")
                        message.occurredAtUnixTsUtc = parseInt(object.occurredAtUnixTsUtc, 10);
                    else if (typeof object.occurredAtUnixTsUtc === "number")
                        message.occurredAtUnixTsUtc = object.occurredAtUnixTsUtc;
                    else if (typeof object.occurredAtUnixTsUtc === "object")
                        message.occurredAtUnixTsUtc = new $util.LongBits(object.occurredAtUnixTsUtc.low >>> 0, object.occurredAtUnixTsUtc.high >>> 0).toNumber();
                if (object.error != null)
                    message.error = String(object.error);
                if (object.metadata) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".protos.records.ErrorRecord.metadata: object expected");
                    message.metadata = {};
                    for (var keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i)
                        if (typeof object.metadata[keys[i]] === "string")
                            $util.base64.decode(object.metadata[keys[i]], message.metadata[keys[i]] = $util.newBuffer($util.base64.length(object.metadata[keys[i]])), 0);
                        else if (object.metadata[keys[i]].length)
                            message.metadata[keys[i]] = object.metadata[keys[i]];
                }
                return message;
            };

            /**
             * Creates a plain object from an ErrorRecord message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {protos.records.ErrorRecord} message ErrorRecord
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ErrorRecord.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.metadata = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.occurredAtUnixTsUtc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.occurredAtUnixTsUtc = options.longs === String ? "0" : 0;
                    object.error = "";
                }
                if (message.occurredAtUnixTsUtc != null && message.hasOwnProperty("occurredAtUnixTsUtc"))
                    if (typeof message.occurredAtUnixTsUtc === "number")
                        object.occurredAtUnixTsUtc = options.longs === String ? String(message.occurredAtUnixTsUtc) : message.occurredAtUnixTsUtc;
                    else
                        object.occurredAtUnixTsUtc = options.longs === String ? $util.Long.prototype.toString.call(message.occurredAtUnixTsUtc) : options.longs === Number ? new $util.LongBits(message.occurredAtUnixTsUtc.low >>> 0, message.occurredAtUnixTsUtc.high >>> 0).toNumber() : message.occurredAtUnixTsUtc;
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = message.error;
                var keys2;
                if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                    object.metadata = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.metadata[keys2[j]] = options.bytes === String ? $util.base64.encode(message.metadata[keys2[j]], 0, message.metadata[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata[keys2[j]]) : message.metadata[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this ErrorRecord to JSON.
             * @function toJSON
             * @memberof protos.records.ErrorRecord
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ErrorRecord.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ErrorRecord;
        })();

        records.ActiveMQ = (function() {

            /**
             * Properties of an ActiveMQ.
             * @memberof protos.records
             * @interface IActiveMQ
             * @property {string|null} [destination] ActiveMQ destination
             * @property {string|null} [contentType] ActiveMQ contentType
             * @property {string|null} [subscriptionId] ActiveMQ subscriptionId
             * @property {number|Long|null} [timestamp] ActiveMQ timestamp
             * @property {Uint8Array|null} [value] ActiveMQ value
             */

            /**
             * Constructs a new ActiveMQ.
             * @memberof protos.records
             * @classdesc Represents an ActiveMQ.
             * @implements IActiveMQ
             * @constructor
             * @param {protos.records.IActiveMQ=} [properties] Properties to set
             */
            function ActiveMQ(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActiveMQ destination.
             * @member {string} destination
             * @memberof protos.records.ActiveMQ
             * @instance
             */
            ActiveMQ.prototype.destination = "";

            /**
             * ActiveMQ contentType.
             * @member {string} contentType
             * @memberof protos.records.ActiveMQ
             * @instance
             */
            ActiveMQ.prototype.contentType = "";

            /**
             * ActiveMQ subscriptionId.
             * @member {string} subscriptionId
             * @memberof protos.records.ActiveMQ
             * @instance
             */
            ActiveMQ.prototype.subscriptionId = "";

            /**
             * ActiveMQ timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.ActiveMQ
             * @instance
             */
            ActiveMQ.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ActiveMQ value.
             * @member {Uint8Array} value
             * @memberof protos.records.ActiveMQ
             * @instance
             */
            ActiveMQ.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new ActiveMQ instance using the specified properties.
             * @function create
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {protos.records.IActiveMQ=} [properties] Properties to set
             * @returns {protos.records.ActiveMQ} ActiveMQ instance
             */
            ActiveMQ.create = function create(properties) {
                return new ActiveMQ(properties);
            };

            /**
             * Encodes the specified ActiveMQ message. Does not implicitly {@link protos.records.ActiveMQ.verify|verify} messages.
             * @function encode
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {protos.records.IActiveMQ} message ActiveMQ message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQ.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.destination);
                if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.contentType);
                if (message.subscriptionId != null && Object.hasOwnProperty.call(message, "subscriptionId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.subscriptionId);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestamp);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified ActiveMQ message, length delimited. Does not implicitly {@link protos.records.ActiveMQ.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {protos.records.IActiveMQ} message ActiveMQ message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQ.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ActiveMQ message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.ActiveMQ} ActiveMQ
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQ.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.ActiveMQ();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.destination = reader.string();
                        break;
                    case 2:
                        message.contentType = reader.string();
                        break;
                    case 3:
                        message.subscriptionId = reader.string();
                        break;
                    case 4:
                        message.timestamp = reader.int64();
                        break;
                    case 5:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ActiveMQ message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.ActiveMQ} ActiveMQ
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQ.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ActiveMQ message.
             * @function verify
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActiveMQ.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.destination != null && message.hasOwnProperty("destination"))
                    if (!$util.isString(message.destination))
                        return "destination: string expected";
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    if (!$util.isString(message.contentType))
                        return "contentType: string expected";
                if (message.subscriptionId != null && message.hasOwnProperty("subscriptionId"))
                    if (!$util.isString(message.subscriptionId))
                        return "subscriptionId: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an ActiveMQ message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.ActiveMQ} ActiveMQ
             */
            ActiveMQ.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.ActiveMQ)
                    return object;
                var message = new $root.protos.records.ActiveMQ();
                if (object.destination != null)
                    message.destination = String(object.destination);
                if (object.contentType != null)
                    message.contentType = String(object.contentType);
                if (object.subscriptionId != null)
                    message.subscriptionId = String(object.subscriptionId);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an ActiveMQ message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {protos.records.ActiveMQ} message ActiveMQ
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ActiveMQ.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.destination = "";
                    object.contentType = "";
                    object.subscriptionId = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.destination != null && message.hasOwnProperty("destination"))
                    object.destination = message.destination;
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    object.contentType = message.contentType;
                if (message.subscriptionId != null && message.hasOwnProperty("subscriptionId"))
                    object.subscriptionId = message.subscriptionId;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this ActiveMQ to JSON.
             * @function toJSON
             * @memberof protos.records.ActiveMQ
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ActiveMQ.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ActiveMQ;
        })();

        records.AWSKinesis = (function() {

            /**
             * Properties of a AWSKinesis.
             * @memberof protos.records
             * @interface IAWSKinesis
             * @property {string|null} [partitionKey] AWSKinesis partitionKey
             * @property {string|null} [sequenceNumber] AWSKinesis sequenceNumber
             * @property {string|null} [encryptionType] AWSKinesis encryptionType
             * @property {string|null} [shardId] AWSKinesis shardId
             * @property {Uint8Array|null} [value] AWSKinesis value
             */

            /**
             * Constructs a new AWSKinesis.
             * @memberof protos.records
             * @classdesc Represents a AWSKinesis.
             * @implements IAWSKinesis
             * @constructor
             * @param {protos.records.IAWSKinesis=} [properties] Properties to set
             */
            function AWSKinesis(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSKinesis partitionKey.
             * @member {string} partitionKey
             * @memberof protos.records.AWSKinesis
             * @instance
             */
            AWSKinesis.prototype.partitionKey = "";

            /**
             * AWSKinesis sequenceNumber.
             * @member {string} sequenceNumber
             * @memberof protos.records.AWSKinesis
             * @instance
             */
            AWSKinesis.prototype.sequenceNumber = "";

            /**
             * AWSKinesis encryptionType.
             * @member {string} encryptionType
             * @memberof protos.records.AWSKinesis
             * @instance
             */
            AWSKinesis.prototype.encryptionType = "";

            /**
             * AWSKinesis shardId.
             * @member {string} shardId
             * @memberof protos.records.AWSKinesis
             * @instance
             */
            AWSKinesis.prototype.shardId = "";

            /**
             * AWSKinesis value.
             * @member {Uint8Array} value
             * @memberof protos.records.AWSKinesis
             * @instance
             */
            AWSKinesis.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new AWSKinesis instance using the specified properties.
             * @function create
             * @memberof protos.records.AWSKinesis
             * @static
             * @param {protos.records.IAWSKinesis=} [properties] Properties to set
             * @returns {protos.records.AWSKinesis} AWSKinesis instance
             */
            AWSKinesis.create = function create(properties) {
                return new AWSKinesis(properties);
            };

            /**
             * Encodes the specified AWSKinesis message. Does not implicitly {@link protos.records.AWSKinesis.verify|verify} messages.
             * @function encode
             * @memberof protos.records.AWSKinesis
             * @static
             * @param {protos.records.IAWSKinesis} message AWSKinesis message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSKinesis.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.partitionKey != null && Object.hasOwnProperty.call(message, "partitionKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.partitionKey);
                if (message.sequenceNumber != null && Object.hasOwnProperty.call(message, "sequenceNumber"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.sequenceNumber);
                if (message.encryptionType != null && Object.hasOwnProperty.call(message, "encryptionType"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.encryptionType);
                if (message.shardId != null && Object.hasOwnProperty.call(message, "shardId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.shardId);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified AWSKinesis message, length delimited. Does not implicitly {@link protos.records.AWSKinesis.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.AWSKinesis
             * @static
             * @param {protos.records.IAWSKinesis} message AWSKinesis message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSKinesis.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSKinesis message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.AWSKinesis
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.AWSKinesis} AWSKinesis
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSKinesis.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.AWSKinesis();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.partitionKey = reader.string();
                        break;
                    case 2:
                        message.sequenceNumber = reader.string();
                        break;
                    case 3:
                        message.encryptionType = reader.string();
                        break;
                    case 4:
                        message.shardId = reader.string();
                        break;
                    case 5:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSKinesis message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.AWSKinesis
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.AWSKinesis} AWSKinesis
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSKinesis.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSKinesis message.
             * @function verify
             * @memberof protos.records.AWSKinesis
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSKinesis.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    if (!$util.isString(message.partitionKey))
                        return "partitionKey: string expected";
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    if (!$util.isString(message.sequenceNumber))
                        return "sequenceNumber: string expected";
                if (message.encryptionType != null && message.hasOwnProperty("encryptionType"))
                    if (!$util.isString(message.encryptionType))
                        return "encryptionType: string expected";
                if (message.shardId != null && message.hasOwnProperty("shardId"))
                    if (!$util.isString(message.shardId))
                        return "shardId: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a AWSKinesis message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.AWSKinesis
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.AWSKinesis} AWSKinesis
             */
            AWSKinesis.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.AWSKinesis)
                    return object;
                var message = new $root.protos.records.AWSKinesis();
                if (object.partitionKey != null)
                    message.partitionKey = String(object.partitionKey);
                if (object.sequenceNumber != null)
                    message.sequenceNumber = String(object.sequenceNumber);
                if (object.encryptionType != null)
                    message.encryptionType = String(object.encryptionType);
                if (object.shardId != null)
                    message.shardId = String(object.shardId);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a AWSKinesis message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.AWSKinesis
             * @static
             * @param {protos.records.AWSKinesis} message AWSKinesis
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSKinesis.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.partitionKey = "";
                    object.sequenceNumber = "";
                    object.encryptionType = "";
                    object.shardId = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    object.partitionKey = message.partitionKey;
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    object.sequenceNumber = message.sequenceNumber;
                if (message.encryptionType != null && message.hasOwnProperty("encryptionType"))
                    object.encryptionType = message.encryptionType;
                if (message.shardId != null && message.hasOwnProperty("shardId"))
                    object.shardId = message.shardId;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this AWSKinesis to JSON.
             * @function toJSON
             * @memberof protos.records.AWSKinesis
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSKinesis.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSKinesis;
        })();

        records.AWSSQS = (function() {

            /**
             * Properties of a AWSSQS.
             * @memberof protos.records
             * @interface IAWSSQS
             * @property {string|null} [id] AWSSQS id
             * @property {number|Long|null} [timestamp] AWSSQS timestamp
             * @property {string|null} [recipientHandle] AWSSQS recipientHandle
             * @property {Object.<string,string>|null} [attributes] AWSSQS attributes
             * @property {Uint8Array|null} [value] AWSSQS value
             */

            /**
             * Constructs a new AWSSQS.
             * @memberof protos.records
             * @classdesc Represents a AWSSQS.
             * @implements IAWSSQS
             * @constructor
             * @param {protos.records.IAWSSQS=} [properties] Properties to set
             */
            function AWSSQS(properties) {
                this.attributes = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSQS id.
             * @member {string} id
             * @memberof protos.records.AWSSQS
             * @instance
             */
            AWSSQS.prototype.id = "";

            /**
             * AWSSQS timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.AWSSQS
             * @instance
             */
            AWSSQS.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AWSSQS recipientHandle.
             * @member {string} recipientHandle
             * @memberof protos.records.AWSSQS
             * @instance
             */
            AWSSQS.prototype.recipientHandle = "";

            /**
             * AWSSQS attributes.
             * @member {Object.<string,string>} attributes
             * @memberof protos.records.AWSSQS
             * @instance
             */
            AWSSQS.prototype.attributes = $util.emptyObject;

            /**
             * AWSSQS value.
             * @member {Uint8Array} value
             * @memberof protos.records.AWSSQS
             * @instance
             */
            AWSSQS.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new AWSSQS instance using the specified properties.
             * @function create
             * @memberof protos.records.AWSSQS
             * @static
             * @param {protos.records.IAWSSQS=} [properties] Properties to set
             * @returns {protos.records.AWSSQS} AWSSQS instance
             */
            AWSSQS.create = function create(properties) {
                return new AWSSQS(properties);
            };

            /**
             * Encodes the specified AWSSQS message. Does not implicitly {@link protos.records.AWSSQS.verify|verify} messages.
             * @function encode
             * @memberof protos.records.AWSSQS
             * @static
             * @param {protos.records.IAWSSQS} message AWSSQS message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQS.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                if (message.recipientHandle != null && Object.hasOwnProperty.call(message, "recipientHandle"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.recipientHandle);
                if (message.attributes != null && Object.hasOwnProperty.call(message, "attributes"))
                    for (var keys = Object.keys(message.attributes), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.attributes[keys[i]]).ldelim();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified AWSSQS message, length delimited. Does not implicitly {@link protos.records.AWSSQS.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.AWSSQS
             * @static
             * @param {protos.records.IAWSSQS} message AWSSQS message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQS.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSQS message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.AWSSQS
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.AWSSQS} AWSSQS
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQS.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.AWSSQS(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    case 3:
                        message.recipientHandle = reader.string();
                        break;
                    case 4:
                        if (message.attributes === $util.emptyObject)
                            message.attributes = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.attributes[key] = value;
                        break;
                    case 5:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSQS message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.AWSSQS
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.AWSSQS} AWSSQS
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQS.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSQS message.
             * @function verify
             * @memberof protos.records.AWSSQS
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSQS.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.recipientHandle != null && message.hasOwnProperty("recipientHandle"))
                    if (!$util.isString(message.recipientHandle))
                        return "recipientHandle: string expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    if (!$util.isObject(message.attributes))
                        return "attributes: object expected";
                    var key = Object.keys(message.attributes);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.attributes[key[i]]))
                            return "attributes: string{k:string} expected";
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a AWSSQS message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.AWSSQS
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.AWSSQS} AWSSQS
             */
            AWSSQS.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.AWSSQS)
                    return object;
                var message = new $root.protos.records.AWSSQS();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.recipientHandle != null)
                    message.recipientHandle = String(object.recipientHandle);
                if (object.attributes) {
                    if (typeof object.attributes !== "object")
                        throw TypeError(".protos.records.AWSSQS.attributes: object expected");
                    message.attributes = {};
                    for (var keys = Object.keys(object.attributes), i = 0; i < keys.length; ++i)
                        message.attributes[keys[i]] = String(object.attributes[keys[i]]);
                }
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a AWSSQS message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.AWSSQS
             * @static
             * @param {protos.records.AWSSQS} message AWSSQS
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSQS.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.attributes = {};
                if (options.defaults) {
                    object.id = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    object.recipientHandle = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.recipientHandle != null && message.hasOwnProperty("recipientHandle"))
                    object.recipientHandle = message.recipientHandle;
                var keys2;
                if (message.attributes && (keys2 = Object.keys(message.attributes)).length) {
                    object.attributes = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.attributes[keys2[j]] = message.attributes[keys2[j]];
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this AWSSQS to JSON.
             * @function toJSON
             * @memberof protos.records.AWSSQS
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSQS.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSQS;
        })();

        records.AzureEventHub = (function() {

            /**
             * Properties of an AzureEventHub.
             * @memberof protos.records
             * @interface IAzureEventHub
             * @property {string|null} [id] AzureEventHub id
             * @property {Object.<string,string>|null} [systemProperties] AzureEventHub systemProperties
             * @property {number|Long|null} [timestamp] AzureEventHub timestamp
             * @property {Uint8Array|null} [value] AzureEventHub value
             */

            /**
             * Constructs a new AzureEventHub.
             * @memberof protos.records
             * @classdesc Represents an AzureEventHub.
             * @implements IAzureEventHub
             * @constructor
             * @param {protos.records.IAzureEventHub=} [properties] Properties to set
             */
            function AzureEventHub(properties) {
                this.systemProperties = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureEventHub id.
             * @member {string} id
             * @memberof protos.records.AzureEventHub
             * @instance
             */
            AzureEventHub.prototype.id = "";

            /**
             * AzureEventHub systemProperties.
             * @member {Object.<string,string>} systemProperties
             * @memberof protos.records.AzureEventHub
             * @instance
             */
            AzureEventHub.prototype.systemProperties = $util.emptyObject;

            /**
             * AzureEventHub timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.AzureEventHub
             * @instance
             */
            AzureEventHub.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AzureEventHub value.
             * @member {Uint8Array} value
             * @memberof protos.records.AzureEventHub
             * @instance
             */
            AzureEventHub.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new AzureEventHub instance using the specified properties.
             * @function create
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {protos.records.IAzureEventHub=} [properties] Properties to set
             * @returns {protos.records.AzureEventHub} AzureEventHub instance
             */
            AzureEventHub.create = function create(properties) {
                return new AzureEventHub(properties);
            };

            /**
             * Encodes the specified AzureEventHub message. Does not implicitly {@link protos.records.AzureEventHub.verify|verify} messages.
             * @function encode
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {protos.records.IAzureEventHub} message AzureEventHub message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHub.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.systemProperties != null && Object.hasOwnProperty.call(message, "systemProperties"))
                    for (var keys = Object.keys(message.systemProperties), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.systemProperties[keys[i]]).ldelim();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified AzureEventHub message, length delimited. Does not implicitly {@link protos.records.AzureEventHub.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {protos.records.IAzureEventHub} message AzureEventHub message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHub.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureEventHub message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.AzureEventHub} AzureEventHub
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHub.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.AzureEventHub(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        if (message.systemProperties === $util.emptyObject)
                            message.systemProperties = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.systemProperties[key] = value;
                        break;
                    case 3:
                        message.timestamp = reader.int64();
                        break;
                    case 4:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureEventHub message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.AzureEventHub} AzureEventHub
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHub.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureEventHub message.
             * @function verify
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureEventHub.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.systemProperties != null && message.hasOwnProperty("systemProperties")) {
                    if (!$util.isObject(message.systemProperties))
                        return "systemProperties: object expected";
                    var key = Object.keys(message.systemProperties);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.systemProperties[key[i]]))
                            return "systemProperties: string{k:string} expected";
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an AzureEventHub message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.AzureEventHub} AzureEventHub
             */
            AzureEventHub.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.AzureEventHub)
                    return object;
                var message = new $root.protos.records.AzureEventHub();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.systemProperties) {
                    if (typeof object.systemProperties !== "object")
                        throw TypeError(".protos.records.AzureEventHub.systemProperties: object expected");
                    message.systemProperties = {};
                    for (var keys = Object.keys(object.systemProperties), i = 0; i < keys.length; ++i)
                        message.systemProperties[keys[i]] = String(object.systemProperties[keys[i]]);
                }
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an AzureEventHub message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {protos.records.AzureEventHub} message AzureEventHub
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureEventHub.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.systemProperties = {};
                if (options.defaults) {
                    object.id = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                var keys2;
                if (message.systemProperties && (keys2 = Object.keys(message.systemProperties)).length) {
                    object.systemProperties = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.systemProperties[keys2[j]] = message.systemProperties[keys2[j]];
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this AzureEventHub to JSON.
             * @function toJSON
             * @memberof protos.records.AzureEventHub
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureEventHub.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureEventHub;
        })();

        records.AzureServiceBus = (function() {

            /**
             * Properties of an AzureServiceBus.
             * @memberof protos.records
             * @interface IAzureServiceBus
             * @property {string|null} [contentType] AzureServiceBus contentType
             * @property {string|null} [correlationId] AzureServiceBus correlationId
             * @property {Uint8Array|null} [value] AzureServiceBus value
             * @property {number|null} [deliveryCount] AzureServiceBus deliveryCount
             * @property {string|null} [sessionId] AzureServiceBus sessionId
             * @property {number|null} [groupSequence] AzureServiceBus groupSequence
             * @property {string|null} [id] AzureServiceBus id
             * @property {string|null} [label] AzureServiceBus label
             * @property {string|null} [replyTo] AzureServiceBus replyTo
             * @property {string|null} [replyToGroupId] AzureServiceBus replyToGroupId
             * @property {string|null} [to] AzureServiceBus to
             * @property {number|Long|null} [ttl] AzureServiceBus ttl
             * @property {string|null} [lockToken] AzureServiceBus lockToken
             * @property {protos.records.IAzureSystemProperties|null} [systemProperties] AzureServiceBus systemProperties
             * @property {Object.<string,string>|null} [userProperties] AzureServiceBus userProperties
             * @property {number|null} [format] AzureServiceBus format
             */

            /**
             * Constructs a new AzureServiceBus.
             * @memberof protos.records
             * @classdesc Represents an AzureServiceBus.
             * @implements IAzureServiceBus
             * @constructor
             * @param {protos.records.IAzureServiceBus=} [properties] Properties to set
             */
            function AzureServiceBus(properties) {
                this.userProperties = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureServiceBus contentType.
             * @member {string} contentType
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.contentType = "";

            /**
             * AzureServiceBus correlationId.
             * @member {string} correlationId
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.correlationId = "";

            /**
             * AzureServiceBus value.
             * @member {Uint8Array} value
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.value = $util.newBuffer([]);

            /**
             * AzureServiceBus deliveryCount.
             * @member {number} deliveryCount
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.deliveryCount = 0;

            /**
             * AzureServiceBus sessionId.
             * @member {string} sessionId
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.sessionId = "";

            /**
             * AzureServiceBus groupSequence.
             * @member {number} groupSequence
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.groupSequence = 0;

            /**
             * AzureServiceBus id.
             * @member {string} id
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.id = "";

            /**
             * AzureServiceBus label.
             * @member {string} label
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.label = "";

            /**
             * AzureServiceBus replyTo.
             * @member {string} replyTo
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.replyTo = "";

            /**
             * AzureServiceBus replyToGroupId.
             * @member {string} replyToGroupId
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.replyToGroupId = "";

            /**
             * AzureServiceBus to.
             * @member {string} to
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.to = "";

            /**
             * AzureServiceBus ttl.
             * @member {number|Long} ttl
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.ttl = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AzureServiceBus lockToken.
             * @member {string} lockToken
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.lockToken = "";

            /**
             * AzureServiceBus systemProperties.
             * @member {protos.records.IAzureSystemProperties|null|undefined} systemProperties
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.systemProperties = null;

            /**
             * AzureServiceBus userProperties.
             * @member {Object.<string,string>} userProperties
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.userProperties = $util.emptyObject;

            /**
             * AzureServiceBus format.
             * @member {number} format
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.format = 0;

            /**
             * Creates a new AzureServiceBus instance using the specified properties.
             * @function create
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {protos.records.IAzureServiceBus=} [properties] Properties to set
             * @returns {protos.records.AzureServiceBus} AzureServiceBus instance
             */
            AzureServiceBus.create = function create(properties) {
                return new AzureServiceBus(properties);
            };

            /**
             * Encodes the specified AzureServiceBus message. Does not implicitly {@link protos.records.AzureServiceBus.verify|verify} messages.
             * @function encode
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {protos.records.IAzureServiceBus} message AzureServiceBus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.contentType);
                if (message.correlationId != null && Object.hasOwnProperty.call(message, "correlationId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.correlationId);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                if (message.deliveryCount != null && Object.hasOwnProperty.call(message, "deliveryCount"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.deliveryCount);
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.sessionId);
                if (message.groupSequence != null && Object.hasOwnProperty.call(message, "groupSequence"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.groupSequence);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.id);
                if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.label);
                if (message.replyTo != null && Object.hasOwnProperty.call(message, "replyTo"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.replyTo);
                if (message.replyToGroupId != null && Object.hasOwnProperty.call(message, "replyToGroupId"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.replyToGroupId);
                if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.to);
                if (message.ttl != null && Object.hasOwnProperty.call(message, "ttl"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int64(message.ttl);
                if (message.lockToken != null && Object.hasOwnProperty.call(message, "lockToken"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.lockToken);
                if (message.systemProperties != null && Object.hasOwnProperty.call(message, "systemProperties"))
                    $root.protos.records.AzureSystemProperties.encode(message.systemProperties, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.userProperties != null && Object.hasOwnProperty.call(message, "userProperties"))
                    for (var keys = Object.keys(message.userProperties), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 15, wireType 2 =*/122).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.userProperties[keys[i]]).ldelim();
                if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                    writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.format);
                return writer;
            };

            /**
             * Encodes the specified AzureServiceBus message, length delimited. Does not implicitly {@link protos.records.AzureServiceBus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {protos.records.IAzureServiceBus} message AzureServiceBus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureServiceBus message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.AzureServiceBus} AzureServiceBus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.AzureServiceBus(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.contentType = reader.string();
                        break;
                    case 2:
                        message.correlationId = reader.string();
                        break;
                    case 3:
                        message.value = reader.bytes();
                        break;
                    case 4:
                        message.deliveryCount = reader.uint32();
                        break;
                    case 5:
                        message.sessionId = reader.string();
                        break;
                    case 6:
                        message.groupSequence = reader.uint32();
                        break;
                    case 7:
                        message.id = reader.string();
                        break;
                    case 8:
                        message.label = reader.string();
                        break;
                    case 9:
                        message.replyTo = reader.string();
                        break;
                    case 10:
                        message.replyToGroupId = reader.string();
                        break;
                    case 11:
                        message.to = reader.string();
                        break;
                    case 12:
                        message.ttl = reader.int64();
                        break;
                    case 13:
                        message.lockToken = reader.string();
                        break;
                    case 14:
                        message.systemProperties = $root.protos.records.AzureSystemProperties.decode(reader, reader.uint32());
                        break;
                    case 15:
                        if (message.userProperties === $util.emptyObject)
                            message.userProperties = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.userProperties[key] = value;
                        break;
                    case 16:
                        message.format = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureServiceBus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.AzureServiceBus} AzureServiceBus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureServiceBus message.
             * @function verify
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureServiceBus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    if (!$util.isString(message.contentType))
                        return "contentType: string expected";
                if (message.correlationId != null && message.hasOwnProperty("correlationId"))
                    if (!$util.isString(message.correlationId))
                        return "correlationId: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.deliveryCount != null && message.hasOwnProperty("deliveryCount"))
                    if (!$util.isInteger(message.deliveryCount))
                        return "deliveryCount: integer expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.groupSequence != null && message.hasOwnProperty("groupSequence"))
                    if (!$util.isInteger(message.groupSequence))
                        return "groupSequence: integer expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    if (!$util.isString(message.label))
                        return "label: string expected";
                if (message.replyTo != null && message.hasOwnProperty("replyTo"))
                    if (!$util.isString(message.replyTo))
                        return "replyTo: string expected";
                if (message.replyToGroupId != null && message.hasOwnProperty("replyToGroupId"))
                    if (!$util.isString(message.replyToGroupId))
                        return "replyToGroupId: string expected";
                if (message.to != null && message.hasOwnProperty("to"))
                    if (!$util.isString(message.to))
                        return "to: string expected";
                if (message.ttl != null && message.hasOwnProperty("ttl"))
                    if (!$util.isInteger(message.ttl) && !(message.ttl && $util.isInteger(message.ttl.low) && $util.isInteger(message.ttl.high)))
                        return "ttl: integer|Long expected";
                if (message.lockToken != null && message.hasOwnProperty("lockToken"))
                    if (!$util.isString(message.lockToken))
                        return "lockToken: string expected";
                if (message.systemProperties != null && message.hasOwnProperty("systemProperties")) {
                    var error = $root.protos.records.AzureSystemProperties.verify(message.systemProperties);
                    if (error)
                        return "systemProperties." + error;
                }
                if (message.userProperties != null && message.hasOwnProperty("userProperties")) {
                    if (!$util.isObject(message.userProperties))
                        return "userProperties: object expected";
                    var key = Object.keys(message.userProperties);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.userProperties[key[i]]))
                            return "userProperties: string{k:string} expected";
                }
                if (message.format != null && message.hasOwnProperty("format"))
                    if (!$util.isInteger(message.format))
                        return "format: integer expected";
                return null;
            };

            /**
             * Creates an AzureServiceBus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.AzureServiceBus} AzureServiceBus
             */
            AzureServiceBus.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.AzureServiceBus)
                    return object;
                var message = new $root.protos.records.AzureServiceBus();
                if (object.contentType != null)
                    message.contentType = String(object.contentType);
                if (object.correlationId != null)
                    message.correlationId = String(object.correlationId);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.deliveryCount != null)
                    message.deliveryCount = object.deliveryCount >>> 0;
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.groupSequence != null)
                    message.groupSequence = object.groupSequence >>> 0;
                if (object.id != null)
                    message.id = String(object.id);
                if (object.label != null)
                    message.label = String(object.label);
                if (object.replyTo != null)
                    message.replyTo = String(object.replyTo);
                if (object.replyToGroupId != null)
                    message.replyToGroupId = String(object.replyToGroupId);
                if (object.to != null)
                    message.to = String(object.to);
                if (object.ttl != null)
                    if ($util.Long)
                        (message.ttl = $util.Long.fromValue(object.ttl)).unsigned = false;
                    else if (typeof object.ttl === "string")
                        message.ttl = parseInt(object.ttl, 10);
                    else if (typeof object.ttl === "number")
                        message.ttl = object.ttl;
                    else if (typeof object.ttl === "object")
                        message.ttl = new $util.LongBits(object.ttl.low >>> 0, object.ttl.high >>> 0).toNumber();
                if (object.lockToken != null)
                    message.lockToken = String(object.lockToken);
                if (object.systemProperties != null) {
                    if (typeof object.systemProperties !== "object")
                        throw TypeError(".protos.records.AzureServiceBus.systemProperties: object expected");
                    message.systemProperties = $root.protos.records.AzureSystemProperties.fromObject(object.systemProperties);
                }
                if (object.userProperties) {
                    if (typeof object.userProperties !== "object")
                        throw TypeError(".protos.records.AzureServiceBus.userProperties: object expected");
                    message.userProperties = {};
                    for (var keys = Object.keys(object.userProperties), i = 0; i < keys.length; ++i)
                        message.userProperties[keys[i]] = String(object.userProperties[keys[i]]);
                }
                if (object.format != null)
                    message.format = object.format >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an AzureServiceBus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {protos.records.AzureServiceBus} message AzureServiceBus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureServiceBus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.userProperties = {};
                if (options.defaults) {
                    object.contentType = "";
                    object.correlationId = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    object.deliveryCount = 0;
                    object.sessionId = "";
                    object.groupSequence = 0;
                    object.id = "";
                    object.label = "";
                    object.replyTo = "";
                    object.replyToGroupId = "";
                    object.to = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ttl = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ttl = options.longs === String ? "0" : 0;
                    object.lockToken = "";
                    object.systemProperties = null;
                    object.format = 0;
                }
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    object.contentType = message.contentType;
                if (message.correlationId != null && message.hasOwnProperty("correlationId"))
                    object.correlationId = message.correlationId;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.deliveryCount != null && message.hasOwnProperty("deliveryCount"))
                    object.deliveryCount = message.deliveryCount;
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.groupSequence != null && message.hasOwnProperty("groupSequence"))
                    object.groupSequence = message.groupSequence;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = message.label;
                if (message.replyTo != null && message.hasOwnProperty("replyTo"))
                    object.replyTo = message.replyTo;
                if (message.replyToGroupId != null && message.hasOwnProperty("replyToGroupId"))
                    object.replyToGroupId = message.replyToGroupId;
                if (message.to != null && message.hasOwnProperty("to"))
                    object.to = message.to;
                if (message.ttl != null && message.hasOwnProperty("ttl"))
                    if (typeof message.ttl === "number")
                        object.ttl = options.longs === String ? String(message.ttl) : message.ttl;
                    else
                        object.ttl = options.longs === String ? $util.Long.prototype.toString.call(message.ttl) : options.longs === Number ? new $util.LongBits(message.ttl.low >>> 0, message.ttl.high >>> 0).toNumber() : message.ttl;
                if (message.lockToken != null && message.hasOwnProperty("lockToken"))
                    object.lockToken = message.lockToken;
                if (message.systemProperties != null && message.hasOwnProperty("systemProperties"))
                    object.systemProperties = $root.protos.records.AzureSystemProperties.toObject(message.systemProperties, options);
                var keys2;
                if (message.userProperties && (keys2 = Object.keys(message.userProperties)).length) {
                    object.userProperties = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.userProperties[keys2[j]] = message.userProperties[keys2[j]];
                }
                if (message.format != null && message.hasOwnProperty("format"))
                    object.format = message.format;
                return object;
            };

            /**
             * Converts this AzureServiceBus to JSON.
             * @function toJSON
             * @memberof protos.records.AzureServiceBus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureServiceBus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureServiceBus;
        })();

        records.AzureSystemProperties = (function() {

            /**
             * Properties of an AzureSystemProperties.
             * @memberof protos.records
             * @interface IAzureSystemProperties
             * @property {number|Long|null} [lockedUntil] AzureSystemProperties lockedUntil
             * @property {number|Long|null} [sequenceNumber] AzureSystemProperties sequenceNumber
             * @property {number|null} [partitionId] AzureSystemProperties partitionId
             * @property {string|null} [partitionKey] AzureSystemProperties partitionKey
             * @property {number|Long|null} [enqueuedTime] AzureSystemProperties enqueuedTime
             * @property {string|null} [deadLetterSource] AzureSystemProperties deadLetterSource
             * @property {number|Long|null} [scheduledEnqueueTime] AzureSystemProperties scheduledEnqueueTime
             * @property {number|Long|null} [enqueuedSequenceNumber] AzureSystemProperties enqueuedSequenceNumber
             * @property {string|null} [viaPartitionKey] AzureSystemProperties viaPartitionKey
             * @property {Object.<string,string>|null} [annotations] AzureSystemProperties annotations
             */

            /**
             * Constructs a new AzureSystemProperties.
             * @memberof protos.records
             * @classdesc Represents an AzureSystemProperties.
             * @implements IAzureSystemProperties
             * @constructor
             * @param {protos.records.IAzureSystemProperties=} [properties] Properties to set
             */
            function AzureSystemProperties(properties) {
                this.annotations = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureSystemProperties lockedUntil.
             * @member {number|Long} lockedUntil
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.lockedUntil = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AzureSystemProperties sequenceNumber.
             * @member {number|Long} sequenceNumber
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AzureSystemProperties partitionId.
             * @member {number} partitionId
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.partitionId = 0;

            /**
             * AzureSystemProperties partitionKey.
             * @member {string} partitionKey
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.partitionKey = "";

            /**
             * AzureSystemProperties enqueuedTime.
             * @member {number|Long} enqueuedTime
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.enqueuedTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AzureSystemProperties deadLetterSource.
             * @member {string} deadLetterSource
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.deadLetterSource = "";

            /**
             * AzureSystemProperties scheduledEnqueueTime.
             * @member {number|Long} scheduledEnqueueTime
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.scheduledEnqueueTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AzureSystemProperties enqueuedSequenceNumber.
             * @member {number|Long} enqueuedSequenceNumber
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.enqueuedSequenceNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AzureSystemProperties viaPartitionKey.
             * @member {string} viaPartitionKey
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.viaPartitionKey = "";

            /**
             * AzureSystemProperties annotations.
             * @member {Object.<string,string>} annotations
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.annotations = $util.emptyObject;

            /**
             * Creates a new AzureSystemProperties instance using the specified properties.
             * @function create
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {protos.records.IAzureSystemProperties=} [properties] Properties to set
             * @returns {protos.records.AzureSystemProperties} AzureSystemProperties instance
             */
            AzureSystemProperties.create = function create(properties) {
                return new AzureSystemProperties(properties);
            };

            /**
             * Encodes the specified AzureSystemProperties message. Does not implicitly {@link protos.records.AzureSystemProperties.verify|verify} messages.
             * @function encode
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {protos.records.IAzureSystemProperties} message AzureSystemProperties message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureSystemProperties.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.lockedUntil != null && Object.hasOwnProperty.call(message, "lockedUntil"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.lockedUntil);
                if (message.sequenceNumber != null && Object.hasOwnProperty.call(message, "sequenceNumber"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.sequenceNumber);
                if (message.partitionId != null && Object.hasOwnProperty.call(message, "partitionId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.partitionId);
                if (message.partitionKey != null && Object.hasOwnProperty.call(message, "partitionKey"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.partitionKey);
                if (message.enqueuedTime != null && Object.hasOwnProperty.call(message, "enqueuedTime"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.enqueuedTime);
                if (message.deadLetterSource != null && Object.hasOwnProperty.call(message, "deadLetterSource"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.deadLetterSource);
                if (message.scheduledEnqueueTime != null && Object.hasOwnProperty.call(message, "scheduledEnqueueTime"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.scheduledEnqueueTime);
                if (message.enqueuedSequenceNumber != null && Object.hasOwnProperty.call(message, "enqueuedSequenceNumber"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int64(message.enqueuedSequenceNumber);
                if (message.viaPartitionKey != null && Object.hasOwnProperty.call(message, "viaPartitionKey"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.viaPartitionKey);
                if (message.annotations != null && Object.hasOwnProperty.call(message, "annotations"))
                    for (var keys = Object.keys(message.annotations), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.annotations[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AzureSystemProperties message, length delimited. Does not implicitly {@link protos.records.AzureSystemProperties.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {protos.records.IAzureSystemProperties} message AzureSystemProperties message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureSystemProperties.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureSystemProperties message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.AzureSystemProperties} AzureSystemProperties
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureSystemProperties.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.AzureSystemProperties(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.lockedUntil = reader.int64();
                        break;
                    case 2:
                        message.sequenceNumber = reader.int64();
                        break;
                    case 3:
                        message.partitionId = reader.int32();
                        break;
                    case 4:
                        message.partitionKey = reader.string();
                        break;
                    case 5:
                        message.enqueuedTime = reader.int64();
                        break;
                    case 6:
                        message.deadLetterSource = reader.string();
                        break;
                    case 7:
                        message.scheduledEnqueueTime = reader.int64();
                        break;
                    case 8:
                        message.enqueuedSequenceNumber = reader.int64();
                        break;
                    case 9:
                        message.viaPartitionKey = reader.string();
                        break;
                    case 10:
                        if (message.annotations === $util.emptyObject)
                            message.annotations = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.annotations[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureSystemProperties message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.AzureSystemProperties} AzureSystemProperties
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureSystemProperties.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureSystemProperties message.
             * @function verify
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureSystemProperties.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.lockedUntil != null && message.hasOwnProperty("lockedUntil"))
                    if (!$util.isInteger(message.lockedUntil) && !(message.lockedUntil && $util.isInteger(message.lockedUntil.low) && $util.isInteger(message.lockedUntil.high)))
                        return "lockedUntil: integer|Long expected";
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    if (!$util.isInteger(message.sequenceNumber) && !(message.sequenceNumber && $util.isInteger(message.sequenceNumber.low) && $util.isInteger(message.sequenceNumber.high)))
                        return "sequenceNumber: integer|Long expected";
                if (message.partitionId != null && message.hasOwnProperty("partitionId"))
                    if (!$util.isInteger(message.partitionId))
                        return "partitionId: integer expected";
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    if (!$util.isString(message.partitionKey))
                        return "partitionKey: string expected";
                if (message.enqueuedTime != null && message.hasOwnProperty("enqueuedTime"))
                    if (!$util.isInteger(message.enqueuedTime) && !(message.enqueuedTime && $util.isInteger(message.enqueuedTime.low) && $util.isInteger(message.enqueuedTime.high)))
                        return "enqueuedTime: integer|Long expected";
                if (message.deadLetterSource != null && message.hasOwnProperty("deadLetterSource"))
                    if (!$util.isString(message.deadLetterSource))
                        return "deadLetterSource: string expected";
                if (message.scheduledEnqueueTime != null && message.hasOwnProperty("scheduledEnqueueTime"))
                    if (!$util.isInteger(message.scheduledEnqueueTime) && !(message.scheduledEnqueueTime && $util.isInteger(message.scheduledEnqueueTime.low) && $util.isInteger(message.scheduledEnqueueTime.high)))
                        return "scheduledEnqueueTime: integer|Long expected";
                if (message.enqueuedSequenceNumber != null && message.hasOwnProperty("enqueuedSequenceNumber"))
                    if (!$util.isInteger(message.enqueuedSequenceNumber) && !(message.enqueuedSequenceNumber && $util.isInteger(message.enqueuedSequenceNumber.low) && $util.isInteger(message.enqueuedSequenceNumber.high)))
                        return "enqueuedSequenceNumber: integer|Long expected";
                if (message.viaPartitionKey != null && message.hasOwnProperty("viaPartitionKey"))
                    if (!$util.isString(message.viaPartitionKey))
                        return "viaPartitionKey: string expected";
                if (message.annotations != null && message.hasOwnProperty("annotations")) {
                    if (!$util.isObject(message.annotations))
                        return "annotations: object expected";
                    var key = Object.keys(message.annotations);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.annotations[key[i]]))
                            return "annotations: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates an AzureSystemProperties message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.AzureSystemProperties} AzureSystemProperties
             */
            AzureSystemProperties.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.AzureSystemProperties)
                    return object;
                var message = new $root.protos.records.AzureSystemProperties();
                if (object.lockedUntil != null)
                    if ($util.Long)
                        (message.lockedUntil = $util.Long.fromValue(object.lockedUntil)).unsigned = false;
                    else if (typeof object.lockedUntil === "string")
                        message.lockedUntil = parseInt(object.lockedUntil, 10);
                    else if (typeof object.lockedUntil === "number")
                        message.lockedUntil = object.lockedUntil;
                    else if (typeof object.lockedUntil === "object")
                        message.lockedUntil = new $util.LongBits(object.lockedUntil.low >>> 0, object.lockedUntil.high >>> 0).toNumber();
                if (object.sequenceNumber != null)
                    if ($util.Long)
                        (message.sequenceNumber = $util.Long.fromValue(object.sequenceNumber)).unsigned = false;
                    else if (typeof object.sequenceNumber === "string")
                        message.sequenceNumber = parseInt(object.sequenceNumber, 10);
                    else if (typeof object.sequenceNumber === "number")
                        message.sequenceNumber = object.sequenceNumber;
                    else if (typeof object.sequenceNumber === "object")
                        message.sequenceNumber = new $util.LongBits(object.sequenceNumber.low >>> 0, object.sequenceNumber.high >>> 0).toNumber();
                if (object.partitionId != null)
                    message.partitionId = object.partitionId | 0;
                if (object.partitionKey != null)
                    message.partitionKey = String(object.partitionKey);
                if (object.enqueuedTime != null)
                    if ($util.Long)
                        (message.enqueuedTime = $util.Long.fromValue(object.enqueuedTime)).unsigned = false;
                    else if (typeof object.enqueuedTime === "string")
                        message.enqueuedTime = parseInt(object.enqueuedTime, 10);
                    else if (typeof object.enqueuedTime === "number")
                        message.enqueuedTime = object.enqueuedTime;
                    else if (typeof object.enqueuedTime === "object")
                        message.enqueuedTime = new $util.LongBits(object.enqueuedTime.low >>> 0, object.enqueuedTime.high >>> 0).toNumber();
                if (object.deadLetterSource != null)
                    message.deadLetterSource = String(object.deadLetterSource);
                if (object.scheduledEnqueueTime != null)
                    if ($util.Long)
                        (message.scheduledEnqueueTime = $util.Long.fromValue(object.scheduledEnqueueTime)).unsigned = false;
                    else if (typeof object.scheduledEnqueueTime === "string")
                        message.scheduledEnqueueTime = parseInt(object.scheduledEnqueueTime, 10);
                    else if (typeof object.scheduledEnqueueTime === "number")
                        message.scheduledEnqueueTime = object.scheduledEnqueueTime;
                    else if (typeof object.scheduledEnqueueTime === "object")
                        message.scheduledEnqueueTime = new $util.LongBits(object.scheduledEnqueueTime.low >>> 0, object.scheduledEnqueueTime.high >>> 0).toNumber();
                if (object.enqueuedSequenceNumber != null)
                    if ($util.Long)
                        (message.enqueuedSequenceNumber = $util.Long.fromValue(object.enqueuedSequenceNumber)).unsigned = false;
                    else if (typeof object.enqueuedSequenceNumber === "string")
                        message.enqueuedSequenceNumber = parseInt(object.enqueuedSequenceNumber, 10);
                    else if (typeof object.enqueuedSequenceNumber === "number")
                        message.enqueuedSequenceNumber = object.enqueuedSequenceNumber;
                    else if (typeof object.enqueuedSequenceNumber === "object")
                        message.enqueuedSequenceNumber = new $util.LongBits(object.enqueuedSequenceNumber.low >>> 0, object.enqueuedSequenceNumber.high >>> 0).toNumber();
                if (object.viaPartitionKey != null)
                    message.viaPartitionKey = String(object.viaPartitionKey);
                if (object.annotations) {
                    if (typeof object.annotations !== "object")
                        throw TypeError(".protos.records.AzureSystemProperties.annotations: object expected");
                    message.annotations = {};
                    for (var keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i)
                        message.annotations[keys[i]] = String(object.annotations[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from an AzureSystemProperties message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {protos.records.AzureSystemProperties} message AzureSystemProperties
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureSystemProperties.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.annotations = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.lockedUntil = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lockedUntil = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.sequenceNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sequenceNumber = options.longs === String ? "0" : 0;
                    object.partitionId = 0;
                    object.partitionKey = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.enqueuedTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.enqueuedTime = options.longs === String ? "0" : 0;
                    object.deadLetterSource = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.scheduledEnqueueTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.scheduledEnqueueTime = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.enqueuedSequenceNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.enqueuedSequenceNumber = options.longs === String ? "0" : 0;
                    object.viaPartitionKey = "";
                }
                if (message.lockedUntil != null && message.hasOwnProperty("lockedUntil"))
                    if (typeof message.lockedUntil === "number")
                        object.lockedUntil = options.longs === String ? String(message.lockedUntil) : message.lockedUntil;
                    else
                        object.lockedUntil = options.longs === String ? $util.Long.prototype.toString.call(message.lockedUntil) : options.longs === Number ? new $util.LongBits(message.lockedUntil.low >>> 0, message.lockedUntil.high >>> 0).toNumber() : message.lockedUntil;
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    if (typeof message.sequenceNumber === "number")
                        object.sequenceNumber = options.longs === String ? String(message.sequenceNumber) : message.sequenceNumber;
                    else
                        object.sequenceNumber = options.longs === String ? $util.Long.prototype.toString.call(message.sequenceNumber) : options.longs === Number ? new $util.LongBits(message.sequenceNumber.low >>> 0, message.sequenceNumber.high >>> 0).toNumber() : message.sequenceNumber;
                if (message.partitionId != null && message.hasOwnProperty("partitionId"))
                    object.partitionId = message.partitionId;
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    object.partitionKey = message.partitionKey;
                if (message.enqueuedTime != null && message.hasOwnProperty("enqueuedTime"))
                    if (typeof message.enqueuedTime === "number")
                        object.enqueuedTime = options.longs === String ? String(message.enqueuedTime) : message.enqueuedTime;
                    else
                        object.enqueuedTime = options.longs === String ? $util.Long.prototype.toString.call(message.enqueuedTime) : options.longs === Number ? new $util.LongBits(message.enqueuedTime.low >>> 0, message.enqueuedTime.high >>> 0).toNumber() : message.enqueuedTime;
                if (message.deadLetterSource != null && message.hasOwnProperty("deadLetterSource"))
                    object.deadLetterSource = message.deadLetterSource;
                if (message.scheduledEnqueueTime != null && message.hasOwnProperty("scheduledEnqueueTime"))
                    if (typeof message.scheduledEnqueueTime === "number")
                        object.scheduledEnqueueTime = options.longs === String ? String(message.scheduledEnqueueTime) : message.scheduledEnqueueTime;
                    else
                        object.scheduledEnqueueTime = options.longs === String ? $util.Long.prototype.toString.call(message.scheduledEnqueueTime) : options.longs === Number ? new $util.LongBits(message.scheduledEnqueueTime.low >>> 0, message.scheduledEnqueueTime.high >>> 0).toNumber() : message.scheduledEnqueueTime;
                if (message.enqueuedSequenceNumber != null && message.hasOwnProperty("enqueuedSequenceNumber"))
                    if (typeof message.enqueuedSequenceNumber === "number")
                        object.enqueuedSequenceNumber = options.longs === String ? String(message.enqueuedSequenceNumber) : message.enqueuedSequenceNumber;
                    else
                        object.enqueuedSequenceNumber = options.longs === String ? $util.Long.prototype.toString.call(message.enqueuedSequenceNumber) : options.longs === Number ? new $util.LongBits(message.enqueuedSequenceNumber.low >>> 0, message.enqueuedSequenceNumber.high >>> 0).toNumber() : message.enqueuedSequenceNumber;
                if (message.viaPartitionKey != null && message.hasOwnProperty("viaPartitionKey"))
                    object.viaPartitionKey = message.viaPartitionKey;
                var keys2;
                if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                    object.annotations = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.annotations[keys2[j]] = message.annotations[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this AzureSystemProperties to JSON.
             * @function toJSON
             * @memberof protos.records.AzureSystemProperties
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureSystemProperties.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureSystemProperties;
        })();

        records.GCPPubSub = (function() {

            /**
             * Properties of a GCPPubSub.
             * @memberof protos.records
             * @interface IGCPPubSub
             * @property {string|null} [id] GCPPubSub id
             * @property {Uint8Array|null} [value] GCPPubSub value
             * @property {Object.<string,string>|null} [attributes] GCPPubSub attributes
             * @property {number|Long|null} [publishTime] GCPPubSub publishTime
             * @property {number|null} [deliveryAttempt] GCPPubSub deliveryAttempt
             * @property {string|null} [orderingKey] GCPPubSub orderingKey
             */

            /**
             * Constructs a new GCPPubSub.
             * @memberof protos.records
             * @classdesc Represents a GCPPubSub.
             * @implements IGCPPubSub
             * @constructor
             * @param {protos.records.IGCPPubSub=} [properties] Properties to set
             */
            function GCPPubSub(properties) {
                this.attributes = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GCPPubSub id.
             * @member {string} id
             * @memberof protos.records.GCPPubSub
             * @instance
             */
            GCPPubSub.prototype.id = "";

            /**
             * GCPPubSub value.
             * @member {Uint8Array} value
             * @memberof protos.records.GCPPubSub
             * @instance
             */
            GCPPubSub.prototype.value = $util.newBuffer([]);

            /**
             * GCPPubSub attributes.
             * @member {Object.<string,string>} attributes
             * @memberof protos.records.GCPPubSub
             * @instance
             */
            GCPPubSub.prototype.attributes = $util.emptyObject;

            /**
             * GCPPubSub publishTime.
             * @member {number|Long} publishTime
             * @memberof protos.records.GCPPubSub
             * @instance
             */
            GCPPubSub.prototype.publishTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * GCPPubSub deliveryAttempt.
             * @member {number} deliveryAttempt
             * @memberof protos.records.GCPPubSub
             * @instance
             */
            GCPPubSub.prototype.deliveryAttempt = 0;

            /**
             * GCPPubSub orderingKey.
             * @member {string} orderingKey
             * @memberof protos.records.GCPPubSub
             * @instance
             */
            GCPPubSub.prototype.orderingKey = "";

            /**
             * Creates a new GCPPubSub instance using the specified properties.
             * @function create
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {protos.records.IGCPPubSub=} [properties] Properties to set
             * @returns {protos.records.GCPPubSub} GCPPubSub instance
             */
            GCPPubSub.create = function create(properties) {
                return new GCPPubSub(properties);
            };

            /**
             * Encodes the specified GCPPubSub message. Does not implicitly {@link protos.records.GCPPubSub.verify|verify} messages.
             * @function encode
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {protos.records.IGCPPubSub} message GCPPubSub message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSub.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                if (message.attributes != null && Object.hasOwnProperty.call(message, "attributes"))
                    for (var keys = Object.keys(message.attributes), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.attributes[keys[i]]).ldelim();
                if (message.publishTime != null && Object.hasOwnProperty.call(message, "publishTime"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.publishTime);
                if (message.deliveryAttempt != null && Object.hasOwnProperty.call(message, "deliveryAttempt"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.deliveryAttempt);
                if (message.orderingKey != null && Object.hasOwnProperty.call(message, "orderingKey"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.orderingKey);
                return writer;
            };

            /**
             * Encodes the specified GCPPubSub message, length delimited. Does not implicitly {@link protos.records.GCPPubSub.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {protos.records.IGCPPubSub} message GCPPubSub message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSub.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GCPPubSub message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.GCPPubSub} GCPPubSub
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSub.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.GCPPubSub(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    case 3:
                        if (message.attributes === $util.emptyObject)
                            message.attributes = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.attributes[key] = value;
                        break;
                    case 4:
                        message.publishTime = reader.int64();
                        break;
                    case 5:
                        message.deliveryAttempt = reader.int32();
                        break;
                    case 6:
                        message.orderingKey = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GCPPubSub message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.GCPPubSub} GCPPubSub
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSub.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GCPPubSub message.
             * @function verify
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GCPPubSub.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    if (!$util.isObject(message.attributes))
                        return "attributes: object expected";
                    var key = Object.keys(message.attributes);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.attributes[key[i]]))
                            return "attributes: string{k:string} expected";
                }
                if (message.publishTime != null && message.hasOwnProperty("publishTime"))
                    if (!$util.isInteger(message.publishTime) && !(message.publishTime && $util.isInteger(message.publishTime.low) && $util.isInteger(message.publishTime.high)))
                        return "publishTime: integer|Long expected";
                if (message.deliveryAttempt != null && message.hasOwnProperty("deliveryAttempt"))
                    if (!$util.isInteger(message.deliveryAttempt))
                        return "deliveryAttempt: integer expected";
                if (message.orderingKey != null && message.hasOwnProperty("orderingKey"))
                    if (!$util.isString(message.orderingKey))
                        return "orderingKey: string expected";
                return null;
            };

            /**
             * Creates a GCPPubSub message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.GCPPubSub} GCPPubSub
             */
            GCPPubSub.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.GCPPubSub)
                    return object;
                var message = new $root.protos.records.GCPPubSub();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.attributes) {
                    if (typeof object.attributes !== "object")
                        throw TypeError(".protos.records.GCPPubSub.attributes: object expected");
                    message.attributes = {};
                    for (var keys = Object.keys(object.attributes), i = 0; i < keys.length; ++i)
                        message.attributes[keys[i]] = String(object.attributes[keys[i]]);
                }
                if (object.publishTime != null)
                    if ($util.Long)
                        (message.publishTime = $util.Long.fromValue(object.publishTime)).unsigned = false;
                    else if (typeof object.publishTime === "string")
                        message.publishTime = parseInt(object.publishTime, 10);
                    else if (typeof object.publishTime === "number")
                        message.publishTime = object.publishTime;
                    else if (typeof object.publishTime === "object")
                        message.publishTime = new $util.LongBits(object.publishTime.low >>> 0, object.publishTime.high >>> 0).toNumber();
                if (object.deliveryAttempt != null)
                    message.deliveryAttempt = object.deliveryAttempt | 0;
                if (object.orderingKey != null)
                    message.orderingKey = String(object.orderingKey);
                return message;
            };

            /**
             * Creates a plain object from a GCPPubSub message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {protos.records.GCPPubSub} message GCPPubSub
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GCPPubSub.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.attributes = {};
                if (options.defaults) {
                    object.id = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.publishTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.publishTime = options.longs === String ? "0" : 0;
                    object.deliveryAttempt = 0;
                    object.orderingKey = "";
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                var keys2;
                if (message.attributes && (keys2 = Object.keys(message.attributes)).length) {
                    object.attributes = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.attributes[keys2[j]] = message.attributes[keys2[j]];
                }
                if (message.publishTime != null && message.hasOwnProperty("publishTime"))
                    if (typeof message.publishTime === "number")
                        object.publishTime = options.longs === String ? String(message.publishTime) : message.publishTime;
                    else
                        object.publishTime = options.longs === String ? $util.Long.prototype.toString.call(message.publishTime) : options.longs === Number ? new $util.LongBits(message.publishTime.low >>> 0, message.publishTime.high >>> 0).toNumber() : message.publishTime;
                if (message.deliveryAttempt != null && message.hasOwnProperty("deliveryAttempt"))
                    object.deliveryAttempt = message.deliveryAttempt;
                if (message.orderingKey != null && message.hasOwnProperty("orderingKey"))
                    object.orderingKey = message.orderingKey;
                return object;
            };

            /**
             * Converts this GCPPubSub to JSON.
             * @function toJSON
             * @memberof protos.records.GCPPubSub
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GCPPubSub.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GCPPubSub;
        })();

        records.KafkaHeader = (function() {

            /**
             * Properties of a KafkaHeader.
             * @memberof protos.records
             * @interface IKafkaHeader
             * @property {string|null} [key] KafkaHeader key
             * @property {string|null} [value] KafkaHeader value
             */

            /**
             * Constructs a new KafkaHeader.
             * @memberof protos.records
             * @classdesc Represents a KafkaHeader.
             * @implements IKafkaHeader
             * @constructor
             * @param {protos.records.IKafkaHeader=} [properties] Properties to set
             */
            function KafkaHeader(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KafkaHeader key.
             * @member {string} key
             * @memberof protos.records.KafkaHeader
             * @instance
             */
            KafkaHeader.prototype.key = "";

            /**
             * KafkaHeader value.
             * @member {string} value
             * @memberof protos.records.KafkaHeader
             * @instance
             */
            KafkaHeader.prototype.value = "";

            /**
             * Creates a new KafkaHeader instance using the specified properties.
             * @function create
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {protos.records.IKafkaHeader=} [properties] Properties to set
             * @returns {protos.records.KafkaHeader} KafkaHeader instance
             */
            KafkaHeader.create = function create(properties) {
                return new KafkaHeader(properties);
            };

            /**
             * Encodes the specified KafkaHeader message. Does not implicitly {@link protos.records.KafkaHeader.verify|verify} messages.
             * @function encode
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {protos.records.IKafkaHeader} message KafkaHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaHeader.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };

            /**
             * Encodes the specified KafkaHeader message, length delimited. Does not implicitly {@link protos.records.KafkaHeader.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {protos.records.IKafkaHeader} message KafkaHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaHeader.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KafkaHeader message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.KafkaHeader} KafkaHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaHeader.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.KafkaHeader();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KafkaHeader message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.KafkaHeader} KafkaHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaHeader.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KafkaHeader message.
             * @function verify
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaHeader.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };

            /**
             * Creates a KafkaHeader message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.KafkaHeader} KafkaHeader
             */
            KafkaHeader.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.KafkaHeader)
                    return object;
                var message = new $root.protos.records.KafkaHeader();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };

            /**
             * Creates a plain object from a KafkaHeader message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {protos.records.KafkaHeader} message KafkaHeader
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaHeader.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.value = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this KafkaHeader to JSON.
             * @function toJSON
             * @memberof protos.records.KafkaHeader
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaHeader.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KafkaHeader;
        })();

        records.Kafka = (function() {

            /**
             * Properties of a Kafka.
             * @memberof protos.records
             * @interface IKafka
             * @property {string|null} [topic] Kafka topic
             * @property {Uint8Array|null} [key] Kafka key
             * @property {Uint8Array|null} [value] Kafka value
             * @property {number|Long|null} [timestamp] Kafka timestamp
             * @property {number|Long|null} [offset] Kafka offset
             * @property {number|null} [partition] Kafka partition
             * @property {Array.<protos.records.IKafkaHeader>|null} [headers] Kafka headers
             */

            /**
             * Constructs a new Kafka.
             * @memberof protos.records
             * @classdesc Represents a Kafka.
             * @implements IKafka
             * @constructor
             * @param {protos.records.IKafka=} [properties] Properties to set
             */
            function Kafka(properties) {
                this.headers = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Kafka topic.
             * @member {string} topic
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.topic = "";

            /**
             * Kafka key.
             * @member {Uint8Array} key
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.key = $util.newBuffer([]);

            /**
             * Kafka value.
             * @member {Uint8Array} value
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.value = $util.newBuffer([]);

            /**
             * Kafka timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Kafka offset.
             * @member {number|Long} offset
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.offset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Kafka partition.
             * @member {number} partition
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.partition = 0;

            /**
             * Kafka headers.
             * @member {Array.<protos.records.IKafkaHeader>} headers
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.headers = $util.emptyArray;

            /**
             * Creates a new Kafka instance using the specified properties.
             * @function create
             * @memberof protos.records.Kafka
             * @static
             * @param {protos.records.IKafka=} [properties] Properties to set
             * @returns {protos.records.Kafka} Kafka instance
             */
            Kafka.create = function create(properties) {
                return new Kafka(properties);
            };

            /**
             * Encodes the specified Kafka message. Does not implicitly {@link protos.records.Kafka.verify|verify} messages.
             * @function encode
             * @memberof protos.records.Kafka
             * @static
             * @param {protos.records.IKafka} message Kafka message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Kafka.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestamp);
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.offset);
                if (message.partition != null && Object.hasOwnProperty.call(message, "partition"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.partition);
                if (message.headers != null && message.headers.length)
                    for (var i = 0; i < message.headers.length; ++i)
                        $root.protos.records.KafkaHeader.encode(message.headers[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Kafka message, length delimited. Does not implicitly {@link protos.records.Kafka.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.Kafka
             * @static
             * @param {protos.records.IKafka} message Kafka message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Kafka.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Kafka message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.Kafka
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.Kafka} Kafka
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Kafka.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.Kafka();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.key = reader.bytes();
                        break;
                    case 3:
                        message.value = reader.bytes();
                        break;
                    case 4:
                        message.timestamp = reader.int64();
                        break;
                    case 5:
                        message.offset = reader.int64();
                        break;
                    case 6:
                        message.partition = reader.int32();
                        break;
                    case 7:
                        if (!(message.headers && message.headers.length))
                            message.headers = [];
                        message.headers.push($root.protos.records.KafkaHeader.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Kafka message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.Kafka
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.Kafka} Kafka
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Kafka.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Kafka message.
             * @function verify
             * @memberof protos.records.Kafka
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Kafka.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high)))
                        return "offset: integer|Long expected";
                if (message.partition != null && message.hasOwnProperty("partition"))
                    if (!$util.isInteger(message.partition))
                        return "partition: integer expected";
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    if (!Array.isArray(message.headers))
                        return "headers: array expected";
                    for (var i = 0; i < message.headers.length; ++i) {
                        var error = $root.protos.records.KafkaHeader.verify(message.headers[i]);
                        if (error)
                            return "headers." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Kafka message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.Kafka
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.Kafka} Kafka
             */
            Kafka.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.Kafka)
                    return object;
                var message = new $root.protos.records.Kafka();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length)
                        message.key = object.key;
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.offset != null)
                    if ($util.Long)
                        (message.offset = $util.Long.fromValue(object.offset)).unsigned = false;
                    else if (typeof object.offset === "string")
                        message.offset = parseInt(object.offset, 10);
                    else if (typeof object.offset === "number")
                        message.offset = object.offset;
                    else if (typeof object.offset === "object")
                        message.offset = new $util.LongBits(object.offset.low >>> 0, object.offset.high >>> 0).toNumber();
                if (object.partition != null)
                    message.partition = object.partition | 0;
                if (object.headers) {
                    if (!Array.isArray(object.headers))
                        throw TypeError(".protos.records.Kafka.headers: array expected");
                    message.headers = [];
                    for (var i = 0; i < object.headers.length; ++i) {
                        if (typeof object.headers[i] !== "object")
                            throw TypeError(".protos.records.Kafka.headers: object expected");
                        message.headers[i] = $root.protos.records.KafkaHeader.fromObject(object.headers[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Kafka message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.Kafka
             * @static
             * @param {protos.records.Kafka} message Kafka
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Kafka.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.headers = [];
                if (options.defaults) {
                    object.topic = "";
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.offset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.offset = options.longs === String ? "0" : 0;
                    object.partition = 0;
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (typeof message.offset === "number")
                        object.offset = options.longs === String ? String(message.offset) : message.offset;
                    else
                        object.offset = options.longs === String ? $util.Long.prototype.toString.call(message.offset) : options.longs === Number ? new $util.LongBits(message.offset.low >>> 0, message.offset.high >>> 0).toNumber() : message.offset;
                if (message.partition != null && message.hasOwnProperty("partition"))
                    object.partition = message.partition;
                if (message.headers && message.headers.length) {
                    object.headers = [];
                    for (var j = 0; j < message.headers.length; ++j)
                        object.headers[j] = $root.protos.records.KafkaHeader.toObject(message.headers[j], options);
                }
                return object;
            };

            /**
             * Converts this Kafka to JSON.
             * @function toJSON
             * @memberof protos.records.Kafka
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Kafka.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Kafka;
        })();

        records.KubeMQ = (function() {

            /**
             * Properties of a KubeMQ.
             * @memberof protos.records
             * @interface IKubeMQ
             * @property {string|null} [id] KubeMQ id
             * @property {string|null} [clientId] KubeMQ clientId
             * @property {string|null} [channel] KubeMQ channel
             * @property {Uint8Array|null} [value] KubeMQ value
             * @property {number|Long|null} [timestamp] KubeMQ timestamp
             * @property {number|Long|null} [sequence] KubeMQ sequence
             */

            /**
             * Constructs a new KubeMQ.
             * @memberof protos.records
             * @classdesc Represents a KubeMQ.
             * @implements IKubeMQ
             * @constructor
             * @param {protos.records.IKubeMQ=} [properties] Properties to set
             */
            function KubeMQ(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KubeMQ id.
             * @member {string} id
             * @memberof protos.records.KubeMQ
             * @instance
             */
            KubeMQ.prototype.id = "";

            /**
             * KubeMQ clientId.
             * @member {string} clientId
             * @memberof protos.records.KubeMQ
             * @instance
             */
            KubeMQ.prototype.clientId = "";

            /**
             * KubeMQ channel.
             * @member {string} channel
             * @memberof protos.records.KubeMQ
             * @instance
             */
            KubeMQ.prototype.channel = "";

            /**
             * KubeMQ value.
             * @member {Uint8Array} value
             * @memberof protos.records.KubeMQ
             * @instance
             */
            KubeMQ.prototype.value = $util.newBuffer([]);

            /**
             * KubeMQ timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.KubeMQ
             * @instance
             */
            KubeMQ.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * KubeMQ sequence.
             * @member {number|Long} sequence
             * @memberof protos.records.KubeMQ
             * @instance
             */
            KubeMQ.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new KubeMQ instance using the specified properties.
             * @function create
             * @memberof protos.records.KubeMQ
             * @static
             * @param {protos.records.IKubeMQ=} [properties] Properties to set
             * @returns {protos.records.KubeMQ} KubeMQ instance
             */
            KubeMQ.create = function create(properties) {
                return new KubeMQ(properties);
            };

            /**
             * Encodes the specified KubeMQ message. Does not implicitly {@link protos.records.KubeMQ.verify|verify} messages.
             * @function encode
             * @memberof protos.records.KubeMQ
             * @static
             * @param {protos.records.IKubeMQ} message KubeMQ message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQ.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientId);
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.channel);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.value);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
                if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.sequence);
                return writer;
            };

            /**
             * Encodes the specified KubeMQ message, length delimited. Does not implicitly {@link protos.records.KubeMQ.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.KubeMQ
             * @static
             * @param {protos.records.IKubeMQ} message KubeMQ message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQ.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KubeMQ message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.KubeMQ
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.KubeMQ} KubeMQ
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQ.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.KubeMQ();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.clientId = reader.string();
                        break;
                    case 3:
                        message.channel = reader.string();
                        break;
                    case 4:
                        message.value = reader.bytes();
                        break;
                    case 5:
                        message.timestamp = reader.int64();
                        break;
                    case 6:
                        message.sequence = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KubeMQ message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.KubeMQ
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.KubeMQ} KubeMQ
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQ.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KubeMQ message.
             * @function verify
             * @memberof protos.records.KubeMQ
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KubeMQ.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                        return "sequence: integer|Long expected";
                return null;
            };

            /**
             * Creates a KubeMQ message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.KubeMQ
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.KubeMQ} KubeMQ
             */
            KubeMQ.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.KubeMQ)
                    return object;
                var message = new $root.protos.records.KubeMQ();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                if (object.channel != null)
                    message.channel = String(object.channel);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.sequence != null)
                    if ($util.Long)
                        (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                    else if (typeof object.sequence === "string")
                        message.sequence = parseInt(object.sequence, 10);
                    else if (typeof object.sequence === "number")
                        message.sequence = object.sequence;
                    else if (typeof object.sequence === "object")
                        message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a KubeMQ message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.KubeMQ
             * @static
             * @param {protos.records.KubeMQ} message KubeMQ
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KubeMQ.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    object.clientId = "";
                    object.channel = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sequence = options.longs === String ? "0" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (typeof message.sequence === "number")
                        object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                    else
                        object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
                return object;
            };

            /**
             * Converts this KubeMQ to JSON.
             * @function toJSON
             * @memberof protos.records.KubeMQ
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KubeMQ.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KubeMQ;
        })();

        records.Memphis = (function() {

            /**
             * Properties of a Memphis.
             * @memberof protos.records
             * @interface IMemphis
             * @property {Uint8Array|null} [value] Memphis value
             * @property {number|Long|null} [timestamp] Memphis timestamp
             */

            /**
             * Constructs a new Memphis.
             * @memberof protos.records
             * @classdesc Represents a Memphis.
             * @implements IMemphis
             * @constructor
             * @param {protos.records.IMemphis=} [properties] Properties to set
             */
            function Memphis(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Memphis value.
             * @member {Uint8Array} value
             * @memberof protos.records.Memphis
             * @instance
             */
            Memphis.prototype.value = $util.newBuffer([]);

            /**
             * Memphis timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.Memphis
             * @instance
             */
            Memphis.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Memphis instance using the specified properties.
             * @function create
             * @memberof protos.records.Memphis
             * @static
             * @param {protos.records.IMemphis=} [properties] Properties to set
             * @returns {protos.records.Memphis} Memphis instance
             */
            Memphis.create = function create(properties) {
                return new Memphis(properties);
            };

            /**
             * Encodes the specified Memphis message. Does not implicitly {@link protos.records.Memphis.verify|verify} messages.
             * @function encode
             * @memberof protos.records.Memphis
             * @static
             * @param {protos.records.IMemphis} message Memphis message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Memphis.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified Memphis message, length delimited. Does not implicitly {@link protos.records.Memphis.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.Memphis
             * @static
             * @param {protos.records.IMemphis} message Memphis message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Memphis.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Memphis message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.Memphis
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.Memphis} Memphis
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Memphis.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.Memphis();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.bytes();
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Memphis message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.Memphis
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.Memphis} Memphis
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Memphis.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Memphis message.
             * @function verify
             * @memberof protos.records.Memphis
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Memphis.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a Memphis message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.Memphis
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.Memphis} Memphis
             */
            Memphis.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.Memphis)
                    return object;
                var message = new $root.protos.records.Memphis();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Memphis message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.Memphis
             * @static
             * @param {protos.records.Memphis} message Memphis
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Memphis.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this Memphis to JSON.
             * @function toJSON
             * @memberof protos.records.Memphis
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Memphis.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Memphis;
        })();

        records.Mongo = (function() {

            /**
             * Properties of a Mongo.
             * @memberof protos.records
             * @interface IMongo
             * @property {Uint8Array|null} [value] Mongo value
             * @property {number|Long|null} [timestamp] Mongo timestamp
             */

            /**
             * Constructs a new Mongo.
             * @memberof protos.records
             * @classdesc Represents a Mongo.
             * @implements IMongo
             * @constructor
             * @param {protos.records.IMongo=} [properties] Properties to set
             */
            function Mongo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Mongo value.
             * @member {Uint8Array} value
             * @memberof protos.records.Mongo
             * @instance
             */
            Mongo.prototype.value = $util.newBuffer([]);

            /**
             * Mongo timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.Mongo
             * @instance
             */
            Mongo.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Mongo instance using the specified properties.
             * @function create
             * @memberof protos.records.Mongo
             * @static
             * @param {protos.records.IMongo=} [properties] Properties to set
             * @returns {protos.records.Mongo} Mongo instance
             */
            Mongo.create = function create(properties) {
                return new Mongo(properties);
            };

            /**
             * Encodes the specified Mongo message. Does not implicitly {@link protos.records.Mongo.verify|verify} messages.
             * @function encode
             * @memberof protos.records.Mongo
             * @static
             * @param {protos.records.IMongo} message Mongo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Mongo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified Mongo message, length delimited. Does not implicitly {@link protos.records.Mongo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.Mongo
             * @static
             * @param {protos.records.IMongo} message Mongo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Mongo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Mongo message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.Mongo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.Mongo} Mongo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Mongo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.Mongo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.bytes();
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Mongo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.Mongo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.Mongo} Mongo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Mongo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Mongo message.
             * @function verify
             * @memberof protos.records.Mongo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Mongo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a Mongo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.Mongo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.Mongo} Mongo
             */
            Mongo.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.Mongo)
                    return object;
                var message = new $root.protos.records.Mongo();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Mongo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.Mongo
             * @static
             * @param {protos.records.Mongo} message Mongo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Mongo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this Mongo to JSON.
             * @function toJSON
             * @memberof protos.records.Mongo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Mongo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Mongo;
        })();

        records.MQTT = (function() {

            /**
             * Properties of a MQTT.
             * @memberof protos.records
             * @interface IMQTT
             * @property {number|null} [id] MQTT id
             * @property {string|null} [topic] MQTT topic
             * @property {Uint8Array|null} [value] MQTT value
             * @property {boolean|null} [duplicate] MQTT duplicate
             * @property {boolean|null} [retained] MQTT retained
             * @property {number|null} [qos] MQTT qos
             * @property {number|Long|null} [timestamp] MQTT timestamp
             */

            /**
             * Constructs a new MQTT.
             * @memberof protos.records
             * @classdesc Represents a MQTT.
             * @implements IMQTT
             * @constructor
             * @param {protos.records.IMQTT=} [properties] Properties to set
             */
            function MQTT(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MQTT id.
             * @member {number} id
             * @memberof protos.records.MQTT
             * @instance
             */
            MQTT.prototype.id = 0;

            /**
             * MQTT topic.
             * @member {string} topic
             * @memberof protos.records.MQTT
             * @instance
             */
            MQTT.prototype.topic = "";

            /**
             * MQTT value.
             * @member {Uint8Array} value
             * @memberof protos.records.MQTT
             * @instance
             */
            MQTT.prototype.value = $util.newBuffer([]);

            /**
             * MQTT duplicate.
             * @member {boolean} duplicate
             * @memberof protos.records.MQTT
             * @instance
             */
            MQTT.prototype.duplicate = false;

            /**
             * MQTT retained.
             * @member {boolean} retained
             * @memberof protos.records.MQTT
             * @instance
             */
            MQTT.prototype.retained = false;

            /**
             * MQTT qos.
             * @member {number} qos
             * @memberof protos.records.MQTT
             * @instance
             */
            MQTT.prototype.qos = 0;

            /**
             * MQTT timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.MQTT
             * @instance
             */
            MQTT.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new MQTT instance using the specified properties.
             * @function create
             * @memberof protos.records.MQTT
             * @static
             * @param {protos.records.IMQTT=} [properties] Properties to set
             * @returns {protos.records.MQTT} MQTT instance
             */
            MQTT.create = function create(properties) {
                return new MQTT(properties);
            };

            /**
             * Encodes the specified MQTT message. Does not implicitly {@link protos.records.MQTT.verify|verify} messages.
             * @function encode
             * @memberof protos.records.MQTT
             * @static
             * @param {protos.records.IMQTT} message MQTT message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTT.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.topic);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                if (message.duplicate != null && Object.hasOwnProperty.call(message, "duplicate"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.duplicate);
                if (message.retained != null && Object.hasOwnProperty.call(message, "retained"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.retained);
                if (message.qos != null && Object.hasOwnProperty.call(message, "qos"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.qos);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified MQTT message, length delimited. Does not implicitly {@link protos.records.MQTT.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.MQTT
             * @static
             * @param {protos.records.IMQTT} message MQTT message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTT.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MQTT message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.MQTT
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.MQTT} MQTT
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTT.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.MQTT();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.uint32();
                        break;
                    case 2:
                        message.topic = reader.string();
                        break;
                    case 3:
                        message.value = reader.bytes();
                        break;
                    case 4:
                        message.duplicate = reader.bool();
                        break;
                    case 5:
                        message.retained = reader.bool();
                        break;
                    case 6:
                        message.qos = reader.uint32();
                        break;
                    case 7:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MQTT message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.MQTT
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.MQTT} MQTT
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTT.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MQTT message.
             * @function verify
             * @memberof protos.records.MQTT
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MQTT.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.duplicate != null && message.hasOwnProperty("duplicate"))
                    if (typeof message.duplicate !== "boolean")
                        return "duplicate: boolean expected";
                if (message.retained != null && message.hasOwnProperty("retained"))
                    if (typeof message.retained !== "boolean")
                        return "retained: boolean expected";
                if (message.qos != null && message.hasOwnProperty("qos"))
                    if (!$util.isInteger(message.qos))
                        return "qos: integer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a MQTT message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.MQTT
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.MQTT} MQTT
             */
            MQTT.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.MQTT)
                    return object;
                var message = new $root.protos.records.MQTT();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.duplicate != null)
                    message.duplicate = Boolean(object.duplicate);
                if (object.retained != null)
                    message.retained = Boolean(object.retained);
                if (object.qos != null)
                    message.qos = object.qos >>> 0;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a MQTT message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.MQTT
             * @static
             * @param {protos.records.MQTT} message MQTT
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MQTT.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.topic = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    object.duplicate = false;
                    object.retained = false;
                    object.qos = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.duplicate != null && message.hasOwnProperty("duplicate"))
                    object.duplicate = message.duplicate;
                if (message.retained != null && message.hasOwnProperty("retained"))
                    object.retained = message.retained;
                if (message.qos != null && message.hasOwnProperty("qos"))
                    object.qos = message.qos;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this MQTT to JSON.
             * @function toJSON
             * @memberof protos.records.MQTT
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MQTT.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MQTT;
        })();

        records.Nats = (function() {

            /**
             * Properties of a Nats.
             * @memberof protos.records
             * @interface INats
             * @property {string|null} [subject] Nats subject
             * @property {Uint8Array|null} [value] Nats value
             */

            /**
             * Constructs a new Nats.
             * @memberof protos.records
             * @classdesc Represents a Nats.
             * @implements INats
             * @constructor
             * @param {protos.records.INats=} [properties] Properties to set
             */
            function Nats(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Nats subject.
             * @member {string} subject
             * @memberof protos.records.Nats
             * @instance
             */
            Nats.prototype.subject = "";

            /**
             * Nats value.
             * @member {Uint8Array} value
             * @memberof protos.records.Nats
             * @instance
             */
            Nats.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Nats instance using the specified properties.
             * @function create
             * @memberof protos.records.Nats
             * @static
             * @param {protos.records.INats=} [properties] Properties to set
             * @returns {protos.records.Nats} Nats instance
             */
            Nats.create = function create(properties) {
                return new Nats(properties);
            };

            /**
             * Encodes the specified Nats message. Does not implicitly {@link protos.records.Nats.verify|verify} messages.
             * @function encode
             * @memberof protos.records.Nats
             * @static
             * @param {protos.records.INats} message Nats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Nats.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.subject);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Nats message, length delimited. Does not implicitly {@link protos.records.Nats.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.Nats
             * @static
             * @param {protos.records.INats} message Nats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Nats.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Nats message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.Nats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.Nats} Nats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Nats.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.Nats();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subject = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Nats message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.Nats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.Nats} Nats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Nats.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Nats message.
             * @function verify
             * @memberof protos.records.Nats
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Nats.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    if (!$util.isString(message.subject))
                        return "subject: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a Nats message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.Nats
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.Nats} Nats
             */
            Nats.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.Nats)
                    return object;
                var message = new $root.protos.records.Nats();
                if (object.subject != null)
                    message.subject = String(object.subject);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a Nats message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.Nats
             * @static
             * @param {protos.records.Nats} message Nats
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Nats.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.subject = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.subject != null && message.hasOwnProperty("subject"))
                    object.subject = message.subject;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Nats to JSON.
             * @function toJSON
             * @memberof protos.records.Nats
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Nats.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Nats;
        })();

        records.NatsJetstream = (function() {

            /**
             * Properties of a NatsJetstream.
             * @memberof protos.records
             * @interface INatsJetstream
             * @property {string|null} [stream] NatsJetstream stream
             * @property {Uint8Array|null} [value] NatsJetstream value
             * @property {string|null} [consumerName] NatsJetstream consumerName
             * @property {number|Long|null} [sequence] NatsJetstream sequence
             */

            /**
             * Constructs a new NatsJetstream.
             * @memberof protos.records
             * @classdesc Represents a NatsJetstream.
             * @implements INatsJetstream
             * @constructor
             * @param {protos.records.INatsJetstream=} [properties] Properties to set
             */
            function NatsJetstream(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsJetstream stream.
             * @member {string} stream
             * @memberof protos.records.NatsJetstream
             * @instance
             */
            NatsJetstream.prototype.stream = "";

            /**
             * NatsJetstream value.
             * @member {Uint8Array} value
             * @memberof protos.records.NatsJetstream
             * @instance
             */
            NatsJetstream.prototype.value = $util.newBuffer([]);

            /**
             * NatsJetstream consumerName.
             * @member {string} consumerName
             * @memberof protos.records.NatsJetstream
             * @instance
             */
            NatsJetstream.prototype.consumerName = "";

            /**
             * NatsJetstream sequence.
             * @member {number|Long} sequence
             * @memberof protos.records.NatsJetstream
             * @instance
             */
            NatsJetstream.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new NatsJetstream instance using the specified properties.
             * @function create
             * @memberof protos.records.NatsJetstream
             * @static
             * @param {protos.records.INatsJetstream=} [properties] Properties to set
             * @returns {protos.records.NatsJetstream} NatsJetstream instance
             */
            NatsJetstream.create = function create(properties) {
                return new NatsJetstream(properties);
            };

            /**
             * Encodes the specified NatsJetstream message. Does not implicitly {@link protos.records.NatsJetstream.verify|verify} messages.
             * @function encode
             * @memberof protos.records.NatsJetstream
             * @static
             * @param {protos.records.INatsJetstream} message NatsJetstream message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsJetstream.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stream);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                if (message.consumerName != null && Object.hasOwnProperty.call(message, "consumerName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.consumerName);
                if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.sequence);
                return writer;
            };

            /**
             * Encodes the specified NatsJetstream message, length delimited. Does not implicitly {@link protos.records.NatsJetstream.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.NatsJetstream
             * @static
             * @param {protos.records.INatsJetstream} message NatsJetstream message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsJetstream.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsJetstream message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.NatsJetstream
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.NatsJetstream} NatsJetstream
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsJetstream.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.NatsJetstream();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stream = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    case 3:
                        message.consumerName = reader.string();
                        break;
                    case 4:
                        message.sequence = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsJetstream message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.NatsJetstream
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.NatsJetstream} NatsJetstream
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsJetstream.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsJetstream message.
             * @function verify
             * @memberof protos.records.NatsJetstream
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsJetstream.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isString(message.stream))
                        return "stream: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.consumerName != null && message.hasOwnProperty("consumerName"))
                    if (!$util.isString(message.consumerName))
                        return "consumerName: string expected";
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                        return "sequence: integer|Long expected";
                return null;
            };

            /**
             * Creates a NatsJetstream message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.NatsJetstream
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.NatsJetstream} NatsJetstream
             */
            NatsJetstream.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.NatsJetstream)
                    return object;
                var message = new $root.protos.records.NatsJetstream();
                if (object.stream != null)
                    message.stream = String(object.stream);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.consumerName != null)
                    message.consumerName = String(object.consumerName);
                if (object.sequence != null)
                    if ($util.Long)
                        (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                    else if (typeof object.sequence === "string")
                        message.sequence = parseInt(object.sequence, 10);
                    else if (typeof object.sequence === "number")
                        message.sequence = object.sequence;
                    else if (typeof object.sequence === "object")
                        message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a NatsJetstream message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.NatsJetstream
             * @static
             * @param {protos.records.NatsJetstream} message NatsJetstream
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsJetstream.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.stream = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    object.consumerName = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sequence = options.longs === String ? "0" : 0;
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.consumerName != null && message.hasOwnProperty("consumerName"))
                    object.consumerName = message.consumerName;
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (typeof message.sequence === "number")
                        object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                    else
                        object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
                return object;
            };

            /**
             * Converts this NatsJetstream to JSON.
             * @function toJSON
             * @memberof protos.records.NatsJetstream
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsJetstream.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsJetstream;
        })();

        records.NatsStreaming = (function() {

            /**
             * Properties of a NatsStreaming.
             * @memberof protos.records
             * @interface INatsStreaming
             * @property {Object.<string,string>|null} [metadata] NatsStreaming metadata
             * @property {Uint8Array|null} [value] NatsStreaming value
             * @property {number|Long|null} [timestamp] NatsStreaming timestamp
             */

            /**
             * Constructs a new NatsStreaming.
             * @memberof protos.records
             * @classdesc Represents a NatsStreaming.
             * @implements INatsStreaming
             * @constructor
             * @param {protos.records.INatsStreaming=} [properties] Properties to set
             */
            function NatsStreaming(properties) {
                this.metadata = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsStreaming metadata.
             * @member {Object.<string,string>} metadata
             * @memberof protos.records.NatsStreaming
             * @instance
             */
            NatsStreaming.prototype.metadata = $util.emptyObject;

            /**
             * NatsStreaming value.
             * @member {Uint8Array} value
             * @memberof protos.records.NatsStreaming
             * @instance
             */
            NatsStreaming.prototype.value = $util.newBuffer([]);

            /**
             * NatsStreaming timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.NatsStreaming
             * @instance
             */
            NatsStreaming.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new NatsStreaming instance using the specified properties.
             * @function create
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {protos.records.INatsStreaming=} [properties] Properties to set
             * @returns {protos.records.NatsStreaming} NatsStreaming instance
             */
            NatsStreaming.create = function create(properties) {
                return new NatsStreaming(properties);
            };

            /**
             * Encodes the specified NatsStreaming message. Does not implicitly {@link protos.records.NatsStreaming.verify|verify} messages.
             * @function encode
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {protos.records.INatsStreaming} message NatsStreaming message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreaming.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    for (var keys = Object.keys(message.metadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.metadata[keys[i]]).ldelim();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified NatsStreaming message, length delimited. Does not implicitly {@link protos.records.NatsStreaming.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {protos.records.INatsStreaming} message NatsStreaming message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreaming.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsStreaming message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.NatsStreaming} NatsStreaming
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreaming.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.NatsStreaming(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.metadata === $util.emptyObject)
                            message.metadata = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.metadata[key] = value;
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    case 3:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsStreaming message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.NatsStreaming} NatsStreaming
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreaming.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsStreaming message.
             * @function verify
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsStreaming.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    if (!$util.isObject(message.metadata))
                        return "metadata: object expected";
                    var key = Object.keys(message.metadata);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.metadata[key[i]]))
                            return "metadata: string{k:string} expected";
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a NatsStreaming message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.NatsStreaming} NatsStreaming
             */
            NatsStreaming.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.NatsStreaming)
                    return object;
                var message = new $root.protos.records.NatsStreaming();
                if (object.metadata) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".protos.records.NatsStreaming.metadata: object expected");
                    message.metadata = {};
                    for (var keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i)
                        message.metadata[keys[i]] = String(object.metadata[keys[i]]);
                }
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a NatsStreaming message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {protos.records.NatsStreaming} message NatsStreaming
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsStreaming.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.metadata = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                var keys2;
                if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                    object.metadata = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.metadata[keys2[j]] = message.metadata[keys2[j]];
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this NatsStreaming to JSON.
             * @function toJSON
             * @memberof protos.records.NatsStreaming
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsStreaming.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsStreaming;
        })();

        records.NSQ = (function() {

            /**
             * Properties of a NSQ.
             * @memberof protos.records
             * @interface INSQ
             * @property {string|null} [id] NSQ id
             * @property {string|null} [topic] NSQ topic
             * @property {string|null} [channel] NSQ channel
             * @property {number|null} [attempts] NSQ attempts
             * @property {string|null} [nsqdAddress] NSQ nsqdAddress
             * @property {Uint8Array|null} [value] NSQ value
             * @property {number|Long|null} [timestamp] NSQ timestamp
             */

            /**
             * Constructs a new NSQ.
             * @memberof protos.records
             * @classdesc Represents a NSQ.
             * @implements INSQ
             * @constructor
             * @param {protos.records.INSQ=} [properties] Properties to set
             */
            function NSQ(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NSQ id.
             * @member {string} id
             * @memberof protos.records.NSQ
             * @instance
             */
            NSQ.prototype.id = "";

            /**
             * NSQ topic.
             * @member {string} topic
             * @memberof protos.records.NSQ
             * @instance
             */
            NSQ.prototype.topic = "";

            /**
             * NSQ channel.
             * @member {string} channel
             * @memberof protos.records.NSQ
             * @instance
             */
            NSQ.prototype.channel = "";

            /**
             * NSQ attempts.
             * @member {number} attempts
             * @memberof protos.records.NSQ
             * @instance
             */
            NSQ.prototype.attempts = 0;

            /**
             * NSQ nsqdAddress.
             * @member {string} nsqdAddress
             * @memberof protos.records.NSQ
             * @instance
             */
            NSQ.prototype.nsqdAddress = "";

            /**
             * NSQ value.
             * @member {Uint8Array} value
             * @memberof protos.records.NSQ
             * @instance
             */
            NSQ.prototype.value = $util.newBuffer([]);

            /**
             * NSQ timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.NSQ
             * @instance
             */
            NSQ.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new NSQ instance using the specified properties.
             * @function create
             * @memberof protos.records.NSQ
             * @static
             * @param {protos.records.INSQ=} [properties] Properties to set
             * @returns {protos.records.NSQ} NSQ instance
             */
            NSQ.create = function create(properties) {
                return new NSQ(properties);
            };

            /**
             * Encodes the specified NSQ message. Does not implicitly {@link protos.records.NSQ.verify|verify} messages.
             * @function encode
             * @memberof protos.records.NSQ
             * @static
             * @param {protos.records.INSQ} message NSQ message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQ.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.topic);
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.channel);
                if (message.attempts != null && Object.hasOwnProperty.call(message, "attempts"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.attempts);
                if (message.nsqdAddress != null && Object.hasOwnProperty.call(message, "nsqdAddress"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.nsqdAddress);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.value);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified NSQ message, length delimited. Does not implicitly {@link protos.records.NSQ.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.NSQ
             * @static
             * @param {protos.records.INSQ} message NSQ message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQ.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NSQ message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.NSQ
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.NSQ} NSQ
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQ.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.NSQ();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.topic = reader.string();
                        break;
                    case 3:
                        message.channel = reader.string();
                        break;
                    case 4:
                        message.attempts = reader.int32();
                        break;
                    case 5:
                        message.nsqdAddress = reader.string();
                        break;
                    case 6:
                        message.value = reader.bytes();
                        break;
                    case 7:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NSQ message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.NSQ
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.NSQ} NSQ
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQ.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NSQ message.
             * @function verify
             * @memberof protos.records.NSQ
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NSQ.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                if (message.attempts != null && message.hasOwnProperty("attempts"))
                    if (!$util.isInteger(message.attempts))
                        return "attempts: integer expected";
                if (message.nsqdAddress != null && message.hasOwnProperty("nsqdAddress"))
                    if (!$util.isString(message.nsqdAddress))
                        return "nsqdAddress: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a NSQ message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.NSQ
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.NSQ} NSQ
             */
            NSQ.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.NSQ)
                    return object;
                var message = new $root.protos.records.NSQ();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.channel != null)
                    message.channel = String(object.channel);
                if (object.attempts != null)
                    message.attempts = object.attempts | 0;
                if (object.nsqdAddress != null)
                    message.nsqdAddress = String(object.nsqdAddress);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a NSQ message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.NSQ
             * @static
             * @param {protos.records.NSQ} message NSQ
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NSQ.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    object.topic = "";
                    object.channel = "";
                    object.attempts = 0;
                    object.nsqdAddress = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.attempts != null && message.hasOwnProperty("attempts"))
                    object.attempts = message.attempts;
                if (message.nsqdAddress != null && message.hasOwnProperty("nsqdAddress"))
                    object.nsqdAddress = message.nsqdAddress;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this NSQ to JSON.
             * @function toJSON
             * @memberof protos.records.NSQ
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NSQ.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NSQ;
        })();

        records.Postgres = (function() {

            /**
             * Properties of a Postgres.
             * @memberof protos.records
             * @interface IPostgres
             * @property {Object.<string,string>|null} [metadata] Postgres metadata
             * @property {number|Long|null} [timestamp] Postgres timestamp
             * @property {Uint8Array|null} [value] Postgres value
             */

            /**
             * Constructs a new Postgres.
             * @memberof protos.records
             * @classdesc Represents a Postgres.
             * @implements IPostgres
             * @constructor
             * @param {protos.records.IPostgres=} [properties] Properties to set
             */
            function Postgres(properties) {
                this.metadata = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Postgres metadata.
             * @member {Object.<string,string>} metadata
             * @memberof protos.records.Postgres
             * @instance
             */
            Postgres.prototype.metadata = $util.emptyObject;

            /**
             * Postgres timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.Postgres
             * @instance
             */
            Postgres.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Postgres value.
             * @member {Uint8Array} value
             * @memberof protos.records.Postgres
             * @instance
             */
            Postgres.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Postgres instance using the specified properties.
             * @function create
             * @memberof protos.records.Postgres
             * @static
             * @param {protos.records.IPostgres=} [properties] Properties to set
             * @returns {protos.records.Postgres} Postgres instance
             */
            Postgres.create = function create(properties) {
                return new Postgres(properties);
            };

            /**
             * Encodes the specified Postgres message. Does not implicitly {@link protos.records.Postgres.verify|verify} messages.
             * @function encode
             * @memberof protos.records.Postgres
             * @static
             * @param {protos.records.IPostgres} message Postgres message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Postgres.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    for (var keys = Object.keys(message.metadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.metadata[keys[i]]).ldelim();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Postgres message, length delimited. Does not implicitly {@link protos.records.Postgres.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.Postgres
             * @static
             * @param {protos.records.IPostgres} message Postgres message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Postgres.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Postgres message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.Postgres
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.Postgres} Postgres
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Postgres.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.Postgres(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.metadata === $util.emptyObject)
                            message.metadata = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.metadata[key] = value;
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    case 3:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Postgres message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.Postgres
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.Postgres} Postgres
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Postgres.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Postgres message.
             * @function verify
             * @memberof protos.records.Postgres
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Postgres.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    if (!$util.isObject(message.metadata))
                        return "metadata: object expected";
                    var key = Object.keys(message.metadata);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.metadata[key[i]]))
                            return "metadata: string{k:string} expected";
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a Postgres message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.Postgres
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.Postgres} Postgres
             */
            Postgres.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.Postgres)
                    return object;
                var message = new $root.protos.records.Postgres();
                if (object.metadata) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".protos.records.Postgres.metadata: object expected");
                    message.metadata = {};
                    for (var keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i)
                        message.metadata[keys[i]] = String(object.metadata[keys[i]]);
                }
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a Postgres message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.Postgres
             * @static
             * @param {protos.records.Postgres} message Postgres
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Postgres.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.metadata = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                var keys2;
                if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                    object.metadata = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.metadata[keys2[j]] = message.metadata[keys2[j]];
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Postgres to JSON.
             * @function toJSON
             * @memberof protos.records.Postgres
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Postgres.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Postgres;
        })();

        records.Pulsar = (function() {

            /**
             * Properties of a Pulsar.
             * @memberof protos.records
             * @interface IPulsar
             * @property {string|null} [id] Pulsar id
             * @property {string|null} [key] Pulsar key
             * @property {string|null} [topic] Pulsar topic
             * @property {Object.<string,string>|null} [properties] Pulsar properties
             * @property {number|null} [redeliveryCount] Pulsar redeliveryCount
             * @property {string|null} [eventTime] Pulsar eventTime
             * @property {boolean|null} [isReplicated] Pulsar isReplicated
             * @property {string|null} [orderingKey] Pulsar orderingKey
             * @property {string|null} [producerName] Pulsar producerName
             * @property {string|null} [publishTime] Pulsar publishTime
             * @property {number|Long|null} [timestamp] Pulsar timestamp
             * @property {Uint8Array|null} [value] Pulsar value
             */

            /**
             * Constructs a new Pulsar.
             * @memberof protos.records
             * @classdesc Represents a Pulsar.
             * @implements IPulsar
             * @constructor
             * @param {protos.records.IPulsar=} [properties] Properties to set
             */
            function Pulsar(properties) {
                this.properties = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Pulsar id.
             * @member {string} id
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.id = "";

            /**
             * Pulsar key.
             * @member {string} key
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.key = "";

            /**
             * Pulsar topic.
             * @member {string} topic
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.topic = "";

            /**
             * Pulsar properties.
             * @member {Object.<string,string>} properties
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.properties = $util.emptyObject;

            /**
             * Pulsar redeliveryCount.
             * @member {number} redeliveryCount
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.redeliveryCount = 0;

            /**
             * Pulsar eventTime.
             * @member {string} eventTime
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.eventTime = "";

            /**
             * Pulsar isReplicated.
             * @member {boolean} isReplicated
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.isReplicated = false;

            /**
             * Pulsar orderingKey.
             * @member {string} orderingKey
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.orderingKey = "";

            /**
             * Pulsar producerName.
             * @member {string} producerName
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.producerName = "";

            /**
             * Pulsar publishTime.
             * @member {string} publishTime
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.publishTime = "";

            /**
             * Pulsar timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Pulsar value.
             * @member {Uint8Array} value
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Pulsar instance using the specified properties.
             * @function create
             * @memberof protos.records.Pulsar
             * @static
             * @param {protos.records.IPulsar=} [properties] Properties to set
             * @returns {protos.records.Pulsar} Pulsar instance
             */
            Pulsar.create = function create(properties) {
                return new Pulsar(properties);
            };

            /**
             * Encodes the specified Pulsar message. Does not implicitly {@link protos.records.Pulsar.verify|verify} messages.
             * @function encode
             * @memberof protos.records.Pulsar
             * @static
             * @param {protos.records.IPulsar} message Pulsar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Pulsar.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.key);
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.topic);
                if (message.properties != null && Object.hasOwnProperty.call(message, "properties"))
                    for (var keys = Object.keys(message.properties), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.properties[keys[i]]).ldelim();
                if (message.redeliveryCount != null && Object.hasOwnProperty.call(message, "redeliveryCount"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.redeliveryCount);
                if (message.eventTime != null && Object.hasOwnProperty.call(message, "eventTime"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.eventTime);
                if (message.isReplicated != null && Object.hasOwnProperty.call(message, "isReplicated"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isReplicated);
                if (message.orderingKey != null && Object.hasOwnProperty.call(message, "orderingKey"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.orderingKey);
                if (message.producerName != null && Object.hasOwnProperty.call(message, "producerName"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.producerName);
                if (message.publishTime != null && Object.hasOwnProperty.call(message, "publishTime"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.publishTime);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int64(message.timestamp);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Pulsar message, length delimited. Does not implicitly {@link protos.records.Pulsar.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.Pulsar
             * @static
             * @param {protos.records.IPulsar} message Pulsar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Pulsar.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Pulsar message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.Pulsar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.Pulsar} Pulsar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Pulsar.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.Pulsar(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.key = reader.string();
                        break;
                    case 3:
                        message.topic = reader.string();
                        break;
                    case 4:
                        if (message.properties === $util.emptyObject)
                            message.properties = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.properties[key] = value;
                        break;
                    case 5:
                        message.redeliveryCount = reader.uint32();
                        break;
                    case 6:
                        message.eventTime = reader.string();
                        break;
                    case 7:
                        message.isReplicated = reader.bool();
                        break;
                    case 8:
                        message.orderingKey = reader.string();
                        break;
                    case 9:
                        message.producerName = reader.string();
                        break;
                    case 10:
                        message.publishTime = reader.string();
                        break;
                    case 11:
                        message.timestamp = reader.int64();
                        break;
                    case 12:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Pulsar message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.Pulsar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.Pulsar} Pulsar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Pulsar.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Pulsar message.
             * @function verify
             * @memberof protos.records.Pulsar
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Pulsar.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.properties != null && message.hasOwnProperty("properties")) {
                    if (!$util.isObject(message.properties))
                        return "properties: object expected";
                    var key = Object.keys(message.properties);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.properties[key[i]]))
                            return "properties: string{k:string} expected";
                }
                if (message.redeliveryCount != null && message.hasOwnProperty("redeliveryCount"))
                    if (!$util.isInteger(message.redeliveryCount))
                        return "redeliveryCount: integer expected";
                if (message.eventTime != null && message.hasOwnProperty("eventTime"))
                    if (!$util.isString(message.eventTime))
                        return "eventTime: string expected";
                if (message.isReplicated != null && message.hasOwnProperty("isReplicated"))
                    if (typeof message.isReplicated !== "boolean")
                        return "isReplicated: boolean expected";
                if (message.orderingKey != null && message.hasOwnProperty("orderingKey"))
                    if (!$util.isString(message.orderingKey))
                        return "orderingKey: string expected";
                if (message.producerName != null && message.hasOwnProperty("producerName"))
                    if (!$util.isString(message.producerName))
                        return "producerName: string expected";
                if (message.publishTime != null && message.hasOwnProperty("publishTime"))
                    if (!$util.isString(message.publishTime))
                        return "publishTime: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a Pulsar message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.Pulsar
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.Pulsar} Pulsar
             */
            Pulsar.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.Pulsar)
                    return object;
                var message = new $root.protos.records.Pulsar();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.key != null)
                    message.key = String(object.key);
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.properties) {
                    if (typeof object.properties !== "object")
                        throw TypeError(".protos.records.Pulsar.properties: object expected");
                    message.properties = {};
                    for (var keys = Object.keys(object.properties), i = 0; i < keys.length; ++i)
                        message.properties[keys[i]] = String(object.properties[keys[i]]);
                }
                if (object.redeliveryCount != null)
                    message.redeliveryCount = object.redeliveryCount >>> 0;
                if (object.eventTime != null)
                    message.eventTime = String(object.eventTime);
                if (object.isReplicated != null)
                    message.isReplicated = Boolean(object.isReplicated);
                if (object.orderingKey != null)
                    message.orderingKey = String(object.orderingKey);
                if (object.producerName != null)
                    message.producerName = String(object.producerName);
                if (object.publishTime != null)
                    message.publishTime = String(object.publishTime);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a Pulsar message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.Pulsar
             * @static
             * @param {protos.records.Pulsar} message Pulsar
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Pulsar.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.properties = {};
                if (options.defaults) {
                    object.id = "";
                    object.key = "";
                    object.topic = "";
                    object.redeliveryCount = 0;
                    object.eventTime = "";
                    object.isReplicated = false;
                    object.orderingKey = "";
                    object.producerName = "";
                    object.publishTime = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                var keys2;
                if (message.properties && (keys2 = Object.keys(message.properties)).length) {
                    object.properties = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.properties[keys2[j]] = message.properties[keys2[j]];
                }
                if (message.redeliveryCount != null && message.hasOwnProperty("redeliveryCount"))
                    object.redeliveryCount = message.redeliveryCount;
                if (message.eventTime != null && message.hasOwnProperty("eventTime"))
                    object.eventTime = message.eventTime;
                if (message.isReplicated != null && message.hasOwnProperty("isReplicated"))
                    object.isReplicated = message.isReplicated;
                if (message.orderingKey != null && message.hasOwnProperty("orderingKey"))
                    object.orderingKey = message.orderingKey;
                if (message.producerName != null && message.hasOwnProperty("producerName"))
                    object.producerName = message.producerName;
                if (message.publishTime != null && message.hasOwnProperty("publishTime"))
                    object.publishTime = message.publishTime;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Pulsar to JSON.
             * @function toJSON
             * @memberof protos.records.Pulsar
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Pulsar.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Pulsar;
        })();

        records.RabbitHeader = (function() {

            /**
             * Properties of a RabbitHeader.
             * @memberof protos.records
             * @interface IRabbitHeader
             * @property {string|null} [key] RabbitHeader key
             * @property {string|null} [value] RabbitHeader value
             */

            /**
             * Constructs a new RabbitHeader.
             * @memberof protos.records
             * @classdesc Represents a RabbitHeader.
             * @implements IRabbitHeader
             * @constructor
             * @param {protos.records.IRabbitHeader=} [properties] Properties to set
             */
            function RabbitHeader(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitHeader key.
             * @member {string} key
             * @memberof protos.records.RabbitHeader
             * @instance
             */
            RabbitHeader.prototype.key = "";

            /**
             * RabbitHeader value.
             * @member {string} value
             * @memberof protos.records.RabbitHeader
             * @instance
             */
            RabbitHeader.prototype.value = "";

            /**
             * Creates a new RabbitHeader instance using the specified properties.
             * @function create
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {protos.records.IRabbitHeader=} [properties] Properties to set
             * @returns {protos.records.RabbitHeader} RabbitHeader instance
             */
            RabbitHeader.create = function create(properties) {
                return new RabbitHeader(properties);
            };

            /**
             * Encodes the specified RabbitHeader message. Does not implicitly {@link protos.records.RabbitHeader.verify|verify} messages.
             * @function encode
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {protos.records.IRabbitHeader} message RabbitHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitHeader.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };

            /**
             * Encodes the specified RabbitHeader message, length delimited. Does not implicitly {@link protos.records.RabbitHeader.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {protos.records.IRabbitHeader} message RabbitHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitHeader.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitHeader message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.RabbitHeader} RabbitHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitHeader.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.RabbitHeader();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitHeader message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.RabbitHeader} RabbitHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitHeader.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitHeader message.
             * @function verify
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitHeader.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };

            /**
             * Creates a RabbitHeader message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.RabbitHeader} RabbitHeader
             */
            RabbitHeader.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.RabbitHeader)
                    return object;
                var message = new $root.protos.records.RabbitHeader();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };

            /**
             * Creates a plain object from a RabbitHeader message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {protos.records.RabbitHeader} message RabbitHeader
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitHeader.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.value = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this RabbitHeader to JSON.
             * @function toJSON
             * @memberof protos.records.RabbitHeader
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitHeader.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitHeader;
        })();

        records.Rabbit = (function() {

            /**
             * Properties of a Rabbit.
             * @memberof protos.records
             * @interface IRabbit
             * @property {Uint8Array|null} [body] Rabbit body
             * @property {number|Long|null} [timestamp] Rabbit timestamp
             * @property {string|null} [type] Rabbit type
             * @property {string|null} [exchange] Rabbit exchange
             * @property {string|null} [routingKey] Rabbit routingKey
             * @property {string|null} [contentType] Rabbit contentType
             * @property {string|null} [contentEncoding] Rabbit contentEncoding
             * @property {number|null} [priority] Rabbit priority
             * @property {string|null} [expiration] Rabbit expiration
             * @property {string|null} [messageId] Rabbit messageId
             * @property {string|null} [userId] Rabbit userId
             * @property {string|null} [appId] Rabbit appId
             * @property {string|null} [replyTo] Rabbit replyTo
             * @property {string|null} [correlationId] Rabbit correlationId
             * @property {Array.<protos.records.IRabbitHeader>|null} [headers] Rabbit headers
             */

            /**
             * Constructs a new Rabbit.
             * @memberof protos.records
             * @classdesc Represents a Rabbit.
             * @implements IRabbit
             * @constructor
             * @param {protos.records.IRabbit=} [properties] Properties to set
             */
            function Rabbit(properties) {
                this.headers = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Rabbit body.
             * @member {Uint8Array} body
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.body = $util.newBuffer([]);

            /**
             * Rabbit timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Rabbit type.
             * @member {string} type
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.type = "";

            /**
             * Rabbit exchange.
             * @member {string} exchange
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.exchange = "";

            /**
             * Rabbit routingKey.
             * @member {string} routingKey
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.routingKey = "";

            /**
             * Rabbit contentType.
             * @member {string} contentType
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.contentType = "";

            /**
             * Rabbit contentEncoding.
             * @member {string} contentEncoding
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.contentEncoding = "";

            /**
             * Rabbit priority.
             * @member {number} priority
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.priority = 0;

            /**
             * Rabbit expiration.
             * @member {string} expiration
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.expiration = "";

            /**
             * Rabbit messageId.
             * @member {string} messageId
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.messageId = "";

            /**
             * Rabbit userId.
             * @member {string} userId
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.userId = "";

            /**
             * Rabbit appId.
             * @member {string} appId
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.appId = "";

            /**
             * Rabbit replyTo.
             * @member {string} replyTo
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.replyTo = "";

            /**
             * Rabbit correlationId.
             * @member {string} correlationId
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.correlationId = "";

            /**
             * Rabbit headers.
             * @member {Array.<protos.records.IRabbitHeader>} headers
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.headers = $util.emptyArray;

            /**
             * Creates a new Rabbit instance using the specified properties.
             * @function create
             * @memberof protos.records.Rabbit
             * @static
             * @param {protos.records.IRabbit=} [properties] Properties to set
             * @returns {protos.records.Rabbit} Rabbit instance
             */
            Rabbit.create = function create(properties) {
                return new Rabbit(properties);
            };

            /**
             * Encodes the specified Rabbit message. Does not implicitly {@link protos.records.Rabbit.verify|verify} messages.
             * @function encode
             * @memberof protos.records.Rabbit
             * @static
             * @param {protos.records.IRabbit} message Rabbit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Rabbit.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.body);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.type);
                if (message.exchange != null && Object.hasOwnProperty.call(message, "exchange"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.exchange);
                if (message.routingKey != null && Object.hasOwnProperty.call(message, "routingKey"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.routingKey);
                if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.contentType);
                if (message.contentEncoding != null && Object.hasOwnProperty.call(message, "contentEncoding"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.contentEncoding);
                if (message.priority != null && Object.hasOwnProperty.call(message, "priority"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.priority);
                if (message.expiration != null && Object.hasOwnProperty.call(message, "expiration"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.expiration);
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.messageId);
                if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.userId);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.appId);
                if (message.replyTo != null && Object.hasOwnProperty.call(message, "replyTo"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.replyTo);
                if (message.correlationId != null && Object.hasOwnProperty.call(message, "correlationId"))
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.correlationId);
                if (message.headers != null && message.headers.length)
                    for (var i = 0; i < message.headers.length; ++i)
                        $root.protos.records.RabbitHeader.encode(message.headers[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Rabbit message, length delimited. Does not implicitly {@link protos.records.Rabbit.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.Rabbit
             * @static
             * @param {protos.records.IRabbit} message Rabbit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Rabbit.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Rabbit message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.Rabbit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.Rabbit} Rabbit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Rabbit.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.Rabbit();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.body = reader.bytes();
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    case 3:
                        message.type = reader.string();
                        break;
                    case 4:
                        message.exchange = reader.string();
                        break;
                    case 5:
                        message.routingKey = reader.string();
                        break;
                    case 6:
                        message.contentType = reader.string();
                        break;
                    case 7:
                        message.contentEncoding = reader.string();
                        break;
                    case 8:
                        message.priority = reader.int32();
                        break;
                    case 9:
                        message.expiration = reader.string();
                        break;
                    case 10:
                        message.messageId = reader.string();
                        break;
                    case 11:
                        message.userId = reader.string();
                        break;
                    case 12:
                        message.appId = reader.string();
                        break;
                    case 13:
                        message.replyTo = reader.string();
                        break;
                    case 14:
                        message.correlationId = reader.string();
                        break;
                    case 15:
                        if (!(message.headers && message.headers.length))
                            message.headers = [];
                        message.headers.push($root.protos.records.RabbitHeader.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Rabbit message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.Rabbit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.Rabbit} Rabbit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Rabbit.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Rabbit message.
             * @function verify
             * @memberof protos.records.Rabbit
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Rabbit.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.body != null && message.hasOwnProperty("body"))
                    if (!(message.body && typeof message.body.length === "number" || $util.isString(message.body)))
                        return "body: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isString(message.type))
                        return "type: string expected";
                if (message.exchange != null && message.hasOwnProperty("exchange"))
                    if (!$util.isString(message.exchange))
                        return "exchange: string expected";
                if (message.routingKey != null && message.hasOwnProperty("routingKey"))
                    if (!$util.isString(message.routingKey))
                        return "routingKey: string expected";
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    if (!$util.isString(message.contentType))
                        return "contentType: string expected";
                if (message.contentEncoding != null && message.hasOwnProperty("contentEncoding"))
                    if (!$util.isString(message.contentEncoding))
                        return "contentEncoding: string expected";
                if (message.priority != null && message.hasOwnProperty("priority"))
                    if (!$util.isInteger(message.priority))
                        return "priority: integer expected";
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    if (!$util.isString(message.expiration))
                        return "expiration: string expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                if (message.userId != null && message.hasOwnProperty("userId"))
                    if (!$util.isString(message.userId))
                        return "userId: string expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!$util.isString(message.appId))
                        return "appId: string expected";
                if (message.replyTo != null && message.hasOwnProperty("replyTo"))
                    if (!$util.isString(message.replyTo))
                        return "replyTo: string expected";
                if (message.correlationId != null && message.hasOwnProperty("correlationId"))
                    if (!$util.isString(message.correlationId))
                        return "correlationId: string expected";
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    if (!Array.isArray(message.headers))
                        return "headers: array expected";
                    for (var i = 0; i < message.headers.length; ++i) {
                        var error = $root.protos.records.RabbitHeader.verify(message.headers[i]);
                        if (error)
                            return "headers." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Rabbit message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.Rabbit
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.Rabbit} Rabbit
             */
            Rabbit.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.Rabbit)
                    return object;
                var message = new $root.protos.records.Rabbit();
                if (object.body != null)
                    if (typeof object.body === "string")
                        $util.base64.decode(object.body, message.body = $util.newBuffer($util.base64.length(object.body)), 0);
                    else if (object.body.length)
                        message.body = object.body;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.type != null)
                    message.type = String(object.type);
                if (object.exchange != null)
                    message.exchange = String(object.exchange);
                if (object.routingKey != null)
                    message.routingKey = String(object.routingKey);
                if (object.contentType != null)
                    message.contentType = String(object.contentType);
                if (object.contentEncoding != null)
                    message.contentEncoding = String(object.contentEncoding);
                if (object.priority != null)
                    message.priority = object.priority | 0;
                if (object.expiration != null)
                    message.expiration = String(object.expiration);
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.userId != null)
                    message.userId = String(object.userId);
                if (object.appId != null)
                    message.appId = String(object.appId);
                if (object.replyTo != null)
                    message.replyTo = String(object.replyTo);
                if (object.correlationId != null)
                    message.correlationId = String(object.correlationId);
                if (object.headers) {
                    if (!Array.isArray(object.headers))
                        throw TypeError(".protos.records.Rabbit.headers: array expected");
                    message.headers = [];
                    for (var i = 0; i < object.headers.length; ++i) {
                        if (typeof object.headers[i] !== "object")
                            throw TypeError(".protos.records.Rabbit.headers: object expected");
                        message.headers[i] = $root.protos.records.RabbitHeader.fromObject(object.headers[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Rabbit message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.Rabbit
             * @static
             * @param {protos.records.Rabbit} message Rabbit
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Rabbit.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.headers = [];
                if (options.defaults) {
                    if (options.bytes === String)
                        object.body = "";
                    else {
                        object.body = [];
                        if (options.bytes !== Array)
                            object.body = $util.newBuffer(object.body);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    object.type = "";
                    object.exchange = "";
                    object.routingKey = "";
                    object.contentType = "";
                    object.contentEncoding = "";
                    object.priority = 0;
                    object.expiration = "";
                    object.messageId = "";
                    object.userId = "";
                    object.appId = "";
                    object.replyTo = "";
                    object.correlationId = "";
                }
                if (message.body != null && message.hasOwnProperty("body"))
                    object.body = options.bytes === String ? $util.base64.encode(message.body, 0, message.body.length) : options.bytes === Array ? Array.prototype.slice.call(message.body) : message.body;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.exchange != null && message.hasOwnProperty("exchange"))
                    object.exchange = message.exchange;
                if (message.routingKey != null && message.hasOwnProperty("routingKey"))
                    object.routingKey = message.routingKey;
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    object.contentType = message.contentType;
                if (message.contentEncoding != null && message.hasOwnProperty("contentEncoding"))
                    object.contentEncoding = message.contentEncoding;
                if (message.priority != null && message.hasOwnProperty("priority"))
                    object.priority = message.priority;
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    object.expiration = message.expiration;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                if (message.userId != null && message.hasOwnProperty("userId"))
                    object.userId = message.userId;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = message.appId;
                if (message.replyTo != null && message.hasOwnProperty("replyTo"))
                    object.replyTo = message.replyTo;
                if (message.correlationId != null && message.hasOwnProperty("correlationId"))
                    object.correlationId = message.correlationId;
                if (message.headers && message.headers.length) {
                    object.headers = [];
                    for (var j = 0; j < message.headers.length; ++j)
                        object.headers[j] = $root.protos.records.RabbitHeader.toObject(message.headers[j], options);
                }
                return object;
            };

            /**
             * Converts this Rabbit to JSON.
             * @function toJSON
             * @memberof protos.records.Rabbit
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Rabbit.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Rabbit;
        })();

        records.RabbitStreams = (function() {

            /**
             * Properties of a RabbitStreams.
             * @memberof protos.records
             * @interface IRabbitStreams
             * @property {string|null} [deliveryTag] RabbitStreams deliveryTag
             * @property {number|null} [format] RabbitStreams format
             * @property {protos.records.IRabbitStreamsHeader|null} [header] RabbitStreams header
             * @property {Object.<string,string>|null} [deliveryAnnotations] RabbitStreams deliveryAnnotations
             * @property {boolean|null} [sendSettled] RabbitStreams sendSettled
             * @property {string|null} [streamName] RabbitStreams streamName
             * @property {number|Long|null} [timestamp] RabbitStreams timestamp
             * @property {Uint8Array|null} [value] RabbitStreams value
             */

            /**
             * Constructs a new RabbitStreams.
             * @memberof protos.records
             * @classdesc Represents a RabbitStreams.
             * @implements IRabbitStreams
             * @constructor
             * @param {protos.records.IRabbitStreams=} [properties] Properties to set
             */
            function RabbitStreams(properties) {
                this.deliveryAnnotations = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreams deliveryTag.
             * @member {string} deliveryTag
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.deliveryTag = "";

            /**
             * RabbitStreams format.
             * @member {number} format
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.format = 0;

            /**
             * RabbitStreams header.
             * @member {protos.records.IRabbitStreamsHeader|null|undefined} header
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.header = null;

            /**
             * RabbitStreams deliveryAnnotations.
             * @member {Object.<string,string>} deliveryAnnotations
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.deliveryAnnotations = $util.emptyObject;

            /**
             * RabbitStreams sendSettled.
             * @member {boolean} sendSettled
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.sendSettled = false;

            /**
             * RabbitStreams streamName.
             * @member {string} streamName
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.streamName = "";

            /**
             * RabbitStreams timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * RabbitStreams value.
             * @member {Uint8Array} value
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new RabbitStreams instance using the specified properties.
             * @function create
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {protos.records.IRabbitStreams=} [properties] Properties to set
             * @returns {protos.records.RabbitStreams} RabbitStreams instance
             */
            RabbitStreams.create = function create(properties) {
                return new RabbitStreams(properties);
            };

            /**
             * Encodes the specified RabbitStreams message. Does not implicitly {@link protos.records.RabbitStreams.verify|verify} messages.
             * @function encode
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {protos.records.IRabbitStreams} message RabbitStreams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreams.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deliveryTag != null && Object.hasOwnProperty.call(message, "deliveryTag"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.deliveryTag);
                if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.format);
                if (message.header != null && Object.hasOwnProperty.call(message, "header"))
                    $root.protos.records.RabbitStreamsHeader.encode(message.header, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.deliveryAnnotations != null && Object.hasOwnProperty.call(message, "deliveryAnnotations"))
                    for (var keys = Object.keys(message.deliveryAnnotations), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.deliveryAnnotations[keys[i]]).ldelim();
                if (message.sendSettled != null && Object.hasOwnProperty.call(message, "sendSettled"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.sendSettled);
                if (message.streamName != null && Object.hasOwnProperty.call(message, "streamName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.streamName);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified RabbitStreams message, length delimited. Does not implicitly {@link protos.records.RabbitStreams.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {protos.records.IRabbitStreams} message RabbitStreams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreams.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreams message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.RabbitStreams} RabbitStreams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreams.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.RabbitStreams(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.deliveryTag = reader.string();
                        break;
                    case 2:
                        message.format = reader.uint32();
                        break;
                    case 3:
                        message.header = $root.protos.records.RabbitStreamsHeader.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (message.deliveryAnnotations === $util.emptyObject)
                            message.deliveryAnnotations = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.deliveryAnnotations[key] = value;
                        break;
                    case 5:
                        message.sendSettled = reader.bool();
                        break;
                    case 6:
                        message.streamName = reader.string();
                        break;
                    case 7:
                        message.timestamp = reader.int64();
                        break;
                    case 8:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreams message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.RabbitStreams} RabbitStreams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreams.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreams message.
             * @function verify
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreams.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deliveryTag != null && message.hasOwnProperty("deliveryTag"))
                    if (!$util.isString(message.deliveryTag))
                        return "deliveryTag: string expected";
                if (message.format != null && message.hasOwnProperty("format"))
                    if (!$util.isInteger(message.format))
                        return "format: integer expected";
                if (message.header != null && message.hasOwnProperty("header")) {
                    var error = $root.protos.records.RabbitStreamsHeader.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                if (message.deliveryAnnotations != null && message.hasOwnProperty("deliveryAnnotations")) {
                    if (!$util.isObject(message.deliveryAnnotations))
                        return "deliveryAnnotations: object expected";
                    var key = Object.keys(message.deliveryAnnotations);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.deliveryAnnotations[key[i]]))
                            return "deliveryAnnotations: string{k:string} expected";
                }
                if (message.sendSettled != null && message.hasOwnProperty("sendSettled"))
                    if (typeof message.sendSettled !== "boolean")
                        return "sendSettled: boolean expected";
                if (message.streamName != null && message.hasOwnProperty("streamName"))
                    if (!$util.isString(message.streamName))
                        return "streamName: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a RabbitStreams message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.RabbitStreams} RabbitStreams
             */
            RabbitStreams.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.RabbitStreams)
                    return object;
                var message = new $root.protos.records.RabbitStreams();
                if (object.deliveryTag != null)
                    message.deliveryTag = String(object.deliveryTag);
                if (object.format != null)
                    message.format = object.format >>> 0;
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".protos.records.RabbitStreams.header: object expected");
                    message.header = $root.protos.records.RabbitStreamsHeader.fromObject(object.header);
                }
                if (object.deliveryAnnotations) {
                    if (typeof object.deliveryAnnotations !== "object")
                        throw TypeError(".protos.records.RabbitStreams.deliveryAnnotations: object expected");
                    message.deliveryAnnotations = {};
                    for (var keys = Object.keys(object.deliveryAnnotations), i = 0; i < keys.length; ++i)
                        message.deliveryAnnotations[keys[i]] = String(object.deliveryAnnotations[keys[i]]);
                }
                if (object.sendSettled != null)
                    message.sendSettled = Boolean(object.sendSettled);
                if (object.streamName != null)
                    message.streamName = String(object.streamName);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreams message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {protos.records.RabbitStreams} message RabbitStreams
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreams.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.deliveryAnnotations = {};
                if (options.defaults) {
                    object.deliveryTag = "";
                    object.format = 0;
                    object.header = null;
                    object.sendSettled = false;
                    object.streamName = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.deliveryTag != null && message.hasOwnProperty("deliveryTag"))
                    object.deliveryTag = message.deliveryTag;
                if (message.format != null && message.hasOwnProperty("format"))
                    object.format = message.format;
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.protos.records.RabbitStreamsHeader.toObject(message.header, options);
                var keys2;
                if (message.deliveryAnnotations && (keys2 = Object.keys(message.deliveryAnnotations)).length) {
                    object.deliveryAnnotations = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.deliveryAnnotations[keys2[j]] = message.deliveryAnnotations[keys2[j]];
                }
                if (message.sendSettled != null && message.hasOwnProperty("sendSettled"))
                    object.sendSettled = message.sendSettled;
                if (message.streamName != null && message.hasOwnProperty("streamName"))
                    object.streamName = message.streamName;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this RabbitStreams to JSON.
             * @function toJSON
             * @memberof protos.records.RabbitStreams
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreams.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreams;
        })();

        records.RabbitStreamsHeader = (function() {

            /**
             * Properties of a RabbitStreamsHeader.
             * @memberof protos.records
             * @interface IRabbitStreamsHeader
             * @property {boolean|null} [durable] RabbitStreamsHeader durable
             * @property {number|null} [priority] RabbitStreamsHeader priority
             * @property {number|Long|null} [ttl] RabbitStreamsHeader ttl
             * @property {boolean|null} [firstAcquirer] RabbitStreamsHeader firstAcquirer
             * @property {number|null} [deliveryCount] RabbitStreamsHeader deliveryCount
             */

            /**
             * Constructs a new RabbitStreamsHeader.
             * @memberof protos.records
             * @classdesc Represents a RabbitStreamsHeader.
             * @implements IRabbitStreamsHeader
             * @constructor
             * @param {protos.records.IRabbitStreamsHeader=} [properties] Properties to set
             */
            function RabbitStreamsHeader(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreamsHeader durable.
             * @member {boolean} durable
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.durable = false;

            /**
             * RabbitStreamsHeader priority.
             * @member {number} priority
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.priority = 0;

            /**
             * RabbitStreamsHeader ttl.
             * @member {number|Long} ttl
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.ttl = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * RabbitStreamsHeader firstAcquirer.
             * @member {boolean} firstAcquirer
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.firstAcquirer = false;

            /**
             * RabbitStreamsHeader deliveryCount.
             * @member {number} deliveryCount
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.deliveryCount = 0;

            /**
             * Creates a new RabbitStreamsHeader instance using the specified properties.
             * @function create
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {protos.records.IRabbitStreamsHeader=} [properties] Properties to set
             * @returns {protos.records.RabbitStreamsHeader} RabbitStreamsHeader instance
             */
            RabbitStreamsHeader.create = function create(properties) {
                return new RabbitStreamsHeader(properties);
            };

            /**
             * Encodes the specified RabbitStreamsHeader message. Does not implicitly {@link protos.records.RabbitStreamsHeader.verify|verify} messages.
             * @function encode
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {protos.records.IRabbitStreamsHeader} message RabbitStreamsHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsHeader.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.durable != null && Object.hasOwnProperty.call(message, "durable"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.durable);
                if (message.priority != null && Object.hasOwnProperty.call(message, "priority"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.priority);
                if (message.ttl != null && Object.hasOwnProperty.call(message, "ttl"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.ttl);
                if (message.firstAcquirer != null && Object.hasOwnProperty.call(message, "firstAcquirer"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.firstAcquirer);
                if (message.deliveryCount != null && Object.hasOwnProperty.call(message, "deliveryCount"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.deliveryCount);
                return writer;
            };

            /**
             * Encodes the specified RabbitStreamsHeader message, length delimited. Does not implicitly {@link protos.records.RabbitStreamsHeader.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {protos.records.IRabbitStreamsHeader} message RabbitStreamsHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsHeader.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreamsHeader message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.RabbitStreamsHeader} RabbitStreamsHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsHeader.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.RabbitStreamsHeader();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.durable = reader.bool();
                        break;
                    case 2:
                        message.priority = reader.uint32();
                        break;
                    case 3:
                        message.ttl = reader.int64();
                        break;
                    case 4:
                        message.firstAcquirer = reader.bool();
                        break;
                    case 5:
                        message.deliveryCount = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreamsHeader message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.RabbitStreamsHeader} RabbitStreamsHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsHeader.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreamsHeader message.
             * @function verify
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreamsHeader.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.durable != null && message.hasOwnProperty("durable"))
                    if (typeof message.durable !== "boolean")
                        return "durable: boolean expected";
                if (message.priority != null && message.hasOwnProperty("priority"))
                    if (!$util.isInteger(message.priority))
                        return "priority: integer expected";
                if (message.ttl != null && message.hasOwnProperty("ttl"))
                    if (!$util.isInteger(message.ttl) && !(message.ttl && $util.isInteger(message.ttl.low) && $util.isInteger(message.ttl.high)))
                        return "ttl: integer|Long expected";
                if (message.firstAcquirer != null && message.hasOwnProperty("firstAcquirer"))
                    if (typeof message.firstAcquirer !== "boolean")
                        return "firstAcquirer: boolean expected";
                if (message.deliveryCount != null && message.hasOwnProperty("deliveryCount"))
                    if (!$util.isInteger(message.deliveryCount))
                        return "deliveryCount: integer expected";
                return null;
            };

            /**
             * Creates a RabbitStreamsHeader message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.RabbitStreamsHeader} RabbitStreamsHeader
             */
            RabbitStreamsHeader.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.RabbitStreamsHeader)
                    return object;
                var message = new $root.protos.records.RabbitStreamsHeader();
                if (object.durable != null)
                    message.durable = Boolean(object.durable);
                if (object.priority != null)
                    message.priority = object.priority >>> 0;
                if (object.ttl != null)
                    if ($util.Long)
                        (message.ttl = $util.Long.fromValue(object.ttl)).unsigned = false;
                    else if (typeof object.ttl === "string")
                        message.ttl = parseInt(object.ttl, 10);
                    else if (typeof object.ttl === "number")
                        message.ttl = object.ttl;
                    else if (typeof object.ttl === "object")
                        message.ttl = new $util.LongBits(object.ttl.low >>> 0, object.ttl.high >>> 0).toNumber();
                if (object.firstAcquirer != null)
                    message.firstAcquirer = Boolean(object.firstAcquirer);
                if (object.deliveryCount != null)
                    message.deliveryCount = object.deliveryCount >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreamsHeader message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {protos.records.RabbitStreamsHeader} message RabbitStreamsHeader
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreamsHeader.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.durable = false;
                    object.priority = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ttl = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ttl = options.longs === String ? "0" : 0;
                    object.firstAcquirer = false;
                    object.deliveryCount = 0;
                }
                if (message.durable != null && message.hasOwnProperty("durable"))
                    object.durable = message.durable;
                if (message.priority != null && message.hasOwnProperty("priority"))
                    object.priority = message.priority;
                if (message.ttl != null && message.hasOwnProperty("ttl"))
                    if (typeof message.ttl === "number")
                        object.ttl = options.longs === String ? String(message.ttl) : message.ttl;
                    else
                        object.ttl = options.longs === String ? $util.Long.prototype.toString.call(message.ttl) : options.longs === Number ? new $util.LongBits(message.ttl.low >>> 0, message.ttl.high >>> 0).toNumber() : message.ttl;
                if (message.firstAcquirer != null && message.hasOwnProperty("firstAcquirer"))
                    object.firstAcquirer = message.firstAcquirer;
                if (message.deliveryCount != null && message.hasOwnProperty("deliveryCount"))
                    object.deliveryCount = message.deliveryCount;
                return object;
            };

            /**
             * Converts this RabbitStreamsHeader to JSON.
             * @function toJSON
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreamsHeader.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreamsHeader;
        })();

        records.RedisPubsub = (function() {

            /**
             * Properties of a RedisPubsub.
             * @memberof protos.records
             * @interface IRedisPubsub
             * @property {Object.<string,string>|null} [metadata] RedisPubsub metadata
             * @property {Uint8Array|null} [value] RedisPubsub value
             * @property {number|Long|null} [timestamp] RedisPubsub timestamp
             */

            /**
             * Constructs a new RedisPubsub.
             * @memberof protos.records
             * @classdesc Represents a RedisPubsub.
             * @implements IRedisPubsub
             * @constructor
             * @param {protos.records.IRedisPubsub=} [properties] Properties to set
             */
            function RedisPubsub(properties) {
                this.metadata = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisPubsub metadata.
             * @member {Object.<string,string>} metadata
             * @memberof protos.records.RedisPubsub
             * @instance
             */
            RedisPubsub.prototype.metadata = $util.emptyObject;

            /**
             * RedisPubsub value.
             * @member {Uint8Array} value
             * @memberof protos.records.RedisPubsub
             * @instance
             */
            RedisPubsub.prototype.value = $util.newBuffer([]);

            /**
             * RedisPubsub timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.RedisPubsub
             * @instance
             */
            RedisPubsub.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new RedisPubsub instance using the specified properties.
             * @function create
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {protos.records.IRedisPubsub=} [properties] Properties to set
             * @returns {protos.records.RedisPubsub} RedisPubsub instance
             */
            RedisPubsub.create = function create(properties) {
                return new RedisPubsub(properties);
            };

            /**
             * Encodes the specified RedisPubsub message. Does not implicitly {@link protos.records.RedisPubsub.verify|verify} messages.
             * @function encode
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {protos.records.IRedisPubsub} message RedisPubsub message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubsub.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    for (var keys = Object.keys(message.metadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.metadata[keys[i]]).ldelim();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified RedisPubsub message, length delimited. Does not implicitly {@link protos.records.RedisPubsub.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {protos.records.IRedisPubsub} message RedisPubsub message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubsub.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisPubsub message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.RedisPubsub} RedisPubsub
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubsub.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.RedisPubsub(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.metadata === $util.emptyObject)
                            message.metadata = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.metadata[key] = value;
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    case 3:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisPubsub message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.RedisPubsub} RedisPubsub
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubsub.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisPubsub message.
             * @function verify
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisPubsub.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    if (!$util.isObject(message.metadata))
                        return "metadata: object expected";
                    var key = Object.keys(message.metadata);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.metadata[key[i]]))
                            return "metadata: string{k:string} expected";
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a RedisPubsub message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.RedisPubsub} RedisPubsub
             */
            RedisPubsub.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.RedisPubsub)
                    return object;
                var message = new $root.protos.records.RedisPubsub();
                if (object.metadata) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".protos.records.RedisPubsub.metadata: object expected");
                    message.metadata = {};
                    for (var keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i)
                        message.metadata[keys[i]] = String(object.metadata[keys[i]]);
                }
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a RedisPubsub message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {protos.records.RedisPubsub} message RedisPubsub
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisPubsub.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.metadata = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                var keys2;
                if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                    object.metadata = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.metadata[keys2[j]] = message.metadata[keys2[j]];
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this RedisPubsub to JSON.
             * @function toJSON
             * @memberof protos.records.RedisPubsub
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisPubsub.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisPubsub;
        })();

        records.RedisStreams = (function() {

            /**
             * Properties of a RedisStreams.
             * @memberof protos.records
             * @interface IRedisStreams
             * @property {string|null} [id] RedisStreams id
             * @property {string|null} [key] RedisStreams key
             * @property {string|null} [value] RedisStreams value
             * @property {string|null} [stream] RedisStreams stream
             * @property {number|Long|null} [timestamp] RedisStreams timestamp
             */

            /**
             * Constructs a new RedisStreams.
             * @memberof protos.records
             * @classdesc Represents a RedisStreams.
             * @implements IRedisStreams
             * @constructor
             * @param {protos.records.IRedisStreams=} [properties] Properties to set
             */
            function RedisStreams(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisStreams id.
             * @member {string} id
             * @memberof protos.records.RedisStreams
             * @instance
             */
            RedisStreams.prototype.id = "";

            /**
             * RedisStreams key.
             * @member {string} key
             * @memberof protos.records.RedisStreams
             * @instance
             */
            RedisStreams.prototype.key = "";

            /**
             * RedisStreams value.
             * @member {string} value
             * @memberof protos.records.RedisStreams
             * @instance
             */
            RedisStreams.prototype.value = "";

            /**
             * RedisStreams stream.
             * @member {string} stream
             * @memberof protos.records.RedisStreams
             * @instance
             */
            RedisStreams.prototype.stream = "";

            /**
             * RedisStreams timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.RedisStreams
             * @instance
             */
            RedisStreams.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new RedisStreams instance using the specified properties.
             * @function create
             * @memberof protos.records.RedisStreams
             * @static
             * @param {protos.records.IRedisStreams=} [properties] Properties to set
             * @returns {protos.records.RedisStreams} RedisStreams instance
             */
            RedisStreams.create = function create(properties) {
                return new RedisStreams(properties);
            };

            /**
             * Encodes the specified RedisStreams message. Does not implicitly {@link protos.records.RedisStreams.verify|verify} messages.
             * @function encode
             * @memberof protos.records.RedisStreams
             * @static
             * @param {protos.records.IRedisStreams} message RedisStreams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreams.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.value);
                if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.stream);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified RedisStreams message, length delimited. Does not implicitly {@link protos.records.RedisStreams.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.RedisStreams
             * @static
             * @param {protos.records.IRedisStreams} message RedisStreams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreams.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisStreams message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.RedisStreams
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.RedisStreams} RedisStreams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreams.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.RedisStreams();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.key = reader.string();
                        break;
                    case 3:
                        message.value = reader.string();
                        break;
                    case 4:
                        message.stream = reader.string();
                        break;
                    case 5:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisStreams message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.RedisStreams
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.RedisStreams} RedisStreams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreams.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisStreams message.
             * @function verify
             * @memberof protos.records.RedisStreams
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisStreams.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isString(message.stream))
                        return "stream: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a RedisStreams message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.RedisStreams
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.RedisStreams} RedisStreams
             */
            RedisStreams.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.RedisStreams)
                    return object;
                var message = new $root.protos.records.RedisStreams();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    message.value = String(object.value);
                if (object.stream != null)
                    message.stream = String(object.stream);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a RedisStreams message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.RedisStreams
             * @static
             * @param {protos.records.RedisStreams} message RedisStreams
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisStreams.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    object.key = "";
                    object.value = "";
                    object.stream = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this RedisStreams to JSON.
             * @function toJSON
             * @memberof protos.records.RedisStreams
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisStreams.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisStreams;
        })();

        return records;
    })();

    return protos;
})();

module.exports = $root;
