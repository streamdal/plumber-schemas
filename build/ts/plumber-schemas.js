/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.protos = (function() {

    /**
     * Namespace protos.
     * @exports protos
     * @namespace
     */
    var protos = {};

    protos.PlumberServer = (function() {

        /**
         * Constructs a new PlumberServer service.
         * @memberof protos
         * @classdesc Represents a PlumberServer
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function PlumberServer(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (PlumberServer.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = PlumberServer;

        /**
         * Creates new PlumberServer service using the specified rpc implementation.
         * @function create
         * @memberof protos.PlumberServer
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {PlumberServer} RPC service. Useful where requests and/or responses are streamed.
         */
        PlumberServer.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link protos.PlumberServer#getAllConnections}.
         * @memberof protos.PlumberServer
         * @typedef GetAllConnectionsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetAllConnectionsResponse} [response] GetAllConnectionsResponse
         */

        /**
         * Calls GetAllConnections.
         * @function getAllConnections
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllConnectionsRequest} request GetAllConnectionsRequest message or plain object
         * @param {protos.PlumberServer.GetAllConnectionsCallback} callback Node-style callback called with the error, if any, and GetAllConnectionsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getAllConnections = function getAllConnections(request, callback) {
            return this.rpcCall(getAllConnections, $root.protos.GetAllConnectionsRequest, $root.protos.GetAllConnectionsResponse, request, callback);
        }, "name", { value: "GetAllConnections" });

        /**
         * Calls GetAllConnections.
         * @function getAllConnections
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllConnectionsRequest} request GetAllConnectionsRequest message or plain object
         * @returns {Promise<protos.GetAllConnectionsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getConnection}.
         * @memberof protos.PlumberServer
         * @typedef GetConnectionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetConnectionResponse} [response] GetConnectionResponse
         */

        /**
         * Calls GetConnection.
         * @function getConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetConnectionRequest} request GetConnectionRequest message or plain object
         * @param {protos.PlumberServer.GetConnectionCallback} callback Node-style callback called with the error, if any, and GetConnectionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getConnection = function getConnection(request, callback) {
            return this.rpcCall(getConnection, $root.protos.GetConnectionRequest, $root.protos.GetConnectionResponse, request, callback);
        }, "name", { value: "GetConnection" });

        /**
         * Calls GetConnection.
         * @function getConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetConnectionRequest} request GetConnectionRequest message or plain object
         * @returns {Promise<protos.GetConnectionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#createConnection}.
         * @memberof protos.PlumberServer
         * @typedef CreateConnectionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.CreateConnectionResponse} [response] CreateConnectionResponse
         */

        /**
         * Calls CreateConnection.
         * @function createConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateConnectionRequest} request CreateConnectionRequest message or plain object
         * @param {protos.PlumberServer.CreateConnectionCallback} callback Node-style callback called with the error, if any, and CreateConnectionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.createConnection = function createConnection(request, callback) {
            return this.rpcCall(createConnection, $root.protos.CreateConnectionRequest, $root.protos.CreateConnectionResponse, request, callback);
        }, "name", { value: "CreateConnection" });

        /**
         * Calls CreateConnection.
         * @function createConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateConnectionRequest} request CreateConnectionRequest message or plain object
         * @returns {Promise<protos.CreateConnectionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#testConnection}.
         * @memberof protos.PlumberServer
         * @typedef TestConnectionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.TestConnectionResponse} [response] TestConnectionResponse
         */

        /**
         * Calls TestConnection.
         * @function testConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ITestConnectionRequest} request TestConnectionRequest message or plain object
         * @param {protos.PlumberServer.TestConnectionCallback} callback Node-style callback called with the error, if any, and TestConnectionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.testConnection = function testConnection(request, callback) {
            return this.rpcCall(testConnection, $root.protos.TestConnectionRequest, $root.protos.TestConnectionResponse, request, callback);
        }, "name", { value: "TestConnection" });

        /**
         * Calls TestConnection.
         * @function testConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ITestConnectionRequest} request TestConnectionRequest message or plain object
         * @returns {Promise<protos.TestConnectionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#updateConnection}.
         * @memberof protos.PlumberServer
         * @typedef UpdateConnectionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.UpdateConnectionResponse} [response] UpdateConnectionResponse
         */

        /**
         * Calls UpdateConnection.
         * @function updateConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateConnectionRequest} request UpdateConnectionRequest message or plain object
         * @param {protos.PlumberServer.UpdateConnectionCallback} callback Node-style callback called with the error, if any, and UpdateConnectionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.updateConnection = function updateConnection(request, callback) {
            return this.rpcCall(updateConnection, $root.protos.UpdateConnectionRequest, $root.protos.UpdateConnectionResponse, request, callback);
        }, "name", { value: "UpdateConnection" });

        /**
         * Calls UpdateConnection.
         * @function updateConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateConnectionRequest} request UpdateConnectionRequest message or plain object
         * @returns {Promise<protos.UpdateConnectionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#deleteConnection}.
         * @memberof protos.PlumberServer
         * @typedef DeleteConnectionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.DeleteConnectionResponse} [response] DeleteConnectionResponse
         */

        /**
         * Calls DeleteConnection.
         * @function deleteConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteConnectionRequest} request DeleteConnectionRequest message or plain object
         * @param {protos.PlumberServer.DeleteConnectionCallback} callback Node-style callback called with the error, if any, and DeleteConnectionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.deleteConnection = function deleteConnection(request, callback) {
            return this.rpcCall(deleteConnection, $root.protos.DeleteConnectionRequest, $root.protos.DeleteConnectionResponse, request, callback);
        }, "name", { value: "DeleteConnection" });

        /**
         * Calls DeleteConnection.
         * @function deleteConnection
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteConnectionRequest} request DeleteConnectionRequest message or plain object
         * @returns {Promise<protos.DeleteConnectionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getAllRelays}.
         * @memberof protos.PlumberServer
         * @typedef GetAllRelaysCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetAllRelaysResponse} [response] GetAllRelaysResponse
         */

        /**
         * Calls GetAllRelays.
         * @function getAllRelays
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllRelaysRequest} request GetAllRelaysRequest message or plain object
         * @param {protos.PlumberServer.GetAllRelaysCallback} callback Node-style callback called with the error, if any, and GetAllRelaysResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getAllRelays = function getAllRelays(request, callback) {
            return this.rpcCall(getAllRelays, $root.protos.GetAllRelaysRequest, $root.protos.GetAllRelaysResponse, request, callback);
        }, "name", { value: "GetAllRelays" });

        /**
         * Calls GetAllRelays.
         * @function getAllRelays
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllRelaysRequest} request GetAllRelaysRequest message or plain object
         * @returns {Promise<protos.GetAllRelaysResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getRelay}.
         * @memberof protos.PlumberServer
         * @typedef GetRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetRelayResponse} [response] GetRelayResponse
         */

        /**
         * Calls GetRelay.
         * @function getRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetRelayRequest} request GetRelayRequest message or plain object
         * @param {protos.PlumberServer.GetRelayCallback} callback Node-style callback called with the error, if any, and GetRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getRelay = function getRelay(request, callback) {
            return this.rpcCall(getRelay, $root.protos.GetRelayRequest, $root.protos.GetRelayResponse, request, callback);
        }, "name", { value: "GetRelay" });

        /**
         * Calls GetRelay.
         * @function getRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetRelayRequest} request GetRelayRequest message or plain object
         * @returns {Promise<protos.GetRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#createRelay}.
         * @memberof protos.PlumberServer
         * @typedef CreateRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.CreateRelayResponse} [response] CreateRelayResponse
         */

        /**
         * Calls CreateRelay.
         * @function createRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateRelayRequest} request CreateRelayRequest message or plain object
         * @param {protos.PlumberServer.CreateRelayCallback} callback Node-style callback called with the error, if any, and CreateRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.createRelay = function createRelay(request, callback) {
            return this.rpcCall(createRelay, $root.protos.CreateRelayRequest, $root.protos.CreateRelayResponse, request, callback);
        }, "name", { value: "CreateRelay" });

        /**
         * Calls CreateRelay.
         * @function createRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateRelayRequest} request CreateRelayRequest message or plain object
         * @returns {Promise<protos.CreateRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#updateRelay}.
         * @memberof protos.PlumberServer
         * @typedef UpdateRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.UpdateRelayResponse} [response] UpdateRelayResponse
         */

        /**
         * Calls UpdateRelay.
         * @function updateRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateRelayRequest} request UpdateRelayRequest message or plain object
         * @param {protos.PlumberServer.UpdateRelayCallback} callback Node-style callback called with the error, if any, and UpdateRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.updateRelay = function updateRelay(request, callback) {
            return this.rpcCall(updateRelay, $root.protos.UpdateRelayRequest, $root.protos.UpdateRelayResponse, request, callback);
        }, "name", { value: "UpdateRelay" });

        /**
         * Calls UpdateRelay.
         * @function updateRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateRelayRequest} request UpdateRelayRequest message or plain object
         * @returns {Promise<protos.UpdateRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#resumeRelay}.
         * @memberof protos.PlumberServer
         * @typedef ResumeRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.ResumeRelayResponse} [response] ResumeRelayResponse
         */

        /**
         * Calls ResumeRelay.
         * @function resumeRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IResumeRelayRequest} request ResumeRelayRequest message or plain object
         * @param {protos.PlumberServer.ResumeRelayCallback} callback Node-style callback called with the error, if any, and ResumeRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.resumeRelay = function resumeRelay(request, callback) {
            return this.rpcCall(resumeRelay, $root.protos.ResumeRelayRequest, $root.protos.ResumeRelayResponse, request, callback);
        }, "name", { value: "ResumeRelay" });

        /**
         * Calls ResumeRelay.
         * @function resumeRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IResumeRelayRequest} request ResumeRelayRequest message or plain object
         * @returns {Promise<protos.ResumeRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#stopRelay}.
         * @memberof protos.PlumberServer
         * @typedef StopRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.StopRelayResponse} [response] StopRelayResponse
         */

        /**
         * Calls StopRelay.
         * @function stopRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IStopRelayRequest} request StopRelayRequest message or plain object
         * @param {protos.PlumberServer.StopRelayCallback} callback Node-style callback called with the error, if any, and StopRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.stopRelay = function stopRelay(request, callback) {
            return this.rpcCall(stopRelay, $root.protos.StopRelayRequest, $root.protos.StopRelayResponse, request, callback);
        }, "name", { value: "StopRelay" });

        /**
         * Calls StopRelay.
         * @function stopRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IStopRelayRequest} request StopRelayRequest message or plain object
         * @returns {Promise<protos.StopRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#deleteRelay}.
         * @memberof protos.PlumberServer
         * @typedef DeleteRelayCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.DeleteRelayResponse} [response] DeleteRelayResponse
         */

        /**
         * Calls DeleteRelay.
         * @function deleteRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteRelayRequest} request DeleteRelayRequest message or plain object
         * @param {protos.PlumberServer.DeleteRelayCallback} callback Node-style callback called with the error, if any, and DeleteRelayResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.deleteRelay = function deleteRelay(request, callback) {
            return this.rpcCall(deleteRelay, $root.protos.DeleteRelayRequest, $root.protos.DeleteRelayResponse, request, callback);
        }, "name", { value: "DeleteRelay" });

        /**
         * Calls DeleteRelay.
         * @function deleteRelay
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteRelayRequest} request DeleteRelayRequest message or plain object
         * @returns {Promise<protos.DeleteRelayResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getDynamic}.
         * @memberof protos.PlumberServer
         * @typedef GetDynamicCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetDynamicResponse} [response] GetDynamicResponse
         */

        /**
         * Calls GetDynamic.
         * @function getDynamic
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetDynamicRequest} request GetDynamicRequest message or plain object
         * @param {protos.PlumberServer.GetDynamicCallback} callback Node-style callback called with the error, if any, and GetDynamicResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getDynamic = function getDynamic(request, callback) {
            return this.rpcCall(getDynamic, $root.protos.GetDynamicRequest, $root.protos.GetDynamicResponse, request, callback);
        }, "name", { value: "GetDynamic" });

        /**
         * Calls GetDynamic.
         * @function getDynamic
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetDynamicRequest} request GetDynamicRequest message or plain object
         * @returns {Promise<protos.GetDynamicResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getAllDynamic}.
         * @memberof protos.PlumberServer
         * @typedef GetAllDynamicCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetAllDynamicResponse} [response] GetAllDynamicResponse
         */

        /**
         * Calls GetAllDynamic.
         * @function getAllDynamic
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllDynamicRequest} request GetAllDynamicRequest message or plain object
         * @param {protos.PlumberServer.GetAllDynamicCallback} callback Node-style callback called with the error, if any, and GetAllDynamicResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getAllDynamic = function getAllDynamic(request, callback) {
            return this.rpcCall(getAllDynamic, $root.protos.GetAllDynamicRequest, $root.protos.GetAllDynamicResponse, request, callback);
        }, "name", { value: "GetAllDynamic" });

        /**
         * Calls GetAllDynamic.
         * @function getAllDynamic
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetAllDynamicRequest} request GetAllDynamicRequest message or plain object
         * @returns {Promise<protos.GetAllDynamicResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#createDynamic}.
         * @memberof protos.PlumberServer
         * @typedef CreateDynamicCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.CreateDynamicResponse} [response] CreateDynamicResponse
         */

        /**
         * Calls CreateDynamic.
         * @function createDynamic
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateDynamicRequest} request CreateDynamicRequest message or plain object
         * @param {protos.PlumberServer.CreateDynamicCallback} callback Node-style callback called with the error, if any, and CreateDynamicResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.createDynamic = function createDynamic(request, callback) {
            return this.rpcCall(createDynamic, $root.protos.CreateDynamicRequest, $root.protos.CreateDynamicResponse, request, callback);
        }, "name", { value: "CreateDynamic" });

        /**
         * Calls CreateDynamic.
         * @function createDynamic
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.ICreateDynamicRequest} request CreateDynamicRequest message or plain object
         * @returns {Promise<protos.CreateDynamicResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#stopDynamic}.
         * @memberof protos.PlumberServer
         * @typedef StopDynamicCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.StopDynamicResponse} [response] StopDynamicResponse
         */

        /**
         * Calls StopDynamic.
         * @function stopDynamic
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IStopDynamicRequest} request StopDynamicRequest message or plain object
         * @param {protos.PlumberServer.StopDynamicCallback} callback Node-style callback called with the error, if any, and StopDynamicResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.stopDynamic = function stopDynamic(request, callback) {
            return this.rpcCall(stopDynamic, $root.protos.StopDynamicRequest, $root.protos.StopDynamicResponse, request, callback);
        }, "name", { value: "StopDynamic" });

        /**
         * Calls StopDynamic.
         * @function stopDynamic
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IStopDynamicRequest} request StopDynamicRequest message or plain object
         * @returns {Promise<protos.StopDynamicResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#resumeDynamic}.
         * @memberof protos.PlumberServer
         * @typedef ResumeDynamicCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.ResumeDynamicResponse} [response] ResumeDynamicResponse
         */

        /**
         * Calls ResumeDynamic.
         * @function resumeDynamic
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IResumeDynamicRequest} request ResumeDynamicRequest message or plain object
         * @param {protos.PlumberServer.ResumeDynamicCallback} callback Node-style callback called with the error, if any, and ResumeDynamicResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.resumeDynamic = function resumeDynamic(request, callback) {
            return this.rpcCall(resumeDynamic, $root.protos.ResumeDynamicRequest, $root.protos.ResumeDynamicResponse, request, callback);
        }, "name", { value: "ResumeDynamic" });

        /**
         * Calls ResumeDynamic.
         * @function resumeDynamic
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IResumeDynamicRequest} request ResumeDynamicRequest message or plain object
         * @returns {Promise<protos.ResumeDynamicResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#updateDynamic}.
         * @memberof protos.PlumberServer
         * @typedef UpdateDynamicCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.UpdateDynamicResponse} [response] UpdateDynamicResponse
         */

        /**
         * Calls UpdateDynamic.
         * @function updateDynamic
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateDynamicRequest} request UpdateDynamicRequest message or plain object
         * @param {protos.PlumberServer.UpdateDynamicCallback} callback Node-style callback called with the error, if any, and UpdateDynamicResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.updateDynamic = function updateDynamic(request, callback) {
            return this.rpcCall(updateDynamic, $root.protos.UpdateDynamicRequest, $root.protos.UpdateDynamicResponse, request, callback);
        }, "name", { value: "UpdateDynamic" });

        /**
         * Calls UpdateDynamic.
         * @function updateDynamic
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IUpdateDynamicRequest} request UpdateDynamicRequest message or plain object
         * @returns {Promise<protos.UpdateDynamicResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#deleteDynamic}.
         * @memberof protos.PlumberServer
         * @typedef DeleteDynamicCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.DeleteDynamicResponse} [response] DeleteDynamicResponse
         */

        /**
         * Calls DeleteDynamic.
         * @function deleteDynamic
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteDynamicRequest} request DeleteDynamicRequest message or plain object
         * @param {protos.PlumberServer.DeleteDynamicCallback} callback Node-style callback called with the error, if any, and DeleteDynamicResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.deleteDynamic = function deleteDynamic(request, callback) {
            return this.rpcCall(deleteDynamic, $root.protos.DeleteDynamicRequest, $root.protos.DeleteDynamicResponse, request, callback);
        }, "name", { value: "DeleteDynamic" });

        /**
         * Calls DeleteDynamic.
         * @function deleteDynamic
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IDeleteDynamicRequest} request DeleteDynamicRequest message or plain object
         * @returns {Promise<protos.DeleteDynamicResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link protos.PlumberServer#getServerOptions}.
         * @memberof protos.PlumberServer
         * @typedef GetServerOptionsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {protos.GetServerOptionsResponse} [response] GetServerOptionsResponse
         */

        /**
         * Calls GetServerOptions.
         * @function getServerOptions
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetServerOptionsRequest} request GetServerOptionsRequest message or plain object
         * @param {protos.PlumberServer.GetServerOptionsCallback} callback Node-style callback called with the error, if any, and GetServerOptionsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(PlumberServer.prototype.getServerOptions = function getServerOptions(request, callback) {
            return this.rpcCall(getServerOptions, $root.protos.GetServerOptionsRequest, $root.protos.GetServerOptionsResponse, request, callback);
        }, "name", { value: "GetServerOptions" });

        /**
         * Calls GetServerOptions.
         * @function getServerOptions
         * @memberof protos.PlumberServer
         * @instance
         * @param {protos.IGetServerOptionsRequest} request GetServerOptionsRequest message or plain object
         * @returns {Promise<protos.GetServerOptionsResponse>} Promise
         * @variation 2
         */

        return PlumberServer;
    })();

    protos.GetAllConnectionsRequest = (function() {

        /**
         * Properties of a GetAllConnectionsRequest.
         * @memberof protos
         * @interface IGetAllConnectionsRequest
         * @property {protos.common.IAuth|null} [auth] GetAllConnectionsRequest auth
         */

        /**
         * Constructs a new GetAllConnectionsRequest.
         * @memberof protos
         * @classdesc Represents a GetAllConnectionsRequest.
         * @implements IGetAllConnectionsRequest
         * @constructor
         * @param {protos.IGetAllConnectionsRequest=} [properties] Properties to set
         */
        function GetAllConnectionsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllConnectionsRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetAllConnectionsRequest
         * @instance
         */
        GetAllConnectionsRequest.prototype.auth = null;

        /**
         * Creates a new GetAllConnectionsRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {protos.IGetAllConnectionsRequest=} [properties] Properties to set
         * @returns {protos.GetAllConnectionsRequest} GetAllConnectionsRequest instance
         */
        GetAllConnectionsRequest.create = function create(properties) {
            return new GetAllConnectionsRequest(properties);
        };

        /**
         * Encodes the specified GetAllConnectionsRequest message. Does not implicitly {@link protos.GetAllConnectionsRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {protos.IGetAllConnectionsRequest} message GetAllConnectionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllConnectionsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllConnectionsRequest message, length delimited. Does not implicitly {@link protos.GetAllConnectionsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {protos.IGetAllConnectionsRequest} message GetAllConnectionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllConnectionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllConnectionsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllConnectionsRequest} GetAllConnectionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllConnectionsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllConnectionsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllConnectionsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllConnectionsRequest} GetAllConnectionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllConnectionsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllConnectionsRequest message.
         * @function verify
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllConnectionsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };

        /**
         * Creates a GetAllConnectionsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllConnectionsRequest} GetAllConnectionsRequest
         */
        GetAllConnectionsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllConnectionsRequest)
                return object;
            var message = new $root.protos.GetAllConnectionsRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetAllConnectionsRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllConnectionsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllConnectionsRequest
         * @static
         * @param {protos.GetAllConnectionsRequest} message GetAllConnectionsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllConnectionsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.auth = null;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetAllConnectionsRequest to JSON.
         * @function toJSON
         * @memberof protos.GetAllConnectionsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllConnectionsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllConnectionsRequest;
    })();

    protos.GetAllConnectionsResponse = (function() {

        /**
         * Properties of a GetAllConnectionsResponse.
         * @memberof protos
         * @interface IGetAllConnectionsResponse
         * @property {Array.<protos.opts.IConnectionOptions>|null} [options] GetAllConnectionsResponse options
         */

        /**
         * Constructs a new GetAllConnectionsResponse.
         * @memberof protos
         * @classdesc Represents a GetAllConnectionsResponse.
         * @implements IGetAllConnectionsResponse
         * @constructor
         * @param {protos.IGetAllConnectionsResponse=} [properties] Properties to set
         */
        function GetAllConnectionsResponse(properties) {
            this.options = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllConnectionsResponse options.
         * @member {Array.<protos.opts.IConnectionOptions>} options
         * @memberof protos.GetAllConnectionsResponse
         * @instance
         */
        GetAllConnectionsResponse.prototype.options = $util.emptyArray;

        /**
         * Creates a new GetAllConnectionsResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {protos.IGetAllConnectionsResponse=} [properties] Properties to set
         * @returns {protos.GetAllConnectionsResponse} GetAllConnectionsResponse instance
         */
        GetAllConnectionsResponse.create = function create(properties) {
            return new GetAllConnectionsResponse(properties);
        };

        /**
         * Encodes the specified GetAllConnectionsResponse message. Does not implicitly {@link protos.GetAllConnectionsResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {protos.IGetAllConnectionsResponse} message GetAllConnectionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllConnectionsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.options != null && message.options.length)
                for (var i = 0; i < message.options.length; ++i)
                    $root.protos.opts.ConnectionOptions.encode(message.options[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllConnectionsResponse message, length delimited. Does not implicitly {@link protos.GetAllConnectionsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {protos.IGetAllConnectionsResponse} message GetAllConnectionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllConnectionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllConnectionsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllConnectionsResponse} GetAllConnectionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllConnectionsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllConnectionsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.options && message.options.length))
                        message.options = [];
                    message.options.push($root.protos.opts.ConnectionOptions.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllConnectionsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllConnectionsResponse} GetAllConnectionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllConnectionsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllConnectionsResponse message.
         * @function verify
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllConnectionsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                if (!Array.isArray(message.options))
                    return "options: array expected";
                for (var i = 0; i < message.options.length; ++i) {
                    var error = $root.protos.opts.ConnectionOptions.verify(message.options[i]);
                    if (error)
                        return "options." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetAllConnectionsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllConnectionsResponse} GetAllConnectionsResponse
         */
        GetAllConnectionsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllConnectionsResponse)
                return object;
            var message = new $root.protos.GetAllConnectionsResponse();
            if (object.options) {
                if (!Array.isArray(object.options))
                    throw TypeError(".protos.GetAllConnectionsResponse.options: array expected");
                message.options = [];
                for (var i = 0; i < object.options.length; ++i) {
                    if (typeof object.options[i] !== "object")
                        throw TypeError(".protos.GetAllConnectionsResponse.options: object expected");
                    message.options[i] = $root.protos.opts.ConnectionOptions.fromObject(object.options[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllConnectionsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllConnectionsResponse
         * @static
         * @param {protos.GetAllConnectionsResponse} message GetAllConnectionsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllConnectionsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.options = [];
            if (message.options && message.options.length) {
                object.options = [];
                for (var j = 0; j < message.options.length; ++j)
                    object.options[j] = $root.protos.opts.ConnectionOptions.toObject(message.options[j], options);
            }
            return object;
        };

        /**
         * Converts this GetAllConnectionsResponse to JSON.
         * @function toJSON
         * @memberof protos.GetAllConnectionsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllConnectionsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllConnectionsResponse;
    })();

    protos.GetConnectionRequest = (function() {

        /**
         * Properties of a GetConnectionRequest.
         * @memberof protos
         * @interface IGetConnectionRequest
         * @property {protos.common.IAuth|null} [auth] GetConnectionRequest auth
         * @property {string|null} [connectionId] GetConnectionRequest connectionId
         */

        /**
         * Constructs a new GetConnectionRequest.
         * @memberof protos
         * @classdesc Represents a GetConnectionRequest.
         * @implements IGetConnectionRequest
         * @constructor
         * @param {protos.IGetConnectionRequest=} [properties] Properties to set
         */
        function GetConnectionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetConnectionRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetConnectionRequest
         * @instance
         */
        GetConnectionRequest.prototype.auth = null;

        /**
         * GetConnectionRequest connectionId.
         * @member {string} connectionId
         * @memberof protos.GetConnectionRequest
         * @instance
         */
        GetConnectionRequest.prototype.connectionId = "";

        /**
         * Creates a new GetConnectionRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {protos.IGetConnectionRequest=} [properties] Properties to set
         * @returns {protos.GetConnectionRequest} GetConnectionRequest instance
         */
        GetConnectionRequest.create = function create(properties) {
            return new GetConnectionRequest(properties);
        };

        /**
         * Encodes the specified GetConnectionRequest message. Does not implicitly {@link protos.GetConnectionRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {protos.IGetConnectionRequest} message GetConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetConnectionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetConnectionRequest message, length delimited. Does not implicitly {@link protos.GetConnectionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {protos.IGetConnectionRequest} message GetConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetConnectionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetConnectionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetConnectionRequest} GetConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetConnectionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetConnectionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.connectionId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetConnectionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetConnectionRequest} GetConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetConnectionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetConnectionRequest message.
         * @function verify
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetConnectionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                if (!$util.isString(message.connectionId))
                    return "connectionId: string expected";
            return null;
        };

        /**
         * Creates a GetConnectionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetConnectionRequest} GetConnectionRequest
         */
        GetConnectionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetConnectionRequest)
                return object;
            var message = new $root.protos.GetConnectionRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetConnectionRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.connectionId != null)
                message.connectionId = String(object.connectionId);
            return message;
        };

        /**
         * Creates a plain object from a GetConnectionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetConnectionRequest
         * @static
         * @param {protos.GetConnectionRequest} message GetConnectionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetConnectionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.connectionId = "";
                object.auth = null;
            }
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                object.connectionId = message.connectionId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetConnectionRequest to JSON.
         * @function toJSON
         * @memberof protos.GetConnectionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetConnectionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetConnectionRequest;
    })();

    protos.GetConnectionResponse = (function() {

        /**
         * Properties of a GetConnectionResponse.
         * @memberof protos
         * @interface IGetConnectionResponse
         * @property {protos.opts.IConnectionOptions|null} [options] GetConnectionResponse options
         */

        /**
         * Constructs a new GetConnectionResponse.
         * @memberof protos
         * @classdesc Represents a GetConnectionResponse.
         * @implements IGetConnectionResponse
         * @constructor
         * @param {protos.IGetConnectionResponse=} [properties] Properties to set
         */
        function GetConnectionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetConnectionResponse options.
         * @member {protos.opts.IConnectionOptions|null|undefined} options
         * @memberof protos.GetConnectionResponse
         * @instance
         */
        GetConnectionResponse.prototype.options = null;

        /**
         * Creates a new GetConnectionResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {protos.IGetConnectionResponse=} [properties] Properties to set
         * @returns {protos.GetConnectionResponse} GetConnectionResponse instance
         */
        GetConnectionResponse.create = function create(properties) {
            return new GetConnectionResponse(properties);
        };

        /**
         * Encodes the specified GetConnectionResponse message. Does not implicitly {@link protos.GetConnectionResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {protos.IGetConnectionResponse} message GetConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetConnectionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.protos.opts.ConnectionOptions.encode(message.options, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetConnectionResponse message, length delimited. Does not implicitly {@link protos.GetConnectionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {protos.IGetConnectionResponse} message GetConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetConnectionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetConnectionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetConnectionResponse} GetConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetConnectionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetConnectionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.options = $root.protos.opts.ConnectionOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetConnectionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetConnectionResponse} GetConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetConnectionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetConnectionResponse message.
         * @function verify
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetConnectionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.protos.opts.ConnectionOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates a GetConnectionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetConnectionResponse} GetConnectionResponse
         */
        GetConnectionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetConnectionResponse)
                return object;
            var message = new $root.protos.GetConnectionResponse();
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".protos.GetConnectionResponse.options: object expected");
                message.options = $root.protos.opts.ConnectionOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetConnectionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetConnectionResponse
         * @static
         * @param {protos.GetConnectionResponse} message GetConnectionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetConnectionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.options = null;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.protos.opts.ConnectionOptions.toObject(message.options, options);
            return object;
        };

        /**
         * Converts this GetConnectionResponse to JSON.
         * @function toJSON
         * @memberof protos.GetConnectionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetConnectionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetConnectionResponse;
    })();

    protos.CreateConnectionRequest = (function() {

        /**
         * Properties of a CreateConnectionRequest.
         * @memberof protos
         * @interface ICreateConnectionRequest
         * @property {protos.common.IAuth|null} [auth] CreateConnectionRequest auth
         * @property {protos.opts.IConnectionOptions|null} [options] CreateConnectionRequest options
         */

        /**
         * Constructs a new CreateConnectionRequest.
         * @memberof protos
         * @classdesc Represents a CreateConnectionRequest.
         * @implements ICreateConnectionRequest
         * @constructor
         * @param {protos.ICreateConnectionRequest=} [properties] Properties to set
         */
        function CreateConnectionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateConnectionRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.CreateConnectionRequest
         * @instance
         */
        CreateConnectionRequest.prototype.auth = null;

        /**
         * CreateConnectionRequest options.
         * @member {protos.opts.IConnectionOptions|null|undefined} options
         * @memberof protos.CreateConnectionRequest
         * @instance
         */
        CreateConnectionRequest.prototype.options = null;

        /**
         * Creates a new CreateConnectionRequest instance using the specified properties.
         * @function create
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {protos.ICreateConnectionRequest=} [properties] Properties to set
         * @returns {protos.CreateConnectionRequest} CreateConnectionRequest instance
         */
        CreateConnectionRequest.create = function create(properties) {
            return new CreateConnectionRequest(properties);
        };

        /**
         * Encodes the specified CreateConnectionRequest message. Does not implicitly {@link protos.CreateConnectionRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {protos.ICreateConnectionRequest} message CreateConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateConnectionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.protos.opts.ConnectionOptions.encode(message.options, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateConnectionRequest message, length delimited. Does not implicitly {@link protos.CreateConnectionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {protos.ICreateConnectionRequest} message CreateConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateConnectionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateConnectionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateConnectionRequest} CreateConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateConnectionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateConnectionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.options = $root.protos.opts.ConnectionOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateConnectionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateConnectionRequest} CreateConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateConnectionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateConnectionRequest message.
         * @function verify
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateConnectionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.protos.opts.ConnectionOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates a CreateConnectionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateConnectionRequest} CreateConnectionRequest
         */
        CreateConnectionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateConnectionRequest)
                return object;
            var message = new $root.protos.CreateConnectionRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.CreateConnectionRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".protos.CreateConnectionRequest.options: object expected");
                message.options = $root.protos.opts.ConnectionOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateConnectionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateConnectionRequest
         * @static
         * @param {protos.CreateConnectionRequest} message CreateConnectionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateConnectionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.options = null;
                object.auth = null;
            }
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.protos.opts.ConnectionOptions.toObject(message.options, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this CreateConnectionRequest to JSON.
         * @function toJSON
         * @memberof protos.CreateConnectionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateConnectionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateConnectionRequest;
    })();

    protos.CreateConnectionResponse = (function() {

        /**
         * Properties of a CreateConnectionResponse.
         * @memberof protos
         * @interface ICreateConnectionResponse
         * @property {string|null} [connectionId] CreateConnectionResponse connectionId
         */

        /**
         * Constructs a new CreateConnectionResponse.
         * @memberof protos
         * @classdesc Represents a CreateConnectionResponse.
         * @implements ICreateConnectionResponse
         * @constructor
         * @param {protos.ICreateConnectionResponse=} [properties] Properties to set
         */
        function CreateConnectionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateConnectionResponse connectionId.
         * @member {string} connectionId
         * @memberof protos.CreateConnectionResponse
         * @instance
         */
        CreateConnectionResponse.prototype.connectionId = "";

        /**
         * Creates a new CreateConnectionResponse instance using the specified properties.
         * @function create
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {protos.ICreateConnectionResponse=} [properties] Properties to set
         * @returns {protos.CreateConnectionResponse} CreateConnectionResponse instance
         */
        CreateConnectionResponse.create = function create(properties) {
            return new CreateConnectionResponse(properties);
        };

        /**
         * Encodes the specified CreateConnectionResponse message. Does not implicitly {@link protos.CreateConnectionResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {protos.ICreateConnectionResponse} message CreateConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateConnectionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
            return writer;
        };

        /**
         * Encodes the specified CreateConnectionResponse message, length delimited. Does not implicitly {@link protos.CreateConnectionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {protos.ICreateConnectionResponse} message CreateConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateConnectionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateConnectionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateConnectionResponse} CreateConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateConnectionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateConnectionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.connectionId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateConnectionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateConnectionResponse} CreateConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateConnectionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateConnectionResponse message.
         * @function verify
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateConnectionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                if (!$util.isString(message.connectionId))
                    return "connectionId: string expected";
            return null;
        };

        /**
         * Creates a CreateConnectionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateConnectionResponse} CreateConnectionResponse
         */
        CreateConnectionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateConnectionResponse)
                return object;
            var message = new $root.protos.CreateConnectionResponse();
            if (object.connectionId != null)
                message.connectionId = String(object.connectionId);
            return message;
        };

        /**
         * Creates a plain object from a CreateConnectionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateConnectionResponse
         * @static
         * @param {protos.CreateConnectionResponse} message CreateConnectionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateConnectionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.connectionId = "";
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                object.connectionId = message.connectionId;
            return object;
        };

        /**
         * Converts this CreateConnectionResponse to JSON.
         * @function toJSON
         * @memberof protos.CreateConnectionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateConnectionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateConnectionResponse;
    })();

    protos.TestConnectionRequest = (function() {

        /**
         * Properties of a TestConnectionRequest.
         * @memberof protos
         * @interface ITestConnectionRequest
         * @property {protos.common.IAuth|null} [auth] TestConnectionRequest auth
         * @property {protos.opts.IConnectionOptions|null} [options] TestConnectionRequest options
         */

        /**
         * Constructs a new TestConnectionRequest.
         * @memberof protos
         * @classdesc Represents a TestConnectionRequest.
         * @implements ITestConnectionRequest
         * @constructor
         * @param {protos.ITestConnectionRequest=} [properties] Properties to set
         */
        function TestConnectionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TestConnectionRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.TestConnectionRequest
         * @instance
         */
        TestConnectionRequest.prototype.auth = null;

        /**
         * TestConnectionRequest options.
         * @member {protos.opts.IConnectionOptions|null|undefined} options
         * @memberof protos.TestConnectionRequest
         * @instance
         */
        TestConnectionRequest.prototype.options = null;

        /**
         * Creates a new TestConnectionRequest instance using the specified properties.
         * @function create
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {protos.ITestConnectionRequest=} [properties] Properties to set
         * @returns {protos.TestConnectionRequest} TestConnectionRequest instance
         */
        TestConnectionRequest.create = function create(properties) {
            return new TestConnectionRequest(properties);
        };

        /**
         * Encodes the specified TestConnectionRequest message. Does not implicitly {@link protos.TestConnectionRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {protos.ITestConnectionRequest} message TestConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestConnectionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.protos.opts.ConnectionOptions.encode(message.options, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TestConnectionRequest message, length delimited. Does not implicitly {@link protos.TestConnectionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {protos.ITestConnectionRequest} message TestConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestConnectionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TestConnectionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.TestConnectionRequest} TestConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestConnectionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.TestConnectionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.options = $root.protos.opts.ConnectionOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TestConnectionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.TestConnectionRequest} TestConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestConnectionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TestConnectionRequest message.
         * @function verify
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TestConnectionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.protos.opts.ConnectionOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates a TestConnectionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.TestConnectionRequest} TestConnectionRequest
         */
        TestConnectionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.TestConnectionRequest)
                return object;
            var message = new $root.protos.TestConnectionRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.TestConnectionRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".protos.TestConnectionRequest.options: object expected");
                message.options = $root.protos.opts.ConnectionOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from a TestConnectionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.TestConnectionRequest
         * @static
         * @param {protos.TestConnectionRequest} message TestConnectionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TestConnectionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.options = null;
                object.auth = null;
            }
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.protos.opts.ConnectionOptions.toObject(message.options, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this TestConnectionRequest to JSON.
         * @function toJSON
         * @memberof protos.TestConnectionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TestConnectionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TestConnectionRequest;
    })();

    protos.TestConnectionResponse = (function() {

        /**
         * Properties of a TestConnectionResponse.
         * @memberof protos
         * @interface ITestConnectionResponse
         * @property {protos.common.IStatus|null} [status] TestConnectionResponse status
         */

        /**
         * Constructs a new TestConnectionResponse.
         * @memberof protos
         * @classdesc Represents a TestConnectionResponse.
         * @implements ITestConnectionResponse
         * @constructor
         * @param {protos.ITestConnectionResponse=} [properties] Properties to set
         */
        function TestConnectionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TestConnectionResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.TestConnectionResponse
         * @instance
         */
        TestConnectionResponse.prototype.status = null;

        /**
         * Creates a new TestConnectionResponse instance using the specified properties.
         * @function create
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {protos.ITestConnectionResponse=} [properties] Properties to set
         * @returns {protos.TestConnectionResponse} TestConnectionResponse instance
         */
        TestConnectionResponse.create = function create(properties) {
            return new TestConnectionResponse(properties);
        };

        /**
         * Encodes the specified TestConnectionResponse message. Does not implicitly {@link protos.TestConnectionResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {protos.ITestConnectionResponse} message TestConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestConnectionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TestConnectionResponse message, length delimited. Does not implicitly {@link protos.TestConnectionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {protos.ITestConnectionResponse} message TestConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestConnectionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TestConnectionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.TestConnectionResponse} TestConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestConnectionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.TestConnectionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TestConnectionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.TestConnectionResponse} TestConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestConnectionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TestConnectionResponse message.
         * @function verify
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TestConnectionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a TestConnectionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.TestConnectionResponse} TestConnectionResponse
         */
        TestConnectionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.TestConnectionResponse)
                return object;
            var message = new $root.protos.TestConnectionResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.TestConnectionResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a TestConnectionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.TestConnectionResponse
         * @static
         * @param {protos.TestConnectionResponse} message TestConnectionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TestConnectionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this TestConnectionResponse to JSON.
         * @function toJSON
         * @memberof protos.TestConnectionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TestConnectionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TestConnectionResponse;
    })();

    protos.UpdateConnectionRequest = (function() {

        /**
         * Properties of an UpdateConnectionRequest.
         * @memberof protos
         * @interface IUpdateConnectionRequest
         * @property {protos.common.IAuth|null} [auth] UpdateConnectionRequest auth
         * @property {string|null} [connectionId] UpdateConnectionRequest connectionId
         * @property {protos.opts.IConnectionOptions|null} [options] UpdateConnectionRequest options
         */

        /**
         * Constructs a new UpdateConnectionRequest.
         * @memberof protos
         * @classdesc Represents an UpdateConnectionRequest.
         * @implements IUpdateConnectionRequest
         * @constructor
         * @param {protos.IUpdateConnectionRequest=} [properties] Properties to set
         */
        function UpdateConnectionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateConnectionRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.UpdateConnectionRequest
         * @instance
         */
        UpdateConnectionRequest.prototype.auth = null;

        /**
         * UpdateConnectionRequest connectionId.
         * @member {string} connectionId
         * @memberof protos.UpdateConnectionRequest
         * @instance
         */
        UpdateConnectionRequest.prototype.connectionId = "";

        /**
         * UpdateConnectionRequest options.
         * @member {protos.opts.IConnectionOptions|null|undefined} options
         * @memberof protos.UpdateConnectionRequest
         * @instance
         */
        UpdateConnectionRequest.prototype.options = null;

        /**
         * Creates a new UpdateConnectionRequest instance using the specified properties.
         * @function create
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {protos.IUpdateConnectionRequest=} [properties] Properties to set
         * @returns {protos.UpdateConnectionRequest} UpdateConnectionRequest instance
         */
        UpdateConnectionRequest.create = function create(properties) {
            return new UpdateConnectionRequest(properties);
        };

        /**
         * Encodes the specified UpdateConnectionRequest message. Does not implicitly {@link protos.UpdateConnectionRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {protos.IUpdateConnectionRequest} message UpdateConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateConnectionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.protos.opts.ConnectionOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateConnectionRequest message, length delimited. Does not implicitly {@link protos.UpdateConnectionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {protos.IUpdateConnectionRequest} message UpdateConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateConnectionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateConnectionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateConnectionRequest} UpdateConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateConnectionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateConnectionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.connectionId = reader.string();
                    break;
                case 2:
                    message.options = $root.protos.opts.ConnectionOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateConnectionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateConnectionRequest} UpdateConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateConnectionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateConnectionRequest message.
         * @function verify
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateConnectionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                if (!$util.isString(message.connectionId))
                    return "connectionId: string expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.protos.opts.ConnectionOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateConnectionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateConnectionRequest} UpdateConnectionRequest
         */
        UpdateConnectionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateConnectionRequest)
                return object;
            var message = new $root.protos.UpdateConnectionRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.UpdateConnectionRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.connectionId != null)
                message.connectionId = String(object.connectionId);
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".protos.UpdateConnectionRequest.options: object expected");
                message.options = $root.protos.opts.ConnectionOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateConnectionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateConnectionRequest
         * @static
         * @param {protos.UpdateConnectionRequest} message UpdateConnectionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateConnectionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.connectionId = "";
                object.options = null;
                object.auth = null;
            }
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                object.connectionId = message.connectionId;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.protos.opts.ConnectionOptions.toObject(message.options, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this UpdateConnectionRequest to JSON.
         * @function toJSON
         * @memberof protos.UpdateConnectionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateConnectionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateConnectionRequest;
    })();

    protos.UpdateConnectionResponse = (function() {

        /**
         * Properties of an UpdateConnectionResponse.
         * @memberof protos
         * @interface IUpdateConnectionResponse
         * @property {protos.common.IStatus|null} [status] UpdateConnectionResponse status
         */

        /**
         * Constructs a new UpdateConnectionResponse.
         * @memberof protos
         * @classdesc Represents an UpdateConnectionResponse.
         * @implements IUpdateConnectionResponse
         * @constructor
         * @param {protos.IUpdateConnectionResponse=} [properties] Properties to set
         */
        function UpdateConnectionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateConnectionResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.UpdateConnectionResponse
         * @instance
         */
        UpdateConnectionResponse.prototype.status = null;

        /**
         * Creates a new UpdateConnectionResponse instance using the specified properties.
         * @function create
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {protos.IUpdateConnectionResponse=} [properties] Properties to set
         * @returns {protos.UpdateConnectionResponse} UpdateConnectionResponse instance
         */
        UpdateConnectionResponse.create = function create(properties) {
            return new UpdateConnectionResponse(properties);
        };

        /**
         * Encodes the specified UpdateConnectionResponse message. Does not implicitly {@link protos.UpdateConnectionResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {protos.IUpdateConnectionResponse} message UpdateConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateConnectionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateConnectionResponse message, length delimited. Does not implicitly {@link protos.UpdateConnectionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {protos.IUpdateConnectionResponse} message UpdateConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateConnectionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateConnectionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateConnectionResponse} UpdateConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateConnectionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateConnectionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateConnectionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateConnectionResponse} UpdateConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateConnectionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateConnectionResponse message.
         * @function verify
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateConnectionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateConnectionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateConnectionResponse} UpdateConnectionResponse
         */
        UpdateConnectionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateConnectionResponse)
                return object;
            var message = new $root.protos.UpdateConnectionResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.UpdateConnectionResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateConnectionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateConnectionResponse
         * @static
         * @param {protos.UpdateConnectionResponse} message UpdateConnectionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateConnectionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this UpdateConnectionResponse to JSON.
         * @function toJSON
         * @memberof protos.UpdateConnectionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateConnectionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateConnectionResponse;
    })();

    protos.DeleteConnectionRequest = (function() {

        /**
         * Properties of a DeleteConnectionRequest.
         * @memberof protos
         * @interface IDeleteConnectionRequest
         * @property {protos.common.IAuth|null} [auth] DeleteConnectionRequest auth
         * @property {string|null} [connectionId] DeleteConnectionRequest connectionId
         */

        /**
         * Constructs a new DeleteConnectionRequest.
         * @memberof protos
         * @classdesc Represents a DeleteConnectionRequest.
         * @implements IDeleteConnectionRequest
         * @constructor
         * @param {protos.IDeleteConnectionRequest=} [properties] Properties to set
         */
        function DeleteConnectionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteConnectionRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.DeleteConnectionRequest
         * @instance
         */
        DeleteConnectionRequest.prototype.auth = null;

        /**
         * DeleteConnectionRequest connectionId.
         * @member {string} connectionId
         * @memberof protos.DeleteConnectionRequest
         * @instance
         */
        DeleteConnectionRequest.prototype.connectionId = "";

        /**
         * Creates a new DeleteConnectionRequest instance using the specified properties.
         * @function create
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {protos.IDeleteConnectionRequest=} [properties] Properties to set
         * @returns {protos.DeleteConnectionRequest} DeleteConnectionRequest instance
         */
        DeleteConnectionRequest.create = function create(properties) {
            return new DeleteConnectionRequest(properties);
        };

        /**
         * Encodes the specified DeleteConnectionRequest message. Does not implicitly {@link protos.DeleteConnectionRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {protos.IDeleteConnectionRequest} message DeleteConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteConnectionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteConnectionRequest message, length delimited. Does not implicitly {@link protos.DeleteConnectionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {protos.IDeleteConnectionRequest} message DeleteConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteConnectionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteConnectionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteConnectionRequest} DeleteConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteConnectionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteConnectionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.connectionId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteConnectionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteConnectionRequest} DeleteConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteConnectionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteConnectionRequest message.
         * @function verify
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteConnectionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                if (!$util.isString(message.connectionId))
                    return "connectionId: string expected";
            return null;
        };

        /**
         * Creates a DeleteConnectionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteConnectionRequest} DeleteConnectionRequest
         */
        DeleteConnectionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteConnectionRequest)
                return object;
            var message = new $root.protos.DeleteConnectionRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.DeleteConnectionRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.connectionId != null)
                message.connectionId = String(object.connectionId);
            return message;
        };

        /**
         * Creates a plain object from a DeleteConnectionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteConnectionRequest
         * @static
         * @param {protos.DeleteConnectionRequest} message DeleteConnectionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteConnectionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.connectionId = "";
                object.auth = null;
            }
            if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                object.connectionId = message.connectionId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this DeleteConnectionRequest to JSON.
         * @function toJSON
         * @memberof protos.DeleteConnectionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteConnectionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteConnectionRequest;
    })();

    protos.DeleteConnectionResponse = (function() {

        /**
         * Properties of a DeleteConnectionResponse.
         * @memberof protos
         * @interface IDeleteConnectionResponse
         * @property {protos.common.IStatus|null} [status] DeleteConnectionResponse status
         */

        /**
         * Constructs a new DeleteConnectionResponse.
         * @memberof protos
         * @classdesc Represents a DeleteConnectionResponse.
         * @implements IDeleteConnectionResponse
         * @constructor
         * @param {protos.IDeleteConnectionResponse=} [properties] Properties to set
         */
        function DeleteConnectionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteConnectionResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.DeleteConnectionResponse
         * @instance
         */
        DeleteConnectionResponse.prototype.status = null;

        /**
         * Creates a new DeleteConnectionResponse instance using the specified properties.
         * @function create
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {protos.IDeleteConnectionResponse=} [properties] Properties to set
         * @returns {protos.DeleteConnectionResponse} DeleteConnectionResponse instance
         */
        DeleteConnectionResponse.create = function create(properties) {
            return new DeleteConnectionResponse(properties);
        };

        /**
         * Encodes the specified DeleteConnectionResponse message. Does not implicitly {@link protos.DeleteConnectionResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {protos.IDeleteConnectionResponse} message DeleteConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteConnectionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteConnectionResponse message, length delimited. Does not implicitly {@link protos.DeleteConnectionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {protos.IDeleteConnectionResponse} message DeleteConnectionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteConnectionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteConnectionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteConnectionResponse} DeleteConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteConnectionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteConnectionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteConnectionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteConnectionResponse} DeleteConnectionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteConnectionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteConnectionResponse message.
         * @function verify
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteConnectionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a DeleteConnectionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteConnectionResponse} DeleteConnectionResponse
         */
        DeleteConnectionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteConnectionResponse)
                return object;
            var message = new $root.protos.DeleteConnectionResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.DeleteConnectionResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a DeleteConnectionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteConnectionResponse
         * @static
         * @param {protos.DeleteConnectionResponse} message DeleteConnectionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteConnectionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this DeleteConnectionResponse to JSON.
         * @function toJSON
         * @memberof protos.DeleteConnectionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteConnectionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteConnectionResponse;
    })();

    protos.common = (function() {

        /**
         * Namespace common.
         * @memberof protos
         * @namespace
         */
        var common = {};

        common.Auth = (function() {

            /**
             * Properties of an Auth.
             * @memberof protos.common
             * @interface IAuth
             * @property {string|null} [token] Auth token
             */

            /**
             * Constructs a new Auth.
             * @memberof protos.common
             * @classdesc Represents an Auth.
             * @implements IAuth
             * @constructor
             * @param {protos.common.IAuth=} [properties] Properties to set
             */
            function Auth(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Auth token.
             * @member {string} token
             * @memberof protos.common.Auth
             * @instance
             */
            Auth.prototype.token = "";

            /**
             * Creates a new Auth instance using the specified properties.
             * @function create
             * @memberof protos.common.Auth
             * @static
             * @param {protos.common.IAuth=} [properties] Properties to set
             * @returns {protos.common.Auth} Auth instance
             */
            Auth.create = function create(properties) {
                return new Auth(properties);
            };

            /**
             * Encodes the specified Auth message. Does not implicitly {@link protos.common.Auth.verify|verify} messages.
             * @function encode
             * @memberof protos.common.Auth
             * @static
             * @param {protos.common.IAuth} message Auth message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Auth.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
                return writer;
            };

            /**
             * Encodes the specified Auth message, length delimited. Does not implicitly {@link protos.common.Auth.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.common.Auth
             * @static
             * @param {protos.common.IAuth} message Auth message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Auth.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Auth message from the specified reader or buffer.
             * @function decode
             * @memberof protos.common.Auth
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.common.Auth} Auth
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Auth.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.common.Auth();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.token = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Auth message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.common.Auth
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.common.Auth} Auth
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Auth.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Auth message.
             * @function verify
             * @memberof protos.common.Auth
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Auth.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                return null;
            };

            /**
             * Creates an Auth message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.common.Auth
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.common.Auth} Auth
             */
            Auth.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.common.Auth)
                    return object;
                var message = new $root.protos.common.Auth();
                if (object.token != null)
                    message.token = String(object.token);
                return message;
            };

            /**
             * Creates a plain object from an Auth message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.common.Auth
             * @static
             * @param {protos.common.Auth} message Auth
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Auth.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.token = "";
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = message.token;
                return object;
            };

            /**
             * Converts this Auth to JSON.
             * @function toJSON
             * @memberof protos.common.Auth
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Auth.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Auth;
        })();

        /**
         * Code enum.
         * @name protos.common.Code
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} CANCELLED=1 CANCELLED value
         * @property {number} UNKNOWN=2 UNKNOWN value
         * @property {number} INVALID_ARGUMENT=3 INVALID_ARGUMENT value
         * @property {number} DEADLINE_EXCEEDED=4 DEADLINE_EXCEEDED value
         * @property {number} NOT_FOUND=5 NOT_FOUND value
         * @property {number} ALREADY_EXISTS=6 ALREADY_EXISTS value
         * @property {number} PERMISSION_DENIED=7 PERMISSION_DENIED value
         * @property {number} UNAUTHENTICATED=16 UNAUTHENTICATED value
         * @property {number} RESOURCE_EXHAUSTED=8 RESOURCE_EXHAUSTED value
         * @property {number} FAILED_PRECONDITION=9 FAILED_PRECONDITION value
         * @property {number} ABORTED=10 ABORTED value
         * @property {number} OUT_OF_RANGE=11 OUT_OF_RANGE value
         * @property {number} UNIMPLEMENTED=12 UNIMPLEMENTED value
         * @property {number} INTERNAL=13 INTERNAL value
         * @property {number} UNAVAILABLE=14 UNAVAILABLE value
         * @property {number} DATA_LOSS=15 DATA_LOSS value
         */
        common.Code = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "CANCELLED"] = 1;
            values[valuesById[2] = "UNKNOWN"] = 2;
            values[valuesById[3] = "INVALID_ARGUMENT"] = 3;
            values[valuesById[4] = "DEADLINE_EXCEEDED"] = 4;
            values[valuesById[5] = "NOT_FOUND"] = 5;
            values[valuesById[6] = "ALREADY_EXISTS"] = 6;
            values[valuesById[7] = "PERMISSION_DENIED"] = 7;
            values[valuesById[16] = "UNAUTHENTICATED"] = 16;
            values[valuesById[8] = "RESOURCE_EXHAUSTED"] = 8;
            values[valuesById[9] = "FAILED_PRECONDITION"] = 9;
            values[valuesById[10] = "ABORTED"] = 10;
            values[valuesById[11] = "OUT_OF_RANGE"] = 11;
            values[valuesById[12] = "UNIMPLEMENTED"] = 12;
            values[valuesById[13] = "INTERNAL"] = 13;
            values[valuesById[14] = "UNAVAILABLE"] = 14;
            values[valuesById[15] = "DATA_LOSS"] = 15;
            return values;
        })();

        common.Status = (function() {

            /**
             * Properties of a Status.
             * @memberof protos.common
             * @interface IStatus
             * @property {protos.common.Code|null} [code] Status code
             * @property {string|null} [message] Status message
             * @property {string|null} [requestId] Status requestId
             */

            /**
             * Constructs a new Status.
             * @memberof protos.common
             * @classdesc Represents a Status.
             * @implements IStatus
             * @constructor
             * @param {protos.common.IStatus=} [properties] Properties to set
             */
            function Status(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Status code.
             * @member {protos.common.Code} code
             * @memberof protos.common.Status
             * @instance
             */
            Status.prototype.code = 0;

            /**
             * Status message.
             * @member {string} message
             * @memberof protos.common.Status
             * @instance
             */
            Status.prototype.message = "";

            /**
             * Status requestId.
             * @member {string} requestId
             * @memberof protos.common.Status
             * @instance
             */
            Status.prototype.requestId = "";

            /**
             * Creates a new Status instance using the specified properties.
             * @function create
             * @memberof protos.common.Status
             * @static
             * @param {protos.common.IStatus=} [properties] Properties to set
             * @returns {protos.common.Status} Status instance
             */
            Status.create = function create(properties) {
                return new Status(properties);
            };

            /**
             * Encodes the specified Status message. Does not implicitly {@link protos.common.Status.verify|verify} messages.
             * @function encode
             * @memberof protos.common.Status
             * @static
             * @param {protos.common.IStatus} message Status message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Status.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.requestId);
                return writer;
            };

            /**
             * Encodes the specified Status message, length delimited. Does not implicitly {@link protos.common.Status.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.common.Status
             * @static
             * @param {protos.common.IStatus} message Status message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Status.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Status message from the specified reader or buffer.
             * @function decode
             * @memberof protos.common.Status
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.common.Status} Status
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Status.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.common.Status();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.message = reader.string();
                        break;
                    case 3:
                        message.requestId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Status message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.common.Status
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.common.Status} Status
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Status.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Status message.
             * @function verify
             * @memberof protos.common.Status
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Status.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    switch (message.code) {
                    default:
                        return "code: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 16:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                        break;
                    }
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.requestId != null && message.hasOwnProperty("requestId"))
                    if (!$util.isString(message.requestId))
                        return "requestId: string expected";
                return null;
            };

            /**
             * Creates a Status message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.common.Status
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.common.Status} Status
             */
            Status.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.common.Status)
                    return object;
                var message = new $root.protos.common.Status();
                switch (object.code) {
                case "OK":
                case 0:
                    message.code = 0;
                    break;
                case "CANCELLED":
                case 1:
                    message.code = 1;
                    break;
                case "UNKNOWN":
                case 2:
                    message.code = 2;
                    break;
                case "INVALID_ARGUMENT":
                case 3:
                    message.code = 3;
                    break;
                case "DEADLINE_EXCEEDED":
                case 4:
                    message.code = 4;
                    break;
                case "NOT_FOUND":
                case 5:
                    message.code = 5;
                    break;
                case "ALREADY_EXISTS":
                case 6:
                    message.code = 6;
                    break;
                case "PERMISSION_DENIED":
                case 7:
                    message.code = 7;
                    break;
                case "UNAUTHENTICATED":
                case 16:
                    message.code = 16;
                    break;
                case "RESOURCE_EXHAUSTED":
                case 8:
                    message.code = 8;
                    break;
                case "FAILED_PRECONDITION":
                case 9:
                    message.code = 9;
                    break;
                case "ABORTED":
                case 10:
                    message.code = 10;
                    break;
                case "OUT_OF_RANGE":
                case 11:
                    message.code = 11;
                    break;
                case "UNIMPLEMENTED":
                case 12:
                    message.code = 12;
                    break;
                case "INTERNAL":
                case 13:
                    message.code = 13;
                    break;
                case "UNAVAILABLE":
                case 14:
                    message.code = 14;
                    break;
                case "DATA_LOSS":
                case 15:
                    message.code = 15;
                    break;
                }
                if (object.message != null)
                    message.message = String(object.message);
                if (object.requestId != null)
                    message.requestId = String(object.requestId);
                return message;
            };

            /**
             * Creates a plain object from a Status message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.common.Status
             * @static
             * @param {protos.common.Status} message Status
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Status.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.code = options.enums === String ? "OK" : 0;
                    object.message = "";
                    object.requestId = "";
                }
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = options.enums === String ? $root.protos.common.Code[message.code] : message.code;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                if (message.requestId != null && message.hasOwnProperty("requestId"))
                    object.requestId = message.requestId;
                return object;
            };

            /**
             * Converts this Status to JSON.
             * @function toJSON
             * @memberof protos.common.Status
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Status.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Status;
        })();

        /**
         * BackendType enum.
         * @name protos.common.BackendType
         * @enum {number}
         * @property {number} BACKEND_TYPE_UNSET=0 BACKEND_TYPE_UNSET value
         * @property {number} BACKEND_TYPE_KAFKA=1 BACKEND_TYPE_KAFKA value
         * @property {number} BACKEND_TYPE_RABBIT=2 BACKEND_TYPE_RABBIT value
         * @property {number} BACKEND_TYPE_RABBIT_STREAMS=3 BACKEND_TYPE_RABBIT_STREAMS value
         * @property {number} BACKEND_TYPE_NSQ=4 BACKEND_TYPE_NSQ value
         * @property {number} BACKEND_TYPE_NATS=5 BACKEND_TYPE_NATS value
         * @property {number} BACKEND_TYPE_NATS_STREAMING=6 BACKEND_TYPE_NATS_STREAMING value
         * @property {number} BACKEND_TYPE_GCP_PUBSUB=7 BACKEND_TYPE_GCP_PUBSUB value
         * @property {number} BACKEND_TYPE_AZURE_SERVICE_BUS=8 BACKEND_TYPE_AZURE_SERVICE_BUS value
         * @property {number} BACKEND_TYPE_AZURE_EVENT_HUB=9 BACKEND_TYPE_AZURE_EVENT_HUB value
         * @property {number} BACKEND_TYPE_AWS_SQS=10 BACKEND_TYPE_AWS_SQS value
         * @property {number} BACKEND_TYPE_AWS_SNS=11 BACKEND_TYPE_AWS_SNS value
         * @property {number} BACKEND_TYPE_REDIS_PUBSUB=12 BACKEND_TYPE_REDIS_PUBSUB value
         * @property {number} BACKEND_TYPE_REDIS_STREAMS=13 BACKEND_TYPE_REDIS_STREAMS value
         * @property {number} BACKEND_TYPE_ACTIVEMQ=14 BACKEND_TYPE_ACTIVEMQ value
         * @property {number} BACKEND_TYPE_PULSAR=15 BACKEND_TYPE_PULSAR value
         * @property {number} BACKEND_TYPE_MQTT=16 BACKEND_TYPE_MQTT value
         * @property {number} BACKEND_TYPE_POSTGRES_CDC=17 BACKEND_TYPE_POSTGRES_CDC value
         * @property {number} BACKEND_TYPE_MONGODB_CDC=18 BACKEND_TYPE_MONGODB_CDC value
         * @property {number} BACKEND_TYPE_KUBE_MQ=19 BACKEND_TYPE_KUBE_MQ value
         * @property {number} BACKEND_TYPE_AWS_KINESIS=20 BACKEND_TYPE_AWS_KINESIS value
         */
        common.BackendType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "BACKEND_TYPE_UNSET"] = 0;
            values[valuesById[1] = "BACKEND_TYPE_KAFKA"] = 1;
            values[valuesById[2] = "BACKEND_TYPE_RABBIT"] = 2;
            values[valuesById[3] = "BACKEND_TYPE_RABBIT_STREAMS"] = 3;
            values[valuesById[4] = "BACKEND_TYPE_NSQ"] = 4;
            values[valuesById[5] = "BACKEND_TYPE_NATS"] = 5;
            values[valuesById[6] = "BACKEND_TYPE_NATS_STREAMING"] = 6;
            values[valuesById[7] = "BACKEND_TYPE_GCP_PUBSUB"] = 7;
            values[valuesById[8] = "BACKEND_TYPE_AZURE_SERVICE_BUS"] = 8;
            values[valuesById[9] = "BACKEND_TYPE_AZURE_EVENT_HUB"] = 9;
            values[valuesById[10] = "BACKEND_TYPE_AWS_SQS"] = 10;
            values[valuesById[11] = "BACKEND_TYPE_AWS_SNS"] = 11;
            values[valuesById[12] = "BACKEND_TYPE_REDIS_PUBSUB"] = 12;
            values[valuesById[13] = "BACKEND_TYPE_REDIS_STREAMS"] = 13;
            values[valuesById[14] = "BACKEND_TYPE_ACTIVEMQ"] = 14;
            values[valuesById[15] = "BACKEND_TYPE_PULSAR"] = 15;
            values[valuesById[16] = "BACKEND_TYPE_MQTT"] = 16;
            values[valuesById[17] = "BACKEND_TYPE_POSTGRES_CDC"] = 17;
            values[valuesById[18] = "BACKEND_TYPE_MONGODB_CDC"] = 18;
            values[valuesById[19] = "BACKEND_TYPE_KUBE_MQ"] = 19;
            values[valuesById[20] = "BACKEND_TYPE_AWS_KINESIS"] = 20;
            return values;
        })();

        common.Validation = (function() {

            /**
             * Properties of a Validation.
             * @memberof protos.common
             * @interface IValidation
             * @property {string|null} [_id] Validation _id
             * @property {string|null} [schemaId] Validation schemaId
             * @property {Array.<protos.common.Validation.IField>|null} [fields] Validation fields
             */

            /**
             * Constructs a new Validation.
             * @memberof protos.common
             * @classdesc Represents a Validation.
             * @implements IValidation
             * @constructor
             * @param {protos.common.IValidation=} [properties] Properties to set
             */
            function Validation(properties) {
                this.fields = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Validation _id.
             * @member {string} _id
             * @memberof protos.common.Validation
             * @instance
             */
            Validation.prototype._id = "";

            /**
             * Validation schemaId.
             * @member {string} schemaId
             * @memberof protos.common.Validation
             * @instance
             */
            Validation.prototype.schemaId = "";

            /**
             * Validation fields.
             * @member {Array.<protos.common.Validation.IField>} fields
             * @memberof protos.common.Validation
             * @instance
             */
            Validation.prototype.fields = $util.emptyArray;

            /**
             * Creates a new Validation instance using the specified properties.
             * @function create
             * @memberof protos.common.Validation
             * @static
             * @param {protos.common.IValidation=} [properties] Properties to set
             * @returns {protos.common.Validation} Validation instance
             */
            Validation.create = function create(properties) {
                return new Validation(properties);
            };

            /**
             * Encodes the specified Validation message. Does not implicitly {@link protos.common.Validation.verify|verify} messages.
             * @function encode
             * @memberof protos.common.Validation
             * @static
             * @param {protos.common.IValidation} message Validation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Validation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._id != null && Object.hasOwnProperty.call(message, "_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message._id);
                if (message.schemaId != null && Object.hasOwnProperty.call(message, "schemaId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.schemaId);
                if (message.fields != null && message.fields.length)
                    for (var i = 0; i < message.fields.length; ++i)
                        $root.protos.common.Validation.Field.encode(message.fields[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Validation message, length delimited. Does not implicitly {@link protos.common.Validation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.common.Validation
             * @static
             * @param {protos.common.IValidation} message Validation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Validation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Validation message from the specified reader or buffer.
             * @function decode
             * @memberof protos.common.Validation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.common.Validation} Validation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Validation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.common.Validation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._id = reader.string();
                        break;
                    case 2:
                        message.schemaId = reader.string();
                        break;
                    case 3:
                        if (!(message.fields && message.fields.length))
                            message.fields = [];
                        message.fields.push($root.protos.common.Validation.Field.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Validation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.common.Validation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.common.Validation} Validation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Validation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Validation message.
             * @function verify
             * @memberof protos.common.Validation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Validation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._id != null && message.hasOwnProperty("_id"))
                    if (!$util.isString(message._id))
                        return "_id: string expected";
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    if (!$util.isString(message.schemaId))
                        return "schemaId: string expected";
                if (message.fields != null && message.hasOwnProperty("fields")) {
                    if (!Array.isArray(message.fields))
                        return "fields: array expected";
                    for (var i = 0; i < message.fields.length; ++i) {
                        var error = $root.protos.common.Validation.Field.verify(message.fields[i]);
                        if (error)
                            return "fields." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Validation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.common.Validation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.common.Validation} Validation
             */
            Validation.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.common.Validation)
                    return object;
                var message = new $root.protos.common.Validation();
                if (object._id != null)
                    message._id = String(object._id);
                if (object.schemaId != null)
                    message.schemaId = String(object.schemaId);
                if (object.fields) {
                    if (!Array.isArray(object.fields))
                        throw TypeError(".protos.common.Validation.fields: array expected");
                    message.fields = [];
                    for (var i = 0; i < object.fields.length; ++i) {
                        if (typeof object.fields[i] !== "object")
                            throw TypeError(".protos.common.Validation.fields: object expected");
                        message.fields[i] = $root.protos.common.Validation.Field.fromObject(object.fields[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Validation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.common.Validation
             * @static
             * @param {protos.common.Validation} message Validation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Validation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.fields = [];
                if (options.defaults) {
                    object._id = "";
                    object.schemaId = "";
                }
                if (message._id != null && message.hasOwnProperty("_id"))
                    object._id = message._id;
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    object.schemaId = message.schemaId;
                if (message.fields && message.fields.length) {
                    object.fields = [];
                    for (var j = 0; j < message.fields.length; ++j)
                        object.fields[j] = $root.protos.common.Validation.Field.toObject(message.fields[j], options);
                }
                return object;
            };

            /**
             * Converts this Validation to JSON.
             * @function toJSON
             * @memberof protos.common.Validation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Validation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Validation.Field = (function() {

                /**
                 * Properties of a Field.
                 * @memberof protos.common.Validation
                 * @interface IField
                 * @property {string|null} [path] Field path
                 * @property {string|null} [validationType] Field validationType
                 * @property {string|null} [matchValue] Field matchValue
                 */

                /**
                 * Constructs a new Field.
                 * @memberof protos.common.Validation
                 * @classdesc Represents a Field.
                 * @implements IField
                 * @constructor
                 * @param {protos.common.Validation.IField=} [properties] Properties to set
                 */
                function Field(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Field path.
                 * @member {string} path
                 * @memberof protos.common.Validation.Field
                 * @instance
                 */
                Field.prototype.path = "";

                /**
                 * Field validationType.
                 * @member {string} validationType
                 * @memberof protos.common.Validation.Field
                 * @instance
                 */
                Field.prototype.validationType = "";

                /**
                 * Field matchValue.
                 * @member {string} matchValue
                 * @memberof protos.common.Validation.Field
                 * @instance
                 */
                Field.prototype.matchValue = "";

                /**
                 * Creates a new Field instance using the specified properties.
                 * @function create
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {protos.common.Validation.IField=} [properties] Properties to set
                 * @returns {protos.common.Validation.Field} Field instance
                 */
                Field.create = function create(properties) {
                    return new Field(properties);
                };

                /**
                 * Encodes the specified Field message. Does not implicitly {@link protos.common.Validation.Field.verify|verify} messages.
                 * @function encode
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {protos.common.Validation.IField} message Field message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Field.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                    if (message.validationType != null && Object.hasOwnProperty.call(message, "validationType"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.validationType);
                    if (message.matchValue != null && Object.hasOwnProperty.call(message, "matchValue"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.matchValue);
                    return writer;
                };

                /**
                 * Encodes the specified Field message, length delimited. Does not implicitly {@link protos.common.Validation.Field.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {protos.common.Validation.IField} message Field message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Field.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Field message from the specified reader or buffer.
                 * @function decode
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {protos.common.Validation.Field} Field
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Field.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.common.Validation.Field();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.path = reader.string();
                            break;
                        case 2:
                            message.validationType = reader.string();
                            break;
                        case 3:
                            message.matchValue = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Field message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {protos.common.Validation.Field} Field
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Field.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Field message.
                 * @function verify
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Field.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path"))
                        if (!$util.isString(message.path))
                            return "path: string expected";
                    if (message.validationType != null && message.hasOwnProperty("validationType"))
                        if (!$util.isString(message.validationType))
                            return "validationType: string expected";
                    if (message.matchValue != null && message.hasOwnProperty("matchValue"))
                        if (!$util.isString(message.matchValue))
                            return "matchValue: string expected";
                    return null;
                };

                /**
                 * Creates a Field message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {protos.common.Validation.Field} Field
                 */
                Field.fromObject = function fromObject(object) {
                    if (object instanceof $root.protos.common.Validation.Field)
                        return object;
                    var message = new $root.protos.common.Validation.Field();
                    if (object.path != null)
                        message.path = String(object.path);
                    if (object.validationType != null)
                        message.validationType = String(object.validationType);
                    if (object.matchValue != null)
                        message.matchValue = String(object.matchValue);
                    return message;
                };

                /**
                 * Creates a plain object from a Field message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof protos.common.Validation.Field
                 * @static
                 * @param {protos.common.Validation.Field} message Field
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Field.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.path = "";
                        object.validationType = "";
                        object.matchValue = "";
                    }
                    if (message.path != null && message.hasOwnProperty("path"))
                        object.path = message.path;
                    if (message.validationType != null && message.hasOwnProperty("validationType"))
                        object.validationType = message.validationType;
                    if (message.matchValue != null && message.hasOwnProperty("matchValue"))
                        object.matchValue = message.matchValue;
                    return object;
                };

                /**
                 * Converts this Field to JSON.
                 * @function toJSON
                 * @memberof protos.common.Validation.Field
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Field.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Field;
            })();

            return Validation;
        })();

        return common;
    })();

    protos.opts = (function() {

        /**
         * Namespace opts.
         * @memberof protos
         * @namespace
         */
        var opts = {};

        opts.ConnectionOptions = (function() {

            /**
             * Properties of a ConnectionOptions.
             * @memberof protos.opts
             * @interface IConnectionOptions
             * @property {string|null} [name] ConnectionOptions name
             * @property {string|null} [notes] ConnectionOptions notes
             * @property {protos.args.IKafkaConn|null} [kafka] ConnectionOptions kafka
             * @property {protos.args.IActiveMQConn|null} [activeMq] ConnectionOptions activeMq
             * @property {protos.args.IAWSSQSConn|null} [awsSqs] ConnectionOptions awsSqs
             * @property {protos.args.IAWSSNSConn|null} [awsSns] ConnectionOptions awsSns
             * @property {protos.args.IMongoConn|null} [mongo] ConnectionOptions mongo
             * @property {protos.args.INatsConn|null} [nats] ConnectionOptions nats
             * @property {protos.args.INatsStreamingConn|null} [natsStreaming] ConnectionOptions natsStreaming
             * @property {protos.args.INSQConn|null} [nsq] ConnectionOptions nsq
             * @property {protos.args.IPostgresConn|null} [postgres] ConnectionOptions postgres
             * @property {protos.args.IPulsarConn|null} [pulsar] ConnectionOptions pulsar
             * @property {protos.args.IRabbitConn|null} [rabbit] ConnectionOptions rabbit
             * @property {protos.args.IRabbitStreamsConn|null} [rabbitStreams] ConnectionOptions rabbitStreams
             * @property {protos.args.IRedisPubSubConn|null} [redisPubsub] ConnectionOptions redisPubsub
             * @property {protos.args.IRedisStreamsConn|null} [redisStreams] ConnectionOptions redisStreams
             * @property {protos.args.IAzureEventHubConn|null} [azureEventHub] ConnectionOptions azureEventHub
             * @property {protos.args.IAzureServiceBusConn|null} [azureServiceBus] ConnectionOptions azureServiceBus
             * @property {protos.args.IMQTTConn|null} [mqtt] ConnectionOptions mqtt
             * @property {protos.args.IKubeMQQueueConn|null} [kubemqQueue] ConnectionOptions kubemqQueue
             * @property {protos.args.IGCPPubSubConn|null} [gcpPubsub] ConnectionOptions gcpPubsub
             * @property {protos.args.INatsJetstreamConn|null} [natsJetstream] ConnectionOptions natsJetstream
             * @property {protos.args.IAWSKinesisConn|null} [awsKinesis] ConnectionOptions awsKinesis
             * @property {string|null} [_id] ConnectionOptions _id
             */

            /**
             * Constructs a new ConnectionOptions.
             * @memberof protos.opts
             * @classdesc Represents a ConnectionOptions.
             * @implements IConnectionOptions
             * @constructor
             * @param {protos.opts.IConnectionOptions=} [properties] Properties to set
             */
            function ConnectionOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ConnectionOptions name.
             * @member {string} name
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.name = "";

            /**
             * ConnectionOptions notes.
             * @member {string} notes
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.notes = "";

            /**
             * ConnectionOptions kafka.
             * @member {protos.args.IKafkaConn|null|undefined} kafka
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.kafka = null;

            /**
             * ConnectionOptions activeMq.
             * @member {protos.args.IActiveMQConn|null|undefined} activeMq
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.activeMq = null;

            /**
             * ConnectionOptions awsSqs.
             * @member {protos.args.IAWSSQSConn|null|undefined} awsSqs
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.awsSqs = null;

            /**
             * ConnectionOptions awsSns.
             * @member {protos.args.IAWSSNSConn|null|undefined} awsSns
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.awsSns = null;

            /**
             * ConnectionOptions mongo.
             * @member {protos.args.IMongoConn|null|undefined} mongo
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.mongo = null;

            /**
             * ConnectionOptions nats.
             * @member {protos.args.INatsConn|null|undefined} nats
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.nats = null;

            /**
             * ConnectionOptions natsStreaming.
             * @member {protos.args.INatsStreamingConn|null|undefined} natsStreaming
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.natsStreaming = null;

            /**
             * ConnectionOptions nsq.
             * @member {protos.args.INSQConn|null|undefined} nsq
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.nsq = null;

            /**
             * ConnectionOptions postgres.
             * @member {protos.args.IPostgresConn|null|undefined} postgres
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.postgres = null;

            /**
             * ConnectionOptions pulsar.
             * @member {protos.args.IPulsarConn|null|undefined} pulsar
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.pulsar = null;

            /**
             * ConnectionOptions rabbit.
             * @member {protos.args.IRabbitConn|null|undefined} rabbit
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.rabbit = null;

            /**
             * ConnectionOptions rabbitStreams.
             * @member {protos.args.IRabbitStreamsConn|null|undefined} rabbitStreams
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.rabbitStreams = null;

            /**
             * ConnectionOptions redisPubsub.
             * @member {protos.args.IRedisPubSubConn|null|undefined} redisPubsub
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.redisPubsub = null;

            /**
             * ConnectionOptions redisStreams.
             * @member {protos.args.IRedisStreamsConn|null|undefined} redisStreams
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.redisStreams = null;

            /**
             * ConnectionOptions azureEventHub.
             * @member {protos.args.IAzureEventHubConn|null|undefined} azureEventHub
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.azureEventHub = null;

            /**
             * ConnectionOptions azureServiceBus.
             * @member {protos.args.IAzureServiceBusConn|null|undefined} azureServiceBus
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.azureServiceBus = null;

            /**
             * ConnectionOptions mqtt.
             * @member {protos.args.IMQTTConn|null|undefined} mqtt
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.mqtt = null;

            /**
             * ConnectionOptions kubemqQueue.
             * @member {protos.args.IKubeMQQueueConn|null|undefined} kubemqQueue
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.kubemqQueue = null;

            /**
             * ConnectionOptions gcpPubsub.
             * @member {protos.args.IGCPPubSubConn|null|undefined} gcpPubsub
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.gcpPubsub = null;

            /**
             * ConnectionOptions natsJetstream.
             * @member {protos.args.INatsJetstreamConn|null|undefined} natsJetstream
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.natsJetstream = null;

            /**
             * ConnectionOptions awsKinesis.
             * @member {protos.args.IAWSKinesisConn|null|undefined} awsKinesis
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype.awsKinesis = null;

            /**
             * ConnectionOptions _id.
             * @member {string} _id
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            ConnectionOptions.prototype._id = "";

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * ConnectionOptions conn.
             * @member {"kafka"|"activeMq"|"awsSqs"|"awsSns"|"mongo"|"nats"|"natsStreaming"|"nsq"|"postgres"|"pulsar"|"rabbit"|"rabbitStreams"|"redisPubsub"|"redisStreams"|"azureEventHub"|"azureServiceBus"|"mqtt"|"kubemqQueue"|"gcpPubsub"|"natsJetstream"|"awsKinesis"|undefined} conn
             * @memberof protos.opts.ConnectionOptions
             * @instance
             */
            Object.defineProperty(ConnectionOptions.prototype, "conn", {
                get: $util.oneOfGetter($oneOfFields = ["kafka", "activeMq", "awsSqs", "awsSns", "mongo", "nats", "natsStreaming", "nsq", "postgres", "pulsar", "rabbit", "rabbitStreams", "redisPubsub", "redisStreams", "azureEventHub", "azureServiceBus", "mqtt", "kubemqQueue", "gcpPubsub", "natsJetstream", "awsKinesis"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ConnectionOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {protos.opts.IConnectionOptions=} [properties] Properties to set
             * @returns {protos.opts.ConnectionOptions} ConnectionOptions instance
             */
            ConnectionOptions.create = function create(properties) {
                return new ConnectionOptions(properties);
            };

            /**
             * Encodes the specified ConnectionOptions message. Does not implicitly {@link protos.opts.ConnectionOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {protos.opts.IConnectionOptions} message ConnectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectionOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.notes);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.args.KafkaConn.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.activeMq != null && Object.hasOwnProperty.call(message, "activeMq"))
                    $root.protos.args.ActiveMQConn.encode(message.activeMq, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.awsSqs != null && Object.hasOwnProperty.call(message, "awsSqs"))
                    $root.protos.args.AWSSQSConn.encode(message.awsSqs, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.awsSns != null && Object.hasOwnProperty.call(message, "awsSns"))
                    $root.protos.args.AWSSNSConn.encode(message.awsSns, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.mongo != null && Object.hasOwnProperty.call(message, "mongo"))
                    $root.protos.args.MongoConn.encode(message.mongo, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.args.NatsConn.encode(message.nats, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.args.NatsStreamingConn.encode(message.natsStreaming, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.args.NSQConn.encode(message.nsq, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.postgres != null && Object.hasOwnProperty.call(message, "postgres"))
                    $root.protos.args.PostgresConn.encode(message.postgres, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.pulsar != null && Object.hasOwnProperty.call(message, "pulsar"))
                    $root.protos.args.PulsarConn.encode(message.pulsar, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.args.RabbitConn.encode(message.rabbit, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
                if (message.rabbitStreams != null && Object.hasOwnProperty.call(message, "rabbitStreams"))
                    $root.protos.args.RabbitStreamsConn.encode(message.rabbitStreams, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.args.RedisPubSubConn.encode(message.redisPubsub, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.args.RedisStreamsConn.encode(message.redisStreams, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.azureEventHub != null && Object.hasOwnProperty.call(message, "azureEventHub"))
                    $root.protos.args.AzureEventHubConn.encode(message.azureEventHub, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.args.AzureServiceBusConn.encode(message.azureServiceBus, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.args.MQTTConn.encode(message.mqtt, writer.uint32(/* id 116, wireType 2 =*/930).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.args.KubeMQQueueConn.encode(message.kubemqQueue, writer.uint32(/* id 117, wireType 2 =*/938).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.args.GCPPubSubConn.encode(message.gcpPubsub, writer.uint32(/* id 118, wireType 2 =*/946).fork()).ldelim();
                if (message.natsJetstream != null && Object.hasOwnProperty.call(message, "natsJetstream"))
                    $root.protos.args.NatsJetstreamConn.encode(message.natsJetstream, writer.uint32(/* id 119, wireType 2 =*/954).fork()).ldelim();
                if (message.awsKinesis != null && Object.hasOwnProperty.call(message, "awsKinesis"))
                    $root.protos.args.AWSKinesisConn.encode(message.awsKinesis, writer.uint32(/* id 120, wireType 2 =*/962).fork()).ldelim();
                if (message._id != null && Object.hasOwnProperty.call(message, "_id"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._id);
                return writer;
            };

            /**
             * Encodes the specified ConnectionOptions message, length delimited. Does not implicitly {@link protos.opts.ConnectionOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {protos.opts.IConnectionOptions} message ConnectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnectionOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ConnectionOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ConnectionOptions} ConnectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectionOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ConnectionOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.notes = reader.string();
                        break;
                    case 100:
                        message.kafka = $root.protos.args.KafkaConn.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.activeMq = $root.protos.args.ActiveMQConn.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.awsSqs = $root.protos.args.AWSSQSConn.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.awsSns = $root.protos.args.AWSSNSConn.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.mongo = $root.protos.args.MongoConn.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.nats = $root.protos.args.NatsConn.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.natsStreaming = $root.protos.args.NatsStreamingConn.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.nsq = $root.protos.args.NSQConn.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.postgres = $root.protos.args.PostgresConn.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.pulsar = $root.protos.args.PulsarConn.decode(reader, reader.uint32());
                        break;
                    case 110:
                        message.rabbit = $root.protos.args.RabbitConn.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.rabbitStreams = $root.protos.args.RabbitStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.redisPubsub = $root.protos.args.RedisPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.redisStreams = $root.protos.args.RedisStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.azureEventHub = $root.protos.args.AzureEventHubConn.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.azureServiceBus = $root.protos.args.AzureServiceBusConn.decode(reader, reader.uint32());
                        break;
                    case 116:
                        message.mqtt = $root.protos.args.MQTTConn.decode(reader, reader.uint32());
                        break;
                    case 117:
                        message.kubemqQueue = $root.protos.args.KubeMQQueueConn.decode(reader, reader.uint32());
                        break;
                    case 118:
                        message.gcpPubsub = $root.protos.args.GCPPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 119:
                        message.natsJetstream = $root.protos.args.NatsJetstreamConn.decode(reader, reader.uint32());
                        break;
                    case 120:
                        message.awsKinesis = $root.protos.args.AWSKinesisConn.decode(reader, reader.uint32());
                        break;
                    case 1000:
                        message._id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ConnectionOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ConnectionOptions} ConnectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnectionOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ConnectionOptions message.
             * @function verify
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConnectionOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.notes != null && message.hasOwnProperty("notes"))
                    if (!$util.isString(message.notes))
                        return "notes: string expected";
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.KafkaConn.verify(message.kafka);
                        if (error)
                            return "kafka." + error;
                    }
                }
                if (message.activeMq != null && message.hasOwnProperty("activeMq")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.ActiveMQConn.verify(message.activeMq);
                        if (error)
                            return "activeMq." + error;
                    }
                }
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.AWSSQSConn.verify(message.awsSqs);
                        if (error)
                            return "awsSqs." + error;
                    }
                }
                if (message.awsSns != null && message.hasOwnProperty("awsSns")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.AWSSNSConn.verify(message.awsSns);
                        if (error)
                            return "awsSns." + error;
                    }
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.MongoConn.verify(message.mongo);
                        if (error)
                            return "mongo." + error;
                    }
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.NatsConn.verify(message.nats);
                        if (error)
                            return "nats." + error;
                    }
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.NatsStreamingConn.verify(message.natsStreaming);
                        if (error)
                            return "natsStreaming." + error;
                    }
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.NSQConn.verify(message.nsq);
                        if (error)
                            return "nsq." + error;
                    }
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.PostgresConn.verify(message.postgres);
                        if (error)
                            return "postgres." + error;
                    }
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.PulsarConn.verify(message.pulsar);
                        if (error)
                            return "pulsar." + error;
                    }
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.RabbitConn.verify(message.rabbit);
                        if (error)
                            return "rabbit." + error;
                    }
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.RabbitStreamsConn.verify(message.rabbitStreams);
                        if (error)
                            return "rabbitStreams." + error;
                    }
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.RedisPubSubConn.verify(message.redisPubsub);
                        if (error)
                            return "redisPubsub." + error;
                    }
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.RedisStreamsConn.verify(message.redisStreams);
                        if (error)
                            return "redisStreams." + error;
                    }
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.AzureEventHubConn.verify(message.azureEventHub);
                        if (error)
                            return "azureEventHub." + error;
                    }
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.AzureServiceBusConn.verify(message.azureServiceBus);
                        if (error)
                            return "azureServiceBus." + error;
                    }
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.MQTTConn.verify(message.mqtt);
                        if (error)
                            return "mqtt." + error;
                    }
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.KubeMQQueueConn.verify(message.kubemqQueue);
                        if (error)
                            return "kubemqQueue." + error;
                    }
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.GCPPubSubConn.verify(message.gcpPubsub);
                        if (error)
                            return "gcpPubsub." + error;
                    }
                }
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.NatsJetstreamConn.verify(message.natsJetstream);
                        if (error)
                            return "natsJetstream." + error;
                    }
                }
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis")) {
                    if (properties.conn === 1)
                        return "conn: multiple values";
                    properties.conn = 1;
                    {
                        var error = $root.protos.args.AWSKinesisConn.verify(message.awsKinesis);
                        if (error)
                            return "awsKinesis." + error;
                    }
                }
                if (message._id != null && message.hasOwnProperty("_id"))
                    if (!$util.isString(message._id))
                        return "_id: string expected";
                return null;
            };

            /**
             * Creates a ConnectionOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ConnectionOptions} ConnectionOptions
             */
            ConnectionOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ConnectionOptions)
                    return object;
                var message = new $root.protos.opts.ConnectionOptions();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.notes != null)
                    message.notes = String(object.notes);
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.kafka: object expected");
                    message.kafka = $root.protos.args.KafkaConn.fromObject(object.kafka);
                }
                if (object.activeMq != null) {
                    if (typeof object.activeMq !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.activeMq: object expected");
                    message.activeMq = $root.protos.args.ActiveMQConn.fromObject(object.activeMq);
                }
                if (object.awsSqs != null) {
                    if (typeof object.awsSqs !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.awsSqs: object expected");
                    message.awsSqs = $root.protos.args.AWSSQSConn.fromObject(object.awsSqs);
                }
                if (object.awsSns != null) {
                    if (typeof object.awsSns !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.awsSns: object expected");
                    message.awsSns = $root.protos.args.AWSSNSConn.fromObject(object.awsSns);
                }
                if (object.mongo != null) {
                    if (typeof object.mongo !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.mongo: object expected");
                    message.mongo = $root.protos.args.MongoConn.fromObject(object.mongo);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.nats: object expected");
                    message.nats = $root.protos.args.NatsConn.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.args.NatsStreamingConn.fromObject(object.natsStreaming);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.nsq: object expected");
                    message.nsq = $root.protos.args.NSQConn.fromObject(object.nsq);
                }
                if (object.postgres != null) {
                    if (typeof object.postgres !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.postgres: object expected");
                    message.postgres = $root.protos.args.PostgresConn.fromObject(object.postgres);
                }
                if (object.pulsar != null) {
                    if (typeof object.pulsar !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.pulsar: object expected");
                    message.pulsar = $root.protos.args.PulsarConn.fromObject(object.pulsar);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.rabbit: object expected");
                    message.rabbit = $root.protos.args.RabbitConn.fromObject(object.rabbit);
                }
                if (object.rabbitStreams != null) {
                    if (typeof object.rabbitStreams !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.rabbitStreams: object expected");
                    message.rabbitStreams = $root.protos.args.RabbitStreamsConn.fromObject(object.rabbitStreams);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.args.RedisPubSubConn.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.args.RedisStreamsConn.fromObject(object.redisStreams);
                }
                if (object.azureEventHub != null) {
                    if (typeof object.azureEventHub !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.azureEventHub: object expected");
                    message.azureEventHub = $root.protos.args.AzureEventHubConn.fromObject(object.azureEventHub);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.args.AzureServiceBusConn.fromObject(object.azureServiceBus);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.mqtt: object expected");
                    message.mqtt = $root.protos.args.MQTTConn.fromObject(object.mqtt);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.args.KubeMQQueueConn.fromObject(object.kubemqQueue);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.args.GCPPubSubConn.fromObject(object.gcpPubsub);
                }
                if (object.natsJetstream != null) {
                    if (typeof object.natsJetstream !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.natsJetstream: object expected");
                    message.natsJetstream = $root.protos.args.NatsJetstreamConn.fromObject(object.natsJetstream);
                }
                if (object.awsKinesis != null) {
                    if (typeof object.awsKinesis !== "object")
                        throw TypeError(".protos.opts.ConnectionOptions.awsKinesis: object expected");
                    message.awsKinesis = $root.protos.args.AWSKinesisConn.fromObject(object.awsKinesis);
                }
                if (object._id != null)
                    message._id = String(object._id);
                return message;
            };

            /**
             * Creates a plain object from a ConnectionOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ConnectionOptions
             * @static
             * @param {protos.opts.ConnectionOptions} message ConnectionOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConnectionOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.notes = "";
                    object._id = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.notes != null && message.hasOwnProperty("notes"))
                    object.notes = message.notes;
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    object.kafka = $root.protos.args.KafkaConn.toObject(message.kafka, options);
                    if (options.oneofs)
                        object.conn = "kafka";
                }
                if (message.activeMq != null && message.hasOwnProperty("activeMq")) {
                    object.activeMq = $root.protos.args.ActiveMQConn.toObject(message.activeMq, options);
                    if (options.oneofs)
                        object.conn = "activeMq";
                }
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs")) {
                    object.awsSqs = $root.protos.args.AWSSQSConn.toObject(message.awsSqs, options);
                    if (options.oneofs)
                        object.conn = "awsSqs";
                }
                if (message.awsSns != null && message.hasOwnProperty("awsSns")) {
                    object.awsSns = $root.protos.args.AWSSNSConn.toObject(message.awsSns, options);
                    if (options.oneofs)
                        object.conn = "awsSns";
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    object.mongo = $root.protos.args.MongoConn.toObject(message.mongo, options);
                    if (options.oneofs)
                        object.conn = "mongo";
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    object.nats = $root.protos.args.NatsConn.toObject(message.nats, options);
                    if (options.oneofs)
                        object.conn = "nats";
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    object.natsStreaming = $root.protos.args.NatsStreamingConn.toObject(message.natsStreaming, options);
                    if (options.oneofs)
                        object.conn = "natsStreaming";
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    object.nsq = $root.protos.args.NSQConn.toObject(message.nsq, options);
                    if (options.oneofs)
                        object.conn = "nsq";
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    object.postgres = $root.protos.args.PostgresConn.toObject(message.postgres, options);
                    if (options.oneofs)
                        object.conn = "postgres";
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    object.pulsar = $root.protos.args.PulsarConn.toObject(message.pulsar, options);
                    if (options.oneofs)
                        object.conn = "pulsar";
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    object.rabbit = $root.protos.args.RabbitConn.toObject(message.rabbit, options);
                    if (options.oneofs)
                        object.conn = "rabbit";
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    object.rabbitStreams = $root.protos.args.RabbitStreamsConn.toObject(message.rabbitStreams, options);
                    if (options.oneofs)
                        object.conn = "rabbitStreams";
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    object.redisPubsub = $root.protos.args.RedisPubSubConn.toObject(message.redisPubsub, options);
                    if (options.oneofs)
                        object.conn = "redisPubsub";
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    object.redisStreams = $root.protos.args.RedisStreamsConn.toObject(message.redisStreams, options);
                    if (options.oneofs)
                        object.conn = "redisStreams";
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    object.azureEventHub = $root.protos.args.AzureEventHubConn.toObject(message.azureEventHub, options);
                    if (options.oneofs)
                        object.conn = "azureEventHub";
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    object.azureServiceBus = $root.protos.args.AzureServiceBusConn.toObject(message.azureServiceBus, options);
                    if (options.oneofs)
                        object.conn = "azureServiceBus";
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    object.mqtt = $root.protos.args.MQTTConn.toObject(message.mqtt, options);
                    if (options.oneofs)
                        object.conn = "mqtt";
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    object.kubemqQueue = $root.protos.args.KubeMQQueueConn.toObject(message.kubemqQueue, options);
                    if (options.oneofs)
                        object.conn = "kubemqQueue";
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    object.gcpPubsub = $root.protos.args.GCPPubSubConn.toObject(message.gcpPubsub, options);
                    if (options.oneofs)
                        object.conn = "gcpPubsub";
                }
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream")) {
                    object.natsJetstream = $root.protos.args.NatsJetstreamConn.toObject(message.natsJetstream, options);
                    if (options.oneofs)
                        object.conn = "natsJetstream";
                }
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis")) {
                    object.awsKinesis = $root.protos.args.AWSKinesisConn.toObject(message.awsKinesis, options);
                    if (options.oneofs)
                        object.conn = "awsKinesis";
                }
                if (message._id != null && message.hasOwnProperty("_id"))
                    object._id = message._id;
                return object;
            };

            /**
             * Converts this ConnectionOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ConnectionOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConnectionOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ConnectionOptions;
        })();

        opts.DynamicOptions = (function() {

            /**
             * Properties of a DynamicOptions.
             * @memberof protos.opts
             * @interface IDynamicOptions
             * @property {string|null} [apiToken] DynamicOptions apiToken
             * @property {string|null} [connectionId] DynamicOptions connectionId
             * @property {string|null} [_grpcAddress] DynamicOptions _grpcAddress
             * @property {number|null} [_grpcTimeoutSeconds] DynamicOptions _grpcTimeoutSeconds
             * @property {boolean|null} [_grpcInsecure] DynamicOptions _grpcInsecure
             * @property {string|null} [_dynamicId] DynamicOptions _dynamicId
             * @property {boolean|null} [_active] DynamicOptions _active
             * @property {protos.opts.IDynamicGroupKafkaOptions|null} [kafka] DynamicOptions kafka
             * @property {protos.opts.IDynamicGroupActiveMQOptions|null} [activemq] DynamicOptions activemq
             * @property {protos.opts.IDynamicGroupAWSSQSOptions|null} [awsSqs] DynamicOptions awsSqs
             * @property {protos.opts.IDynamicGroupAWSSNSOptions|null} [awsSns] DynamicOptions awsSns
             * @property {protos.opts.IDynamicGroupNatsOptions|null} [nats] DynamicOptions nats
             * @property {protos.opts.IDynamicGroupNatsStreamingOptions|null} [natsStreaming] DynamicOptions natsStreaming
             * @property {protos.opts.IDynamicGroupNSQOptions|null} [nsq] DynamicOptions nsq
             * @property {protos.opts.IDynamicGroupRabbitOptions|null} [rabbit] DynamicOptions rabbit
             * @property {protos.opts.IDynamicGroupMQTTOptions|null} [mqtt] DynamicOptions mqtt
             * @property {protos.opts.IDynamicGroupAzureServiceBusOptions|null} [azureServiceBus] DynamicOptions azureServiceBus
             * @property {protos.opts.IDynamicGroupAzureEventHubOptions|null} [azureEventHub] DynamicOptions azureEventHub
             * @property {protos.opts.IDynamicGroupGCPPubSubOptions|null} [gcpPubsub] DynamicOptions gcpPubsub
             * @property {protos.opts.IDynamicGroupKubeMQQueueOptions|null} [kubemqQueue] DynamicOptions kubemqQueue
             * @property {protos.opts.IDynamicGroupRedisPubSubOptions|null} [redisPubsub] DynamicOptions redisPubsub
             * @property {protos.opts.IDynamicGroupRedisStreamsOptions|null} [redisStreams] DynamicOptions redisStreams
             * @property {protos.opts.IDynamicGroupPulsarOptions|null} [pulsar] DynamicOptions pulsar
             * @property {protos.opts.IDynamicGroupRabbitStreamsOptions|null} [rabbitStreams] DynamicOptions rabbitStreams
             * @property {protos.opts.IDynamicGroupNatsJetstreamOptions|null} [natsJetstream] DynamicOptions natsJetstream
             * @property {protos.opts.IDynamicGroupAWSKinesisOptions|null} [awsKinesis] DynamicOptions awsKinesis
             */

            /**
             * Constructs a new DynamicOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicOptions.
             * @implements IDynamicOptions
             * @constructor
             * @param {protos.opts.IDynamicOptions=} [properties] Properties to set
             */
            function DynamicOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicOptions apiToken.
             * @member {string} apiToken
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.apiToken = "";

            /**
             * DynamicOptions connectionId.
             * @member {string} connectionId
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.connectionId = "";

            /**
             * DynamicOptions _grpcAddress.
             * @member {string} _grpcAddress
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype._grpcAddress = "";

            /**
             * DynamicOptions _grpcTimeoutSeconds.
             * @member {number} _grpcTimeoutSeconds
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype._grpcTimeoutSeconds = 0;

            /**
             * DynamicOptions _grpcInsecure.
             * @member {boolean} _grpcInsecure
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype._grpcInsecure = false;

            /**
             * DynamicOptions _dynamicId.
             * @member {string} _dynamicId
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype._dynamicId = "";

            /**
             * DynamicOptions _active.
             * @member {boolean} _active
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype._active = false;

            /**
             * DynamicOptions kafka.
             * @member {protos.opts.IDynamicGroupKafkaOptions|null|undefined} kafka
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.kafka = null;

            /**
             * DynamicOptions activemq.
             * @member {protos.opts.IDynamicGroupActiveMQOptions|null|undefined} activemq
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.activemq = null;

            /**
             * DynamicOptions awsSqs.
             * @member {protos.opts.IDynamicGroupAWSSQSOptions|null|undefined} awsSqs
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.awsSqs = null;

            /**
             * DynamicOptions awsSns.
             * @member {protos.opts.IDynamicGroupAWSSNSOptions|null|undefined} awsSns
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.awsSns = null;

            /**
             * DynamicOptions nats.
             * @member {protos.opts.IDynamicGroupNatsOptions|null|undefined} nats
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.nats = null;

            /**
             * DynamicOptions natsStreaming.
             * @member {protos.opts.IDynamicGroupNatsStreamingOptions|null|undefined} natsStreaming
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.natsStreaming = null;

            /**
             * DynamicOptions nsq.
             * @member {protos.opts.IDynamicGroupNSQOptions|null|undefined} nsq
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.nsq = null;

            /**
             * DynamicOptions rabbit.
             * @member {protos.opts.IDynamicGroupRabbitOptions|null|undefined} rabbit
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.rabbit = null;

            /**
             * DynamicOptions mqtt.
             * @member {protos.opts.IDynamicGroupMQTTOptions|null|undefined} mqtt
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.mqtt = null;

            /**
             * DynamicOptions azureServiceBus.
             * @member {protos.opts.IDynamicGroupAzureServiceBusOptions|null|undefined} azureServiceBus
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.azureServiceBus = null;

            /**
             * DynamicOptions azureEventHub.
             * @member {protos.opts.IDynamicGroupAzureEventHubOptions|null|undefined} azureEventHub
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.azureEventHub = null;

            /**
             * DynamicOptions gcpPubsub.
             * @member {protos.opts.IDynamicGroupGCPPubSubOptions|null|undefined} gcpPubsub
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.gcpPubsub = null;

            /**
             * DynamicOptions kubemqQueue.
             * @member {protos.opts.IDynamicGroupKubeMQQueueOptions|null|undefined} kubemqQueue
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.kubemqQueue = null;

            /**
             * DynamicOptions redisPubsub.
             * @member {protos.opts.IDynamicGroupRedisPubSubOptions|null|undefined} redisPubsub
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.redisPubsub = null;

            /**
             * DynamicOptions redisStreams.
             * @member {protos.opts.IDynamicGroupRedisStreamsOptions|null|undefined} redisStreams
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.redisStreams = null;

            /**
             * DynamicOptions pulsar.
             * @member {protos.opts.IDynamicGroupPulsarOptions|null|undefined} pulsar
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.pulsar = null;

            /**
             * DynamicOptions rabbitStreams.
             * @member {protos.opts.IDynamicGroupRabbitStreamsOptions|null|undefined} rabbitStreams
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.rabbitStreams = null;

            /**
             * DynamicOptions natsJetstream.
             * @member {protos.opts.IDynamicGroupNatsJetstreamOptions|null|undefined} natsJetstream
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.natsJetstream = null;

            /**
             * DynamicOptions awsKinesis.
             * @member {protos.opts.IDynamicGroupAWSKinesisOptions|null|undefined} awsKinesis
             * @memberof protos.opts.DynamicOptions
             * @instance
             */
            DynamicOptions.prototype.awsKinesis = null;

            /**
             * Creates a new DynamicOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {protos.opts.IDynamicOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicOptions} DynamicOptions instance
             */
            DynamicOptions.create = function create(properties) {
                return new DynamicOptions(properties);
            };

            /**
             * Encodes the specified DynamicOptions message. Does not implicitly {@link protos.opts.DynamicOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {protos.opts.IDynamicOptions} message DynamicOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.apiToken != null && Object.hasOwnProperty.call(message, "apiToken"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.apiToken);
                if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.connectionId);
                if (message._grpcAddress != null && Object.hasOwnProperty.call(message, "_grpcAddress"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message._grpcAddress);
                if (message._grpcTimeoutSeconds != null && Object.hasOwnProperty.call(message, "_grpcTimeoutSeconds"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message._grpcTimeoutSeconds);
                if (message._grpcInsecure != null && Object.hasOwnProperty.call(message, "_grpcInsecure"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message._grpcInsecure);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.opts.DynamicGroupKafkaOptions.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.activemq != null && Object.hasOwnProperty.call(message, "activemq"))
                    $root.protos.opts.DynamicGroupActiveMQOptions.encode(message.activemq, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.awsSqs != null && Object.hasOwnProperty.call(message, "awsSqs"))
                    $root.protos.opts.DynamicGroupAWSSQSOptions.encode(message.awsSqs, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.awsSns != null && Object.hasOwnProperty.call(message, "awsSns"))
                    $root.protos.opts.DynamicGroupAWSSNSOptions.encode(message.awsSns, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.opts.DynamicGroupNatsOptions.encode(message.nats, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.opts.DynamicGroupNatsStreamingOptions.encode(message.natsStreaming, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.opts.DynamicGroupNSQOptions.encode(message.nsq, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.opts.DynamicGroupRabbitOptions.encode(message.rabbit, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.opts.DynamicGroupMQTTOptions.encode(message.mqtt, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.opts.DynamicGroupAzureServiceBusOptions.encode(message.azureServiceBus, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.azureEventHub != null && Object.hasOwnProperty.call(message, "azureEventHub"))
                    $root.protos.opts.DynamicGroupAzureEventHubOptions.encode(message.azureEventHub, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.opts.DynamicGroupGCPPubSubOptions.encode(message.gcpPubsub, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.opts.DynamicGroupKubeMQQueueOptions.encode(message.kubemqQueue, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.opts.DynamicGroupRedisPubSubOptions.encode(message.redisPubsub, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.opts.DynamicGroupRedisStreamsOptions.encode(message.redisStreams, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.pulsar != null && Object.hasOwnProperty.call(message, "pulsar"))
                    $root.protos.opts.DynamicGroupPulsarOptions.encode(message.pulsar, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                if (message.rabbitStreams != null && Object.hasOwnProperty.call(message, "rabbitStreams"))
                    $root.protos.opts.DynamicGroupRabbitStreamsOptions.encode(message.rabbitStreams, writer.uint32(/* id 116, wireType 2 =*/930).fork()).ldelim();
                if (message.natsJetstream != null && Object.hasOwnProperty.call(message, "natsJetstream"))
                    $root.protos.opts.DynamicGroupNatsJetstreamOptions.encode(message.natsJetstream, writer.uint32(/* id 117, wireType 2 =*/938).fork()).ldelim();
                if (message.awsKinesis != null && Object.hasOwnProperty.call(message, "awsKinesis"))
                    $root.protos.opts.DynamicGroupAWSKinesisOptions.encode(message.awsKinesis, writer.uint32(/* id 118, wireType 2 =*/946).fork()).ldelim();
                if (message._dynamicId != null && Object.hasOwnProperty.call(message, "_dynamicId"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._dynamicId);
                if (message._active != null && Object.hasOwnProperty.call(message, "_active"))
                    writer.uint32(/* id 1001, wireType 0 =*/8008).bool(message._active);
                return writer;
            };

            /**
             * Encodes the specified DynamicOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {protos.opts.IDynamicOptions} message DynamicOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicOptions} DynamicOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.apiToken = reader.string();
                        break;
                    case 2:
                        message.connectionId = reader.string();
                        break;
                    case 3:
                        message._grpcAddress = reader.string();
                        break;
                    case 4:
                        message._grpcTimeoutSeconds = reader.uint32();
                        break;
                    case 5:
                        message._grpcInsecure = reader.bool();
                        break;
                    case 1000:
                        message._dynamicId = reader.string();
                        break;
                    case 1001:
                        message._active = reader.bool();
                        break;
                    case 100:
                        message.kafka = $root.protos.opts.DynamicGroupKafkaOptions.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.activemq = $root.protos.opts.DynamicGroupActiveMQOptions.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.awsSqs = $root.protos.opts.DynamicGroupAWSSQSOptions.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.awsSns = $root.protos.opts.DynamicGroupAWSSNSOptions.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.nats = $root.protos.opts.DynamicGroupNatsOptions.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.natsStreaming = $root.protos.opts.DynamicGroupNatsStreamingOptions.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.nsq = $root.protos.opts.DynamicGroupNSQOptions.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.rabbit = $root.protos.opts.DynamicGroupRabbitOptions.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.mqtt = $root.protos.opts.DynamicGroupMQTTOptions.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.azureServiceBus = $root.protos.opts.DynamicGroupAzureServiceBusOptions.decode(reader, reader.uint32());
                        break;
                    case 110:
                        message.azureEventHub = $root.protos.opts.DynamicGroupAzureEventHubOptions.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.gcpPubsub = $root.protos.opts.DynamicGroupGCPPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.kubemqQueue = $root.protos.opts.DynamicGroupKubeMQQueueOptions.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.redisPubsub = $root.protos.opts.DynamicGroupRedisPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.redisStreams = $root.protos.opts.DynamicGroupRedisStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.pulsar = $root.protos.opts.DynamicGroupPulsarOptions.decode(reader, reader.uint32());
                        break;
                    case 116:
                        message.rabbitStreams = $root.protos.opts.DynamicGroupRabbitStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 117:
                        message.natsJetstream = $root.protos.opts.DynamicGroupNatsJetstreamOptions.decode(reader, reader.uint32());
                        break;
                    case 118:
                        message.awsKinesis = $root.protos.opts.DynamicGroupAWSKinesisOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicOptions} DynamicOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicOptions message.
             * @function verify
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.apiToken != null && message.hasOwnProperty("apiToken"))
                    if (!$util.isString(message.apiToken))
                        return "apiToken: string expected";
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    if (!$util.isString(message.connectionId))
                        return "connectionId: string expected";
                if (message._grpcAddress != null && message.hasOwnProperty("_grpcAddress"))
                    if (!$util.isString(message._grpcAddress))
                        return "_grpcAddress: string expected";
                if (message._grpcTimeoutSeconds != null && message.hasOwnProperty("_grpcTimeoutSeconds"))
                    if (!$util.isInteger(message._grpcTimeoutSeconds))
                        return "_grpcTimeoutSeconds: integer expected";
                if (message._grpcInsecure != null && message.hasOwnProperty("_grpcInsecure"))
                    if (typeof message._grpcInsecure !== "boolean")
                        return "_grpcInsecure: boolean expected";
                if (message._dynamicId != null && message.hasOwnProperty("_dynamicId"))
                    if (!$util.isString(message._dynamicId))
                        return "_dynamicId: string expected";
                if (message._active != null && message.hasOwnProperty("_active"))
                    if (typeof message._active !== "boolean")
                        return "_active: boolean expected";
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    var error = $root.protos.opts.DynamicGroupKafkaOptions.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.activemq != null && message.hasOwnProperty("activemq")) {
                    var error = $root.protos.opts.DynamicGroupActiveMQOptions.verify(message.activemq);
                    if (error)
                        return "activemq." + error;
                }
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs")) {
                    var error = $root.protos.opts.DynamicGroupAWSSQSOptions.verify(message.awsSqs);
                    if (error)
                        return "awsSqs." + error;
                }
                if (message.awsSns != null && message.hasOwnProperty("awsSns")) {
                    var error = $root.protos.opts.DynamicGroupAWSSNSOptions.verify(message.awsSns);
                    if (error)
                        return "awsSns." + error;
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    var error = $root.protos.opts.DynamicGroupNatsOptions.verify(message.nats);
                    if (error)
                        return "nats." + error;
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    var error = $root.protos.opts.DynamicGroupNatsStreamingOptions.verify(message.natsStreaming);
                    if (error)
                        return "natsStreaming." + error;
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    var error = $root.protos.opts.DynamicGroupNSQOptions.verify(message.nsq);
                    if (error)
                        return "nsq." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    var error = $root.protos.opts.DynamicGroupRabbitOptions.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    var error = $root.protos.opts.DynamicGroupMQTTOptions.verify(message.mqtt);
                    if (error)
                        return "mqtt." + error;
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    var error = $root.protos.opts.DynamicGroupAzureServiceBusOptions.verify(message.azureServiceBus);
                    if (error)
                        return "azureServiceBus." + error;
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    var error = $root.protos.opts.DynamicGroupAzureEventHubOptions.verify(message.azureEventHub);
                    if (error)
                        return "azureEventHub." + error;
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    var error = $root.protos.opts.DynamicGroupGCPPubSubOptions.verify(message.gcpPubsub);
                    if (error)
                        return "gcpPubsub." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    var error = $root.protos.opts.DynamicGroupKubeMQQueueOptions.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    var error = $root.protos.opts.DynamicGroupRedisPubSubOptions.verify(message.redisPubsub);
                    if (error)
                        return "redisPubsub." + error;
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    var error = $root.protos.opts.DynamicGroupRedisStreamsOptions.verify(message.redisStreams);
                    if (error)
                        return "redisStreams." + error;
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    var error = $root.protos.opts.DynamicGroupPulsarOptions.verify(message.pulsar);
                    if (error)
                        return "pulsar." + error;
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    var error = $root.protos.opts.DynamicGroupRabbitStreamsOptions.verify(message.rabbitStreams);
                    if (error)
                        return "rabbitStreams." + error;
                }
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream")) {
                    var error = $root.protos.opts.DynamicGroupNatsJetstreamOptions.verify(message.natsJetstream);
                    if (error)
                        return "natsJetstream." + error;
                }
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis")) {
                    var error = $root.protos.opts.DynamicGroupAWSKinesisOptions.verify(message.awsKinesis);
                    if (error)
                        return "awsKinesis." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicOptions} DynamicOptions
             */
            DynamicOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicOptions)
                    return object;
                var message = new $root.protos.opts.DynamicOptions();
                if (object.apiToken != null)
                    message.apiToken = String(object.apiToken);
                if (object.connectionId != null)
                    message.connectionId = String(object.connectionId);
                if (object._grpcAddress != null)
                    message._grpcAddress = String(object._grpcAddress);
                if (object._grpcTimeoutSeconds != null)
                    message._grpcTimeoutSeconds = object._grpcTimeoutSeconds >>> 0;
                if (object._grpcInsecure != null)
                    message._grpcInsecure = Boolean(object._grpcInsecure);
                if (object._dynamicId != null)
                    message._dynamicId = String(object._dynamicId);
                if (object._active != null)
                    message._active = Boolean(object._active);
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.kafka: object expected");
                    message.kafka = $root.protos.opts.DynamicGroupKafkaOptions.fromObject(object.kafka);
                }
                if (object.activemq != null) {
                    if (typeof object.activemq !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.activemq: object expected");
                    message.activemq = $root.protos.opts.DynamicGroupActiveMQOptions.fromObject(object.activemq);
                }
                if (object.awsSqs != null) {
                    if (typeof object.awsSqs !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.awsSqs: object expected");
                    message.awsSqs = $root.protos.opts.DynamicGroupAWSSQSOptions.fromObject(object.awsSqs);
                }
                if (object.awsSns != null) {
                    if (typeof object.awsSns !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.awsSns: object expected");
                    message.awsSns = $root.protos.opts.DynamicGroupAWSSNSOptions.fromObject(object.awsSns);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.nats: object expected");
                    message.nats = $root.protos.opts.DynamicGroupNatsOptions.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.opts.DynamicGroupNatsStreamingOptions.fromObject(object.natsStreaming);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.nsq: object expected");
                    message.nsq = $root.protos.opts.DynamicGroupNSQOptions.fromObject(object.nsq);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.rabbit: object expected");
                    message.rabbit = $root.protos.opts.DynamicGroupRabbitOptions.fromObject(object.rabbit);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.mqtt: object expected");
                    message.mqtt = $root.protos.opts.DynamicGroupMQTTOptions.fromObject(object.mqtt);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.opts.DynamicGroupAzureServiceBusOptions.fromObject(object.azureServiceBus);
                }
                if (object.azureEventHub != null) {
                    if (typeof object.azureEventHub !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.azureEventHub: object expected");
                    message.azureEventHub = $root.protos.opts.DynamicGroupAzureEventHubOptions.fromObject(object.azureEventHub);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.opts.DynamicGroupGCPPubSubOptions.fromObject(object.gcpPubsub);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.opts.DynamicGroupKubeMQQueueOptions.fromObject(object.kubemqQueue);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.opts.DynamicGroupRedisPubSubOptions.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.opts.DynamicGroupRedisStreamsOptions.fromObject(object.redisStreams);
                }
                if (object.pulsar != null) {
                    if (typeof object.pulsar !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.pulsar: object expected");
                    message.pulsar = $root.protos.opts.DynamicGroupPulsarOptions.fromObject(object.pulsar);
                }
                if (object.rabbitStreams != null) {
                    if (typeof object.rabbitStreams !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.rabbitStreams: object expected");
                    message.rabbitStreams = $root.protos.opts.DynamicGroupRabbitStreamsOptions.fromObject(object.rabbitStreams);
                }
                if (object.natsJetstream != null) {
                    if (typeof object.natsJetstream !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.natsJetstream: object expected");
                    message.natsJetstream = $root.protos.opts.DynamicGroupNatsJetstreamOptions.fromObject(object.natsJetstream);
                }
                if (object.awsKinesis != null) {
                    if (typeof object.awsKinesis !== "object")
                        throw TypeError(".protos.opts.DynamicOptions.awsKinesis: object expected");
                    message.awsKinesis = $root.protos.opts.DynamicGroupAWSKinesisOptions.fromObject(object.awsKinesis);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicOptions
             * @static
             * @param {protos.opts.DynamicOptions} message DynamicOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.apiToken = "";
                    object.connectionId = "";
                    object._grpcAddress = "";
                    object._grpcTimeoutSeconds = 0;
                    object._grpcInsecure = false;
                    object.kafka = null;
                    object.activemq = null;
                    object.awsSqs = null;
                    object.awsSns = null;
                    object.nats = null;
                    object.natsStreaming = null;
                    object.nsq = null;
                    object.rabbit = null;
                    object.mqtt = null;
                    object.azureServiceBus = null;
                    object.azureEventHub = null;
                    object.gcpPubsub = null;
                    object.kubemqQueue = null;
                    object.redisPubsub = null;
                    object.redisStreams = null;
                    object.pulsar = null;
                    object.rabbitStreams = null;
                    object.natsJetstream = null;
                    object.awsKinesis = null;
                    object._dynamicId = "";
                    object._active = false;
                }
                if (message.apiToken != null && message.hasOwnProperty("apiToken"))
                    object.apiToken = message.apiToken;
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    object.connectionId = message.connectionId;
                if (message._grpcAddress != null && message.hasOwnProperty("_grpcAddress"))
                    object._grpcAddress = message._grpcAddress;
                if (message._grpcTimeoutSeconds != null && message.hasOwnProperty("_grpcTimeoutSeconds"))
                    object._grpcTimeoutSeconds = message._grpcTimeoutSeconds;
                if (message._grpcInsecure != null && message.hasOwnProperty("_grpcInsecure"))
                    object._grpcInsecure = message._grpcInsecure;
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.opts.DynamicGroupKafkaOptions.toObject(message.kafka, options);
                if (message.activemq != null && message.hasOwnProperty("activemq"))
                    object.activemq = $root.protos.opts.DynamicGroupActiveMQOptions.toObject(message.activemq, options);
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs"))
                    object.awsSqs = $root.protos.opts.DynamicGroupAWSSQSOptions.toObject(message.awsSqs, options);
                if (message.awsSns != null && message.hasOwnProperty("awsSns"))
                    object.awsSns = $root.protos.opts.DynamicGroupAWSSNSOptions.toObject(message.awsSns, options);
                if (message.nats != null && message.hasOwnProperty("nats"))
                    object.nats = $root.protos.opts.DynamicGroupNatsOptions.toObject(message.nats, options);
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming"))
                    object.natsStreaming = $root.protos.opts.DynamicGroupNatsStreamingOptions.toObject(message.natsStreaming, options);
                if (message.nsq != null && message.hasOwnProperty("nsq"))
                    object.nsq = $root.protos.opts.DynamicGroupNSQOptions.toObject(message.nsq, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.opts.DynamicGroupRabbitOptions.toObject(message.rabbit, options);
                if (message.mqtt != null && message.hasOwnProperty("mqtt"))
                    object.mqtt = $root.protos.opts.DynamicGroupMQTTOptions.toObject(message.mqtt, options);
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus"))
                    object.azureServiceBus = $root.protos.opts.DynamicGroupAzureServiceBusOptions.toObject(message.azureServiceBus, options);
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub"))
                    object.azureEventHub = $root.protos.opts.DynamicGroupAzureEventHubOptions.toObject(message.azureEventHub, options);
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub"))
                    object.gcpPubsub = $root.protos.opts.DynamicGroupGCPPubSubOptions.toObject(message.gcpPubsub, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.opts.DynamicGroupKubeMQQueueOptions.toObject(message.kubemqQueue, options);
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub"))
                    object.redisPubsub = $root.protos.opts.DynamicGroupRedisPubSubOptions.toObject(message.redisPubsub, options);
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams"))
                    object.redisStreams = $root.protos.opts.DynamicGroupRedisStreamsOptions.toObject(message.redisStreams, options);
                if (message.pulsar != null && message.hasOwnProperty("pulsar"))
                    object.pulsar = $root.protos.opts.DynamicGroupPulsarOptions.toObject(message.pulsar, options);
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams"))
                    object.rabbitStreams = $root.protos.opts.DynamicGroupRabbitStreamsOptions.toObject(message.rabbitStreams, options);
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream"))
                    object.natsJetstream = $root.protos.opts.DynamicGroupNatsJetstreamOptions.toObject(message.natsJetstream, options);
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis"))
                    object.awsKinesis = $root.protos.opts.DynamicGroupAWSKinesisOptions.toObject(message.awsKinesis, options);
                if (message._dynamicId != null && message.hasOwnProperty("_dynamicId"))
                    object._dynamicId = message._dynamicId;
                if (message._active != null && message.hasOwnProperty("_active"))
                    object._active = message._active;
                return object;
            };

            /**
             * Converts this DynamicOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicOptions;
        })();

        opts.DynamicGroupKafkaOptions = (function() {

            /**
             * Properties of a DynamicGroupKafkaOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupKafkaOptions
             * @property {protos.args.IKafkaConn|null} [_conn] DynamicGroupKafkaOptions _conn
             * @property {protos.args.IKafkaWriteArgs|null} [args] DynamicGroupKafkaOptions args
             */

            /**
             * Constructs a new DynamicGroupKafkaOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupKafkaOptions.
             * @implements IDynamicGroupKafkaOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupKafkaOptions=} [properties] Properties to set
             */
            function DynamicGroupKafkaOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupKafkaOptions _conn.
             * @member {protos.args.IKafkaConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @instance
             */
            DynamicGroupKafkaOptions.prototype._conn = null;

            /**
             * DynamicGroupKafkaOptions args.
             * @member {protos.args.IKafkaWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @instance
             */
            DynamicGroupKafkaOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupKafkaOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {protos.opts.IDynamicGroupKafkaOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupKafkaOptions} DynamicGroupKafkaOptions instance
             */
            DynamicGroupKafkaOptions.create = function create(properties) {
                return new DynamicGroupKafkaOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupKafkaOptions message. Does not implicitly {@link protos.opts.DynamicGroupKafkaOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {protos.opts.IDynamicGroupKafkaOptions} message DynamicGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupKafkaOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KafkaConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KafkaWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupKafkaOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupKafkaOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {protos.opts.IDynamicGroupKafkaOptions} message DynamicGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupKafkaOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupKafkaOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupKafkaOptions} DynamicGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupKafkaOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupKafkaOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KafkaConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KafkaWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupKafkaOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupKafkaOptions} DynamicGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupKafkaOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupKafkaOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupKafkaOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KafkaConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KafkaWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupKafkaOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupKafkaOptions} DynamicGroupKafkaOptions
             */
            DynamicGroupKafkaOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupKafkaOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupKafkaOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupKafkaOptions._conn: object expected");
                    message._conn = $root.protos.args.KafkaConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupKafkaOptions.args: object expected");
                    message.args = $root.protos.args.KafkaWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupKafkaOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @static
             * @param {protos.opts.DynamicGroupKafkaOptions} message DynamicGroupKafkaOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupKafkaOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KafkaConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KafkaWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupKafkaOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupKafkaOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupKafkaOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupKafkaOptions;
        })();

        opts.DynamicGroupActiveMQOptions = (function() {

            /**
             * Properties of a DynamicGroupActiveMQOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupActiveMQOptions
             * @property {protos.args.IActiveMQConn|null} [_conn] DynamicGroupActiveMQOptions _conn
             * @property {protos.args.IActiveMQWriteArgs|null} [args] DynamicGroupActiveMQOptions args
             */

            /**
             * Constructs a new DynamicGroupActiveMQOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupActiveMQOptions.
             * @implements IDynamicGroupActiveMQOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupActiveMQOptions=} [properties] Properties to set
             */
            function DynamicGroupActiveMQOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupActiveMQOptions _conn.
             * @member {protos.args.IActiveMQConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @instance
             */
            DynamicGroupActiveMQOptions.prototype._conn = null;

            /**
             * DynamicGroupActiveMQOptions args.
             * @member {protos.args.IActiveMQWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @instance
             */
            DynamicGroupActiveMQOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupActiveMQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {protos.opts.IDynamicGroupActiveMQOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupActiveMQOptions} DynamicGroupActiveMQOptions instance
             */
            DynamicGroupActiveMQOptions.create = function create(properties) {
                return new DynamicGroupActiveMQOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupActiveMQOptions message. Does not implicitly {@link protos.opts.DynamicGroupActiveMQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {protos.opts.IDynamicGroupActiveMQOptions} message DynamicGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupActiveMQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.ActiveMQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.ActiveMQWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupActiveMQOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupActiveMQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {protos.opts.IDynamicGroupActiveMQOptions} message DynamicGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupActiveMQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupActiveMQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupActiveMQOptions} DynamicGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupActiveMQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupActiveMQOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.ActiveMQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.ActiveMQWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupActiveMQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupActiveMQOptions} DynamicGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupActiveMQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupActiveMQOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupActiveMQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.ActiveMQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.ActiveMQWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupActiveMQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupActiveMQOptions} DynamicGroupActiveMQOptions
             */
            DynamicGroupActiveMQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupActiveMQOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupActiveMQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupActiveMQOptions._conn: object expected");
                    message._conn = $root.protos.args.ActiveMQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupActiveMQOptions.args: object expected");
                    message.args = $root.protos.args.ActiveMQWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupActiveMQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @static
             * @param {protos.opts.DynamicGroupActiveMQOptions} message DynamicGroupActiveMQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupActiveMQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.ActiveMQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.ActiveMQWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupActiveMQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupActiveMQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupActiveMQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupActiveMQOptions;
        })();

        opts.DynamicGroupAWSSQSOptions = (function() {

            /**
             * Properties of a DynamicGroupAWSSQSOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupAWSSQSOptions
             * @property {protos.args.IAWSSQSConn|null} [_conn] DynamicGroupAWSSQSOptions _conn
             * @property {protos.args.IAWSSQSWriteArgs|null} [args] DynamicGroupAWSSQSOptions args
             */

            /**
             * Constructs a new DynamicGroupAWSSQSOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupAWSSQSOptions.
             * @implements IDynamicGroupAWSSQSOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupAWSSQSOptions=} [properties] Properties to set
             */
            function DynamicGroupAWSSQSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupAWSSQSOptions _conn.
             * @member {protos.args.IAWSSQSConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @instance
             */
            DynamicGroupAWSSQSOptions.prototype._conn = null;

            /**
             * DynamicGroupAWSSQSOptions args.
             * @member {protos.args.IAWSSQSWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @instance
             */
            DynamicGroupAWSSQSOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupAWSSQSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IDynamicGroupAWSSQSOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupAWSSQSOptions} DynamicGroupAWSSQSOptions instance
             */
            DynamicGroupAWSSQSOptions.create = function create(properties) {
                return new DynamicGroupAWSSQSOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupAWSSQSOptions message. Does not implicitly {@link protos.opts.DynamicGroupAWSSQSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IDynamicGroupAWSSQSOptions} message DynamicGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAWSSQSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSQSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSQSWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupAWSSQSOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupAWSSQSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IDynamicGroupAWSSQSOptions} message DynamicGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAWSSQSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupAWSSQSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupAWSSQSOptions} DynamicGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAWSSQSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupAWSSQSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSQSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSQSWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupAWSSQSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupAWSSQSOptions} DynamicGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAWSSQSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupAWSSQSOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupAWSSQSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSSQSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSSQSWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupAWSSQSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupAWSSQSOptions} DynamicGroupAWSSQSOptions
             */
            DynamicGroupAWSSQSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupAWSSQSOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupAWSSQSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAWSSQSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSQSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAWSSQSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSQSWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupAWSSQSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @static
             * @param {protos.opts.DynamicGroupAWSSQSOptions} message DynamicGroupAWSSQSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupAWSSQSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSQSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSQSWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupAWSSQSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupAWSSQSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupAWSSQSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupAWSSQSOptions;
        })();

        opts.DynamicGroupAWSSNSOptions = (function() {

            /**
             * Properties of a DynamicGroupAWSSNSOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupAWSSNSOptions
             * @property {protos.args.IAWSSNSConn|null} [_conn] DynamicGroupAWSSNSOptions _conn
             * @property {protos.args.IAWSSNSWriteArgs|null} [args] DynamicGroupAWSSNSOptions args
             */

            /**
             * Constructs a new DynamicGroupAWSSNSOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupAWSSNSOptions.
             * @implements IDynamicGroupAWSSNSOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupAWSSNSOptions=} [properties] Properties to set
             */
            function DynamicGroupAWSSNSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupAWSSNSOptions _conn.
             * @member {protos.args.IAWSSNSConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @instance
             */
            DynamicGroupAWSSNSOptions.prototype._conn = null;

            /**
             * DynamicGroupAWSSNSOptions args.
             * @member {protos.args.IAWSSNSWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @instance
             */
            DynamicGroupAWSSNSOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupAWSSNSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {protos.opts.IDynamicGroupAWSSNSOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupAWSSNSOptions} DynamicGroupAWSSNSOptions instance
             */
            DynamicGroupAWSSNSOptions.create = function create(properties) {
                return new DynamicGroupAWSSNSOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupAWSSNSOptions message. Does not implicitly {@link protos.opts.DynamicGroupAWSSNSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {protos.opts.IDynamicGroupAWSSNSOptions} message DynamicGroupAWSSNSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAWSSNSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSNSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSNSWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupAWSSNSOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupAWSSNSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {protos.opts.IDynamicGroupAWSSNSOptions} message DynamicGroupAWSSNSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAWSSNSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupAWSSNSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupAWSSNSOptions} DynamicGroupAWSSNSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAWSSNSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupAWSSNSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSNSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSNSWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupAWSSNSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupAWSSNSOptions} DynamicGroupAWSSNSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAWSSNSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupAWSSNSOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupAWSSNSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSSNSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSSNSWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupAWSSNSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupAWSSNSOptions} DynamicGroupAWSSNSOptions
             */
            DynamicGroupAWSSNSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupAWSSNSOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupAWSSNSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAWSSNSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSNSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAWSSNSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSNSWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupAWSSNSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @static
             * @param {protos.opts.DynamicGroupAWSSNSOptions} message DynamicGroupAWSSNSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupAWSSNSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSNSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSNSWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupAWSSNSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupAWSSNSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupAWSSNSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupAWSSNSOptions;
        })();

        opts.DynamicGroupNatsOptions = (function() {

            /**
             * Properties of a DynamicGroupNatsOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupNatsOptions
             * @property {protos.args.INatsConn|null} [_conn] DynamicGroupNatsOptions _conn
             * @property {protos.args.INatsWriteArgs|null} [args] DynamicGroupNatsOptions args
             */

            /**
             * Constructs a new DynamicGroupNatsOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupNatsOptions.
             * @implements IDynamicGroupNatsOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupNatsOptions=} [properties] Properties to set
             */
            function DynamicGroupNatsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupNatsOptions _conn.
             * @member {protos.args.INatsConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @instance
             */
            DynamicGroupNatsOptions.prototype._conn = null;

            /**
             * DynamicGroupNatsOptions args.
             * @member {protos.args.INatsWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @instance
             */
            DynamicGroupNatsOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupNatsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {protos.opts.IDynamicGroupNatsOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupNatsOptions} DynamicGroupNatsOptions instance
             */
            DynamicGroupNatsOptions.create = function create(properties) {
                return new DynamicGroupNatsOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupNatsOptions message. Does not implicitly {@link protos.opts.DynamicGroupNatsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {protos.opts.IDynamicGroupNatsOptions} message DynamicGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupNatsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupNatsOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupNatsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {protos.opts.IDynamicGroupNatsOptions} message DynamicGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupNatsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupNatsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupNatsOptions} DynamicGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupNatsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupNatsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupNatsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupNatsOptions} DynamicGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupNatsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupNatsOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupNatsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupNatsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupNatsOptions} DynamicGroupNatsOptions
             */
            DynamicGroupNatsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupNatsOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupNatsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupNatsOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupNatsOptions.args: object expected");
                    message.args = $root.protos.args.NatsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupNatsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @static
             * @param {protos.opts.DynamicGroupNatsOptions} message DynamicGroupNatsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupNatsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupNatsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupNatsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupNatsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupNatsOptions;
        })();

        opts.DynamicGroupNatsJetstreamOptions = (function() {

            /**
             * Properties of a DynamicGroupNatsJetstreamOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupNatsJetstreamOptions
             * @property {protos.args.INatsJetstreamConn|null} [_conn] DynamicGroupNatsJetstreamOptions _conn
             * @property {protos.args.INatsJetstreamWriteArgs|null} [args] DynamicGroupNatsJetstreamOptions args
             */

            /**
             * Constructs a new DynamicGroupNatsJetstreamOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupNatsJetstreamOptions.
             * @implements IDynamicGroupNatsJetstreamOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupNatsJetstreamOptions=} [properties] Properties to set
             */
            function DynamicGroupNatsJetstreamOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupNatsJetstreamOptions _conn.
             * @member {protos.args.INatsJetstreamConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupNatsJetstreamOptions
             * @instance
             */
            DynamicGroupNatsJetstreamOptions.prototype._conn = null;

            /**
             * DynamicGroupNatsJetstreamOptions args.
             * @member {protos.args.INatsJetstreamWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupNatsJetstreamOptions
             * @instance
             */
            DynamicGroupNatsJetstreamOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupNatsJetstreamOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.IDynamicGroupNatsJetstreamOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupNatsJetstreamOptions} DynamicGroupNatsJetstreamOptions instance
             */
            DynamicGroupNatsJetstreamOptions.create = function create(properties) {
                return new DynamicGroupNatsJetstreamOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupNatsJetstreamOptions message. Does not implicitly {@link protos.opts.DynamicGroupNatsJetstreamOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.IDynamicGroupNatsJetstreamOptions} message DynamicGroupNatsJetstreamOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupNatsJetstreamOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsJetstreamConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsJetstreamWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupNatsJetstreamOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupNatsJetstreamOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.IDynamicGroupNatsJetstreamOptions} message DynamicGroupNatsJetstreamOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupNatsJetstreamOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupNatsJetstreamOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupNatsJetstreamOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupNatsJetstreamOptions} DynamicGroupNatsJetstreamOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupNatsJetstreamOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupNatsJetstreamOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsJetstreamConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsJetstreamWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupNatsJetstreamOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupNatsJetstreamOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupNatsJetstreamOptions} DynamicGroupNatsJetstreamOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupNatsJetstreamOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupNatsJetstreamOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupNatsJetstreamOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupNatsJetstreamOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsJetstreamConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsJetstreamWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupNatsJetstreamOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupNatsJetstreamOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupNatsJetstreamOptions} DynamicGroupNatsJetstreamOptions
             */
            DynamicGroupNatsJetstreamOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupNatsJetstreamOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupNatsJetstreamOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupNatsJetstreamOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsJetstreamConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupNatsJetstreamOptions.args: object expected");
                    message.args = $root.protos.args.NatsJetstreamWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupNatsJetstreamOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.DynamicGroupNatsJetstreamOptions} message DynamicGroupNatsJetstreamOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupNatsJetstreamOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsJetstreamConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsJetstreamWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupNatsJetstreamOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupNatsJetstreamOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupNatsJetstreamOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupNatsJetstreamOptions;
        })();

        opts.DynamicGroupNatsStreamingOptions = (function() {

            /**
             * Properties of a DynamicGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupNatsStreamingOptions
             * @property {protos.args.INatsStreamingConn|null} [_conn] DynamicGroupNatsStreamingOptions _conn
             * @property {protos.args.INatsStreamingWriteArgs|null} [args] DynamicGroupNatsStreamingOptions args
             */

            /**
             * Constructs a new DynamicGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupNatsStreamingOptions.
             * @implements IDynamicGroupNatsStreamingOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupNatsStreamingOptions=} [properties] Properties to set
             */
            function DynamicGroupNatsStreamingOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupNatsStreamingOptions _conn.
             * @member {protos.args.INatsStreamingConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @instance
             */
            DynamicGroupNatsStreamingOptions.prototype._conn = null;

            /**
             * DynamicGroupNatsStreamingOptions args.
             * @member {protos.args.INatsStreamingWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @instance
             */
            DynamicGroupNatsStreamingOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupNatsStreamingOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IDynamicGroupNatsStreamingOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupNatsStreamingOptions} DynamicGroupNatsStreamingOptions instance
             */
            DynamicGroupNatsStreamingOptions.create = function create(properties) {
                return new DynamicGroupNatsStreamingOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupNatsStreamingOptions message. Does not implicitly {@link protos.opts.DynamicGroupNatsStreamingOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IDynamicGroupNatsStreamingOptions} message DynamicGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupNatsStreamingOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsStreamingConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsStreamingWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupNatsStreamingOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupNatsStreamingOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IDynamicGroupNatsStreamingOptions} message DynamicGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupNatsStreamingOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupNatsStreamingOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupNatsStreamingOptions} DynamicGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupNatsStreamingOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupNatsStreamingOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsStreamingConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsStreamingWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupNatsStreamingOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupNatsStreamingOptions} DynamicGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupNatsStreamingOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupNatsStreamingOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupNatsStreamingOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsStreamingConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsStreamingWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupNatsStreamingOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupNatsStreamingOptions} DynamicGroupNatsStreamingOptions
             */
            DynamicGroupNatsStreamingOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupNatsStreamingOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupNatsStreamingOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupNatsStreamingOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsStreamingConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupNatsStreamingOptions.args: object expected");
                    message.args = $root.protos.args.NatsStreamingWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupNatsStreamingOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.DynamicGroupNatsStreamingOptions} message DynamicGroupNatsStreamingOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupNatsStreamingOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsStreamingConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsStreamingWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupNatsStreamingOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupNatsStreamingOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupNatsStreamingOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupNatsStreamingOptions;
        })();

        opts.DynamicGroupNSQOptions = (function() {

            /**
             * Properties of a DynamicGroupNSQOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupNSQOptions
             * @property {protos.args.INSQConn|null} [_conn] DynamicGroupNSQOptions _conn
             * @property {protos.args.INSQWriteArgs|null} [args] DynamicGroupNSQOptions args
             */

            /**
             * Constructs a new DynamicGroupNSQOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupNSQOptions.
             * @implements IDynamicGroupNSQOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupNSQOptions=} [properties] Properties to set
             */
            function DynamicGroupNSQOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupNSQOptions _conn.
             * @member {protos.args.INSQConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @instance
             */
            DynamicGroupNSQOptions.prototype._conn = null;

            /**
             * DynamicGroupNSQOptions args.
             * @member {protos.args.INSQWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @instance
             */
            DynamicGroupNSQOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupNSQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {protos.opts.IDynamicGroupNSQOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupNSQOptions} DynamicGroupNSQOptions instance
             */
            DynamicGroupNSQOptions.create = function create(properties) {
                return new DynamicGroupNSQOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupNSQOptions message. Does not implicitly {@link protos.opts.DynamicGroupNSQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {protos.opts.IDynamicGroupNSQOptions} message DynamicGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupNSQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NSQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NSQWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupNSQOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupNSQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {protos.opts.IDynamicGroupNSQOptions} message DynamicGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupNSQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupNSQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupNSQOptions} DynamicGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupNSQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupNSQOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NSQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NSQWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupNSQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupNSQOptions} DynamicGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupNSQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupNSQOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupNSQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NSQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NSQWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupNSQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupNSQOptions} DynamicGroupNSQOptions
             */
            DynamicGroupNSQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupNSQOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupNSQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupNSQOptions._conn: object expected");
                    message._conn = $root.protos.args.NSQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupNSQOptions.args: object expected");
                    message.args = $root.protos.args.NSQWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupNSQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @static
             * @param {protos.opts.DynamicGroupNSQOptions} message DynamicGroupNSQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupNSQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NSQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NSQWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupNSQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupNSQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupNSQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupNSQOptions;
        })();

        opts.DynamicGroupRabbitOptions = (function() {

            /**
             * Properties of a DynamicGroupRabbitOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupRabbitOptions
             * @property {protos.args.IRabbitConn|null} [_conn] DynamicGroupRabbitOptions _conn
             * @property {protos.args.IRabbitWriteArgs|null} [args] DynamicGroupRabbitOptions args
             */

            /**
             * Constructs a new DynamicGroupRabbitOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupRabbitOptions.
             * @implements IDynamicGroupRabbitOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupRabbitOptions=} [properties] Properties to set
             */
            function DynamicGroupRabbitOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupRabbitOptions _conn.
             * @member {protos.args.IRabbitConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @instance
             */
            DynamicGroupRabbitOptions.prototype._conn = null;

            /**
             * DynamicGroupRabbitOptions args.
             * @member {protos.args.IRabbitWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @instance
             */
            DynamicGroupRabbitOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupRabbitOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {protos.opts.IDynamicGroupRabbitOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupRabbitOptions} DynamicGroupRabbitOptions instance
             */
            DynamicGroupRabbitOptions.create = function create(properties) {
                return new DynamicGroupRabbitOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupRabbitOptions message. Does not implicitly {@link protos.opts.DynamicGroupRabbitOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {protos.opts.IDynamicGroupRabbitOptions} message DynamicGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRabbitOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupRabbitOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupRabbitOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {protos.opts.IDynamicGroupRabbitOptions} message DynamicGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRabbitOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupRabbitOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupRabbitOptions} DynamicGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRabbitOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupRabbitOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupRabbitOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupRabbitOptions} DynamicGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRabbitOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupRabbitOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupRabbitOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RabbitConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RabbitWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupRabbitOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupRabbitOptions} DynamicGroupRabbitOptions
             */
            DynamicGroupRabbitOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupRabbitOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupRabbitOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRabbitOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRabbitOptions.args: object expected");
                    message.args = $root.protos.args.RabbitWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupRabbitOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @static
             * @param {protos.opts.DynamicGroupRabbitOptions} message DynamicGroupRabbitOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupRabbitOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupRabbitOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupRabbitOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupRabbitOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupRabbitOptions;
        })();

        opts.DynamicGroupRabbitStreamsOptions = (function() {

            /**
             * Properties of a DynamicGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupRabbitStreamsOptions
             * @property {protos.args.IRabbitStreamsConn|null} [_conn] DynamicGroupRabbitStreamsOptions _conn
             * @property {protos.args.IRabbitStreamsWriteArgs|null} [args] DynamicGroupRabbitStreamsOptions args
             */

            /**
             * Constructs a new DynamicGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupRabbitStreamsOptions.
             * @implements IDynamicGroupRabbitStreamsOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupRabbitStreamsOptions=} [properties] Properties to set
             */
            function DynamicGroupRabbitStreamsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupRabbitStreamsOptions _conn.
             * @member {protos.args.IRabbitStreamsConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @instance
             */
            DynamicGroupRabbitStreamsOptions.prototype._conn = null;

            /**
             * DynamicGroupRabbitStreamsOptions args.
             * @member {protos.args.IRabbitStreamsWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @instance
             */
            DynamicGroupRabbitStreamsOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupRabbitStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IDynamicGroupRabbitStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupRabbitStreamsOptions} DynamicGroupRabbitStreamsOptions instance
             */
            DynamicGroupRabbitStreamsOptions.create = function create(properties) {
                return new DynamicGroupRabbitStreamsOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupRabbitStreamsOptions message. Does not implicitly {@link protos.opts.DynamicGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IDynamicGroupRabbitStreamsOptions} message DynamicGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRabbitStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitStreamsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupRabbitStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IDynamicGroupRabbitStreamsOptions} message DynamicGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRabbitStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupRabbitStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupRabbitStreamsOptions} DynamicGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRabbitStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupRabbitStreamsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitStreamsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupRabbitStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupRabbitStreamsOptions} DynamicGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRabbitStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupRabbitStreamsOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupRabbitStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RabbitStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RabbitStreamsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupRabbitStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupRabbitStreamsOptions} DynamicGroupRabbitStreamsOptions
             */
            DynamicGroupRabbitStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupRabbitStreamsOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupRabbitStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRabbitStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRabbitStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RabbitStreamsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupRabbitStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.DynamicGroupRabbitStreamsOptions} message DynamicGroupRabbitStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupRabbitStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitStreamsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupRabbitStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupRabbitStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupRabbitStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupRabbitStreamsOptions;
        })();

        opts.DynamicGroupRedisPubSubOptions = (function() {

            /**
             * Properties of a DynamicGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupRedisPubSubOptions
             * @property {protos.args.IRedisPubSubConn|null} [_conn] DynamicGroupRedisPubSubOptions _conn
             * @property {protos.args.IRedisPubSubWriteArgs|null} [args] DynamicGroupRedisPubSubOptions args
             */

            /**
             * Constructs a new DynamicGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupRedisPubSubOptions.
             * @implements IDynamicGroupRedisPubSubOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupRedisPubSubOptions=} [properties] Properties to set
             */
            function DynamicGroupRedisPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupRedisPubSubOptions _conn.
             * @member {protos.args.IRedisPubSubConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @instance
             */
            DynamicGroupRedisPubSubOptions.prototype._conn = null;

            /**
             * DynamicGroupRedisPubSubOptions args.
             * @member {protos.args.IRedisPubSubWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @instance
             */
            DynamicGroupRedisPubSubOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupRedisPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IDynamicGroupRedisPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupRedisPubSubOptions} DynamicGroupRedisPubSubOptions instance
             */
            DynamicGroupRedisPubSubOptions.create = function create(properties) {
                return new DynamicGroupRedisPubSubOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupRedisPubSubOptions message. Does not implicitly {@link protos.opts.DynamicGroupRedisPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IDynamicGroupRedisPubSubOptions} message DynamicGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRedisPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisPubSubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupRedisPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupRedisPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IDynamicGroupRedisPubSubOptions} message DynamicGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRedisPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupRedisPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupRedisPubSubOptions} DynamicGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRedisPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupRedisPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisPubSubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupRedisPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupRedisPubSubOptions} DynamicGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRedisPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupRedisPubSubOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupRedisPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisPubSubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupRedisPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupRedisPubSubOptions} DynamicGroupRedisPubSubOptions
             */
            DynamicGroupRedisPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupRedisPubSubOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupRedisPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRedisPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRedisPubSubOptions.args: object expected");
                    message.args = $root.protos.args.RedisPubSubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupRedisPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.DynamicGroupRedisPubSubOptions} message DynamicGroupRedisPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupRedisPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisPubSubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupRedisPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupRedisPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupRedisPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupRedisPubSubOptions;
        })();

        opts.DynamicGroupRedisStreamsOptions = (function() {

            /**
             * Properties of a DynamicGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupRedisStreamsOptions
             * @property {protos.args.IRedisStreamsConn|null} [_conn] DynamicGroupRedisStreamsOptions _conn
             * @property {protos.args.IRedisStreamsWriteArgs|null} [args] DynamicGroupRedisStreamsOptions args
             */

            /**
             * Constructs a new DynamicGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupRedisStreamsOptions.
             * @implements IDynamicGroupRedisStreamsOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupRedisStreamsOptions=} [properties] Properties to set
             */
            function DynamicGroupRedisStreamsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupRedisStreamsOptions _conn.
             * @member {protos.args.IRedisStreamsConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @instance
             */
            DynamicGroupRedisStreamsOptions.prototype._conn = null;

            /**
             * DynamicGroupRedisStreamsOptions args.
             * @member {protos.args.IRedisStreamsWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @instance
             */
            DynamicGroupRedisStreamsOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupRedisStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IDynamicGroupRedisStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupRedisStreamsOptions} DynamicGroupRedisStreamsOptions instance
             */
            DynamicGroupRedisStreamsOptions.create = function create(properties) {
                return new DynamicGroupRedisStreamsOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupRedisStreamsOptions message. Does not implicitly {@link protos.opts.DynamicGroupRedisStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IDynamicGroupRedisStreamsOptions} message DynamicGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRedisStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisStreamsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupRedisStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupRedisStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IDynamicGroupRedisStreamsOptions} message DynamicGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupRedisStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupRedisStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupRedisStreamsOptions} DynamicGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRedisStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupRedisStreamsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisStreamsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupRedisStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupRedisStreamsOptions} DynamicGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupRedisStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupRedisStreamsOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupRedisStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisStreamsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupRedisStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupRedisStreamsOptions} DynamicGroupRedisStreamsOptions
             */
            DynamicGroupRedisStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupRedisStreamsOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupRedisStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRedisStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupRedisStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RedisStreamsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupRedisStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.DynamicGroupRedisStreamsOptions} message DynamicGroupRedisStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupRedisStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisStreamsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupRedisStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupRedisStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupRedisStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupRedisStreamsOptions;
        })();

        opts.DynamicGroupAzureEventHubOptions = (function() {

            /**
             * Properties of a DynamicGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupAzureEventHubOptions
             * @property {protos.args.IAzureEventHubConn|null} [_conn] DynamicGroupAzureEventHubOptions _conn
             * @property {protos.args.IAzureEventHubWriteArgs|null} [args] DynamicGroupAzureEventHubOptions args
             */

            /**
             * Constructs a new DynamicGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupAzureEventHubOptions.
             * @implements IDynamicGroupAzureEventHubOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupAzureEventHubOptions=} [properties] Properties to set
             */
            function DynamicGroupAzureEventHubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupAzureEventHubOptions _conn.
             * @member {protos.args.IAzureEventHubConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @instance
             */
            DynamicGroupAzureEventHubOptions.prototype._conn = null;

            /**
             * DynamicGroupAzureEventHubOptions args.
             * @member {protos.args.IAzureEventHubWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @instance
             */
            DynamicGroupAzureEventHubOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupAzureEventHubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IDynamicGroupAzureEventHubOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupAzureEventHubOptions} DynamicGroupAzureEventHubOptions instance
             */
            DynamicGroupAzureEventHubOptions.create = function create(properties) {
                return new DynamicGroupAzureEventHubOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupAzureEventHubOptions message. Does not implicitly {@link protos.opts.DynamicGroupAzureEventHubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IDynamicGroupAzureEventHubOptions} message DynamicGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAzureEventHubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureEventHubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureEventHubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupAzureEventHubOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupAzureEventHubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IDynamicGroupAzureEventHubOptions} message DynamicGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAzureEventHubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupAzureEventHubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupAzureEventHubOptions} DynamicGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAzureEventHubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupAzureEventHubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureEventHubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureEventHubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupAzureEventHubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupAzureEventHubOptions} DynamicGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAzureEventHubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupAzureEventHubOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupAzureEventHubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AzureEventHubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AzureEventHubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupAzureEventHubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupAzureEventHubOptions} DynamicGroupAzureEventHubOptions
             */
            DynamicGroupAzureEventHubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupAzureEventHubOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupAzureEventHubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAzureEventHubOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureEventHubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAzureEventHubOptions.args: object expected");
                    message.args = $root.protos.args.AzureEventHubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupAzureEventHubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.DynamicGroupAzureEventHubOptions} message DynamicGroupAzureEventHubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupAzureEventHubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureEventHubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureEventHubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupAzureEventHubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupAzureEventHubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupAzureEventHubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupAzureEventHubOptions;
        })();

        opts.DynamicGroupAzureServiceBusOptions = (function() {

            /**
             * Properties of a DynamicGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupAzureServiceBusOptions
             * @property {protos.args.IAzureServiceBusConn|null} [_conn] DynamicGroupAzureServiceBusOptions _conn
             * @property {protos.args.IAzureServiceBusWriteArgs|null} [args] DynamicGroupAzureServiceBusOptions args
             */

            /**
             * Constructs a new DynamicGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupAzureServiceBusOptions.
             * @implements IDynamicGroupAzureServiceBusOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupAzureServiceBusOptions=} [properties] Properties to set
             */
            function DynamicGroupAzureServiceBusOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupAzureServiceBusOptions _conn.
             * @member {protos.args.IAzureServiceBusConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @instance
             */
            DynamicGroupAzureServiceBusOptions.prototype._conn = null;

            /**
             * DynamicGroupAzureServiceBusOptions args.
             * @member {protos.args.IAzureServiceBusWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @instance
             */
            DynamicGroupAzureServiceBusOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupAzureServiceBusOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IDynamicGroupAzureServiceBusOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupAzureServiceBusOptions} DynamicGroupAzureServiceBusOptions instance
             */
            DynamicGroupAzureServiceBusOptions.create = function create(properties) {
                return new DynamicGroupAzureServiceBusOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupAzureServiceBusOptions message. Does not implicitly {@link protos.opts.DynamicGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IDynamicGroupAzureServiceBusOptions} message DynamicGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAzureServiceBusOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureServiceBusConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureServiceBusWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupAzureServiceBusOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IDynamicGroupAzureServiceBusOptions} message DynamicGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAzureServiceBusOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupAzureServiceBusOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupAzureServiceBusOptions} DynamicGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAzureServiceBusOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupAzureServiceBusOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureServiceBusConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureServiceBusWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupAzureServiceBusOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupAzureServiceBusOptions} DynamicGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAzureServiceBusOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupAzureServiceBusOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupAzureServiceBusOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AzureServiceBusConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AzureServiceBusWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupAzureServiceBusOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupAzureServiceBusOptions} DynamicGroupAzureServiceBusOptions
             */
            DynamicGroupAzureServiceBusOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupAzureServiceBusOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupAzureServiceBusOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAzureServiceBusOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureServiceBusConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAzureServiceBusOptions.args: object expected");
                    message.args = $root.protos.args.AzureServiceBusWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupAzureServiceBusOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.DynamicGroupAzureServiceBusOptions} message DynamicGroupAzureServiceBusOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupAzureServiceBusOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureServiceBusConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureServiceBusWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupAzureServiceBusOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupAzureServiceBusOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupAzureServiceBusOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupAzureServiceBusOptions;
        })();

        opts.DynamicGroupMQTTOptions = (function() {

            /**
             * Properties of a DynamicGroupMQTTOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupMQTTOptions
             * @property {protos.args.IMQTTConn|null} [_conn] DynamicGroupMQTTOptions _conn
             * @property {protos.args.IMQTTWriteArgs|null} [args] DynamicGroupMQTTOptions args
             */

            /**
             * Constructs a new DynamicGroupMQTTOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupMQTTOptions.
             * @implements IDynamicGroupMQTTOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupMQTTOptions=} [properties] Properties to set
             */
            function DynamicGroupMQTTOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupMQTTOptions _conn.
             * @member {protos.args.IMQTTConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @instance
             */
            DynamicGroupMQTTOptions.prototype._conn = null;

            /**
             * DynamicGroupMQTTOptions args.
             * @member {protos.args.IMQTTWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @instance
             */
            DynamicGroupMQTTOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupMQTTOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {protos.opts.IDynamicGroupMQTTOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupMQTTOptions} DynamicGroupMQTTOptions instance
             */
            DynamicGroupMQTTOptions.create = function create(properties) {
                return new DynamicGroupMQTTOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupMQTTOptions message. Does not implicitly {@link protos.opts.DynamicGroupMQTTOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {protos.opts.IDynamicGroupMQTTOptions} message DynamicGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupMQTTOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MQTTConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MQTTWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupMQTTOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupMQTTOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {protos.opts.IDynamicGroupMQTTOptions} message DynamicGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupMQTTOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupMQTTOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupMQTTOptions} DynamicGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupMQTTOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupMQTTOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MQTTConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MQTTWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupMQTTOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupMQTTOptions} DynamicGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupMQTTOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupMQTTOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupMQTTOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.MQTTConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.MQTTWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupMQTTOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupMQTTOptions} DynamicGroupMQTTOptions
             */
            DynamicGroupMQTTOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupMQTTOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupMQTTOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupMQTTOptions._conn: object expected");
                    message._conn = $root.protos.args.MQTTConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupMQTTOptions.args: object expected");
                    message.args = $root.protos.args.MQTTWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupMQTTOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @static
             * @param {protos.opts.DynamicGroupMQTTOptions} message DynamicGroupMQTTOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupMQTTOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MQTTConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MQTTWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupMQTTOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupMQTTOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupMQTTOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupMQTTOptions;
        })();

        opts.DynamicGroupGCPPubSubOptions = (function() {

            /**
             * Properties of a DynamicGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupGCPPubSubOptions
             * @property {protos.args.IGCPPubSubConn|null} [_conn] DynamicGroupGCPPubSubOptions _conn
             * @property {protos.args.IGCPPubSubWriteArgs|null} [args] DynamicGroupGCPPubSubOptions args
             */

            /**
             * Constructs a new DynamicGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupGCPPubSubOptions.
             * @implements IDynamicGroupGCPPubSubOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupGCPPubSubOptions=} [properties] Properties to set
             */
            function DynamicGroupGCPPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupGCPPubSubOptions _conn.
             * @member {protos.args.IGCPPubSubConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @instance
             */
            DynamicGroupGCPPubSubOptions.prototype._conn = null;

            /**
             * DynamicGroupGCPPubSubOptions args.
             * @member {protos.args.IGCPPubSubWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @instance
             */
            DynamicGroupGCPPubSubOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupGCPPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IDynamicGroupGCPPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupGCPPubSubOptions} DynamicGroupGCPPubSubOptions instance
             */
            DynamicGroupGCPPubSubOptions.create = function create(properties) {
                return new DynamicGroupGCPPubSubOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupGCPPubSubOptions message. Does not implicitly {@link protos.opts.DynamicGroupGCPPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IDynamicGroupGCPPubSubOptions} message DynamicGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupGCPPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.GCPPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.GCPPubSubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupGCPPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupGCPPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IDynamicGroupGCPPubSubOptions} message DynamicGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupGCPPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupGCPPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupGCPPubSubOptions} DynamicGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupGCPPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupGCPPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.GCPPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.GCPPubSubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupGCPPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupGCPPubSubOptions} DynamicGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupGCPPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupGCPPubSubOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupGCPPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.GCPPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.GCPPubSubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupGCPPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupGCPPubSubOptions} DynamicGroupGCPPubSubOptions
             */
            DynamicGroupGCPPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupGCPPubSubOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupGCPPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupGCPPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.GCPPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupGCPPubSubOptions.args: object expected");
                    message.args = $root.protos.args.GCPPubSubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupGCPPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.DynamicGroupGCPPubSubOptions} message DynamicGroupGCPPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupGCPPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.GCPPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.GCPPubSubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupGCPPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupGCPPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupGCPPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupGCPPubSubOptions;
        })();

        opts.DynamicGroupKubeMQQueueOptions = (function() {

            /**
             * Properties of a DynamicGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupKubeMQQueueOptions
             * @property {protos.args.IKubeMQQueueConn|null} [_conn] DynamicGroupKubeMQQueueOptions _conn
             * @property {protos.args.IKubeMQQueueWriteArgs|null} [args] DynamicGroupKubeMQQueueOptions args
             */

            /**
             * Constructs a new DynamicGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupKubeMQQueueOptions.
             * @implements IDynamicGroupKubeMQQueueOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupKubeMQQueueOptions=} [properties] Properties to set
             */
            function DynamicGroupKubeMQQueueOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupKubeMQQueueOptions _conn.
             * @member {protos.args.IKubeMQQueueConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @instance
             */
            DynamicGroupKubeMQQueueOptions.prototype._conn = null;

            /**
             * DynamicGroupKubeMQQueueOptions args.
             * @member {protos.args.IKubeMQQueueWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @instance
             */
            DynamicGroupKubeMQQueueOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupKubeMQQueueOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IDynamicGroupKubeMQQueueOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupKubeMQQueueOptions} DynamicGroupKubeMQQueueOptions instance
             */
            DynamicGroupKubeMQQueueOptions.create = function create(properties) {
                return new DynamicGroupKubeMQQueueOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupKubeMQQueueOptions message. Does not implicitly {@link protos.opts.DynamicGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IDynamicGroupKubeMQQueueOptions} message DynamicGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupKubeMQQueueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KubeMQQueueConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KubeMQQueueWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupKubeMQQueueOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IDynamicGroupKubeMQQueueOptions} message DynamicGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupKubeMQQueueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupKubeMQQueueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupKubeMQQueueOptions} DynamicGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupKubeMQQueueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupKubeMQQueueOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KubeMQQueueConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KubeMQQueueWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupKubeMQQueueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupKubeMQQueueOptions} DynamicGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupKubeMQQueueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupKubeMQQueueOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupKubeMQQueueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KubeMQQueueConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KubeMQQueueWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupKubeMQQueueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupKubeMQQueueOptions} DynamicGroupKubeMQQueueOptions
             */
            DynamicGroupKubeMQQueueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupKubeMQQueueOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupKubeMQQueueOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupKubeMQQueueOptions._conn: object expected");
                    message._conn = $root.protos.args.KubeMQQueueConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupKubeMQQueueOptions.args: object expected");
                    message.args = $root.protos.args.KubeMQQueueWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupKubeMQQueueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.DynamicGroupKubeMQQueueOptions} message DynamicGroupKubeMQQueueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupKubeMQQueueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KubeMQQueueConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KubeMQQueueWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupKubeMQQueueOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupKubeMQQueueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupKubeMQQueueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupKubeMQQueueOptions;
        })();

        opts.DynamicGroupPulsarOptions = (function() {

            /**
             * Properties of a DynamicGroupPulsarOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupPulsarOptions
             * @property {protos.args.IPulsarConn|null} [_conn] DynamicGroupPulsarOptions _conn
             * @property {protos.args.IPulsarWriteArgs|null} [args] DynamicGroupPulsarOptions args
             */

            /**
             * Constructs a new DynamicGroupPulsarOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupPulsarOptions.
             * @implements IDynamicGroupPulsarOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupPulsarOptions=} [properties] Properties to set
             */
            function DynamicGroupPulsarOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupPulsarOptions _conn.
             * @member {protos.args.IPulsarConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupPulsarOptions
             * @instance
             */
            DynamicGroupPulsarOptions.prototype._conn = null;

            /**
             * DynamicGroupPulsarOptions args.
             * @member {protos.args.IPulsarWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupPulsarOptions
             * @instance
             */
            DynamicGroupPulsarOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupPulsarOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupPulsarOptions
             * @static
             * @param {protos.opts.IDynamicGroupPulsarOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupPulsarOptions} DynamicGroupPulsarOptions instance
             */
            DynamicGroupPulsarOptions.create = function create(properties) {
                return new DynamicGroupPulsarOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupPulsarOptions message. Does not implicitly {@link protos.opts.DynamicGroupPulsarOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupPulsarOptions
             * @static
             * @param {protos.opts.IDynamicGroupPulsarOptions} message DynamicGroupPulsarOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupPulsarOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.PulsarConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.PulsarWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupPulsarOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupPulsarOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupPulsarOptions
             * @static
             * @param {protos.opts.IDynamicGroupPulsarOptions} message DynamicGroupPulsarOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupPulsarOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupPulsarOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupPulsarOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupPulsarOptions} DynamicGroupPulsarOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupPulsarOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupPulsarOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.PulsarConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.PulsarWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupPulsarOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupPulsarOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupPulsarOptions} DynamicGroupPulsarOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupPulsarOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupPulsarOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupPulsarOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupPulsarOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.PulsarConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.PulsarWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupPulsarOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupPulsarOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupPulsarOptions} DynamicGroupPulsarOptions
             */
            DynamicGroupPulsarOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupPulsarOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupPulsarOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupPulsarOptions._conn: object expected");
                    message._conn = $root.protos.args.PulsarConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupPulsarOptions.args: object expected");
                    message.args = $root.protos.args.PulsarWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupPulsarOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupPulsarOptions
             * @static
             * @param {protos.opts.DynamicGroupPulsarOptions} message DynamicGroupPulsarOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupPulsarOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.PulsarConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.PulsarWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupPulsarOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupPulsarOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupPulsarOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupPulsarOptions;
        })();

        opts.DynamicGroupAWSKinesisOptions = (function() {

            /**
             * Properties of a DynamicGroupAWSKinesisOptions.
             * @memberof protos.opts
             * @interface IDynamicGroupAWSKinesisOptions
             * @property {protos.args.IAWSKinesisConn|null} [_conn] DynamicGroupAWSKinesisOptions _conn
             * @property {protos.args.IAWSKinesisWriteArgs|null} [args] DynamicGroupAWSKinesisOptions args
             */

            /**
             * Constructs a new DynamicGroupAWSKinesisOptions.
             * @memberof protos.opts
             * @classdesc Represents a DynamicGroupAWSKinesisOptions.
             * @implements IDynamicGroupAWSKinesisOptions
             * @constructor
             * @param {protos.opts.IDynamicGroupAWSKinesisOptions=} [properties] Properties to set
             */
            function DynamicGroupAWSKinesisOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DynamicGroupAWSKinesisOptions _conn.
             * @member {protos.args.IAWSKinesisConn|null|undefined} _conn
             * @memberof protos.opts.DynamicGroupAWSKinesisOptions
             * @instance
             */
            DynamicGroupAWSKinesisOptions.prototype._conn = null;

            /**
             * DynamicGroupAWSKinesisOptions args.
             * @member {protos.args.IAWSKinesisWriteArgs|null|undefined} args
             * @memberof protos.opts.DynamicGroupAWSKinesisOptions
             * @instance
             */
            DynamicGroupAWSKinesisOptions.prototype.args = null;

            /**
             * Creates a new DynamicGroupAWSKinesisOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.DynamicGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.IDynamicGroupAWSKinesisOptions=} [properties] Properties to set
             * @returns {protos.opts.DynamicGroupAWSKinesisOptions} DynamicGroupAWSKinesisOptions instance
             */
            DynamicGroupAWSKinesisOptions.create = function create(properties) {
                return new DynamicGroupAWSKinesisOptions(properties);
            };

            /**
             * Encodes the specified DynamicGroupAWSKinesisOptions message. Does not implicitly {@link protos.opts.DynamicGroupAWSKinesisOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.DynamicGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.IDynamicGroupAWSKinesisOptions} message DynamicGroupAWSKinesisOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAWSKinesisOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSKinesisConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSKinesisWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DynamicGroupAWSKinesisOptions message, length delimited. Does not implicitly {@link protos.opts.DynamicGroupAWSKinesisOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.DynamicGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.IDynamicGroupAWSKinesisOptions} message DynamicGroupAWSKinesisOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DynamicGroupAWSKinesisOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DynamicGroupAWSKinesisOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.DynamicGroupAWSKinesisOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.DynamicGroupAWSKinesisOptions} DynamicGroupAWSKinesisOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAWSKinesisOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.DynamicGroupAWSKinesisOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSKinesisConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSKinesisWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DynamicGroupAWSKinesisOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.DynamicGroupAWSKinesisOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.DynamicGroupAWSKinesisOptions} DynamicGroupAWSKinesisOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DynamicGroupAWSKinesisOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DynamicGroupAWSKinesisOptions message.
             * @function verify
             * @memberof protos.opts.DynamicGroupAWSKinesisOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DynamicGroupAWSKinesisOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSKinesisConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSKinesisWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a DynamicGroupAWSKinesisOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.DynamicGroupAWSKinesisOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.DynamicGroupAWSKinesisOptions} DynamicGroupAWSKinesisOptions
             */
            DynamicGroupAWSKinesisOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.DynamicGroupAWSKinesisOptions)
                    return object;
                var message = new $root.protos.opts.DynamicGroupAWSKinesisOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAWSKinesisOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSKinesisConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.DynamicGroupAWSKinesisOptions.args: object expected");
                    message.args = $root.protos.args.AWSKinesisWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a DynamicGroupAWSKinesisOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.DynamicGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.DynamicGroupAWSKinesisOptions} message DynamicGroupAWSKinesisOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DynamicGroupAWSKinesisOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSKinesisConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSKinesisWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this DynamicGroupAWSKinesisOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.DynamicGroupAWSKinesisOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DynamicGroupAWSKinesisOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DynamicGroupAWSKinesisOptions;
        })();

        opts.RelayCLIOptions = (function() {

            /**
             * Properties of a RelayCLIOptions.
             * @memberof protos.opts
             * @interface IRelayCLIOptions
             * @property {string|null} [httpListenAddress] RelayCLIOptions httpListenAddress
             */

            /**
             * Constructs a new RelayCLIOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayCLIOptions.
             * @implements IRelayCLIOptions
             * @constructor
             * @param {protos.opts.IRelayCLIOptions=} [properties] Properties to set
             */
            function RelayCLIOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayCLIOptions httpListenAddress.
             * @member {string} httpListenAddress
             * @memberof protos.opts.RelayCLIOptions
             * @instance
             */
            RelayCLIOptions.prototype.httpListenAddress = "";

            /**
             * Creates a new RelayCLIOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {protos.opts.IRelayCLIOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayCLIOptions} RelayCLIOptions instance
             */
            RelayCLIOptions.create = function create(properties) {
                return new RelayCLIOptions(properties);
            };

            /**
             * Encodes the specified RelayCLIOptions message. Does not implicitly {@link protos.opts.RelayCLIOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {protos.opts.IRelayCLIOptions} message RelayCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayCLIOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.httpListenAddress != null && Object.hasOwnProperty.call(message, "httpListenAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.httpListenAddress);
                return writer;
            };

            /**
             * Encodes the specified RelayCLIOptions message, length delimited. Does not implicitly {@link protos.opts.RelayCLIOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {protos.opts.IRelayCLIOptions} message RelayCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayCLIOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayCLIOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayCLIOptions} RelayCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayCLIOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayCLIOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.httpListenAddress = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayCLIOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayCLIOptions} RelayCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayCLIOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayCLIOptions message.
             * @function verify
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayCLIOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.httpListenAddress != null && message.hasOwnProperty("httpListenAddress"))
                    if (!$util.isString(message.httpListenAddress))
                        return "httpListenAddress: string expected";
                return null;
            };

            /**
             * Creates a RelayCLIOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayCLIOptions} RelayCLIOptions
             */
            RelayCLIOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayCLIOptions)
                    return object;
                var message = new $root.protos.opts.RelayCLIOptions();
                if (object.httpListenAddress != null)
                    message.httpListenAddress = String(object.httpListenAddress);
                return message;
            };

            /**
             * Creates a plain object from a RelayCLIOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayCLIOptions
             * @static
             * @param {protos.opts.RelayCLIOptions} message RelayCLIOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayCLIOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.httpListenAddress = "";
                if (message.httpListenAddress != null && message.hasOwnProperty("httpListenAddress"))
                    object.httpListenAddress = message.httpListenAddress;
                return object;
            };

            /**
             * Converts this RelayCLIOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayCLIOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayCLIOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayCLIOptions;
        })();

        opts.RelayOptions = (function() {

            /**
             * Properties of a RelayOptions.
             * @memberof protos.opts
             * @interface IRelayOptions
             * @property {string|null} [collectionToken] RelayOptions collectionToken
             * @property {number|null} [batchSize] RelayOptions batchSize
             * @property {number|null} [batchMaxRetry] RelayOptions batchMaxRetry
             * @property {string|null} [connectionId] RelayOptions connectionId
             * @property {number|null} [numWorkers] RelayOptions numWorkers
             * @property {boolean|null} [statsEnable] RelayOptions statsEnable
             * @property {number|null} [statsReportIntervalSec] RelayOptions statsReportIntervalSec
             * @property {string|null} [_batchshGrpcAddress] RelayOptions _batchshGrpcAddress
             * @property {boolean|null} [_batchshGrpcDisableTls] RelayOptions _batchshGrpcDisableTls
             * @property {number|null} [_batchshGrpcTimeoutSeconds] RelayOptions _batchshGrpcTimeoutSeconds
             * @property {string|null} [_relayId] RelayOptions _relayId
             * @property {protos.opts.IRelayCLIOptions|null} [_cliOptions] RelayOptions _cliOptions
             * @property {boolean|null} [_active] RelayOptions _active
             * @property {protos.opts.IRelayGroupKafkaOptions|null} [kafka] RelayOptions kafka
             * @property {protos.opts.IRelayGroupAWSSQSOptions|null} [awsSqs] RelayOptions awsSqs
             * @property {protos.opts.IRelayGroupMongoOptions|null} [mongo] RelayOptions mongo
             * @property {protos.opts.IRelayGroupNSQOptions|null} [nsq] RelayOptions nsq
             * @property {protos.opts.IRelayGroupRabbitOptions|null} [rabbit] RelayOptions rabbit
             * @property {protos.opts.IRelayGroupMQTTOptions|null} [mqtt] RelayOptions mqtt
             * @property {protos.opts.IRelayGroupAzureServiceBusOptions|null} [azureServiceBus] RelayOptions azureServiceBus
             * @property {protos.opts.IRelayGroupGCPPubSubOptions|null} [gcpPubsub] RelayOptions gcpPubsub
             * @property {protos.opts.IRelayGroupKubeMQQueueOptions|null} [kubemqQueue] RelayOptions kubemqQueue
             * @property {protos.opts.IRelayGroupRedisPubSubOptions|null} [redisPubsub] RelayOptions redisPubsub
             * @property {protos.opts.IRelayGroupRedisStreamsOptions|null} [redisStreams] RelayOptions redisStreams
             * @property {protos.opts.IRelayGroupPostgresOptions|null} [postgres] RelayOptions postgres
             * @property {protos.opts.IRelayGroupNatsOptions|null} [nats] RelayOptions nats
             * @property {protos.opts.IRelayGroupNatsStreamingOptions|null} [natsStreaming] RelayOptions natsStreaming
             * @property {protos.opts.IRelayGroupNatsJetStreamOptions|null} [natsJetstream] RelayOptions natsJetstream
             */

            /**
             * Constructs a new RelayOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayOptions.
             * @implements IRelayOptions
             * @constructor
             * @param {protos.opts.IRelayOptions=} [properties] Properties to set
             */
            function RelayOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayOptions collectionToken.
             * @member {string} collectionToken
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.collectionToken = "";

            /**
             * RelayOptions batchSize.
             * @member {number} batchSize
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.batchSize = 0;

            /**
             * RelayOptions batchMaxRetry.
             * @member {number} batchMaxRetry
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.batchMaxRetry = 0;

            /**
             * RelayOptions connectionId.
             * @member {string} connectionId
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.connectionId = "";

            /**
             * RelayOptions numWorkers.
             * @member {number} numWorkers
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.numWorkers = 0;

            /**
             * RelayOptions statsEnable.
             * @member {boolean} statsEnable
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.statsEnable = false;

            /**
             * RelayOptions statsReportIntervalSec.
             * @member {number} statsReportIntervalSec
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.statsReportIntervalSec = 0;

            /**
             * RelayOptions _batchshGrpcAddress.
             * @member {string} _batchshGrpcAddress
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._batchshGrpcAddress = "";

            /**
             * RelayOptions _batchshGrpcDisableTls.
             * @member {boolean} _batchshGrpcDisableTls
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._batchshGrpcDisableTls = false;

            /**
             * RelayOptions _batchshGrpcTimeoutSeconds.
             * @member {number} _batchshGrpcTimeoutSeconds
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._batchshGrpcTimeoutSeconds = 0;

            /**
             * RelayOptions _relayId.
             * @member {string} _relayId
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._relayId = "";

            /**
             * RelayOptions _cliOptions.
             * @member {protos.opts.IRelayCLIOptions|null|undefined} _cliOptions
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._cliOptions = null;

            /**
             * RelayOptions _active.
             * @member {boolean} _active
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype._active = false;

            /**
             * RelayOptions kafka.
             * @member {protos.opts.IRelayGroupKafkaOptions|null|undefined} kafka
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.kafka = null;

            /**
             * RelayOptions awsSqs.
             * @member {protos.opts.IRelayGroupAWSSQSOptions|null|undefined} awsSqs
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.awsSqs = null;

            /**
             * RelayOptions mongo.
             * @member {protos.opts.IRelayGroupMongoOptions|null|undefined} mongo
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.mongo = null;

            /**
             * RelayOptions nsq.
             * @member {protos.opts.IRelayGroupNSQOptions|null|undefined} nsq
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.nsq = null;

            /**
             * RelayOptions rabbit.
             * @member {protos.opts.IRelayGroupRabbitOptions|null|undefined} rabbit
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.rabbit = null;

            /**
             * RelayOptions mqtt.
             * @member {protos.opts.IRelayGroupMQTTOptions|null|undefined} mqtt
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.mqtt = null;

            /**
             * RelayOptions azureServiceBus.
             * @member {protos.opts.IRelayGroupAzureServiceBusOptions|null|undefined} azureServiceBus
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.azureServiceBus = null;

            /**
             * RelayOptions gcpPubsub.
             * @member {protos.opts.IRelayGroupGCPPubSubOptions|null|undefined} gcpPubsub
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.gcpPubsub = null;

            /**
             * RelayOptions kubemqQueue.
             * @member {protos.opts.IRelayGroupKubeMQQueueOptions|null|undefined} kubemqQueue
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.kubemqQueue = null;

            /**
             * RelayOptions redisPubsub.
             * @member {protos.opts.IRelayGroupRedisPubSubOptions|null|undefined} redisPubsub
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.redisPubsub = null;

            /**
             * RelayOptions redisStreams.
             * @member {protos.opts.IRelayGroupRedisStreamsOptions|null|undefined} redisStreams
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.redisStreams = null;

            /**
             * RelayOptions postgres.
             * @member {protos.opts.IRelayGroupPostgresOptions|null|undefined} postgres
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.postgres = null;

            /**
             * RelayOptions nats.
             * @member {protos.opts.IRelayGroupNatsOptions|null|undefined} nats
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.nats = null;

            /**
             * RelayOptions natsStreaming.
             * @member {protos.opts.IRelayGroupNatsStreamingOptions|null|undefined} natsStreaming
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.natsStreaming = null;

            /**
             * RelayOptions natsJetstream.
             * @member {protos.opts.IRelayGroupNatsJetStreamOptions|null|undefined} natsJetstream
             * @memberof protos.opts.RelayOptions
             * @instance
             */
            RelayOptions.prototype.natsJetstream = null;

            /**
             * Creates a new RelayOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {protos.opts.IRelayOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayOptions} RelayOptions instance
             */
            RelayOptions.create = function create(properties) {
                return new RelayOptions(properties);
            };

            /**
             * Encodes the specified RelayOptions message. Does not implicitly {@link protos.opts.RelayOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {protos.opts.IRelayOptions} message RelayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collectionToken != null && Object.hasOwnProperty.call(message, "collectionToken"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.collectionToken);
                if (message.batchSize != null && Object.hasOwnProperty.call(message, "batchSize"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.batchSize);
                if (message.batchMaxRetry != null && Object.hasOwnProperty.call(message, "batchMaxRetry"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.batchMaxRetry);
                if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.connectionId);
                if (message.numWorkers != null && Object.hasOwnProperty.call(message, "numWorkers"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.numWorkers);
                if (message.statsEnable != null && Object.hasOwnProperty.call(message, "statsEnable"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.statsEnable);
                if (message.statsReportIntervalSec != null && Object.hasOwnProperty.call(message, "statsReportIntervalSec"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.statsReportIntervalSec);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.opts.RelayGroupKafkaOptions.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.awsSqs != null && Object.hasOwnProperty.call(message, "awsSqs"))
                    $root.protos.opts.RelayGroupAWSSQSOptions.encode(message.awsSqs, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.mongo != null && Object.hasOwnProperty.call(message, "mongo"))
                    $root.protos.opts.RelayGroupMongoOptions.encode(message.mongo, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.opts.RelayGroupNSQOptions.encode(message.nsq, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.opts.RelayGroupRabbitOptions.encode(message.rabbit, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.opts.RelayGroupMQTTOptions.encode(message.mqtt, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.opts.RelayGroupAzureServiceBusOptions.encode(message.azureServiceBus, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.opts.RelayGroupGCPPubSubOptions.encode(message.gcpPubsub, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.opts.RelayGroupKubeMQQueueOptions.encode(message.kubemqQueue, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.opts.RelayGroupRedisPubSubOptions.encode(message.redisPubsub, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.opts.RelayGroupRedisStreamsOptions.encode(message.redisStreams, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.postgres != null && Object.hasOwnProperty.call(message, "postgres"))
                    $root.protos.opts.RelayGroupPostgresOptions.encode(message.postgres, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.opts.RelayGroupNatsOptions.encode(message.nats, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.opts.RelayGroupNatsStreamingOptions.encode(message.natsStreaming, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.natsJetstream != null && Object.hasOwnProperty.call(message, "natsJetstream"))
                    $root.protos.opts.RelayGroupNatsJetStreamOptions.encode(message.natsJetstream, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                if (message._batchshGrpcAddress != null && Object.hasOwnProperty.call(message, "_batchshGrpcAddress"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._batchshGrpcAddress);
                if (message._batchshGrpcDisableTls != null && Object.hasOwnProperty.call(message, "_batchshGrpcDisableTls"))
                    writer.uint32(/* id 1001, wireType 0 =*/8008).bool(message._batchshGrpcDisableTls);
                if (message._batchshGrpcTimeoutSeconds != null && Object.hasOwnProperty.call(message, "_batchshGrpcTimeoutSeconds"))
                    writer.uint32(/* id 1002, wireType 0 =*/8016).int32(message._batchshGrpcTimeoutSeconds);
                if (message._relayId != null && Object.hasOwnProperty.call(message, "_relayId"))
                    writer.uint32(/* id 1003, wireType 2 =*/8026).string(message._relayId);
                if (message._cliOptions != null && Object.hasOwnProperty.call(message, "_cliOptions"))
                    $root.protos.opts.RelayCLIOptions.encode(message._cliOptions, writer.uint32(/* id 1004, wireType 2 =*/8034).fork()).ldelim();
                if (message._active != null && Object.hasOwnProperty.call(message, "_active"))
                    writer.uint32(/* id 1005, wireType 0 =*/8040).bool(message._active);
                return writer;
            };

            /**
             * Encodes the specified RelayOptions message, length delimited. Does not implicitly {@link protos.opts.RelayOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {protos.opts.IRelayOptions} message RelayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayOptions} RelayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collectionToken = reader.string();
                        break;
                    case 2:
                        message.batchSize = reader.int32();
                        break;
                    case 3:
                        message.batchMaxRetry = reader.int32();
                        break;
                    case 4:
                        message.connectionId = reader.string();
                        break;
                    case 5:
                        message.numWorkers = reader.int32();
                        break;
                    case 6:
                        message.statsEnable = reader.bool();
                        break;
                    case 7:
                        message.statsReportIntervalSec = reader.int32();
                        break;
                    case 1000:
                        message._batchshGrpcAddress = reader.string();
                        break;
                    case 1001:
                        message._batchshGrpcDisableTls = reader.bool();
                        break;
                    case 1002:
                        message._batchshGrpcTimeoutSeconds = reader.int32();
                        break;
                    case 1003:
                        message._relayId = reader.string();
                        break;
                    case 1004:
                        message._cliOptions = $root.protos.opts.RelayCLIOptions.decode(reader, reader.uint32());
                        break;
                    case 1005:
                        message._active = reader.bool();
                        break;
                    case 100:
                        message.kafka = $root.protos.opts.RelayGroupKafkaOptions.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.awsSqs = $root.protos.opts.RelayGroupAWSSQSOptions.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.mongo = $root.protos.opts.RelayGroupMongoOptions.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.nsq = $root.protos.opts.RelayGroupNSQOptions.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.rabbit = $root.protos.opts.RelayGroupRabbitOptions.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.mqtt = $root.protos.opts.RelayGroupMQTTOptions.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.azureServiceBus = $root.protos.opts.RelayGroupAzureServiceBusOptions.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.gcpPubsub = $root.protos.opts.RelayGroupGCPPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.kubemqQueue = $root.protos.opts.RelayGroupKubeMQQueueOptions.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.redisPubsub = $root.protos.opts.RelayGroupRedisPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.redisStreams = $root.protos.opts.RelayGroupRedisStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.postgres = $root.protos.opts.RelayGroupPostgresOptions.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.nats = $root.protos.opts.RelayGroupNatsOptions.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.natsStreaming = $root.protos.opts.RelayGroupNatsStreamingOptions.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.natsJetstream = $root.protos.opts.RelayGroupNatsJetStreamOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayOptions} RelayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayOptions message.
             * @function verify
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collectionToken != null && message.hasOwnProperty("collectionToken"))
                    if (!$util.isString(message.collectionToken))
                        return "collectionToken: string expected";
                if (message.batchSize != null && message.hasOwnProperty("batchSize"))
                    if (!$util.isInteger(message.batchSize))
                        return "batchSize: integer expected";
                if (message.batchMaxRetry != null && message.hasOwnProperty("batchMaxRetry"))
                    if (!$util.isInteger(message.batchMaxRetry))
                        return "batchMaxRetry: integer expected";
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    if (!$util.isString(message.connectionId))
                        return "connectionId: string expected";
                if (message.numWorkers != null && message.hasOwnProperty("numWorkers"))
                    if (!$util.isInteger(message.numWorkers))
                        return "numWorkers: integer expected";
                if (message.statsEnable != null && message.hasOwnProperty("statsEnable"))
                    if (typeof message.statsEnable !== "boolean")
                        return "statsEnable: boolean expected";
                if (message.statsReportIntervalSec != null && message.hasOwnProperty("statsReportIntervalSec"))
                    if (!$util.isInteger(message.statsReportIntervalSec))
                        return "statsReportIntervalSec: integer expected";
                if (message._batchshGrpcAddress != null && message.hasOwnProperty("_batchshGrpcAddress"))
                    if (!$util.isString(message._batchshGrpcAddress))
                        return "_batchshGrpcAddress: string expected";
                if (message._batchshGrpcDisableTls != null && message.hasOwnProperty("_batchshGrpcDisableTls"))
                    if (typeof message._batchshGrpcDisableTls !== "boolean")
                        return "_batchshGrpcDisableTls: boolean expected";
                if (message._batchshGrpcTimeoutSeconds != null && message.hasOwnProperty("_batchshGrpcTimeoutSeconds"))
                    if (!$util.isInteger(message._batchshGrpcTimeoutSeconds))
                        return "_batchshGrpcTimeoutSeconds: integer expected";
                if (message._relayId != null && message.hasOwnProperty("_relayId"))
                    if (!$util.isString(message._relayId))
                        return "_relayId: string expected";
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions")) {
                    var error = $root.protos.opts.RelayCLIOptions.verify(message._cliOptions);
                    if (error)
                        return "_cliOptions." + error;
                }
                if (message._active != null && message.hasOwnProperty("_active"))
                    if (typeof message._active !== "boolean")
                        return "_active: boolean expected";
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    var error = $root.protos.opts.RelayGroupKafkaOptions.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs")) {
                    var error = $root.protos.opts.RelayGroupAWSSQSOptions.verify(message.awsSqs);
                    if (error)
                        return "awsSqs." + error;
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    var error = $root.protos.opts.RelayGroupMongoOptions.verify(message.mongo);
                    if (error)
                        return "mongo." + error;
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    var error = $root.protos.opts.RelayGroupNSQOptions.verify(message.nsq);
                    if (error)
                        return "nsq." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    var error = $root.protos.opts.RelayGroupRabbitOptions.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    var error = $root.protos.opts.RelayGroupMQTTOptions.verify(message.mqtt);
                    if (error)
                        return "mqtt." + error;
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    var error = $root.protos.opts.RelayGroupAzureServiceBusOptions.verify(message.azureServiceBus);
                    if (error)
                        return "azureServiceBus." + error;
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    var error = $root.protos.opts.RelayGroupGCPPubSubOptions.verify(message.gcpPubsub);
                    if (error)
                        return "gcpPubsub." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    var error = $root.protos.opts.RelayGroupKubeMQQueueOptions.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    var error = $root.protos.opts.RelayGroupRedisPubSubOptions.verify(message.redisPubsub);
                    if (error)
                        return "redisPubsub." + error;
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    var error = $root.protos.opts.RelayGroupRedisStreamsOptions.verify(message.redisStreams);
                    if (error)
                        return "redisStreams." + error;
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    var error = $root.protos.opts.RelayGroupPostgresOptions.verify(message.postgres);
                    if (error)
                        return "postgres." + error;
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    var error = $root.protos.opts.RelayGroupNatsOptions.verify(message.nats);
                    if (error)
                        return "nats." + error;
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    var error = $root.protos.opts.RelayGroupNatsStreamingOptions.verify(message.natsStreaming);
                    if (error)
                        return "natsStreaming." + error;
                }
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream")) {
                    var error = $root.protos.opts.RelayGroupNatsJetStreamOptions.verify(message.natsJetstream);
                    if (error)
                        return "natsJetstream." + error;
                }
                return null;
            };

            /**
             * Creates a RelayOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayOptions} RelayOptions
             */
            RelayOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayOptions)
                    return object;
                var message = new $root.protos.opts.RelayOptions();
                if (object.collectionToken != null)
                    message.collectionToken = String(object.collectionToken);
                if (object.batchSize != null)
                    message.batchSize = object.batchSize | 0;
                if (object.batchMaxRetry != null)
                    message.batchMaxRetry = object.batchMaxRetry | 0;
                if (object.connectionId != null)
                    message.connectionId = String(object.connectionId);
                if (object.numWorkers != null)
                    message.numWorkers = object.numWorkers | 0;
                if (object.statsEnable != null)
                    message.statsEnable = Boolean(object.statsEnable);
                if (object.statsReportIntervalSec != null)
                    message.statsReportIntervalSec = object.statsReportIntervalSec | 0;
                if (object._batchshGrpcAddress != null)
                    message._batchshGrpcAddress = String(object._batchshGrpcAddress);
                if (object._batchshGrpcDisableTls != null)
                    message._batchshGrpcDisableTls = Boolean(object._batchshGrpcDisableTls);
                if (object._batchshGrpcTimeoutSeconds != null)
                    message._batchshGrpcTimeoutSeconds = object._batchshGrpcTimeoutSeconds | 0;
                if (object._relayId != null)
                    message._relayId = String(object._relayId);
                if (object._cliOptions != null) {
                    if (typeof object._cliOptions !== "object")
                        throw TypeError(".protos.opts.RelayOptions._cliOptions: object expected");
                    message._cliOptions = $root.protos.opts.RelayCLIOptions.fromObject(object._cliOptions);
                }
                if (object._active != null)
                    message._active = Boolean(object._active);
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.RelayOptions.kafka: object expected");
                    message.kafka = $root.protos.opts.RelayGroupKafkaOptions.fromObject(object.kafka);
                }
                if (object.awsSqs != null) {
                    if (typeof object.awsSqs !== "object")
                        throw TypeError(".protos.opts.RelayOptions.awsSqs: object expected");
                    message.awsSqs = $root.protos.opts.RelayGroupAWSSQSOptions.fromObject(object.awsSqs);
                }
                if (object.mongo != null) {
                    if (typeof object.mongo !== "object")
                        throw TypeError(".protos.opts.RelayOptions.mongo: object expected");
                    message.mongo = $root.protos.opts.RelayGroupMongoOptions.fromObject(object.mongo);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.RelayOptions.nsq: object expected");
                    message.nsq = $root.protos.opts.RelayGroupNSQOptions.fromObject(object.nsq);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.RelayOptions.rabbit: object expected");
                    message.rabbit = $root.protos.opts.RelayGroupRabbitOptions.fromObject(object.rabbit);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.RelayOptions.mqtt: object expected");
                    message.mqtt = $root.protos.opts.RelayGroupMQTTOptions.fromObject(object.mqtt);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.RelayOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.opts.RelayGroupAzureServiceBusOptions.fromObject(object.azureServiceBus);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.RelayOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.opts.RelayGroupGCPPubSubOptions.fromObject(object.gcpPubsub);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.RelayOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.opts.RelayGroupKubeMQQueueOptions.fromObject(object.kubemqQueue);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.RelayOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.opts.RelayGroupRedisPubSubOptions.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.RelayOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.opts.RelayGroupRedisStreamsOptions.fromObject(object.redisStreams);
                }
                if (object.postgres != null) {
                    if (typeof object.postgres !== "object")
                        throw TypeError(".protos.opts.RelayOptions.postgres: object expected");
                    message.postgres = $root.protos.opts.RelayGroupPostgresOptions.fromObject(object.postgres);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.opts.RelayOptions.nats: object expected");
                    message.nats = $root.protos.opts.RelayGroupNatsOptions.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.opts.RelayOptions.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.opts.RelayGroupNatsStreamingOptions.fromObject(object.natsStreaming);
                }
                if (object.natsJetstream != null) {
                    if (typeof object.natsJetstream !== "object")
                        throw TypeError(".protos.opts.RelayOptions.natsJetstream: object expected");
                    message.natsJetstream = $root.protos.opts.RelayGroupNatsJetStreamOptions.fromObject(object.natsJetstream);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayOptions
             * @static
             * @param {protos.opts.RelayOptions} message RelayOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.collectionToken = "";
                    object.batchSize = 0;
                    object.batchMaxRetry = 0;
                    object.connectionId = "";
                    object.numWorkers = 0;
                    object.statsEnable = false;
                    object.statsReportIntervalSec = 0;
                    object.kafka = null;
                    object.awsSqs = null;
                    object.mongo = null;
                    object.nsq = null;
                    object.rabbit = null;
                    object.mqtt = null;
                    object.azureServiceBus = null;
                    object.gcpPubsub = null;
                    object.kubemqQueue = null;
                    object.redisPubsub = null;
                    object.redisStreams = null;
                    object.postgres = null;
                    object.nats = null;
                    object.natsStreaming = null;
                    object.natsJetstream = null;
                    object._batchshGrpcAddress = "";
                    object._batchshGrpcDisableTls = false;
                    object._batchshGrpcTimeoutSeconds = 0;
                    object._relayId = "";
                    object._cliOptions = null;
                    object._active = false;
                }
                if (message.collectionToken != null && message.hasOwnProperty("collectionToken"))
                    object.collectionToken = message.collectionToken;
                if (message.batchSize != null && message.hasOwnProperty("batchSize"))
                    object.batchSize = message.batchSize;
                if (message.batchMaxRetry != null && message.hasOwnProperty("batchMaxRetry"))
                    object.batchMaxRetry = message.batchMaxRetry;
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    object.connectionId = message.connectionId;
                if (message.numWorkers != null && message.hasOwnProperty("numWorkers"))
                    object.numWorkers = message.numWorkers;
                if (message.statsEnable != null && message.hasOwnProperty("statsEnable"))
                    object.statsEnable = message.statsEnable;
                if (message.statsReportIntervalSec != null && message.hasOwnProperty("statsReportIntervalSec"))
                    object.statsReportIntervalSec = message.statsReportIntervalSec;
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.opts.RelayGroupKafkaOptions.toObject(message.kafka, options);
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs"))
                    object.awsSqs = $root.protos.opts.RelayGroupAWSSQSOptions.toObject(message.awsSqs, options);
                if (message.mongo != null && message.hasOwnProperty("mongo"))
                    object.mongo = $root.protos.opts.RelayGroupMongoOptions.toObject(message.mongo, options);
                if (message.nsq != null && message.hasOwnProperty("nsq"))
                    object.nsq = $root.protos.opts.RelayGroupNSQOptions.toObject(message.nsq, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.opts.RelayGroupRabbitOptions.toObject(message.rabbit, options);
                if (message.mqtt != null && message.hasOwnProperty("mqtt"))
                    object.mqtt = $root.protos.opts.RelayGroupMQTTOptions.toObject(message.mqtt, options);
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus"))
                    object.azureServiceBus = $root.protos.opts.RelayGroupAzureServiceBusOptions.toObject(message.azureServiceBus, options);
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub"))
                    object.gcpPubsub = $root.protos.opts.RelayGroupGCPPubSubOptions.toObject(message.gcpPubsub, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.opts.RelayGroupKubeMQQueueOptions.toObject(message.kubemqQueue, options);
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub"))
                    object.redisPubsub = $root.protos.opts.RelayGroupRedisPubSubOptions.toObject(message.redisPubsub, options);
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams"))
                    object.redisStreams = $root.protos.opts.RelayGroupRedisStreamsOptions.toObject(message.redisStreams, options);
                if (message.postgres != null && message.hasOwnProperty("postgres"))
                    object.postgres = $root.protos.opts.RelayGroupPostgresOptions.toObject(message.postgres, options);
                if (message.nats != null && message.hasOwnProperty("nats"))
                    object.nats = $root.protos.opts.RelayGroupNatsOptions.toObject(message.nats, options);
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming"))
                    object.natsStreaming = $root.protos.opts.RelayGroupNatsStreamingOptions.toObject(message.natsStreaming, options);
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream"))
                    object.natsJetstream = $root.protos.opts.RelayGroupNatsJetStreamOptions.toObject(message.natsJetstream, options);
                if (message._batchshGrpcAddress != null && message.hasOwnProperty("_batchshGrpcAddress"))
                    object._batchshGrpcAddress = message._batchshGrpcAddress;
                if (message._batchshGrpcDisableTls != null && message.hasOwnProperty("_batchshGrpcDisableTls"))
                    object._batchshGrpcDisableTls = message._batchshGrpcDisableTls;
                if (message._batchshGrpcTimeoutSeconds != null && message.hasOwnProperty("_batchshGrpcTimeoutSeconds"))
                    object._batchshGrpcTimeoutSeconds = message._batchshGrpcTimeoutSeconds;
                if (message._relayId != null && message.hasOwnProperty("_relayId"))
                    object._relayId = message._relayId;
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions"))
                    object._cliOptions = $root.protos.opts.RelayCLIOptions.toObject(message._cliOptions, options);
                if (message._active != null && message.hasOwnProperty("_active"))
                    object._active = message._active;
                return object;
            };

            /**
             * Converts this RelayOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayOptions;
        })();

        opts.RelayGroupKafkaOptions = (function() {

            /**
             * Properties of a RelayGroupKafkaOptions.
             * @memberof protos.opts
             * @interface IRelayGroupKafkaOptions
             * @property {protos.args.IKafkaConn|null} [_conn] RelayGroupKafkaOptions _conn
             * @property {protos.args.IKafkaRelayArgs|null} [args] RelayGroupKafkaOptions args
             */

            /**
             * Constructs a new RelayGroupKafkaOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupKafkaOptions.
             * @implements IRelayGroupKafkaOptions
             * @constructor
             * @param {protos.opts.IRelayGroupKafkaOptions=} [properties] Properties to set
             */
            function RelayGroupKafkaOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupKafkaOptions _conn.
             * @member {protos.args.IKafkaConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @instance
             */
            RelayGroupKafkaOptions.prototype._conn = null;

            /**
             * RelayGroupKafkaOptions args.
             * @member {protos.args.IKafkaRelayArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @instance
             */
            RelayGroupKafkaOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupKafkaOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {protos.opts.IRelayGroupKafkaOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupKafkaOptions} RelayGroupKafkaOptions instance
             */
            RelayGroupKafkaOptions.create = function create(properties) {
                return new RelayGroupKafkaOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupKafkaOptions message. Does not implicitly {@link protos.opts.RelayGroupKafkaOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {protos.opts.IRelayGroupKafkaOptions} message RelayGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupKafkaOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KafkaConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KafkaRelayArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupKafkaOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupKafkaOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {protos.opts.IRelayGroupKafkaOptions} message RelayGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupKafkaOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupKafkaOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupKafkaOptions} RelayGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupKafkaOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupKafkaOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KafkaConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KafkaRelayArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupKafkaOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupKafkaOptions} RelayGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupKafkaOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupKafkaOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupKafkaOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KafkaConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KafkaRelayArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupKafkaOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupKafkaOptions} RelayGroupKafkaOptions
             */
            RelayGroupKafkaOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupKafkaOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupKafkaOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupKafkaOptions._conn: object expected");
                    message._conn = $root.protos.args.KafkaConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupKafkaOptions.args: object expected");
                    message.args = $root.protos.args.KafkaRelayArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupKafkaOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @static
             * @param {protos.opts.RelayGroupKafkaOptions} message RelayGroupKafkaOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupKafkaOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KafkaConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KafkaRelayArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupKafkaOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupKafkaOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupKafkaOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupKafkaOptions;
        })();

        opts.RelayGroupAWSSQSOptions = (function() {

            /**
             * Properties of a RelayGroupAWSSQSOptions.
             * @memberof protos.opts
             * @interface IRelayGroupAWSSQSOptions
             * @property {protos.args.IAWSSQSConn|null} [_conn] RelayGroupAWSSQSOptions _conn
             * @property {protos.args.IAWSSQSRelayArgs|null} [args] RelayGroupAWSSQSOptions args
             */

            /**
             * Constructs a new RelayGroupAWSSQSOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupAWSSQSOptions.
             * @implements IRelayGroupAWSSQSOptions
             * @constructor
             * @param {protos.opts.IRelayGroupAWSSQSOptions=} [properties] Properties to set
             */
            function RelayGroupAWSSQSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupAWSSQSOptions _conn.
             * @member {protos.args.IAWSSQSConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @instance
             */
            RelayGroupAWSSQSOptions.prototype._conn = null;

            /**
             * RelayGroupAWSSQSOptions args.
             * @member {protos.args.IAWSSQSRelayArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @instance
             */
            RelayGroupAWSSQSOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupAWSSQSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IRelayGroupAWSSQSOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupAWSSQSOptions} RelayGroupAWSSQSOptions instance
             */
            RelayGroupAWSSQSOptions.create = function create(properties) {
                return new RelayGroupAWSSQSOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupAWSSQSOptions message. Does not implicitly {@link protos.opts.RelayGroupAWSSQSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IRelayGroupAWSSQSOptions} message RelayGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupAWSSQSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSQSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSQSRelayArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupAWSSQSOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupAWSSQSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IRelayGroupAWSSQSOptions} message RelayGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupAWSSQSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupAWSSQSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupAWSSQSOptions} RelayGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupAWSSQSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupAWSSQSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSQSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSQSRelayArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupAWSSQSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupAWSSQSOptions} RelayGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupAWSSQSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupAWSSQSOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupAWSSQSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSSQSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSSQSRelayArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupAWSSQSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupAWSSQSOptions} RelayGroupAWSSQSOptions
             */
            RelayGroupAWSSQSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupAWSSQSOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupAWSSQSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupAWSSQSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSQSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupAWSSQSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSQSRelayArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupAWSSQSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @static
             * @param {protos.opts.RelayGroupAWSSQSOptions} message RelayGroupAWSSQSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupAWSSQSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSQSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSQSRelayArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupAWSSQSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupAWSSQSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupAWSSQSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupAWSSQSOptions;
        })();

        opts.RelayGroupMongoOptions = (function() {

            /**
             * Properties of a RelayGroupMongoOptions.
             * @memberof protos.opts
             * @interface IRelayGroupMongoOptions
             * @property {protos.args.IMongoConn|null} [_conn] RelayGroupMongoOptions _conn
             * @property {protos.args.IMongoReadArgs|null} [args] RelayGroupMongoOptions args
             */

            /**
             * Constructs a new RelayGroupMongoOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupMongoOptions.
             * @implements IRelayGroupMongoOptions
             * @constructor
             * @param {protos.opts.IRelayGroupMongoOptions=} [properties] Properties to set
             */
            function RelayGroupMongoOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupMongoOptions _conn.
             * @member {protos.args.IMongoConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupMongoOptions
             * @instance
             */
            RelayGroupMongoOptions.prototype._conn = null;

            /**
             * RelayGroupMongoOptions args.
             * @member {protos.args.IMongoReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupMongoOptions
             * @instance
             */
            RelayGroupMongoOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupMongoOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {protos.opts.IRelayGroupMongoOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupMongoOptions} RelayGroupMongoOptions instance
             */
            RelayGroupMongoOptions.create = function create(properties) {
                return new RelayGroupMongoOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupMongoOptions message. Does not implicitly {@link protos.opts.RelayGroupMongoOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {protos.opts.IRelayGroupMongoOptions} message RelayGroupMongoOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupMongoOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MongoConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MongoReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupMongoOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupMongoOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {protos.opts.IRelayGroupMongoOptions} message RelayGroupMongoOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupMongoOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupMongoOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupMongoOptions} RelayGroupMongoOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupMongoOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupMongoOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MongoConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MongoReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupMongoOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupMongoOptions} RelayGroupMongoOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupMongoOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupMongoOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupMongoOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.MongoConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.MongoReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupMongoOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupMongoOptions} RelayGroupMongoOptions
             */
            RelayGroupMongoOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupMongoOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupMongoOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupMongoOptions._conn: object expected");
                    message._conn = $root.protos.args.MongoConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupMongoOptions.args: object expected");
                    message.args = $root.protos.args.MongoReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupMongoOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupMongoOptions
             * @static
             * @param {protos.opts.RelayGroupMongoOptions} message RelayGroupMongoOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupMongoOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MongoConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MongoReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupMongoOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupMongoOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupMongoOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupMongoOptions;
        })();

        opts.RelayGroupNSQOptions = (function() {

            /**
             * Properties of a RelayGroupNSQOptions.
             * @memberof protos.opts
             * @interface IRelayGroupNSQOptions
             * @property {protos.args.INSQConn|null} [_conn] RelayGroupNSQOptions _conn
             * @property {protos.args.INSQReadArgs|null} [args] RelayGroupNSQOptions args
             */

            /**
             * Constructs a new RelayGroupNSQOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupNSQOptions.
             * @implements IRelayGroupNSQOptions
             * @constructor
             * @param {protos.opts.IRelayGroupNSQOptions=} [properties] Properties to set
             */
            function RelayGroupNSQOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupNSQOptions _conn.
             * @member {protos.args.INSQConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupNSQOptions
             * @instance
             */
            RelayGroupNSQOptions.prototype._conn = null;

            /**
             * RelayGroupNSQOptions args.
             * @member {protos.args.INSQReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupNSQOptions
             * @instance
             */
            RelayGroupNSQOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupNSQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {protos.opts.IRelayGroupNSQOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupNSQOptions} RelayGroupNSQOptions instance
             */
            RelayGroupNSQOptions.create = function create(properties) {
                return new RelayGroupNSQOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupNSQOptions message. Does not implicitly {@link protos.opts.RelayGroupNSQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {protos.opts.IRelayGroupNSQOptions} message RelayGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupNSQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NSQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NSQReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupNSQOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupNSQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {protos.opts.IRelayGroupNSQOptions} message RelayGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupNSQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupNSQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupNSQOptions} RelayGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupNSQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupNSQOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NSQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NSQReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupNSQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupNSQOptions} RelayGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupNSQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupNSQOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupNSQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NSQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NSQReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupNSQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupNSQOptions} RelayGroupNSQOptions
             */
            RelayGroupNSQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupNSQOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupNSQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupNSQOptions._conn: object expected");
                    message._conn = $root.protos.args.NSQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupNSQOptions.args: object expected");
                    message.args = $root.protos.args.NSQReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupNSQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupNSQOptions
             * @static
             * @param {protos.opts.RelayGroupNSQOptions} message RelayGroupNSQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupNSQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NSQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NSQReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupNSQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupNSQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupNSQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupNSQOptions;
        })();

        opts.RelayGroupPostgresOptions = (function() {

            /**
             * Properties of a RelayGroupPostgresOptions.
             * @memberof protos.opts
             * @interface IRelayGroupPostgresOptions
             * @property {protos.args.IPostgresConn|null} [_conn] RelayGroupPostgresOptions _conn
             * @property {protos.args.IPostgresReadArgs|null} [args] RelayGroupPostgresOptions args
             */

            /**
             * Constructs a new RelayGroupPostgresOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupPostgresOptions.
             * @implements IRelayGroupPostgresOptions
             * @constructor
             * @param {protos.opts.IRelayGroupPostgresOptions=} [properties] Properties to set
             */
            function RelayGroupPostgresOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupPostgresOptions _conn.
             * @member {protos.args.IPostgresConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @instance
             */
            RelayGroupPostgresOptions.prototype._conn = null;

            /**
             * RelayGroupPostgresOptions args.
             * @member {protos.args.IPostgresReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @instance
             */
            RelayGroupPostgresOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupPostgresOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {protos.opts.IRelayGroupPostgresOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupPostgresOptions} RelayGroupPostgresOptions instance
             */
            RelayGroupPostgresOptions.create = function create(properties) {
                return new RelayGroupPostgresOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupPostgresOptions message. Does not implicitly {@link protos.opts.RelayGroupPostgresOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {protos.opts.IRelayGroupPostgresOptions} message RelayGroupPostgresOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupPostgresOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.PostgresConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.PostgresReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupPostgresOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupPostgresOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {protos.opts.IRelayGroupPostgresOptions} message RelayGroupPostgresOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupPostgresOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupPostgresOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupPostgresOptions} RelayGroupPostgresOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupPostgresOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupPostgresOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.PostgresConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.PostgresReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupPostgresOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupPostgresOptions} RelayGroupPostgresOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupPostgresOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupPostgresOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupPostgresOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.PostgresConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.PostgresReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupPostgresOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupPostgresOptions} RelayGroupPostgresOptions
             */
            RelayGroupPostgresOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupPostgresOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupPostgresOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupPostgresOptions._conn: object expected");
                    message._conn = $root.protos.args.PostgresConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupPostgresOptions.args: object expected");
                    message.args = $root.protos.args.PostgresReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupPostgresOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @static
             * @param {protos.opts.RelayGroupPostgresOptions} message RelayGroupPostgresOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupPostgresOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.PostgresConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.PostgresReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupPostgresOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupPostgresOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupPostgresOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupPostgresOptions;
        })();

        opts.RelayGroupRabbitOptions = (function() {

            /**
             * Properties of a RelayGroupRabbitOptions.
             * @memberof protos.opts
             * @interface IRelayGroupRabbitOptions
             * @property {protos.args.IRabbitConn|null} [_conn] RelayGroupRabbitOptions _conn
             * @property {protos.args.IRabbitReadArgs|null} [args] RelayGroupRabbitOptions args
             */

            /**
             * Constructs a new RelayGroupRabbitOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupRabbitOptions.
             * @implements IRelayGroupRabbitOptions
             * @constructor
             * @param {protos.opts.IRelayGroupRabbitOptions=} [properties] Properties to set
             */
            function RelayGroupRabbitOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupRabbitOptions _conn.
             * @member {protos.args.IRabbitConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @instance
             */
            RelayGroupRabbitOptions.prototype._conn = null;

            /**
             * RelayGroupRabbitOptions args.
             * @member {protos.args.IRabbitReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @instance
             */
            RelayGroupRabbitOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupRabbitOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {protos.opts.IRelayGroupRabbitOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupRabbitOptions} RelayGroupRabbitOptions instance
             */
            RelayGroupRabbitOptions.create = function create(properties) {
                return new RelayGroupRabbitOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupRabbitOptions message. Does not implicitly {@link protos.opts.RelayGroupRabbitOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {protos.opts.IRelayGroupRabbitOptions} message RelayGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRabbitOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupRabbitOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupRabbitOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {protos.opts.IRelayGroupRabbitOptions} message RelayGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRabbitOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupRabbitOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupRabbitOptions} RelayGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRabbitOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupRabbitOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupRabbitOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupRabbitOptions} RelayGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRabbitOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupRabbitOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupRabbitOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RabbitConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RabbitReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupRabbitOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupRabbitOptions} RelayGroupRabbitOptions
             */
            RelayGroupRabbitOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupRabbitOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupRabbitOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupRabbitOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupRabbitOptions.args: object expected");
                    message.args = $root.protos.args.RabbitReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupRabbitOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @static
             * @param {protos.opts.RelayGroupRabbitOptions} message RelayGroupRabbitOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupRabbitOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupRabbitOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupRabbitOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupRabbitOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupRabbitOptions;
        })();

        opts.RelayGroupRedisPubSubOptions = (function() {

            /**
             * Properties of a RelayGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @interface IRelayGroupRedisPubSubOptions
             * @property {protos.args.IRedisPubSubConn|null} [_conn] RelayGroupRedisPubSubOptions _conn
             * @property {protos.args.IRedisPubSubReadArgs|null} [args] RelayGroupRedisPubSubOptions args
             */

            /**
             * Constructs a new RelayGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupRedisPubSubOptions.
             * @implements IRelayGroupRedisPubSubOptions
             * @constructor
             * @param {protos.opts.IRelayGroupRedisPubSubOptions=} [properties] Properties to set
             */
            function RelayGroupRedisPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupRedisPubSubOptions _conn.
             * @member {protos.args.IRedisPubSubConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @instance
             */
            RelayGroupRedisPubSubOptions.prototype._conn = null;

            /**
             * RelayGroupRedisPubSubOptions args.
             * @member {protos.args.IRedisPubSubReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @instance
             */
            RelayGroupRedisPubSubOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupRedisPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupRedisPubSubOptions} RelayGroupRedisPubSubOptions instance
             */
            RelayGroupRedisPubSubOptions.create = function create(properties) {
                return new RelayGroupRedisPubSubOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupRedisPubSubOptions message. Does not implicitly {@link protos.opts.RelayGroupRedisPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisPubSubOptions} message RelayGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRedisPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisPubSubReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupRedisPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupRedisPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisPubSubOptions} message RelayGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRedisPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupRedisPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupRedisPubSubOptions} RelayGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRedisPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupRedisPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisPubSubReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupRedisPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupRedisPubSubOptions} RelayGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRedisPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupRedisPubSubOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupRedisPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisPubSubReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupRedisPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupRedisPubSubOptions} RelayGroupRedisPubSubOptions
             */
            RelayGroupRedisPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupRedisPubSubOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupRedisPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupRedisPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupRedisPubSubOptions.args: object expected");
                    message.args = $root.protos.args.RedisPubSubReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupRedisPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.RelayGroupRedisPubSubOptions} message RelayGroupRedisPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupRedisPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisPubSubReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupRedisPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupRedisPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupRedisPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupRedisPubSubOptions;
        })();

        opts.RelayGroupRedisStreamsOptions = (function() {

            /**
             * Properties of a RelayGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @interface IRelayGroupRedisStreamsOptions
             * @property {protos.args.IRedisStreamsConn|null} [_conn] RelayGroupRedisStreamsOptions _conn
             * @property {protos.args.IRedisStreamsReadArgs|null} [args] RelayGroupRedisStreamsOptions args
             */

            /**
             * Constructs a new RelayGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupRedisStreamsOptions.
             * @implements IRelayGroupRedisStreamsOptions
             * @constructor
             * @param {protos.opts.IRelayGroupRedisStreamsOptions=} [properties] Properties to set
             */
            function RelayGroupRedisStreamsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupRedisStreamsOptions _conn.
             * @member {protos.args.IRedisStreamsConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @instance
             */
            RelayGroupRedisStreamsOptions.prototype._conn = null;

            /**
             * RelayGroupRedisStreamsOptions args.
             * @member {protos.args.IRedisStreamsReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @instance
             */
            RelayGroupRedisStreamsOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupRedisStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupRedisStreamsOptions} RelayGroupRedisStreamsOptions instance
             */
            RelayGroupRedisStreamsOptions.create = function create(properties) {
                return new RelayGroupRedisStreamsOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupRedisStreamsOptions message. Does not implicitly {@link protos.opts.RelayGroupRedisStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisStreamsOptions} message RelayGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRedisStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisStreamsReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupRedisStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupRedisStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IRelayGroupRedisStreamsOptions} message RelayGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupRedisStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupRedisStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupRedisStreamsOptions} RelayGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRedisStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupRedisStreamsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisStreamsReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupRedisStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupRedisStreamsOptions} RelayGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupRedisStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupRedisStreamsOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupRedisStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisStreamsReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupRedisStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupRedisStreamsOptions} RelayGroupRedisStreamsOptions
             */
            RelayGroupRedisStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupRedisStreamsOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupRedisStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupRedisStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupRedisStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RedisStreamsReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupRedisStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.RelayGroupRedisStreamsOptions} message RelayGroupRedisStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupRedisStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisStreamsReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupRedisStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupRedisStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupRedisStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupRedisStreamsOptions;
        })();

        opts.RelayGroupAzureServiceBusOptions = (function() {

            /**
             * Properties of a RelayGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @interface IRelayGroupAzureServiceBusOptions
             * @property {protos.args.IAzureServiceBusConn|null} [_conn] RelayGroupAzureServiceBusOptions _conn
             * @property {protos.args.IAzureServiceBusReadArgs|null} [args] RelayGroupAzureServiceBusOptions args
             */

            /**
             * Constructs a new RelayGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupAzureServiceBusOptions.
             * @implements IRelayGroupAzureServiceBusOptions
             * @constructor
             * @param {protos.opts.IRelayGroupAzureServiceBusOptions=} [properties] Properties to set
             */
            function RelayGroupAzureServiceBusOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupAzureServiceBusOptions _conn.
             * @member {protos.args.IAzureServiceBusConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @instance
             */
            RelayGroupAzureServiceBusOptions.prototype._conn = null;

            /**
             * RelayGroupAzureServiceBusOptions args.
             * @member {protos.args.IAzureServiceBusReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @instance
             */
            RelayGroupAzureServiceBusOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupAzureServiceBusOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IRelayGroupAzureServiceBusOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupAzureServiceBusOptions} RelayGroupAzureServiceBusOptions instance
             */
            RelayGroupAzureServiceBusOptions.create = function create(properties) {
                return new RelayGroupAzureServiceBusOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupAzureServiceBusOptions message. Does not implicitly {@link protos.opts.RelayGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IRelayGroupAzureServiceBusOptions} message RelayGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupAzureServiceBusOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureServiceBusConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureServiceBusReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupAzureServiceBusOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IRelayGroupAzureServiceBusOptions} message RelayGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupAzureServiceBusOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupAzureServiceBusOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupAzureServiceBusOptions} RelayGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupAzureServiceBusOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupAzureServiceBusOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureServiceBusConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureServiceBusReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupAzureServiceBusOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupAzureServiceBusOptions} RelayGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupAzureServiceBusOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupAzureServiceBusOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupAzureServiceBusOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AzureServiceBusConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AzureServiceBusReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupAzureServiceBusOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupAzureServiceBusOptions} RelayGroupAzureServiceBusOptions
             */
            RelayGroupAzureServiceBusOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupAzureServiceBusOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupAzureServiceBusOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupAzureServiceBusOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureServiceBusConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupAzureServiceBusOptions.args: object expected");
                    message.args = $root.protos.args.AzureServiceBusReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupAzureServiceBusOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.RelayGroupAzureServiceBusOptions} message RelayGroupAzureServiceBusOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupAzureServiceBusOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureServiceBusConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureServiceBusReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupAzureServiceBusOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupAzureServiceBusOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupAzureServiceBusOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupAzureServiceBusOptions;
        })();

        opts.RelayGroupMQTTOptions = (function() {

            /**
             * Properties of a RelayGroupMQTTOptions.
             * @memberof protos.opts
             * @interface IRelayGroupMQTTOptions
             * @property {protos.args.IMQTTConn|null} [_conn] RelayGroupMQTTOptions _conn
             * @property {protos.args.IMQTTReadArgs|null} [args] RelayGroupMQTTOptions args
             */

            /**
             * Constructs a new RelayGroupMQTTOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupMQTTOptions.
             * @implements IRelayGroupMQTTOptions
             * @constructor
             * @param {protos.opts.IRelayGroupMQTTOptions=} [properties] Properties to set
             */
            function RelayGroupMQTTOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupMQTTOptions _conn.
             * @member {protos.args.IMQTTConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @instance
             */
            RelayGroupMQTTOptions.prototype._conn = null;

            /**
             * RelayGroupMQTTOptions args.
             * @member {protos.args.IMQTTReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @instance
             */
            RelayGroupMQTTOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupMQTTOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {protos.opts.IRelayGroupMQTTOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupMQTTOptions} RelayGroupMQTTOptions instance
             */
            RelayGroupMQTTOptions.create = function create(properties) {
                return new RelayGroupMQTTOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupMQTTOptions message. Does not implicitly {@link protos.opts.RelayGroupMQTTOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {protos.opts.IRelayGroupMQTTOptions} message RelayGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupMQTTOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MQTTConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MQTTReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupMQTTOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupMQTTOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {protos.opts.IRelayGroupMQTTOptions} message RelayGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupMQTTOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupMQTTOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupMQTTOptions} RelayGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupMQTTOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupMQTTOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MQTTConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MQTTReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupMQTTOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupMQTTOptions} RelayGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupMQTTOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupMQTTOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupMQTTOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.MQTTConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.MQTTReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupMQTTOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupMQTTOptions} RelayGroupMQTTOptions
             */
            RelayGroupMQTTOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupMQTTOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupMQTTOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupMQTTOptions._conn: object expected");
                    message._conn = $root.protos.args.MQTTConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupMQTTOptions.args: object expected");
                    message.args = $root.protos.args.MQTTReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupMQTTOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @static
             * @param {protos.opts.RelayGroupMQTTOptions} message RelayGroupMQTTOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupMQTTOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MQTTConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MQTTReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupMQTTOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupMQTTOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupMQTTOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupMQTTOptions;
        })();

        opts.RelayGroupGCPPubSubOptions = (function() {

            /**
             * Properties of a RelayGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @interface IRelayGroupGCPPubSubOptions
             * @property {protos.args.IGCPPubSubConn|null} [_conn] RelayGroupGCPPubSubOptions _conn
             * @property {protos.args.IGCPPubSubReadArgs|null} [args] RelayGroupGCPPubSubOptions args
             */

            /**
             * Constructs a new RelayGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupGCPPubSubOptions.
             * @implements IRelayGroupGCPPubSubOptions
             * @constructor
             * @param {protos.opts.IRelayGroupGCPPubSubOptions=} [properties] Properties to set
             */
            function RelayGroupGCPPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupGCPPubSubOptions _conn.
             * @member {protos.args.IGCPPubSubConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @instance
             */
            RelayGroupGCPPubSubOptions.prototype._conn = null;

            /**
             * RelayGroupGCPPubSubOptions args.
             * @member {protos.args.IGCPPubSubReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @instance
             */
            RelayGroupGCPPubSubOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupGCPPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupGCPPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupGCPPubSubOptions} RelayGroupGCPPubSubOptions instance
             */
            RelayGroupGCPPubSubOptions.create = function create(properties) {
                return new RelayGroupGCPPubSubOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupGCPPubSubOptions message. Does not implicitly {@link protos.opts.RelayGroupGCPPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupGCPPubSubOptions} message RelayGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupGCPPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.GCPPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.GCPPubSubReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupGCPPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupGCPPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IRelayGroupGCPPubSubOptions} message RelayGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupGCPPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupGCPPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupGCPPubSubOptions} RelayGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupGCPPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupGCPPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.GCPPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.GCPPubSubReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupGCPPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupGCPPubSubOptions} RelayGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupGCPPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupGCPPubSubOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupGCPPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.GCPPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.GCPPubSubReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupGCPPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupGCPPubSubOptions} RelayGroupGCPPubSubOptions
             */
            RelayGroupGCPPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupGCPPubSubOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupGCPPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupGCPPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.GCPPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupGCPPubSubOptions.args: object expected");
                    message.args = $root.protos.args.GCPPubSubReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupGCPPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.RelayGroupGCPPubSubOptions} message RelayGroupGCPPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupGCPPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.GCPPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.GCPPubSubReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupGCPPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupGCPPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupGCPPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupGCPPubSubOptions;
        })();

        opts.RelayGroupKubeMQQueueOptions = (function() {

            /**
             * Properties of a RelayGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @interface IRelayGroupKubeMQQueueOptions
             * @property {protos.args.IKubeMQQueueConn|null} [_conn] RelayGroupKubeMQQueueOptions _conn
             * @property {protos.args.IKubeMQQueueReadArgs|null} [args] RelayGroupKubeMQQueueOptions args
             */

            /**
             * Constructs a new RelayGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupKubeMQQueueOptions.
             * @implements IRelayGroupKubeMQQueueOptions
             * @constructor
             * @param {protos.opts.IRelayGroupKubeMQQueueOptions=} [properties] Properties to set
             */
            function RelayGroupKubeMQQueueOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupKubeMQQueueOptions _conn.
             * @member {protos.args.IKubeMQQueueConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @instance
             */
            RelayGroupKubeMQQueueOptions.prototype._conn = null;

            /**
             * RelayGroupKubeMQQueueOptions args.
             * @member {protos.args.IKubeMQQueueReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @instance
             */
            RelayGroupKubeMQQueueOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupKubeMQQueueOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IRelayGroupKubeMQQueueOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupKubeMQQueueOptions} RelayGroupKubeMQQueueOptions instance
             */
            RelayGroupKubeMQQueueOptions.create = function create(properties) {
                return new RelayGroupKubeMQQueueOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupKubeMQQueueOptions message. Does not implicitly {@link protos.opts.RelayGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IRelayGroupKubeMQQueueOptions} message RelayGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupKubeMQQueueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KubeMQQueueConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KubeMQQueueReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupKubeMQQueueOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IRelayGroupKubeMQQueueOptions} message RelayGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupKubeMQQueueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupKubeMQQueueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupKubeMQQueueOptions} RelayGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupKubeMQQueueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupKubeMQQueueOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KubeMQQueueConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KubeMQQueueReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupKubeMQQueueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupKubeMQQueueOptions} RelayGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupKubeMQQueueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupKubeMQQueueOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupKubeMQQueueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KubeMQQueueConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KubeMQQueueReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupKubeMQQueueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupKubeMQQueueOptions} RelayGroupKubeMQQueueOptions
             */
            RelayGroupKubeMQQueueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupKubeMQQueueOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupKubeMQQueueOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupKubeMQQueueOptions._conn: object expected");
                    message._conn = $root.protos.args.KubeMQQueueConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupKubeMQQueueOptions.args: object expected");
                    message.args = $root.protos.args.KubeMQQueueReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupKubeMQQueueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.RelayGroupKubeMQQueueOptions} message RelayGroupKubeMQQueueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupKubeMQQueueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KubeMQQueueConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KubeMQQueueReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupKubeMQQueueOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupKubeMQQueueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupKubeMQQueueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupKubeMQQueueOptions;
        })();

        opts.RelayGroupNatsOptions = (function() {

            /**
             * Properties of a RelayGroupNatsOptions.
             * @memberof protos.opts
             * @interface IRelayGroupNatsOptions
             * @property {protos.args.INatsConn|null} [_conn] RelayGroupNatsOptions _conn
             * @property {protos.args.INatsReadArgs|null} [args] RelayGroupNatsOptions args
             */

            /**
             * Constructs a new RelayGroupNatsOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupNatsOptions.
             * @implements IRelayGroupNatsOptions
             * @constructor
             * @param {protos.opts.IRelayGroupNatsOptions=} [properties] Properties to set
             */
            function RelayGroupNatsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupNatsOptions _conn.
             * @member {protos.args.INatsConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupNatsOptions
             * @instance
             */
            RelayGroupNatsOptions.prototype._conn = null;

            /**
             * RelayGroupNatsOptions args.
             * @member {protos.args.INatsReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupNatsOptions
             * @instance
             */
            RelayGroupNatsOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupNatsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupNatsOptions
             * @static
             * @param {protos.opts.IRelayGroupNatsOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupNatsOptions} RelayGroupNatsOptions instance
             */
            RelayGroupNatsOptions.create = function create(properties) {
                return new RelayGroupNatsOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupNatsOptions message. Does not implicitly {@link protos.opts.RelayGroupNatsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupNatsOptions
             * @static
             * @param {protos.opts.IRelayGroupNatsOptions} message RelayGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupNatsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupNatsOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupNatsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupNatsOptions
             * @static
             * @param {protos.opts.IRelayGroupNatsOptions} message RelayGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupNatsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupNatsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupNatsOptions} RelayGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupNatsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupNatsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupNatsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupNatsOptions} RelayGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupNatsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupNatsOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupNatsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupNatsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupNatsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupNatsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupNatsOptions} RelayGroupNatsOptions
             */
            RelayGroupNatsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupNatsOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupNatsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupNatsOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupNatsOptions.args: object expected");
                    message.args = $root.protos.args.NatsReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupNatsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupNatsOptions
             * @static
             * @param {protos.opts.RelayGroupNatsOptions} message RelayGroupNatsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupNatsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupNatsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupNatsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupNatsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupNatsOptions;
        })();

        opts.RelayGroupNatsStreamingOptions = (function() {

            /**
             * Properties of a RelayGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @interface IRelayGroupNatsStreamingOptions
             * @property {protos.args.INatsStreamingConn|null} [_conn] RelayGroupNatsStreamingOptions _conn
             * @property {protos.args.INatsStreamingReadArgs|null} [args] RelayGroupNatsStreamingOptions args
             */

            /**
             * Constructs a new RelayGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupNatsStreamingOptions.
             * @implements IRelayGroupNatsStreamingOptions
             * @constructor
             * @param {protos.opts.IRelayGroupNatsStreamingOptions=} [properties] Properties to set
             */
            function RelayGroupNatsStreamingOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupNatsStreamingOptions _conn.
             * @member {protos.args.INatsStreamingConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @instance
             */
            RelayGroupNatsStreamingOptions.prototype._conn = null;

            /**
             * RelayGroupNatsStreamingOptions args.
             * @member {protos.args.INatsStreamingReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @instance
             */
            RelayGroupNatsStreamingOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupNatsStreamingOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IRelayGroupNatsStreamingOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupNatsStreamingOptions} RelayGroupNatsStreamingOptions instance
             */
            RelayGroupNatsStreamingOptions.create = function create(properties) {
                return new RelayGroupNatsStreamingOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupNatsStreamingOptions message. Does not implicitly {@link protos.opts.RelayGroupNatsStreamingOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IRelayGroupNatsStreamingOptions} message RelayGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupNatsStreamingOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsStreamingConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsStreamingReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupNatsStreamingOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupNatsStreamingOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IRelayGroupNatsStreamingOptions} message RelayGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupNatsStreamingOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupNatsStreamingOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupNatsStreamingOptions} RelayGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupNatsStreamingOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupNatsStreamingOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsStreamingConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsStreamingReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupNatsStreamingOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupNatsStreamingOptions} RelayGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupNatsStreamingOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupNatsStreamingOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupNatsStreamingOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsStreamingConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsStreamingReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupNatsStreamingOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupNatsStreamingOptions} RelayGroupNatsStreamingOptions
             */
            RelayGroupNatsStreamingOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupNatsStreamingOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupNatsStreamingOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupNatsStreamingOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsStreamingConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupNatsStreamingOptions.args: object expected");
                    message.args = $root.protos.args.NatsStreamingReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupNatsStreamingOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.RelayGroupNatsStreamingOptions} message RelayGroupNatsStreamingOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupNatsStreamingOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsStreamingConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsStreamingReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupNatsStreamingOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupNatsStreamingOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupNatsStreamingOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupNatsStreamingOptions;
        })();

        opts.RelayGroupNatsJetStreamOptions = (function() {

            /**
             * Properties of a RelayGroupNatsJetStreamOptions.
             * @memberof protos.opts
             * @interface IRelayGroupNatsJetStreamOptions
             * @property {protos.args.INatsJetstreamConn|null} [_conn] RelayGroupNatsJetStreamOptions _conn
             * @property {protos.args.INatsJetstreamReadArgs|null} [args] RelayGroupNatsJetStreamOptions args
             */

            /**
             * Constructs a new RelayGroupNatsJetStreamOptions.
             * @memberof protos.opts
             * @classdesc Represents a RelayGroupNatsJetStreamOptions.
             * @implements IRelayGroupNatsJetStreamOptions
             * @constructor
             * @param {protos.opts.IRelayGroupNatsJetStreamOptions=} [properties] Properties to set
             */
            function RelayGroupNatsJetStreamOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RelayGroupNatsJetStreamOptions _conn.
             * @member {protos.args.INatsJetstreamConn|null|undefined} _conn
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @instance
             */
            RelayGroupNatsJetStreamOptions.prototype._conn = null;

            /**
             * RelayGroupNatsJetStreamOptions args.
             * @member {protos.args.INatsJetstreamReadArgs|null|undefined} args
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @instance
             */
            RelayGroupNatsJetStreamOptions.prototype.args = null;

            /**
             * Creates a new RelayGroupNatsJetStreamOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @static
             * @param {protos.opts.IRelayGroupNatsJetStreamOptions=} [properties] Properties to set
             * @returns {protos.opts.RelayGroupNatsJetStreamOptions} RelayGroupNatsJetStreamOptions instance
             */
            RelayGroupNatsJetStreamOptions.create = function create(properties) {
                return new RelayGroupNatsJetStreamOptions(properties);
            };

            /**
             * Encodes the specified RelayGroupNatsJetStreamOptions message. Does not implicitly {@link protos.opts.RelayGroupNatsJetStreamOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @static
             * @param {protos.opts.IRelayGroupNatsJetStreamOptions} message RelayGroupNatsJetStreamOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupNatsJetStreamOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsJetstreamConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsJetstreamReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RelayGroupNatsJetStreamOptions message, length delimited. Does not implicitly {@link protos.opts.RelayGroupNatsJetStreamOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @static
             * @param {protos.opts.IRelayGroupNatsJetStreamOptions} message RelayGroupNatsJetStreamOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelayGroupNatsJetStreamOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RelayGroupNatsJetStreamOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.RelayGroupNatsJetStreamOptions} RelayGroupNatsJetStreamOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupNatsJetStreamOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.RelayGroupNatsJetStreamOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsJetstreamConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsJetstreamReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RelayGroupNatsJetStreamOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.RelayGroupNatsJetStreamOptions} RelayGroupNatsJetStreamOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelayGroupNatsJetStreamOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RelayGroupNatsJetStreamOptions message.
             * @function verify
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RelayGroupNatsJetStreamOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsJetstreamConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsJetstreamReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a RelayGroupNatsJetStreamOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.RelayGroupNatsJetStreamOptions} RelayGroupNatsJetStreamOptions
             */
            RelayGroupNatsJetStreamOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.RelayGroupNatsJetStreamOptions)
                    return object;
                var message = new $root.protos.opts.RelayGroupNatsJetStreamOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.RelayGroupNatsJetStreamOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsJetstreamConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.RelayGroupNatsJetStreamOptions.args: object expected");
                    message.args = $root.protos.args.NatsJetstreamReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a RelayGroupNatsJetStreamOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @static
             * @param {protos.opts.RelayGroupNatsJetStreamOptions} message RelayGroupNatsJetStreamOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RelayGroupNatsJetStreamOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsJetstreamConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsJetstreamReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this RelayGroupNatsJetStreamOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.RelayGroupNatsJetStreamOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RelayGroupNatsJetStreamOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RelayGroupNatsJetStreamOptions;
        })();

        opts.ServerOptions = (function() {

            /**
             * Properties of a ServerOptions.
             * @memberof protos.opts
             * @interface IServerOptions
             * @property {string|null} [nodeId] ServerOptions nodeId
             * @property {string|null} [clusterId] ServerOptions clusterId
             * @property {string|null} [grpcListenAddress] ServerOptions grpcListenAddress
             * @property {string|null} [authToken] ServerOptions authToken
             * @property {Array.<string>|null} [natsUrl] ServerOptions natsUrl
             * @property {boolean|null} [useTls] ServerOptions useTls
             * @property {string|null} [tlsCertFile] ServerOptions tlsCertFile
             * @property {string|null} [tlsKeyFile] ServerOptions tlsKeyFile
             * @property {string|null} [tlsCaFile] ServerOptions tlsCaFile
             * @property {boolean|null} [tlsSkipVerify] ServerOptions tlsSkipVerify
             * @property {boolean|null} [enableCluster] ServerOptions enableCluster
             * @property {string|null} [vcserviceGrpcAddress] ServerOptions vcserviceGrpcAddress
             * @property {number|null} [vcserviceGrpcTimeoutSeconds] ServerOptions vcserviceGrpcTimeoutSeconds
             * @property {boolean|null} [vcserviceGrpcInsecure] ServerOptions vcserviceGrpcInsecure
             * @property {string|null} [statsDatabasePath] ServerOptions statsDatabasePath
             * @property {number|null} [statsFlushIntervalSeconds] ServerOptions statsFlushIntervalSeconds
             * @property {string|null} [httpListenAddress] ServerOptions httpListenAddress
             * @property {string|null} [storagePath] ServerOptions storagePath
             */

            /**
             * Constructs a new ServerOptions.
             * @memberof protos.opts
             * @classdesc Represents a ServerOptions.
             * @implements IServerOptions
             * @constructor
             * @param {protos.opts.IServerOptions=} [properties] Properties to set
             */
            function ServerOptions(properties) {
                this.natsUrl = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServerOptions nodeId.
             * @member {string} nodeId
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.nodeId = "";

            /**
             * ServerOptions clusterId.
             * @member {string} clusterId
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.clusterId = "";

            /**
             * ServerOptions grpcListenAddress.
             * @member {string} grpcListenAddress
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.grpcListenAddress = "";

            /**
             * ServerOptions authToken.
             * @member {string} authToken
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.authToken = "";

            /**
             * ServerOptions natsUrl.
             * @member {Array.<string>} natsUrl
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.natsUrl = $util.emptyArray;

            /**
             * ServerOptions useTls.
             * @member {boolean} useTls
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.useTls = false;

            /**
             * ServerOptions tlsCertFile.
             * @member {string} tlsCertFile
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.tlsCertFile = "";

            /**
             * ServerOptions tlsKeyFile.
             * @member {string} tlsKeyFile
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.tlsKeyFile = "";

            /**
             * ServerOptions tlsCaFile.
             * @member {string} tlsCaFile
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.tlsCaFile = "";

            /**
             * ServerOptions tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.tlsSkipVerify = false;

            /**
             * ServerOptions enableCluster.
             * @member {boolean} enableCluster
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.enableCluster = false;

            /**
             * ServerOptions vcserviceGrpcAddress.
             * @member {string} vcserviceGrpcAddress
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.vcserviceGrpcAddress = "";

            /**
             * ServerOptions vcserviceGrpcTimeoutSeconds.
             * @member {number} vcserviceGrpcTimeoutSeconds
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.vcserviceGrpcTimeoutSeconds = 0;

            /**
             * ServerOptions vcserviceGrpcInsecure.
             * @member {boolean} vcserviceGrpcInsecure
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.vcserviceGrpcInsecure = false;

            /**
             * ServerOptions statsDatabasePath.
             * @member {string} statsDatabasePath
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.statsDatabasePath = "";

            /**
             * ServerOptions statsFlushIntervalSeconds.
             * @member {number} statsFlushIntervalSeconds
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.statsFlushIntervalSeconds = 0;

            /**
             * ServerOptions httpListenAddress.
             * @member {string} httpListenAddress
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.httpListenAddress = "";

            /**
             * ServerOptions storagePath.
             * @member {string} storagePath
             * @memberof protos.opts.ServerOptions
             * @instance
             */
            ServerOptions.prototype.storagePath = "";

            /**
             * Creates a new ServerOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {protos.opts.IServerOptions=} [properties] Properties to set
             * @returns {protos.opts.ServerOptions} ServerOptions instance
             */
            ServerOptions.create = function create(properties) {
                return new ServerOptions(properties);
            };

            /**
             * Encodes the specified ServerOptions message. Does not implicitly {@link protos.opts.ServerOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {protos.opts.IServerOptions} message ServerOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServerOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nodeId);
                if (message.clusterId != null && Object.hasOwnProperty.call(message, "clusterId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.clusterId);
                if (message.grpcListenAddress != null && Object.hasOwnProperty.call(message, "grpcListenAddress"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.grpcListenAddress);
                if (message.authToken != null && Object.hasOwnProperty.call(message, "authToken"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.authToken);
                if (message.natsUrl != null && message.natsUrl.length)
                    for (var i = 0; i < message.natsUrl.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.natsUrl[i]);
                if (message.tlsCertFile != null && Object.hasOwnProperty.call(message, "tlsCertFile"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.tlsCertFile);
                if (message.tlsKeyFile != null && Object.hasOwnProperty.call(message, "tlsKeyFile"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.tlsKeyFile);
                if (message.tlsCaFile != null && Object.hasOwnProperty.call(message, "tlsCaFile"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.tlsCaFile);
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.tlsSkipVerify);
                if (message.enableCluster != null && Object.hasOwnProperty.call(message, "enableCluster"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.enableCluster);
                if (message.vcserviceGrpcAddress != null && Object.hasOwnProperty.call(message, "vcserviceGrpcAddress"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.vcserviceGrpcAddress);
                if (message.vcserviceGrpcTimeoutSeconds != null && Object.hasOwnProperty.call(message, "vcserviceGrpcTimeoutSeconds"))
                    writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.vcserviceGrpcTimeoutSeconds);
                if (message.vcserviceGrpcInsecure != null && Object.hasOwnProperty.call(message, "vcserviceGrpcInsecure"))
                    writer.uint32(/* id 13, wireType 0 =*/104).bool(message.vcserviceGrpcInsecure);
                if (message.statsDatabasePath != null && Object.hasOwnProperty.call(message, "statsDatabasePath"))
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.statsDatabasePath);
                if (message.statsFlushIntervalSeconds != null && Object.hasOwnProperty.call(message, "statsFlushIntervalSeconds"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.statsFlushIntervalSeconds);
                if (message.httpListenAddress != null && Object.hasOwnProperty.call(message, "httpListenAddress"))
                    writer.uint32(/* id 16, wireType 2 =*/130).string(message.httpListenAddress);
                if (message.storagePath != null && Object.hasOwnProperty.call(message, "storagePath"))
                    writer.uint32(/* id 17, wireType 2 =*/138).string(message.storagePath);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 500, wireType 0 =*/4000).bool(message.useTls);
                return writer;
            };

            /**
             * Encodes the specified ServerOptions message, length delimited. Does not implicitly {@link protos.opts.ServerOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {protos.opts.IServerOptions} message ServerOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServerOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServerOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ServerOptions} ServerOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServerOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ServerOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nodeId = reader.string();
                        break;
                    case 2:
                        message.clusterId = reader.string();
                        break;
                    case 3:
                        message.grpcListenAddress = reader.string();
                        break;
                    case 4:
                        message.authToken = reader.string();
                        break;
                    case 5:
                        if (!(message.natsUrl && message.natsUrl.length))
                            message.natsUrl = [];
                        message.natsUrl.push(reader.string());
                        break;
                    case 500:
                        message.useTls = reader.bool();
                        break;
                    case 6:
                        message.tlsCertFile = reader.string();
                        break;
                    case 7:
                        message.tlsKeyFile = reader.string();
                        break;
                    case 8:
                        message.tlsCaFile = reader.string();
                        break;
                    case 9:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    case 10:
                        message.enableCluster = reader.bool();
                        break;
                    case 11:
                        message.vcserviceGrpcAddress = reader.string();
                        break;
                    case 12:
                        message.vcserviceGrpcTimeoutSeconds = reader.uint32();
                        break;
                    case 13:
                        message.vcserviceGrpcInsecure = reader.bool();
                        break;
                    case 14:
                        message.statsDatabasePath = reader.string();
                        break;
                    case 15:
                        message.statsFlushIntervalSeconds = reader.int32();
                        break;
                    case 16:
                        message.httpListenAddress = reader.string();
                        break;
                    case 17:
                        message.storagePath = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServerOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ServerOptions} ServerOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServerOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServerOptions message.
             * @function verify
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServerOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    if (!$util.isString(message.nodeId))
                        return "nodeId: string expected";
                if (message.clusterId != null && message.hasOwnProperty("clusterId"))
                    if (!$util.isString(message.clusterId))
                        return "clusterId: string expected";
                if (message.grpcListenAddress != null && message.hasOwnProperty("grpcListenAddress"))
                    if (!$util.isString(message.grpcListenAddress))
                        return "grpcListenAddress: string expected";
                if (message.authToken != null && message.hasOwnProperty("authToken"))
                    if (!$util.isString(message.authToken))
                        return "authToken: string expected";
                if (message.natsUrl != null && message.hasOwnProperty("natsUrl")) {
                    if (!Array.isArray(message.natsUrl))
                        return "natsUrl: array expected";
                    for (var i = 0; i < message.natsUrl.length; ++i)
                        if (!$util.isString(message.natsUrl[i]))
                            return "natsUrl: string[] expected";
                }
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.tlsCertFile != null && message.hasOwnProperty("tlsCertFile"))
                    if (!$util.isString(message.tlsCertFile))
                        return "tlsCertFile: string expected";
                if (message.tlsKeyFile != null && message.hasOwnProperty("tlsKeyFile"))
                    if (!$util.isString(message.tlsKeyFile))
                        return "tlsKeyFile: string expected";
                if (message.tlsCaFile != null && message.hasOwnProperty("tlsCaFile"))
                    if (!$util.isString(message.tlsCaFile))
                        return "tlsCaFile: string expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                if (message.enableCluster != null && message.hasOwnProperty("enableCluster"))
                    if (typeof message.enableCluster !== "boolean")
                        return "enableCluster: boolean expected";
                if (message.vcserviceGrpcAddress != null && message.hasOwnProperty("vcserviceGrpcAddress"))
                    if (!$util.isString(message.vcserviceGrpcAddress))
                        return "vcserviceGrpcAddress: string expected";
                if (message.vcserviceGrpcTimeoutSeconds != null && message.hasOwnProperty("vcserviceGrpcTimeoutSeconds"))
                    if (!$util.isInteger(message.vcserviceGrpcTimeoutSeconds))
                        return "vcserviceGrpcTimeoutSeconds: integer expected";
                if (message.vcserviceGrpcInsecure != null && message.hasOwnProperty("vcserviceGrpcInsecure"))
                    if (typeof message.vcserviceGrpcInsecure !== "boolean")
                        return "vcserviceGrpcInsecure: boolean expected";
                if (message.statsDatabasePath != null && message.hasOwnProperty("statsDatabasePath"))
                    if (!$util.isString(message.statsDatabasePath))
                        return "statsDatabasePath: string expected";
                if (message.statsFlushIntervalSeconds != null && message.hasOwnProperty("statsFlushIntervalSeconds"))
                    if (!$util.isInteger(message.statsFlushIntervalSeconds))
                        return "statsFlushIntervalSeconds: integer expected";
                if (message.httpListenAddress != null && message.hasOwnProperty("httpListenAddress"))
                    if (!$util.isString(message.httpListenAddress))
                        return "httpListenAddress: string expected";
                if (message.storagePath != null && message.hasOwnProperty("storagePath"))
                    if (!$util.isString(message.storagePath))
                        return "storagePath: string expected";
                return null;
            };

            /**
             * Creates a ServerOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ServerOptions} ServerOptions
             */
            ServerOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ServerOptions)
                    return object;
                var message = new $root.protos.opts.ServerOptions();
                if (object.nodeId != null)
                    message.nodeId = String(object.nodeId);
                if (object.clusterId != null)
                    message.clusterId = String(object.clusterId);
                if (object.grpcListenAddress != null)
                    message.grpcListenAddress = String(object.grpcListenAddress);
                if (object.authToken != null)
                    message.authToken = String(object.authToken);
                if (object.natsUrl) {
                    if (!Array.isArray(object.natsUrl))
                        throw TypeError(".protos.opts.ServerOptions.natsUrl: array expected");
                    message.natsUrl = [];
                    for (var i = 0; i < object.natsUrl.length; ++i)
                        message.natsUrl[i] = String(object.natsUrl[i]);
                }
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.tlsCertFile != null)
                    message.tlsCertFile = String(object.tlsCertFile);
                if (object.tlsKeyFile != null)
                    message.tlsKeyFile = String(object.tlsKeyFile);
                if (object.tlsCaFile != null)
                    message.tlsCaFile = String(object.tlsCaFile);
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                if (object.enableCluster != null)
                    message.enableCluster = Boolean(object.enableCluster);
                if (object.vcserviceGrpcAddress != null)
                    message.vcserviceGrpcAddress = String(object.vcserviceGrpcAddress);
                if (object.vcserviceGrpcTimeoutSeconds != null)
                    message.vcserviceGrpcTimeoutSeconds = object.vcserviceGrpcTimeoutSeconds >>> 0;
                if (object.vcserviceGrpcInsecure != null)
                    message.vcserviceGrpcInsecure = Boolean(object.vcserviceGrpcInsecure);
                if (object.statsDatabasePath != null)
                    message.statsDatabasePath = String(object.statsDatabasePath);
                if (object.statsFlushIntervalSeconds != null)
                    message.statsFlushIntervalSeconds = object.statsFlushIntervalSeconds | 0;
                if (object.httpListenAddress != null)
                    message.httpListenAddress = String(object.httpListenAddress);
                if (object.storagePath != null)
                    message.storagePath = String(object.storagePath);
                return message;
            };

            /**
             * Creates a plain object from a ServerOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ServerOptions
             * @static
             * @param {protos.opts.ServerOptions} message ServerOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServerOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.natsUrl = [];
                if (options.defaults) {
                    object.nodeId = "";
                    object.clusterId = "";
                    object.grpcListenAddress = "";
                    object.authToken = "";
                    object.tlsCertFile = "";
                    object.tlsKeyFile = "";
                    object.tlsCaFile = "";
                    object.tlsSkipVerify = false;
                    object.enableCluster = false;
                    object.vcserviceGrpcAddress = "";
                    object.vcserviceGrpcTimeoutSeconds = 0;
                    object.vcserviceGrpcInsecure = false;
                    object.statsDatabasePath = "";
                    object.statsFlushIntervalSeconds = 0;
                    object.httpListenAddress = "";
                    object.storagePath = "";
                    object.useTls = false;
                }
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    object.nodeId = message.nodeId;
                if (message.clusterId != null && message.hasOwnProperty("clusterId"))
                    object.clusterId = message.clusterId;
                if (message.grpcListenAddress != null && message.hasOwnProperty("grpcListenAddress"))
                    object.grpcListenAddress = message.grpcListenAddress;
                if (message.authToken != null && message.hasOwnProperty("authToken"))
                    object.authToken = message.authToken;
                if (message.natsUrl && message.natsUrl.length) {
                    object.natsUrl = [];
                    for (var j = 0; j < message.natsUrl.length; ++j)
                        object.natsUrl[j] = message.natsUrl[j];
                }
                if (message.tlsCertFile != null && message.hasOwnProperty("tlsCertFile"))
                    object.tlsCertFile = message.tlsCertFile;
                if (message.tlsKeyFile != null && message.hasOwnProperty("tlsKeyFile"))
                    object.tlsKeyFile = message.tlsKeyFile;
                if (message.tlsCaFile != null && message.hasOwnProperty("tlsCaFile"))
                    object.tlsCaFile = message.tlsCaFile;
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                if (message.enableCluster != null && message.hasOwnProperty("enableCluster"))
                    object.enableCluster = message.enableCluster;
                if (message.vcserviceGrpcAddress != null && message.hasOwnProperty("vcserviceGrpcAddress"))
                    object.vcserviceGrpcAddress = message.vcserviceGrpcAddress;
                if (message.vcserviceGrpcTimeoutSeconds != null && message.hasOwnProperty("vcserviceGrpcTimeoutSeconds"))
                    object.vcserviceGrpcTimeoutSeconds = message.vcserviceGrpcTimeoutSeconds;
                if (message.vcserviceGrpcInsecure != null && message.hasOwnProperty("vcserviceGrpcInsecure"))
                    object.vcserviceGrpcInsecure = message.vcserviceGrpcInsecure;
                if (message.statsDatabasePath != null && message.hasOwnProperty("statsDatabasePath"))
                    object.statsDatabasePath = message.statsDatabasePath;
                if (message.statsFlushIntervalSeconds != null && message.hasOwnProperty("statsFlushIntervalSeconds"))
                    object.statsFlushIntervalSeconds = message.statsFlushIntervalSeconds;
                if (message.httpListenAddress != null && message.hasOwnProperty("httpListenAddress"))
                    object.httpListenAddress = message.httpListenAddress;
                if (message.storagePath != null && message.hasOwnProperty("storagePath"))
                    object.storagePath = message.storagePath;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                return object;
            };

            /**
             * Converts this ServerOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ServerOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServerOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServerOptions;
        })();

        /**
         * BatchOutputType enum.
         * @name protos.opts.BatchOutputType
         * @enum {number}
         * @property {number} TABLE=0 TABLE value
         * @property {number} JSON=1 JSON value
         */
        opts.BatchOutputType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "TABLE"] = 0;
            values[valuesById[1] = "JSON"] = 1;
            return values;
        })();

        /**
         * BatchReplayType enum.
         * @name protos.opts.BatchReplayType
         * @enum {number}
         * @property {number} SINGLE=0 SINGLE value
         * @property {number} CONTINUOUS=1 CONTINUOUS value
         */
        opts.BatchReplayType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SINGLE"] = 0;
            values[valuesById[1] = "CONTINUOUS"] = 1;
            return values;
        })();

        opts.BatchOptions = (function() {

            /**
             * Properties of a BatchOptions.
             * @memberof protos.opts
             * @interface IBatchOptions
             * @property {protos.opts.BatchOutputType|null} [outputType] BatchOptions outputType
             * @property {string|null} [apiUrl] BatchOptions apiUrl
             * @property {protos.opts.IBatchLoginOptions|null} [login] BatchOptions login
             * @property {protos.opts.IBatchLogoutOptions|null} [logout] BatchOptions logout
             * @property {protos.opts.IBatchListOptions|null} [list] BatchOptions list
             * @property {protos.opts.IBatchCreateOptions|null} [create] BatchOptions create
             * @property {protos.opts.IBatchSearchOptions|null} [search] BatchOptions search
             * @property {protos.opts.IBatchArchiveOptions|null} [archive] BatchOptions archive
             */

            /**
             * Constructs a new BatchOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchOptions.
             * @implements IBatchOptions
             * @constructor
             * @param {protos.opts.IBatchOptions=} [properties] Properties to set
             */
            function BatchOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchOptions outputType.
             * @member {protos.opts.BatchOutputType} outputType
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.outputType = 0;

            /**
             * BatchOptions apiUrl.
             * @member {string} apiUrl
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.apiUrl = "";

            /**
             * BatchOptions login.
             * @member {protos.opts.IBatchLoginOptions|null|undefined} login
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.login = null;

            /**
             * BatchOptions logout.
             * @member {protos.opts.IBatchLogoutOptions|null|undefined} logout
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.logout = null;

            /**
             * BatchOptions list.
             * @member {protos.opts.IBatchListOptions|null|undefined} list
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.list = null;

            /**
             * BatchOptions create.
             * @member {protos.opts.IBatchCreateOptions|null|undefined} create
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.create = null;

            /**
             * BatchOptions search.
             * @member {protos.opts.IBatchSearchOptions|null|undefined} search
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.search = null;

            /**
             * BatchOptions archive.
             * @member {protos.opts.IBatchArchiveOptions|null|undefined} archive
             * @memberof protos.opts.BatchOptions
             * @instance
             */
            BatchOptions.prototype.archive = null;

            /**
             * Creates a new BatchOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {protos.opts.IBatchOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchOptions} BatchOptions instance
             */
            BatchOptions.create = function create(properties) {
                return new BatchOptions(properties);
            };

            /**
             * Encodes the specified BatchOptions message. Does not implicitly {@link protos.opts.BatchOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {protos.opts.IBatchOptions} message BatchOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.outputType != null && Object.hasOwnProperty.call(message, "outputType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.outputType);
                if (message.apiUrl != null && Object.hasOwnProperty.call(message, "apiUrl"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.apiUrl);
                if (message.login != null && Object.hasOwnProperty.call(message, "login"))
                    $root.protos.opts.BatchLoginOptions.encode(message.login, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.logout != null && Object.hasOwnProperty.call(message, "logout"))
                    $root.protos.opts.BatchLogoutOptions.encode(message.logout, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.list != null && Object.hasOwnProperty.call(message, "list"))
                    $root.protos.opts.BatchListOptions.encode(message.list, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.create != null && Object.hasOwnProperty.call(message, "create"))
                    $root.protos.opts.BatchCreateOptions.encode(message.create, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.search != null && Object.hasOwnProperty.call(message, "search"))
                    $root.protos.opts.BatchSearchOptions.encode(message.search, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.archive != null && Object.hasOwnProperty.call(message, "archive"))
                    $root.protos.opts.BatchArchiveOptions.encode(message.archive, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BatchOptions message, length delimited. Does not implicitly {@link protos.opts.BatchOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {protos.opts.IBatchOptions} message BatchOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchOptions} BatchOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.outputType = reader.int32();
                        break;
                    case 2:
                        message.apiUrl = reader.string();
                        break;
                    case 3:
                        message.login = $root.protos.opts.BatchLoginOptions.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.logout = $root.protos.opts.BatchLogoutOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.list = $root.protos.opts.BatchListOptions.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.create = $root.protos.opts.BatchCreateOptions.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.search = $root.protos.opts.BatchSearchOptions.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.archive = $root.protos.opts.BatchArchiveOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchOptions} BatchOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchOptions message.
             * @function verify
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    switch (message.outputType) {
                    default:
                        return "outputType: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.apiUrl != null && message.hasOwnProperty("apiUrl"))
                    if (!$util.isString(message.apiUrl))
                        return "apiUrl: string expected";
                if (message.login != null && message.hasOwnProperty("login")) {
                    var error = $root.protos.opts.BatchLoginOptions.verify(message.login);
                    if (error)
                        return "login." + error;
                }
                if (message.logout != null && message.hasOwnProperty("logout")) {
                    var error = $root.protos.opts.BatchLogoutOptions.verify(message.logout);
                    if (error)
                        return "logout." + error;
                }
                if (message.list != null && message.hasOwnProperty("list")) {
                    var error = $root.protos.opts.BatchListOptions.verify(message.list);
                    if (error)
                        return "list." + error;
                }
                if (message.create != null && message.hasOwnProperty("create")) {
                    var error = $root.protos.opts.BatchCreateOptions.verify(message.create);
                    if (error)
                        return "create." + error;
                }
                if (message.search != null && message.hasOwnProperty("search")) {
                    var error = $root.protos.opts.BatchSearchOptions.verify(message.search);
                    if (error)
                        return "search." + error;
                }
                if (message.archive != null && message.hasOwnProperty("archive")) {
                    var error = $root.protos.opts.BatchArchiveOptions.verify(message.archive);
                    if (error)
                        return "archive." + error;
                }
                return null;
            };

            /**
             * Creates a BatchOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchOptions} BatchOptions
             */
            BatchOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchOptions)
                    return object;
                var message = new $root.protos.opts.BatchOptions();
                switch (object.outputType) {
                case "TABLE":
                case 0:
                    message.outputType = 0;
                    break;
                case "JSON":
                case 1:
                    message.outputType = 1;
                    break;
                }
                if (object.apiUrl != null)
                    message.apiUrl = String(object.apiUrl);
                if (object.login != null) {
                    if (typeof object.login !== "object")
                        throw TypeError(".protos.opts.BatchOptions.login: object expected");
                    message.login = $root.protos.opts.BatchLoginOptions.fromObject(object.login);
                }
                if (object.logout != null) {
                    if (typeof object.logout !== "object")
                        throw TypeError(".protos.opts.BatchOptions.logout: object expected");
                    message.logout = $root.protos.opts.BatchLogoutOptions.fromObject(object.logout);
                }
                if (object.list != null) {
                    if (typeof object.list !== "object")
                        throw TypeError(".protos.opts.BatchOptions.list: object expected");
                    message.list = $root.protos.opts.BatchListOptions.fromObject(object.list);
                }
                if (object.create != null) {
                    if (typeof object.create !== "object")
                        throw TypeError(".protos.opts.BatchOptions.create: object expected");
                    message.create = $root.protos.opts.BatchCreateOptions.fromObject(object.create);
                }
                if (object.search != null) {
                    if (typeof object.search !== "object")
                        throw TypeError(".protos.opts.BatchOptions.search: object expected");
                    message.search = $root.protos.opts.BatchSearchOptions.fromObject(object.search);
                }
                if (object.archive != null) {
                    if (typeof object.archive !== "object")
                        throw TypeError(".protos.opts.BatchOptions.archive: object expected");
                    message.archive = $root.protos.opts.BatchArchiveOptions.fromObject(object.archive);
                }
                return message;
            };

            /**
             * Creates a plain object from a BatchOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchOptions
             * @static
             * @param {protos.opts.BatchOptions} message BatchOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.outputType = options.enums === String ? "TABLE" : 0;
                    object.apiUrl = "";
                    object.login = null;
                    object.logout = null;
                    object.list = null;
                    object.create = null;
                    object.search = null;
                    object.archive = null;
                }
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    object.outputType = options.enums === String ? $root.protos.opts.BatchOutputType[message.outputType] : message.outputType;
                if (message.apiUrl != null && message.hasOwnProperty("apiUrl"))
                    object.apiUrl = message.apiUrl;
                if (message.login != null && message.hasOwnProperty("login"))
                    object.login = $root.protos.opts.BatchLoginOptions.toObject(message.login, options);
                if (message.logout != null && message.hasOwnProperty("logout"))
                    object.logout = $root.protos.opts.BatchLogoutOptions.toObject(message.logout, options);
                if (message.list != null && message.hasOwnProperty("list"))
                    object.list = $root.protos.opts.BatchListOptions.toObject(message.list, options);
                if (message.create != null && message.hasOwnProperty("create"))
                    object.create = $root.protos.opts.BatchCreateOptions.toObject(message.create, options);
                if (message.search != null && message.hasOwnProperty("search"))
                    object.search = $root.protos.opts.BatchSearchOptions.toObject(message.search, options);
                if (message.archive != null && message.hasOwnProperty("archive"))
                    object.archive = $root.protos.opts.BatchArchiveOptions.toObject(message.archive, options);
                return object;
            };

            /**
             * Converts this BatchOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchOptions;
        })();

        opts.BatchLoginOptions = (function() {

            /**
             * Properties of a BatchLoginOptions.
             * @memberof protos.opts
             * @interface IBatchLoginOptions
             */

            /**
             * Constructs a new BatchLoginOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchLoginOptions.
             * @implements IBatchLoginOptions
             * @constructor
             * @param {protos.opts.IBatchLoginOptions=} [properties] Properties to set
             */
            function BatchLoginOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new BatchLoginOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {protos.opts.IBatchLoginOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchLoginOptions} BatchLoginOptions instance
             */
            BatchLoginOptions.create = function create(properties) {
                return new BatchLoginOptions(properties);
            };

            /**
             * Encodes the specified BatchLoginOptions message. Does not implicitly {@link protos.opts.BatchLoginOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {protos.opts.IBatchLoginOptions} message BatchLoginOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchLoginOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified BatchLoginOptions message, length delimited. Does not implicitly {@link protos.opts.BatchLoginOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {protos.opts.IBatchLoginOptions} message BatchLoginOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchLoginOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchLoginOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchLoginOptions} BatchLoginOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchLoginOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchLoginOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchLoginOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchLoginOptions} BatchLoginOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchLoginOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchLoginOptions message.
             * @function verify
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchLoginOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a BatchLoginOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchLoginOptions} BatchLoginOptions
             */
            BatchLoginOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchLoginOptions)
                    return object;
                return new $root.protos.opts.BatchLoginOptions();
            };

            /**
             * Creates a plain object from a BatchLoginOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchLoginOptions
             * @static
             * @param {protos.opts.BatchLoginOptions} message BatchLoginOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchLoginOptions.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this BatchLoginOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchLoginOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchLoginOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchLoginOptions;
        })();

        opts.BatchLogoutOptions = (function() {

            /**
             * Properties of a BatchLogoutOptions.
             * @memberof protos.opts
             * @interface IBatchLogoutOptions
             */

            /**
             * Constructs a new BatchLogoutOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchLogoutOptions.
             * @implements IBatchLogoutOptions
             * @constructor
             * @param {protos.opts.IBatchLogoutOptions=} [properties] Properties to set
             */
            function BatchLogoutOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new BatchLogoutOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {protos.opts.IBatchLogoutOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchLogoutOptions} BatchLogoutOptions instance
             */
            BatchLogoutOptions.create = function create(properties) {
                return new BatchLogoutOptions(properties);
            };

            /**
             * Encodes the specified BatchLogoutOptions message. Does not implicitly {@link protos.opts.BatchLogoutOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {protos.opts.IBatchLogoutOptions} message BatchLogoutOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchLogoutOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified BatchLogoutOptions message, length delimited. Does not implicitly {@link protos.opts.BatchLogoutOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {protos.opts.IBatchLogoutOptions} message BatchLogoutOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchLogoutOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchLogoutOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchLogoutOptions} BatchLogoutOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchLogoutOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchLogoutOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchLogoutOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchLogoutOptions} BatchLogoutOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchLogoutOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchLogoutOptions message.
             * @function verify
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchLogoutOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a BatchLogoutOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchLogoutOptions} BatchLogoutOptions
             */
            BatchLogoutOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchLogoutOptions)
                    return object;
                return new $root.protos.opts.BatchLogoutOptions();
            };

            /**
             * Creates a plain object from a BatchLogoutOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchLogoutOptions
             * @static
             * @param {protos.opts.BatchLogoutOptions} message BatchLogoutOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchLogoutOptions.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this BatchLogoutOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchLogoutOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchLogoutOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchLogoutOptions;
        })();

        opts.BatchListCollectionOptions = (function() {

            /**
             * Properties of a BatchListCollectionOptions.
             * @memberof protos.opts
             * @interface IBatchListCollectionOptions
             */

            /**
             * Constructs a new BatchListCollectionOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchListCollectionOptions.
             * @implements IBatchListCollectionOptions
             * @constructor
             * @param {protos.opts.IBatchListCollectionOptions=} [properties] Properties to set
             */
            function BatchListCollectionOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new BatchListCollectionOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchListCollectionOptions
             * @static
             * @param {protos.opts.IBatchListCollectionOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchListCollectionOptions} BatchListCollectionOptions instance
             */
            BatchListCollectionOptions.create = function create(properties) {
                return new BatchListCollectionOptions(properties);
            };

            /**
             * Encodes the specified BatchListCollectionOptions message. Does not implicitly {@link protos.opts.BatchListCollectionOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchListCollectionOptions
             * @static
             * @param {protos.opts.IBatchListCollectionOptions} message BatchListCollectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchListCollectionOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified BatchListCollectionOptions message, length delimited. Does not implicitly {@link protos.opts.BatchListCollectionOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchListCollectionOptions
             * @static
             * @param {protos.opts.IBatchListCollectionOptions} message BatchListCollectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchListCollectionOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchListCollectionOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchListCollectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchListCollectionOptions} BatchListCollectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchListCollectionOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchListCollectionOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchListCollectionOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchListCollectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchListCollectionOptions} BatchListCollectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchListCollectionOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchListCollectionOptions message.
             * @function verify
             * @memberof protos.opts.BatchListCollectionOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchListCollectionOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a BatchListCollectionOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchListCollectionOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchListCollectionOptions} BatchListCollectionOptions
             */
            BatchListCollectionOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchListCollectionOptions)
                    return object;
                return new $root.protos.opts.BatchListCollectionOptions();
            };

            /**
             * Creates a plain object from a BatchListCollectionOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchListCollectionOptions
             * @static
             * @param {protos.opts.BatchListCollectionOptions} message BatchListCollectionOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchListCollectionOptions.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this BatchListCollectionOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchListCollectionOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchListCollectionOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchListCollectionOptions;
        })();

        opts.BatchListDestinationOptions = (function() {

            /**
             * Properties of a BatchListDestinationOptions.
             * @memberof protos.opts
             * @interface IBatchListDestinationOptions
             */

            /**
             * Constructs a new BatchListDestinationOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchListDestinationOptions.
             * @implements IBatchListDestinationOptions
             * @constructor
             * @param {protos.opts.IBatchListDestinationOptions=} [properties] Properties to set
             */
            function BatchListDestinationOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new BatchListDestinationOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchListDestinationOptions
             * @static
             * @param {protos.opts.IBatchListDestinationOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchListDestinationOptions} BatchListDestinationOptions instance
             */
            BatchListDestinationOptions.create = function create(properties) {
                return new BatchListDestinationOptions(properties);
            };

            /**
             * Encodes the specified BatchListDestinationOptions message. Does not implicitly {@link protos.opts.BatchListDestinationOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchListDestinationOptions
             * @static
             * @param {protos.opts.IBatchListDestinationOptions} message BatchListDestinationOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchListDestinationOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified BatchListDestinationOptions message, length delimited. Does not implicitly {@link protos.opts.BatchListDestinationOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchListDestinationOptions
             * @static
             * @param {protos.opts.IBatchListDestinationOptions} message BatchListDestinationOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchListDestinationOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchListDestinationOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchListDestinationOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchListDestinationOptions} BatchListDestinationOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchListDestinationOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchListDestinationOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchListDestinationOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchListDestinationOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchListDestinationOptions} BatchListDestinationOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchListDestinationOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchListDestinationOptions message.
             * @function verify
             * @memberof protos.opts.BatchListDestinationOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchListDestinationOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a BatchListDestinationOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchListDestinationOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchListDestinationOptions} BatchListDestinationOptions
             */
            BatchListDestinationOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchListDestinationOptions)
                    return object;
                return new $root.protos.opts.BatchListDestinationOptions();
            };

            /**
             * Creates a plain object from a BatchListDestinationOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchListDestinationOptions
             * @static
             * @param {protos.opts.BatchListDestinationOptions} message BatchListDestinationOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchListDestinationOptions.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this BatchListDestinationOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchListDestinationOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchListDestinationOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchListDestinationOptions;
        })();

        opts.BatchListSchemaOptions = (function() {

            /**
             * Properties of a BatchListSchemaOptions.
             * @memberof protos.opts
             * @interface IBatchListSchemaOptions
             */

            /**
             * Constructs a new BatchListSchemaOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchListSchemaOptions.
             * @implements IBatchListSchemaOptions
             * @constructor
             * @param {protos.opts.IBatchListSchemaOptions=} [properties] Properties to set
             */
            function BatchListSchemaOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new BatchListSchemaOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchListSchemaOptions
             * @static
             * @param {protos.opts.IBatchListSchemaOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchListSchemaOptions} BatchListSchemaOptions instance
             */
            BatchListSchemaOptions.create = function create(properties) {
                return new BatchListSchemaOptions(properties);
            };

            /**
             * Encodes the specified BatchListSchemaOptions message. Does not implicitly {@link protos.opts.BatchListSchemaOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchListSchemaOptions
             * @static
             * @param {protos.opts.IBatchListSchemaOptions} message BatchListSchemaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchListSchemaOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified BatchListSchemaOptions message, length delimited. Does not implicitly {@link protos.opts.BatchListSchemaOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchListSchemaOptions
             * @static
             * @param {protos.opts.IBatchListSchemaOptions} message BatchListSchemaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchListSchemaOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchListSchemaOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchListSchemaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchListSchemaOptions} BatchListSchemaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchListSchemaOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchListSchemaOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchListSchemaOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchListSchemaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchListSchemaOptions} BatchListSchemaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchListSchemaOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchListSchemaOptions message.
             * @function verify
             * @memberof protos.opts.BatchListSchemaOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchListSchemaOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a BatchListSchemaOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchListSchemaOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchListSchemaOptions} BatchListSchemaOptions
             */
            BatchListSchemaOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchListSchemaOptions)
                    return object;
                return new $root.protos.opts.BatchListSchemaOptions();
            };

            /**
             * Creates a plain object from a BatchListSchemaOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchListSchemaOptions
             * @static
             * @param {protos.opts.BatchListSchemaOptions} message BatchListSchemaOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchListSchemaOptions.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this BatchListSchemaOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchListSchemaOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchListSchemaOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchListSchemaOptions;
        })();

        opts.BatchListReplayOptions = (function() {

            /**
             * Properties of a BatchListReplayOptions.
             * @memberof protos.opts
             * @interface IBatchListReplayOptions
             */

            /**
             * Constructs a new BatchListReplayOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchListReplayOptions.
             * @implements IBatchListReplayOptions
             * @constructor
             * @param {protos.opts.IBatchListReplayOptions=} [properties] Properties to set
             */
            function BatchListReplayOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new BatchListReplayOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchListReplayOptions
             * @static
             * @param {protos.opts.IBatchListReplayOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchListReplayOptions} BatchListReplayOptions instance
             */
            BatchListReplayOptions.create = function create(properties) {
                return new BatchListReplayOptions(properties);
            };

            /**
             * Encodes the specified BatchListReplayOptions message. Does not implicitly {@link protos.opts.BatchListReplayOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchListReplayOptions
             * @static
             * @param {protos.opts.IBatchListReplayOptions} message BatchListReplayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchListReplayOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified BatchListReplayOptions message, length delimited. Does not implicitly {@link protos.opts.BatchListReplayOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchListReplayOptions
             * @static
             * @param {protos.opts.IBatchListReplayOptions} message BatchListReplayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchListReplayOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchListReplayOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchListReplayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchListReplayOptions} BatchListReplayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchListReplayOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchListReplayOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchListReplayOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchListReplayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchListReplayOptions} BatchListReplayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchListReplayOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchListReplayOptions message.
             * @function verify
             * @memberof protos.opts.BatchListReplayOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchListReplayOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a BatchListReplayOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchListReplayOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchListReplayOptions} BatchListReplayOptions
             */
            BatchListReplayOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchListReplayOptions)
                    return object;
                return new $root.protos.opts.BatchListReplayOptions();
            };

            /**
             * Creates a plain object from a BatchListReplayOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchListReplayOptions
             * @static
             * @param {protos.opts.BatchListReplayOptions} message BatchListReplayOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchListReplayOptions.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this BatchListReplayOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchListReplayOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchListReplayOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchListReplayOptions;
        })();

        opts.BatchArchiveOptions = (function() {

            /**
             * Properties of a BatchArchiveOptions.
             * @memberof protos.opts
             * @interface IBatchArchiveOptions
             * @property {protos.opts.IBatchArchiveReplayOptions|null} [replay] BatchArchiveOptions replay
             */

            /**
             * Constructs a new BatchArchiveOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchArchiveOptions.
             * @implements IBatchArchiveOptions
             * @constructor
             * @param {protos.opts.IBatchArchiveOptions=} [properties] Properties to set
             */
            function BatchArchiveOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchArchiveOptions replay.
             * @member {protos.opts.IBatchArchiveReplayOptions|null|undefined} replay
             * @memberof protos.opts.BatchArchiveOptions
             * @instance
             */
            BatchArchiveOptions.prototype.replay = null;

            /**
             * Creates a new BatchArchiveOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {protos.opts.IBatchArchiveOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchArchiveOptions} BatchArchiveOptions instance
             */
            BatchArchiveOptions.create = function create(properties) {
                return new BatchArchiveOptions(properties);
            };

            /**
             * Encodes the specified BatchArchiveOptions message. Does not implicitly {@link protos.opts.BatchArchiveOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {protos.opts.IBatchArchiveOptions} message BatchArchiveOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchArchiveOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.replay != null && Object.hasOwnProperty.call(message, "replay"))
                    $root.protos.opts.BatchArchiveReplayOptions.encode(message.replay, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BatchArchiveOptions message, length delimited. Does not implicitly {@link protos.opts.BatchArchiveOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {protos.opts.IBatchArchiveOptions} message BatchArchiveOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchArchiveOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchArchiveOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchArchiveOptions} BatchArchiveOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchArchiveOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchArchiveOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.replay = $root.protos.opts.BatchArchiveReplayOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchArchiveOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchArchiveOptions} BatchArchiveOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchArchiveOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchArchiveOptions message.
             * @function verify
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchArchiveOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.replay != null && message.hasOwnProperty("replay")) {
                    var error = $root.protos.opts.BatchArchiveReplayOptions.verify(message.replay);
                    if (error)
                        return "replay." + error;
                }
                return null;
            };

            /**
             * Creates a BatchArchiveOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchArchiveOptions} BatchArchiveOptions
             */
            BatchArchiveOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchArchiveOptions)
                    return object;
                var message = new $root.protos.opts.BatchArchiveOptions();
                if (object.replay != null) {
                    if (typeof object.replay !== "object")
                        throw TypeError(".protos.opts.BatchArchiveOptions.replay: object expected");
                    message.replay = $root.protos.opts.BatchArchiveReplayOptions.fromObject(object.replay);
                }
                return message;
            };

            /**
             * Creates a plain object from a BatchArchiveOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchArchiveOptions
             * @static
             * @param {protos.opts.BatchArchiveOptions} message BatchArchiveOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchArchiveOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.replay = null;
                if (message.replay != null && message.hasOwnProperty("replay"))
                    object.replay = $root.protos.opts.BatchArchiveReplayOptions.toObject(message.replay, options);
                return object;
            };

            /**
             * Converts this BatchArchiveOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchArchiveOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchArchiveOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchArchiveOptions;
        })();

        opts.BatchArchiveReplayOptions = (function() {

            /**
             * Properties of a BatchArchiveReplayOptions.
             * @memberof protos.opts
             * @interface IBatchArchiveReplayOptions
             * @property {string|null} [replayId] BatchArchiveReplayOptions replayId
             */

            /**
             * Constructs a new BatchArchiveReplayOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchArchiveReplayOptions.
             * @implements IBatchArchiveReplayOptions
             * @constructor
             * @param {protos.opts.IBatchArchiveReplayOptions=} [properties] Properties to set
             */
            function BatchArchiveReplayOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchArchiveReplayOptions replayId.
             * @member {string} replayId
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @instance
             */
            BatchArchiveReplayOptions.prototype.replayId = "";

            /**
             * Creates a new BatchArchiveReplayOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {protos.opts.IBatchArchiveReplayOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchArchiveReplayOptions} BatchArchiveReplayOptions instance
             */
            BatchArchiveReplayOptions.create = function create(properties) {
                return new BatchArchiveReplayOptions(properties);
            };

            /**
             * Encodes the specified BatchArchiveReplayOptions message. Does not implicitly {@link protos.opts.BatchArchiveReplayOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {protos.opts.IBatchArchiveReplayOptions} message BatchArchiveReplayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchArchiveReplayOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.replayId != null && Object.hasOwnProperty.call(message, "replayId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.replayId);
                return writer;
            };

            /**
             * Encodes the specified BatchArchiveReplayOptions message, length delimited. Does not implicitly {@link protos.opts.BatchArchiveReplayOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {protos.opts.IBatchArchiveReplayOptions} message BatchArchiveReplayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchArchiveReplayOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchArchiveReplayOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchArchiveReplayOptions} BatchArchiveReplayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchArchiveReplayOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchArchiveReplayOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.replayId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchArchiveReplayOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchArchiveReplayOptions} BatchArchiveReplayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchArchiveReplayOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchArchiveReplayOptions message.
             * @function verify
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchArchiveReplayOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.replayId != null && message.hasOwnProperty("replayId"))
                    if (!$util.isString(message.replayId))
                        return "replayId: string expected";
                return null;
            };

            /**
             * Creates a BatchArchiveReplayOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchArchiveReplayOptions} BatchArchiveReplayOptions
             */
            BatchArchiveReplayOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchArchiveReplayOptions)
                    return object;
                var message = new $root.protos.opts.BatchArchiveReplayOptions();
                if (object.replayId != null)
                    message.replayId = String(object.replayId);
                return message;
            };

            /**
             * Creates a plain object from a BatchArchiveReplayOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @static
             * @param {protos.opts.BatchArchiveReplayOptions} message BatchArchiveReplayOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchArchiveReplayOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.replayId = "";
                if (message.replayId != null && message.hasOwnProperty("replayId"))
                    object.replayId = message.replayId;
                return object;
            };

            /**
             * Converts this BatchArchiveReplayOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchArchiveReplayOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchArchiveReplayOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchArchiveReplayOptions;
        })();

        opts.BatchListOptions = (function() {

            /**
             * Properties of a BatchListOptions.
             * @memberof protos.opts
             * @interface IBatchListOptions
             * @property {protos.opts.IBatchListCollectionOptions|null} [collection] BatchListOptions collection
             * @property {protos.opts.IBatchListDestinationOptions|null} [destination] BatchListOptions destination
             * @property {protos.opts.IBatchListReplayOptions|null} [replay] BatchListOptions replay
             * @property {protos.opts.IBatchListSchemaOptions|null} [schema] BatchListOptions schema
             */

            /**
             * Constructs a new BatchListOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchListOptions.
             * @implements IBatchListOptions
             * @constructor
             * @param {protos.opts.IBatchListOptions=} [properties] Properties to set
             */
            function BatchListOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchListOptions collection.
             * @member {protos.opts.IBatchListCollectionOptions|null|undefined} collection
             * @memberof protos.opts.BatchListOptions
             * @instance
             */
            BatchListOptions.prototype.collection = null;

            /**
             * BatchListOptions destination.
             * @member {protos.opts.IBatchListDestinationOptions|null|undefined} destination
             * @memberof protos.opts.BatchListOptions
             * @instance
             */
            BatchListOptions.prototype.destination = null;

            /**
             * BatchListOptions replay.
             * @member {protos.opts.IBatchListReplayOptions|null|undefined} replay
             * @memberof protos.opts.BatchListOptions
             * @instance
             */
            BatchListOptions.prototype.replay = null;

            /**
             * BatchListOptions schema.
             * @member {protos.opts.IBatchListSchemaOptions|null|undefined} schema
             * @memberof protos.opts.BatchListOptions
             * @instance
             */
            BatchListOptions.prototype.schema = null;

            /**
             * Creates a new BatchListOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {protos.opts.IBatchListOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchListOptions} BatchListOptions instance
             */
            BatchListOptions.create = function create(properties) {
                return new BatchListOptions(properties);
            };

            /**
             * Encodes the specified BatchListOptions message. Does not implicitly {@link protos.opts.BatchListOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {protos.opts.IBatchListOptions} message BatchListOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchListOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    $root.protos.opts.BatchListCollectionOptions.encode(message.collection, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                    $root.protos.opts.BatchListDestinationOptions.encode(message.destination, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.replay != null && Object.hasOwnProperty.call(message, "replay"))
                    $root.protos.opts.BatchListReplayOptions.encode(message.replay, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                    $root.protos.opts.BatchListSchemaOptions.encode(message.schema, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BatchListOptions message, length delimited. Does not implicitly {@link protos.opts.BatchListOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {protos.opts.IBatchListOptions} message BatchListOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchListOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchListOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchListOptions} BatchListOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchListOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchListOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collection = $root.protos.opts.BatchListCollectionOptions.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.destination = $root.protos.opts.BatchListDestinationOptions.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.replay = $root.protos.opts.BatchListReplayOptions.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.schema = $root.protos.opts.BatchListSchemaOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchListOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchListOptions} BatchListOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchListOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchListOptions message.
             * @function verify
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchListOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collection != null && message.hasOwnProperty("collection")) {
                    var error = $root.protos.opts.BatchListCollectionOptions.verify(message.collection);
                    if (error)
                        return "collection." + error;
                }
                if (message.destination != null && message.hasOwnProperty("destination")) {
                    var error = $root.protos.opts.BatchListDestinationOptions.verify(message.destination);
                    if (error)
                        return "destination." + error;
                }
                if (message.replay != null && message.hasOwnProperty("replay")) {
                    var error = $root.protos.opts.BatchListReplayOptions.verify(message.replay);
                    if (error)
                        return "replay." + error;
                }
                if (message.schema != null && message.hasOwnProperty("schema")) {
                    var error = $root.protos.opts.BatchListSchemaOptions.verify(message.schema);
                    if (error)
                        return "schema." + error;
                }
                return null;
            };

            /**
             * Creates a BatchListOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchListOptions} BatchListOptions
             */
            BatchListOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchListOptions)
                    return object;
                var message = new $root.protos.opts.BatchListOptions();
                if (object.collection != null) {
                    if (typeof object.collection !== "object")
                        throw TypeError(".protos.opts.BatchListOptions.collection: object expected");
                    message.collection = $root.protos.opts.BatchListCollectionOptions.fromObject(object.collection);
                }
                if (object.destination != null) {
                    if (typeof object.destination !== "object")
                        throw TypeError(".protos.opts.BatchListOptions.destination: object expected");
                    message.destination = $root.protos.opts.BatchListDestinationOptions.fromObject(object.destination);
                }
                if (object.replay != null) {
                    if (typeof object.replay !== "object")
                        throw TypeError(".protos.opts.BatchListOptions.replay: object expected");
                    message.replay = $root.protos.opts.BatchListReplayOptions.fromObject(object.replay);
                }
                if (object.schema != null) {
                    if (typeof object.schema !== "object")
                        throw TypeError(".protos.opts.BatchListOptions.schema: object expected");
                    message.schema = $root.protos.opts.BatchListSchemaOptions.fromObject(object.schema);
                }
                return message;
            };

            /**
             * Creates a plain object from a BatchListOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchListOptions
             * @static
             * @param {protos.opts.BatchListOptions} message BatchListOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchListOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.collection = null;
                    object.destination = null;
                    object.replay = null;
                    object.schema = null;
                }
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = $root.protos.opts.BatchListCollectionOptions.toObject(message.collection, options);
                if (message.destination != null && message.hasOwnProperty("destination"))
                    object.destination = $root.protos.opts.BatchListDestinationOptions.toObject(message.destination, options);
                if (message.replay != null && message.hasOwnProperty("replay"))
                    object.replay = $root.protos.opts.BatchListReplayOptions.toObject(message.replay, options);
                if (message.schema != null && message.hasOwnProperty("schema"))
                    object.schema = $root.protos.opts.BatchListSchemaOptions.toObject(message.schema, options);
                return object;
            };

            /**
             * Converts this BatchListOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchListOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchListOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchListOptions;
        })();

        opts.BatchCreateOptions = (function() {

            /**
             * Properties of a BatchCreateOptions.
             * @memberof protos.opts
             * @interface IBatchCreateOptions
             * @property {protos.opts.IBatchCreateCollectionOptions|null} [collection] BatchCreateOptions collection
             * @property {protos.opts.IBatchCreateReplayOptions|null} [replay] BatchCreateOptions replay
             * @property {protos.opts.IBatchCreateDestinationOptions|null} [destination] BatchCreateOptions destination
             */

            /**
             * Constructs a new BatchCreateOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchCreateOptions.
             * @implements IBatchCreateOptions
             * @constructor
             * @param {protos.opts.IBatchCreateOptions=} [properties] Properties to set
             */
            function BatchCreateOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchCreateOptions collection.
             * @member {protos.opts.IBatchCreateCollectionOptions|null|undefined} collection
             * @memberof protos.opts.BatchCreateOptions
             * @instance
             */
            BatchCreateOptions.prototype.collection = null;

            /**
             * BatchCreateOptions replay.
             * @member {protos.opts.IBatchCreateReplayOptions|null|undefined} replay
             * @memberof protos.opts.BatchCreateOptions
             * @instance
             */
            BatchCreateOptions.prototype.replay = null;

            /**
             * BatchCreateOptions destination.
             * @member {protos.opts.IBatchCreateDestinationOptions|null|undefined} destination
             * @memberof protos.opts.BatchCreateOptions
             * @instance
             */
            BatchCreateOptions.prototype.destination = null;

            /**
             * Creates a new BatchCreateOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {protos.opts.IBatchCreateOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchCreateOptions} BatchCreateOptions instance
             */
            BatchCreateOptions.create = function create(properties) {
                return new BatchCreateOptions(properties);
            };

            /**
             * Encodes the specified BatchCreateOptions message. Does not implicitly {@link protos.opts.BatchCreateOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {protos.opts.IBatchCreateOptions} message BatchCreateOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    $root.protos.opts.BatchCreateCollectionOptions.encode(message.collection, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.replay != null && Object.hasOwnProperty.call(message, "replay"))
                    $root.protos.opts.BatchCreateReplayOptions.encode(message.replay, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                    $root.protos.opts.BatchCreateDestinationOptions.encode(message.destination, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BatchCreateOptions message, length delimited. Does not implicitly {@link protos.opts.BatchCreateOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {protos.opts.IBatchCreateOptions} message BatchCreateOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchCreateOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchCreateOptions} BatchCreateOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchCreateOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collection = $root.protos.opts.BatchCreateCollectionOptions.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.replay = $root.protos.opts.BatchCreateReplayOptions.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.destination = $root.protos.opts.BatchCreateDestinationOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchCreateOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchCreateOptions} BatchCreateOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchCreateOptions message.
             * @function verify
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchCreateOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collection != null && message.hasOwnProperty("collection")) {
                    var error = $root.protos.opts.BatchCreateCollectionOptions.verify(message.collection);
                    if (error)
                        return "collection." + error;
                }
                if (message.replay != null && message.hasOwnProperty("replay")) {
                    var error = $root.protos.opts.BatchCreateReplayOptions.verify(message.replay);
                    if (error)
                        return "replay." + error;
                }
                if (message.destination != null && message.hasOwnProperty("destination")) {
                    var error = $root.protos.opts.BatchCreateDestinationOptions.verify(message.destination);
                    if (error)
                        return "destination." + error;
                }
                return null;
            };

            /**
             * Creates a BatchCreateOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchCreateOptions} BatchCreateOptions
             */
            BatchCreateOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchCreateOptions)
                    return object;
                var message = new $root.protos.opts.BatchCreateOptions();
                if (object.collection != null) {
                    if (typeof object.collection !== "object")
                        throw TypeError(".protos.opts.BatchCreateOptions.collection: object expected");
                    message.collection = $root.protos.opts.BatchCreateCollectionOptions.fromObject(object.collection);
                }
                if (object.replay != null) {
                    if (typeof object.replay !== "object")
                        throw TypeError(".protos.opts.BatchCreateOptions.replay: object expected");
                    message.replay = $root.protos.opts.BatchCreateReplayOptions.fromObject(object.replay);
                }
                if (object.destination != null) {
                    if (typeof object.destination !== "object")
                        throw TypeError(".protos.opts.BatchCreateOptions.destination: object expected");
                    message.destination = $root.protos.opts.BatchCreateDestinationOptions.fromObject(object.destination);
                }
                return message;
            };

            /**
             * Creates a plain object from a BatchCreateOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchCreateOptions
             * @static
             * @param {protos.opts.BatchCreateOptions} message BatchCreateOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchCreateOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.collection = null;
                    object.replay = null;
                    object.destination = null;
                }
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = $root.protos.opts.BatchCreateCollectionOptions.toObject(message.collection, options);
                if (message.replay != null && message.hasOwnProperty("replay"))
                    object.replay = $root.protos.opts.BatchCreateReplayOptions.toObject(message.replay, options);
                if (message.destination != null && message.hasOwnProperty("destination"))
                    object.destination = $root.protos.opts.BatchCreateDestinationOptions.toObject(message.destination, options);
                return object;
            };

            /**
             * Converts this BatchCreateOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchCreateOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchCreateOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchCreateOptions;
        })();

        opts.BatchSearchOptions = (function() {

            /**
             * Properties of a BatchSearchOptions.
             * @memberof protos.opts
             * @interface IBatchSearchOptions
             * @property {string|null} [query] BatchSearchOptions query
             * @property {string|null} [collectionId] BatchSearchOptions collectionId
             * @property {number|null} [page] BatchSearchOptions page
             */

            /**
             * Constructs a new BatchSearchOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchSearchOptions.
             * @implements IBatchSearchOptions
             * @constructor
             * @param {protos.opts.IBatchSearchOptions=} [properties] Properties to set
             */
            function BatchSearchOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchSearchOptions query.
             * @member {string} query
             * @memberof protos.opts.BatchSearchOptions
             * @instance
             */
            BatchSearchOptions.prototype.query = "";

            /**
             * BatchSearchOptions collectionId.
             * @member {string} collectionId
             * @memberof protos.opts.BatchSearchOptions
             * @instance
             */
            BatchSearchOptions.prototype.collectionId = "";

            /**
             * BatchSearchOptions page.
             * @member {number} page
             * @memberof protos.opts.BatchSearchOptions
             * @instance
             */
            BatchSearchOptions.prototype.page = 0;

            /**
             * Creates a new BatchSearchOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {protos.opts.IBatchSearchOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchSearchOptions} BatchSearchOptions instance
             */
            BatchSearchOptions.create = function create(properties) {
                return new BatchSearchOptions(properties);
            };

            /**
             * Encodes the specified BatchSearchOptions message. Does not implicitly {@link protos.opts.BatchSearchOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {protos.opts.IBatchSearchOptions} message BatchSearchOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchSearchOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.query);
                if (message.collectionId != null && Object.hasOwnProperty.call(message, "collectionId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.collectionId);
                if (message.page != null && Object.hasOwnProperty.call(message, "page"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.page);
                return writer;
            };

            /**
             * Encodes the specified BatchSearchOptions message, length delimited. Does not implicitly {@link protos.opts.BatchSearchOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {protos.opts.IBatchSearchOptions} message BatchSearchOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchSearchOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchSearchOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchSearchOptions} BatchSearchOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchSearchOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchSearchOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.query = reader.string();
                        break;
                    case 2:
                        message.collectionId = reader.string();
                        break;
                    case 3:
                        message.page = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchSearchOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchSearchOptions} BatchSearchOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchSearchOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchSearchOptions message.
             * @function verify
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchSearchOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.query != null && message.hasOwnProperty("query"))
                    if (!$util.isString(message.query))
                        return "query: string expected";
                if (message.collectionId != null && message.hasOwnProperty("collectionId"))
                    if (!$util.isString(message.collectionId))
                        return "collectionId: string expected";
                if (message.page != null && message.hasOwnProperty("page"))
                    if (!$util.isInteger(message.page))
                        return "page: integer expected";
                return null;
            };

            /**
             * Creates a BatchSearchOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchSearchOptions} BatchSearchOptions
             */
            BatchSearchOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchSearchOptions)
                    return object;
                var message = new $root.protos.opts.BatchSearchOptions();
                if (object.query != null)
                    message.query = String(object.query);
                if (object.collectionId != null)
                    message.collectionId = String(object.collectionId);
                if (object.page != null)
                    message.page = object.page | 0;
                return message;
            };

            /**
             * Creates a plain object from a BatchSearchOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchSearchOptions
             * @static
             * @param {protos.opts.BatchSearchOptions} message BatchSearchOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchSearchOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.query = "";
                    object.collectionId = "";
                    object.page = 0;
                }
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = message.query;
                if (message.collectionId != null && message.hasOwnProperty("collectionId"))
                    object.collectionId = message.collectionId;
                if (message.page != null && message.hasOwnProperty("page"))
                    object.page = message.page;
                return object;
            };

            /**
             * Converts this BatchSearchOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchSearchOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchSearchOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchSearchOptions;
        })();

        opts.BatchCreateCollectionOptions = (function() {

            /**
             * Properties of a BatchCreateCollectionOptions.
             * @memberof protos.opts
             * @interface IBatchCreateCollectionOptions
             * @property {string|null} [name] BatchCreateCollectionOptions name
             * @property {string|null} [schemaId] BatchCreateCollectionOptions schemaId
             * @property {string|null} [notes] BatchCreateCollectionOptions notes
             */

            /**
             * Constructs a new BatchCreateCollectionOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchCreateCollectionOptions.
             * @implements IBatchCreateCollectionOptions
             * @constructor
             * @param {protos.opts.IBatchCreateCollectionOptions=} [properties] Properties to set
             */
            function BatchCreateCollectionOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchCreateCollectionOptions name.
             * @member {string} name
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @instance
             */
            BatchCreateCollectionOptions.prototype.name = "";

            /**
             * BatchCreateCollectionOptions schemaId.
             * @member {string} schemaId
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @instance
             */
            BatchCreateCollectionOptions.prototype.schemaId = "";

            /**
             * BatchCreateCollectionOptions notes.
             * @member {string} notes
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @instance
             */
            BatchCreateCollectionOptions.prototype.notes = "";

            /**
             * Creates a new BatchCreateCollectionOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {protos.opts.IBatchCreateCollectionOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchCreateCollectionOptions} BatchCreateCollectionOptions instance
             */
            BatchCreateCollectionOptions.create = function create(properties) {
                return new BatchCreateCollectionOptions(properties);
            };

            /**
             * Encodes the specified BatchCreateCollectionOptions message. Does not implicitly {@link protos.opts.BatchCreateCollectionOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {protos.opts.IBatchCreateCollectionOptions} message BatchCreateCollectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateCollectionOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.schemaId != null && Object.hasOwnProperty.call(message, "schemaId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.schemaId);
                if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.notes);
                return writer;
            };

            /**
             * Encodes the specified BatchCreateCollectionOptions message, length delimited. Does not implicitly {@link protos.opts.BatchCreateCollectionOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {protos.opts.IBatchCreateCollectionOptions} message BatchCreateCollectionOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateCollectionOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchCreateCollectionOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchCreateCollectionOptions} BatchCreateCollectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateCollectionOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchCreateCollectionOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.schemaId = reader.string();
                        break;
                    case 3:
                        message.notes = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchCreateCollectionOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchCreateCollectionOptions} BatchCreateCollectionOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateCollectionOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchCreateCollectionOptions message.
             * @function verify
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchCreateCollectionOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    if (!$util.isString(message.schemaId))
                        return "schemaId: string expected";
                if (message.notes != null && message.hasOwnProperty("notes"))
                    if (!$util.isString(message.notes))
                        return "notes: string expected";
                return null;
            };

            /**
             * Creates a BatchCreateCollectionOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchCreateCollectionOptions} BatchCreateCollectionOptions
             */
            BatchCreateCollectionOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchCreateCollectionOptions)
                    return object;
                var message = new $root.protos.opts.BatchCreateCollectionOptions();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.schemaId != null)
                    message.schemaId = String(object.schemaId);
                if (object.notes != null)
                    message.notes = String(object.notes);
                return message;
            };

            /**
             * Creates a plain object from a BatchCreateCollectionOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @static
             * @param {protos.opts.BatchCreateCollectionOptions} message BatchCreateCollectionOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchCreateCollectionOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.schemaId = "";
                    object.notes = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    object.schemaId = message.schemaId;
                if (message.notes != null && message.hasOwnProperty("notes"))
                    object.notes = message.notes;
                return object;
            };

            /**
             * Converts this BatchCreateCollectionOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchCreateCollectionOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchCreateCollectionOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchCreateCollectionOptions;
        })();

        opts.BatchCreateReplayOptions = (function() {

            /**
             * Properties of a BatchCreateReplayOptions.
             * @memberof protos.opts
             * @interface IBatchCreateReplayOptions
             * @property {string|null} [name] BatchCreateReplayOptions name
             * @property {protos.opts.BatchReplayType|null} [type] BatchCreateReplayOptions type
             * @property {string|null} [notes] BatchCreateReplayOptions notes
             * @property {string|null} [collectionId] BatchCreateReplayOptions collectionId
             * @property {string|null} [destinationId] BatchCreateReplayOptions destinationId
             * @property {string|null} [query] BatchCreateReplayOptions query
             * @property {string|null} [fromTimestamp] BatchCreateReplayOptions fromTimestamp
             * @property {string|null} [toTimestamp] BatchCreateReplayOptions toTimestamp
             */

            /**
             * Constructs a new BatchCreateReplayOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchCreateReplayOptions.
             * @implements IBatchCreateReplayOptions
             * @constructor
             * @param {protos.opts.IBatchCreateReplayOptions=} [properties] Properties to set
             */
            function BatchCreateReplayOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchCreateReplayOptions name.
             * @member {string} name
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.name = "";

            /**
             * BatchCreateReplayOptions type.
             * @member {protos.opts.BatchReplayType} type
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.type = 0;

            /**
             * BatchCreateReplayOptions notes.
             * @member {string} notes
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.notes = "";

            /**
             * BatchCreateReplayOptions collectionId.
             * @member {string} collectionId
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.collectionId = "";

            /**
             * BatchCreateReplayOptions destinationId.
             * @member {string} destinationId
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.destinationId = "";

            /**
             * BatchCreateReplayOptions query.
             * @member {string} query
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.query = "";

            /**
             * BatchCreateReplayOptions fromTimestamp.
             * @member {string} fromTimestamp
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.fromTimestamp = "";

            /**
             * BatchCreateReplayOptions toTimestamp.
             * @member {string} toTimestamp
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             */
            BatchCreateReplayOptions.prototype.toTimestamp = "";

            /**
             * Creates a new BatchCreateReplayOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {protos.opts.IBatchCreateReplayOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchCreateReplayOptions} BatchCreateReplayOptions instance
             */
            BatchCreateReplayOptions.create = function create(properties) {
                return new BatchCreateReplayOptions(properties);
            };

            /**
             * Encodes the specified BatchCreateReplayOptions message. Does not implicitly {@link protos.opts.BatchCreateReplayOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {protos.opts.IBatchCreateReplayOptions} message BatchCreateReplayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateReplayOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.notes);
                if (message.collectionId != null && Object.hasOwnProperty.call(message, "collectionId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.collectionId);
                if (message.destinationId != null && Object.hasOwnProperty.call(message, "destinationId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.destinationId);
                if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.query);
                if (message.fromTimestamp != null && Object.hasOwnProperty.call(message, "fromTimestamp"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.fromTimestamp);
                if (message.toTimestamp != null && Object.hasOwnProperty.call(message, "toTimestamp"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.toTimestamp);
                return writer;
            };

            /**
             * Encodes the specified BatchCreateReplayOptions message, length delimited. Does not implicitly {@link protos.opts.BatchCreateReplayOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {protos.opts.IBatchCreateReplayOptions} message BatchCreateReplayOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateReplayOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchCreateReplayOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchCreateReplayOptions} BatchCreateReplayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateReplayOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchCreateReplayOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.notes = reader.string();
                        break;
                    case 4:
                        message.collectionId = reader.string();
                        break;
                    case 5:
                        message.destinationId = reader.string();
                        break;
                    case 6:
                        message.query = reader.string();
                        break;
                    case 7:
                        message.fromTimestamp = reader.string();
                        break;
                    case 8:
                        message.toTimestamp = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchCreateReplayOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchCreateReplayOptions} BatchCreateReplayOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateReplayOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchCreateReplayOptions message.
             * @function verify
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchCreateReplayOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.notes != null && message.hasOwnProperty("notes"))
                    if (!$util.isString(message.notes))
                        return "notes: string expected";
                if (message.collectionId != null && message.hasOwnProperty("collectionId"))
                    if (!$util.isString(message.collectionId))
                        return "collectionId: string expected";
                if (message.destinationId != null && message.hasOwnProperty("destinationId"))
                    if (!$util.isString(message.destinationId))
                        return "destinationId: string expected";
                if (message.query != null && message.hasOwnProperty("query"))
                    if (!$util.isString(message.query))
                        return "query: string expected";
                if (message.fromTimestamp != null && message.hasOwnProperty("fromTimestamp"))
                    if (!$util.isString(message.fromTimestamp))
                        return "fromTimestamp: string expected";
                if (message.toTimestamp != null && message.hasOwnProperty("toTimestamp"))
                    if (!$util.isString(message.toTimestamp))
                        return "toTimestamp: string expected";
                return null;
            };

            /**
             * Creates a BatchCreateReplayOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchCreateReplayOptions} BatchCreateReplayOptions
             */
            BatchCreateReplayOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchCreateReplayOptions)
                    return object;
                var message = new $root.protos.opts.BatchCreateReplayOptions();
                if (object.name != null)
                    message.name = String(object.name);
                switch (object.type) {
                case "SINGLE":
                case 0:
                    message.type = 0;
                    break;
                case "CONTINUOUS":
                case 1:
                    message.type = 1;
                    break;
                }
                if (object.notes != null)
                    message.notes = String(object.notes);
                if (object.collectionId != null)
                    message.collectionId = String(object.collectionId);
                if (object.destinationId != null)
                    message.destinationId = String(object.destinationId);
                if (object.query != null)
                    message.query = String(object.query);
                if (object.fromTimestamp != null)
                    message.fromTimestamp = String(object.fromTimestamp);
                if (object.toTimestamp != null)
                    message.toTimestamp = String(object.toTimestamp);
                return message;
            };

            /**
             * Creates a plain object from a BatchCreateReplayOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchCreateReplayOptions
             * @static
             * @param {protos.opts.BatchCreateReplayOptions} message BatchCreateReplayOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchCreateReplayOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.type = options.enums === String ? "SINGLE" : 0;
                    object.notes = "";
                    object.collectionId = "";
                    object.destinationId = "";
                    object.query = "";
                    object.fromTimestamp = "";
                    object.toTimestamp = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.protos.opts.BatchReplayType[message.type] : message.type;
                if (message.notes != null && message.hasOwnProperty("notes"))
                    object.notes = message.notes;
                if (message.collectionId != null && message.hasOwnProperty("collectionId"))
                    object.collectionId = message.collectionId;
                if (message.destinationId != null && message.hasOwnProperty("destinationId"))
                    object.destinationId = message.destinationId;
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = message.query;
                if (message.fromTimestamp != null && message.hasOwnProperty("fromTimestamp"))
                    object.fromTimestamp = message.fromTimestamp;
                if (message.toTimestamp != null && message.hasOwnProperty("toTimestamp"))
                    object.toTimestamp = message.toTimestamp;
                return object;
            };

            /**
             * Converts this BatchCreateReplayOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchCreateReplayOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchCreateReplayOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchCreateReplayOptions;
        })();

        opts.BatchCreateDestinationOptions = (function() {

            /**
             * Properties of a BatchCreateDestinationOptions.
             * @memberof protos.opts
             * @interface IBatchCreateDestinationOptions
             * @property {string|null} [name] BatchCreateDestinationOptions name
             * @property {string|null} [notes] BatchCreateDestinationOptions notes
             * @property {string|null} [_apiDestinationType] BatchCreateDestinationOptions _apiDestinationType
             * @property {protos.opts.IWriteGroupKafkaOptions|null} [kafka] BatchCreateDestinationOptions kafka
             * @property {protos.opts.IWriteGroupRabbitOptions|null} [rabbit] BatchCreateDestinationOptions rabbit
             * @property {protos.opts.IWriteGroupKubeMQQueueOptions|null} [kubemqQueue] BatchCreateDestinationOptions kubemqQueue
             * @property {protos.opts.IWriteGroupAWSSQSOptions|null} [awsSqs] BatchCreateDestinationOptions awsSqs
             * @property {protos.opts.IHTTPDestination|null} [http] BatchCreateDestinationOptions http
             */

            /**
             * Constructs a new BatchCreateDestinationOptions.
             * @memberof protos.opts
             * @classdesc Represents a BatchCreateDestinationOptions.
             * @implements IBatchCreateDestinationOptions
             * @constructor
             * @param {protos.opts.IBatchCreateDestinationOptions=} [properties] Properties to set
             */
            function BatchCreateDestinationOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchCreateDestinationOptions name.
             * @member {string} name
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype.name = "";

            /**
             * BatchCreateDestinationOptions notes.
             * @member {string} notes
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype.notes = "";

            /**
             * BatchCreateDestinationOptions _apiDestinationType.
             * @member {string} _apiDestinationType
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype._apiDestinationType = "";

            /**
             * BatchCreateDestinationOptions kafka.
             * @member {protos.opts.IWriteGroupKafkaOptions|null|undefined} kafka
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype.kafka = null;

            /**
             * BatchCreateDestinationOptions rabbit.
             * @member {protos.opts.IWriteGroupRabbitOptions|null|undefined} rabbit
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype.rabbit = null;

            /**
             * BatchCreateDestinationOptions kubemqQueue.
             * @member {protos.opts.IWriteGroupKubeMQQueueOptions|null|undefined} kubemqQueue
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype.kubemqQueue = null;

            /**
             * BatchCreateDestinationOptions awsSqs.
             * @member {protos.opts.IWriteGroupAWSSQSOptions|null|undefined} awsSqs
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype.awsSqs = null;

            /**
             * BatchCreateDestinationOptions http.
             * @member {protos.opts.IHTTPDestination|null|undefined} http
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             */
            BatchCreateDestinationOptions.prototype.http = null;

            /**
             * Creates a new BatchCreateDestinationOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {protos.opts.IBatchCreateDestinationOptions=} [properties] Properties to set
             * @returns {protos.opts.BatchCreateDestinationOptions} BatchCreateDestinationOptions instance
             */
            BatchCreateDestinationOptions.create = function create(properties) {
                return new BatchCreateDestinationOptions(properties);
            };

            /**
             * Encodes the specified BatchCreateDestinationOptions message. Does not implicitly {@link protos.opts.BatchCreateDestinationOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {protos.opts.IBatchCreateDestinationOptions} message BatchCreateDestinationOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateDestinationOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.notes);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.opts.WriteGroupKafkaOptions.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.opts.WriteGroupRabbitOptions.encode(message.rabbit, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.opts.WriteGroupKubeMQQueueOptions.encode(message.kubemqQueue, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.awsSqs != null && Object.hasOwnProperty.call(message, "awsSqs"))
                    $root.protos.opts.WriteGroupAWSSQSOptions.encode(message.awsSqs, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.http != null && Object.hasOwnProperty.call(message, "http"))
                    $root.protos.opts.HTTPDestination.encode(message.http, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message._apiDestinationType != null && Object.hasOwnProperty.call(message, "_apiDestinationType"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._apiDestinationType);
                return writer;
            };

            /**
             * Encodes the specified BatchCreateDestinationOptions message, length delimited. Does not implicitly {@link protos.opts.BatchCreateDestinationOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {protos.opts.IBatchCreateDestinationOptions} message BatchCreateDestinationOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchCreateDestinationOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchCreateDestinationOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.BatchCreateDestinationOptions} BatchCreateDestinationOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateDestinationOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.BatchCreateDestinationOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.notes = reader.string();
                        break;
                    case 1000:
                        message._apiDestinationType = reader.string();
                        break;
                    case 100:
                        message.kafka = $root.protos.opts.WriteGroupKafkaOptions.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.rabbit = $root.protos.opts.WriteGroupRabbitOptions.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.awsSqs = $root.protos.opts.WriteGroupAWSSQSOptions.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.http = $root.protos.opts.HTTPDestination.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchCreateDestinationOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.BatchCreateDestinationOptions} BatchCreateDestinationOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchCreateDestinationOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchCreateDestinationOptions message.
             * @function verify
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchCreateDestinationOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.notes != null && message.hasOwnProperty("notes"))
                    if (!$util.isString(message.notes))
                        return "notes: string expected";
                if (message._apiDestinationType != null && message.hasOwnProperty("_apiDestinationType"))
                    if (!$util.isString(message._apiDestinationType))
                        return "_apiDestinationType: string expected";
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    var error = $root.protos.opts.WriteGroupKafkaOptions.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    var error = $root.protos.opts.WriteGroupRabbitOptions.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    var error = $root.protos.opts.WriteGroupKubeMQQueueOptions.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs")) {
                    var error = $root.protos.opts.WriteGroupAWSSQSOptions.verify(message.awsSqs);
                    if (error)
                        return "awsSqs." + error;
                }
                if (message.http != null && message.hasOwnProperty("http")) {
                    var error = $root.protos.opts.HTTPDestination.verify(message.http);
                    if (error)
                        return "http." + error;
                }
                return null;
            };

            /**
             * Creates a BatchCreateDestinationOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.BatchCreateDestinationOptions} BatchCreateDestinationOptions
             */
            BatchCreateDestinationOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.BatchCreateDestinationOptions)
                    return object;
                var message = new $root.protos.opts.BatchCreateDestinationOptions();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.notes != null)
                    message.notes = String(object.notes);
                if (object._apiDestinationType != null)
                    message._apiDestinationType = String(object._apiDestinationType);
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.BatchCreateDestinationOptions.kafka: object expected");
                    message.kafka = $root.protos.opts.WriteGroupKafkaOptions.fromObject(object.kafka);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.BatchCreateDestinationOptions.rabbit: object expected");
                    message.rabbit = $root.protos.opts.WriteGroupRabbitOptions.fromObject(object.rabbit);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.BatchCreateDestinationOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.fromObject(object.kubemqQueue);
                }
                if (object.awsSqs != null) {
                    if (typeof object.awsSqs !== "object")
                        throw TypeError(".protos.opts.BatchCreateDestinationOptions.awsSqs: object expected");
                    message.awsSqs = $root.protos.opts.WriteGroupAWSSQSOptions.fromObject(object.awsSqs);
                }
                if (object.http != null) {
                    if (typeof object.http !== "object")
                        throw TypeError(".protos.opts.BatchCreateDestinationOptions.http: object expected");
                    message.http = $root.protos.opts.HTTPDestination.fromObject(object.http);
                }
                return message;
            };

            /**
             * Creates a plain object from a BatchCreateDestinationOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @static
             * @param {protos.opts.BatchCreateDestinationOptions} message BatchCreateDestinationOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchCreateDestinationOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.notes = "";
                    object.kafka = null;
                    object.rabbit = null;
                    object.kubemqQueue = null;
                    object.awsSqs = null;
                    object.http = null;
                    object._apiDestinationType = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.notes != null && message.hasOwnProperty("notes"))
                    object.notes = message.notes;
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.opts.WriteGroupKafkaOptions.toObject(message.kafka, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.opts.WriteGroupRabbitOptions.toObject(message.rabbit, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.toObject(message.kubemqQueue, options);
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs"))
                    object.awsSqs = $root.protos.opts.WriteGroupAWSSQSOptions.toObject(message.awsSqs, options);
                if (message.http != null && message.hasOwnProperty("http"))
                    object.http = $root.protos.opts.HTTPDestination.toObject(message.http, options);
                if (message._apiDestinationType != null && message.hasOwnProperty("_apiDestinationType"))
                    object._apiDestinationType = message._apiDestinationType;
                return object;
            };

            /**
             * Converts this BatchCreateDestinationOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.BatchCreateDestinationOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchCreateDestinationOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchCreateDestinationOptions;
        })();

        opts.HTTPDestination = (function() {

            /**
             * Properties of a HTTPDestination.
             * @memberof protos.opts
             * @interface IHTTPDestination
             * @property {string|null} [url] HTTPDestination url
             * @property {Object.<string,string>|null} [headers] HTTPDestination headers
             */

            /**
             * Constructs a new HTTPDestination.
             * @memberof protos.opts
             * @classdesc Represents a HTTPDestination.
             * @implements IHTTPDestination
             * @constructor
             * @param {protos.opts.IHTTPDestination=} [properties] Properties to set
             */
            function HTTPDestination(properties) {
                this.headers = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HTTPDestination url.
             * @member {string} url
             * @memberof protos.opts.HTTPDestination
             * @instance
             */
            HTTPDestination.prototype.url = "";

            /**
             * HTTPDestination headers.
             * @member {Object.<string,string>} headers
             * @memberof protos.opts.HTTPDestination
             * @instance
             */
            HTTPDestination.prototype.headers = $util.emptyObject;

            /**
             * Creates a new HTTPDestination instance using the specified properties.
             * @function create
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {protos.opts.IHTTPDestination=} [properties] Properties to set
             * @returns {protos.opts.HTTPDestination} HTTPDestination instance
             */
            HTTPDestination.create = function create(properties) {
                return new HTTPDestination(properties);
            };

            /**
             * Encodes the specified HTTPDestination message. Does not implicitly {@link protos.opts.HTTPDestination.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {protos.opts.IHTTPDestination} message HTTPDestination message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HTTPDestination.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.headers != null && Object.hasOwnProperty.call(message, "headers"))
                    for (var keys = Object.keys(message.headers), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.headers[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified HTTPDestination message, length delimited. Does not implicitly {@link protos.opts.HTTPDestination.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {protos.opts.IHTTPDestination} message HTTPDestination message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HTTPDestination.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HTTPDestination message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.HTTPDestination} HTTPDestination
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HTTPDestination.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.HTTPDestination(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.url = reader.string();
                        break;
                    case 2:
                        if (message.headers === $util.emptyObject)
                            message.headers = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.headers[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HTTPDestination message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.HTTPDestination} HTTPDestination
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HTTPDestination.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HTTPDestination message.
             * @function verify
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HTTPDestination.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    if (!$util.isObject(message.headers))
                        return "headers: object expected";
                    var key = Object.keys(message.headers);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.headers[key[i]]))
                            return "headers: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a HTTPDestination message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.HTTPDestination} HTTPDestination
             */
            HTTPDestination.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.HTTPDestination)
                    return object;
                var message = new $root.protos.opts.HTTPDestination();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.headers) {
                    if (typeof object.headers !== "object")
                        throw TypeError(".protos.opts.HTTPDestination.headers: object expected");
                    message.headers = {};
                    for (var keys = Object.keys(object.headers), i = 0; i < keys.length; ++i)
                        message.headers[keys[i]] = String(object.headers[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a HTTPDestination message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.HTTPDestination
             * @static
             * @param {protos.opts.HTTPDestination} message HTTPDestination
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HTTPDestination.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.headers = {};
                if (options.defaults)
                    object.url = "";
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                var keys2;
                if (message.headers && (keys2 = Object.keys(message.headers)).length) {
                    object.headers = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.headers[keys2[j]] = message.headers[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this HTTPDestination to JSON.
             * @function toJSON
             * @memberof protos.opts.HTTPDestination
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HTTPDestination.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HTTPDestination;
        })();

        opts.WriteCLIOptions = (function() {

            /**
             * Properties of a WriteCLIOptions.
             * @memberof protos.opts
             * @interface IWriteCLIOptions
             * @property {string|null} [inputFile] WriteCLIOptions inputFile
             * @property {boolean|null} [inputAsJsonArray] WriteCLIOptions inputAsJsonArray
             * @property {Array.<string>|null} [inputStdin] WriteCLIOptions inputStdin
             */

            /**
             * Constructs a new WriteCLIOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteCLIOptions.
             * @implements IWriteCLIOptions
             * @constructor
             * @param {protos.opts.IWriteCLIOptions=} [properties] Properties to set
             */
            function WriteCLIOptions(properties) {
                this.inputStdin = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteCLIOptions inputFile.
             * @member {string} inputFile
             * @memberof protos.opts.WriteCLIOptions
             * @instance
             */
            WriteCLIOptions.prototype.inputFile = "";

            /**
             * WriteCLIOptions inputAsJsonArray.
             * @member {boolean} inputAsJsonArray
             * @memberof protos.opts.WriteCLIOptions
             * @instance
             */
            WriteCLIOptions.prototype.inputAsJsonArray = false;

            /**
             * WriteCLIOptions inputStdin.
             * @member {Array.<string>} inputStdin
             * @memberof protos.opts.WriteCLIOptions
             * @instance
             */
            WriteCLIOptions.prototype.inputStdin = $util.emptyArray;

            /**
             * Creates a new WriteCLIOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {protos.opts.IWriteCLIOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteCLIOptions} WriteCLIOptions instance
             */
            WriteCLIOptions.create = function create(properties) {
                return new WriteCLIOptions(properties);
            };

            /**
             * Encodes the specified WriteCLIOptions message. Does not implicitly {@link protos.opts.WriteCLIOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {protos.opts.IWriteCLIOptions} message WriteCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteCLIOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.inputFile != null && Object.hasOwnProperty.call(message, "inputFile"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.inputFile);
                if (message.inputAsJsonArray != null && Object.hasOwnProperty.call(message, "inputAsJsonArray"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.inputAsJsonArray);
                if (message.inputStdin != null && message.inputStdin.length)
                    for (var i = 0; i < message.inputStdin.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.inputStdin[i]);
                return writer;
            };

            /**
             * Encodes the specified WriteCLIOptions message, length delimited. Does not implicitly {@link protos.opts.WriteCLIOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {protos.opts.IWriteCLIOptions} message WriteCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteCLIOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteCLIOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteCLIOptions} WriteCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteCLIOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteCLIOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.inputFile = reader.string();
                        break;
                    case 2:
                        message.inputAsJsonArray = reader.bool();
                        break;
                    case 3:
                        if (!(message.inputStdin && message.inputStdin.length))
                            message.inputStdin = [];
                        message.inputStdin.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteCLIOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteCLIOptions} WriteCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteCLIOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteCLIOptions message.
             * @function verify
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteCLIOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.inputFile != null && message.hasOwnProperty("inputFile"))
                    if (!$util.isString(message.inputFile))
                        return "inputFile: string expected";
                if (message.inputAsJsonArray != null && message.hasOwnProperty("inputAsJsonArray"))
                    if (typeof message.inputAsJsonArray !== "boolean")
                        return "inputAsJsonArray: boolean expected";
                if (message.inputStdin != null && message.hasOwnProperty("inputStdin")) {
                    if (!Array.isArray(message.inputStdin))
                        return "inputStdin: array expected";
                    for (var i = 0; i < message.inputStdin.length; ++i)
                        if (!$util.isString(message.inputStdin[i]))
                            return "inputStdin: string[] expected";
                }
                return null;
            };

            /**
             * Creates a WriteCLIOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteCLIOptions} WriteCLIOptions
             */
            WriteCLIOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteCLIOptions)
                    return object;
                var message = new $root.protos.opts.WriteCLIOptions();
                if (object.inputFile != null)
                    message.inputFile = String(object.inputFile);
                if (object.inputAsJsonArray != null)
                    message.inputAsJsonArray = Boolean(object.inputAsJsonArray);
                if (object.inputStdin) {
                    if (!Array.isArray(object.inputStdin))
                        throw TypeError(".protos.opts.WriteCLIOptions.inputStdin: array expected");
                    message.inputStdin = [];
                    for (var i = 0; i < object.inputStdin.length; ++i)
                        message.inputStdin[i] = String(object.inputStdin[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteCLIOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteCLIOptions
             * @static
             * @param {protos.opts.WriteCLIOptions} message WriteCLIOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteCLIOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.inputStdin = [];
                if (options.defaults) {
                    object.inputFile = "";
                    object.inputAsJsonArray = false;
                }
                if (message.inputFile != null && message.hasOwnProperty("inputFile"))
                    object.inputFile = message.inputFile;
                if (message.inputAsJsonArray != null && message.hasOwnProperty("inputAsJsonArray"))
                    object.inputAsJsonArray = message.inputAsJsonArray;
                if (message.inputStdin && message.inputStdin.length) {
                    object.inputStdin = [];
                    for (var j = 0; j < message.inputStdin.length; ++j)
                        object.inputStdin[j] = message.inputStdin[j];
                }
                return object;
            };

            /**
             * Converts this WriteCLIOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteCLIOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteCLIOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteCLIOptions;
        })();

        opts.WriteOptions = (function() {

            /**
             * Properties of a WriteOptions.
             * @memberof protos.opts
             * @interface IWriteOptions
             * @property {string|null} [connectionId] WriteOptions connectionId
             * @property {protos.records.IWriteRecord|null} [record] WriteOptions record
             * @property {protos.encoding.IEncodeOptions|null} [encodeOptions] WriteOptions encodeOptions
             * @property {protos.opts.IWriteCLIOptions|null} [_cliOptions] WriteOptions _cliOptions
             * @property {protos.opts.IWriteGroupKafkaOptions|null} [kafka] WriteOptions kafka
             * @property {protos.opts.IWriteGroupActiveMQOptions|null} [activemq] WriteOptions activemq
             * @property {protos.opts.IWriteGroupAWSSQSOptions|null} [awsSqs] WriteOptions awsSqs
             * @property {protos.opts.IWriteGroupAWSSNSOptions|null} [awsSns] WriteOptions awsSns
             * @property {protos.opts.IWriteGroupNatsOptions|null} [nats] WriteOptions nats
             * @property {protos.opts.IWriteGroupNatsStreamingOptions|null} [natsStreaming] WriteOptions natsStreaming
             * @property {protos.opts.IWriteGroupNSQOptions|null} [nsq] WriteOptions nsq
             * @property {protos.opts.IWriteGroupPulsarOptions|null} [pulsar] WriteOptions pulsar
             * @property {protos.opts.IWriteGroupRabbitOptions|null} [rabbit] WriteOptions rabbit
             * @property {protos.opts.IWriteGroupRabbitStreamsOptions|null} [rabbitStreams] WriteOptions rabbitStreams
             * @property {protos.opts.IWriteGroupMQTTOptions|null} [mqtt] WriteOptions mqtt
             * @property {protos.opts.IWriteGroupAzureServiceBusOptions|null} [azureServiceBus] WriteOptions azureServiceBus
             * @property {protos.opts.IWriteGroupAzureEventHubOptions|null} [azureEventHub] WriteOptions azureEventHub
             * @property {protos.opts.IWriteGroupGCPPubSubOptions|null} [gcpPubsub] WriteOptions gcpPubsub
             * @property {protos.opts.IWriteGroupKubeMQQueueOptions|null} [kubemqQueue] WriteOptions kubemqQueue
             * @property {protos.opts.IWriteGroupRedisPubSubOptions|null} [redisPubsub] WriteOptions redisPubsub
             * @property {protos.opts.IWriteGroupRedisStreamsOptions|null} [redisStreams] WriteOptions redisStreams
             * @property {protos.opts.IWriteGroupNatsJetstreamOptions|null} [natsJetstream] WriteOptions natsJetstream
             * @property {protos.opts.IWriteGroupAWSKinesisOptions|null} [awsKinesis] WriteOptions awsKinesis
             */

            /**
             * Constructs a new WriteOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteOptions.
             * @implements IWriteOptions
             * @constructor
             * @param {protos.opts.IWriteOptions=} [properties] Properties to set
             */
            function WriteOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteOptions connectionId.
             * @member {string} connectionId
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.connectionId = "";

            /**
             * WriteOptions record.
             * @member {protos.records.IWriteRecord|null|undefined} record
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.record = null;

            /**
             * WriteOptions encodeOptions.
             * @member {protos.encoding.IEncodeOptions|null|undefined} encodeOptions
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.encodeOptions = null;

            /**
             * WriteOptions _cliOptions.
             * @member {protos.opts.IWriteCLIOptions|null|undefined} _cliOptions
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype._cliOptions = null;

            /**
             * WriteOptions kafka.
             * @member {protos.opts.IWriteGroupKafkaOptions|null|undefined} kafka
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.kafka = null;

            /**
             * WriteOptions activemq.
             * @member {protos.opts.IWriteGroupActiveMQOptions|null|undefined} activemq
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.activemq = null;

            /**
             * WriteOptions awsSqs.
             * @member {protos.opts.IWriteGroupAWSSQSOptions|null|undefined} awsSqs
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.awsSqs = null;

            /**
             * WriteOptions awsSns.
             * @member {protos.opts.IWriteGroupAWSSNSOptions|null|undefined} awsSns
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.awsSns = null;

            /**
             * WriteOptions nats.
             * @member {protos.opts.IWriteGroupNatsOptions|null|undefined} nats
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.nats = null;

            /**
             * WriteOptions natsStreaming.
             * @member {protos.opts.IWriteGroupNatsStreamingOptions|null|undefined} natsStreaming
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.natsStreaming = null;

            /**
             * WriteOptions nsq.
             * @member {protos.opts.IWriteGroupNSQOptions|null|undefined} nsq
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.nsq = null;

            /**
             * WriteOptions pulsar.
             * @member {protos.opts.IWriteGroupPulsarOptions|null|undefined} pulsar
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.pulsar = null;

            /**
             * WriteOptions rabbit.
             * @member {protos.opts.IWriteGroupRabbitOptions|null|undefined} rabbit
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.rabbit = null;

            /**
             * WriteOptions rabbitStreams.
             * @member {protos.opts.IWriteGroupRabbitStreamsOptions|null|undefined} rabbitStreams
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.rabbitStreams = null;

            /**
             * WriteOptions mqtt.
             * @member {protos.opts.IWriteGroupMQTTOptions|null|undefined} mqtt
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.mqtt = null;

            /**
             * WriteOptions azureServiceBus.
             * @member {protos.opts.IWriteGroupAzureServiceBusOptions|null|undefined} azureServiceBus
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.azureServiceBus = null;

            /**
             * WriteOptions azureEventHub.
             * @member {protos.opts.IWriteGroupAzureEventHubOptions|null|undefined} azureEventHub
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.azureEventHub = null;

            /**
             * WriteOptions gcpPubsub.
             * @member {protos.opts.IWriteGroupGCPPubSubOptions|null|undefined} gcpPubsub
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.gcpPubsub = null;

            /**
             * WriteOptions kubemqQueue.
             * @member {protos.opts.IWriteGroupKubeMQQueueOptions|null|undefined} kubemqQueue
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.kubemqQueue = null;

            /**
             * WriteOptions redisPubsub.
             * @member {protos.opts.IWriteGroupRedisPubSubOptions|null|undefined} redisPubsub
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.redisPubsub = null;

            /**
             * WriteOptions redisStreams.
             * @member {protos.opts.IWriteGroupRedisStreamsOptions|null|undefined} redisStreams
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.redisStreams = null;

            /**
             * WriteOptions natsJetstream.
             * @member {protos.opts.IWriteGroupNatsJetstreamOptions|null|undefined} natsJetstream
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.natsJetstream = null;

            /**
             * WriteOptions awsKinesis.
             * @member {protos.opts.IWriteGroupAWSKinesisOptions|null|undefined} awsKinesis
             * @memberof protos.opts.WriteOptions
             * @instance
             */
            WriteOptions.prototype.awsKinesis = null;

            /**
             * Creates a new WriteOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {protos.opts.IWriteOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteOptions} WriteOptions instance
             */
            WriteOptions.create = function create(properties) {
                return new WriteOptions(properties);
            };

            /**
             * Encodes the specified WriteOptions message. Does not implicitly {@link protos.opts.WriteOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {protos.opts.IWriteOptions} message WriteOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
                if (message.record != null && Object.hasOwnProperty.call(message, "record"))
                    $root.protos.records.WriteRecord.encode(message.record, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.encodeOptions != null && Object.hasOwnProperty.call(message, "encodeOptions"))
                    $root.protos.encoding.EncodeOptions.encode(message.encodeOptions, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.opts.WriteGroupKafkaOptions.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.activemq != null && Object.hasOwnProperty.call(message, "activemq"))
                    $root.protos.opts.WriteGroupActiveMQOptions.encode(message.activemq, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.awsSqs != null && Object.hasOwnProperty.call(message, "awsSqs"))
                    $root.protos.opts.WriteGroupAWSSQSOptions.encode(message.awsSqs, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.awsSns != null && Object.hasOwnProperty.call(message, "awsSns"))
                    $root.protos.opts.WriteGroupAWSSNSOptions.encode(message.awsSns, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.opts.WriteGroupNatsOptions.encode(message.nats, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.opts.WriteGroupNatsStreamingOptions.encode(message.natsStreaming, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.opts.WriteGroupNSQOptions.encode(message.nsq, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.pulsar != null && Object.hasOwnProperty.call(message, "pulsar"))
                    $root.protos.opts.WriteGroupPulsarOptions.encode(message.pulsar, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.opts.WriteGroupRabbitOptions.encode(message.rabbit, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.rabbitStreams != null && Object.hasOwnProperty.call(message, "rabbitStreams"))
                    $root.protos.opts.WriteGroupRabbitStreamsOptions.encode(message.rabbitStreams, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.opts.WriteGroupMQTTOptions.encode(message.mqtt, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.opts.WriteGroupAzureServiceBusOptions.encode(message.azureServiceBus, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.azureEventHub != null && Object.hasOwnProperty.call(message, "azureEventHub"))
                    $root.protos.opts.WriteGroupAzureEventHubOptions.encode(message.azureEventHub, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.opts.WriteGroupGCPPubSubOptions.encode(message.gcpPubsub, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.opts.WriteGroupKubeMQQueueOptions.encode(message.kubemqQueue, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.opts.WriteGroupRedisPubSubOptions.encode(message.redisPubsub, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.opts.WriteGroupRedisStreamsOptions.encode(message.redisStreams, writer.uint32(/* id 116, wireType 2 =*/930).fork()).ldelim();
                if (message.natsJetstream != null && Object.hasOwnProperty.call(message, "natsJetstream"))
                    $root.protos.opts.WriteGroupNatsJetstreamOptions.encode(message.natsJetstream, writer.uint32(/* id 117, wireType 2 =*/938).fork()).ldelim();
                if (message.awsKinesis != null && Object.hasOwnProperty.call(message, "awsKinesis"))
                    $root.protos.opts.WriteGroupAWSKinesisOptions.encode(message.awsKinesis, writer.uint32(/* id 118, wireType 2 =*/946).fork()).ldelim();
                if (message._cliOptions != null && Object.hasOwnProperty.call(message, "_cliOptions"))
                    $root.protos.opts.WriteCLIOptions.encode(message._cliOptions, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteOptions message, length delimited. Does not implicitly {@link protos.opts.WriteOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {protos.opts.IWriteOptions} message WriteOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteOptions} WriteOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.connectionId = reader.string();
                        break;
                    case 2:
                        message.record = $root.protos.records.WriteRecord.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.encodeOptions = $root.protos.encoding.EncodeOptions.decode(reader, reader.uint32());
                        break;
                    case 1000:
                        message._cliOptions = $root.protos.opts.WriteCLIOptions.decode(reader, reader.uint32());
                        break;
                    case 100:
                        message.kafka = $root.protos.opts.WriteGroupKafkaOptions.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.activemq = $root.protos.opts.WriteGroupActiveMQOptions.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.awsSqs = $root.protos.opts.WriteGroupAWSSQSOptions.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.awsSns = $root.protos.opts.WriteGroupAWSSNSOptions.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.nats = $root.protos.opts.WriteGroupNatsOptions.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.natsStreaming = $root.protos.opts.WriteGroupNatsStreamingOptions.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.nsq = $root.protos.opts.WriteGroupNSQOptions.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.pulsar = $root.protos.opts.WriteGroupPulsarOptions.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.rabbit = $root.protos.opts.WriteGroupRabbitOptions.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.rabbitStreams = $root.protos.opts.WriteGroupRabbitStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 110:
                        message.mqtt = $root.protos.opts.WriteGroupMQTTOptions.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.azureServiceBus = $root.protos.opts.WriteGroupAzureServiceBusOptions.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.azureEventHub = $root.protos.opts.WriteGroupAzureEventHubOptions.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.gcpPubsub = $root.protos.opts.WriteGroupGCPPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.redisPubsub = $root.protos.opts.WriteGroupRedisPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 116:
                        message.redisStreams = $root.protos.opts.WriteGroupRedisStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 117:
                        message.natsJetstream = $root.protos.opts.WriteGroupNatsJetstreamOptions.decode(reader, reader.uint32());
                        break;
                    case 118:
                        message.awsKinesis = $root.protos.opts.WriteGroupAWSKinesisOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteOptions} WriteOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteOptions message.
             * @function verify
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    if (!$util.isString(message.connectionId))
                        return "connectionId: string expected";
                if (message.record != null && message.hasOwnProperty("record")) {
                    var error = $root.protos.records.WriteRecord.verify(message.record);
                    if (error)
                        return "record." + error;
                }
                if (message.encodeOptions != null && message.hasOwnProperty("encodeOptions")) {
                    var error = $root.protos.encoding.EncodeOptions.verify(message.encodeOptions);
                    if (error)
                        return "encodeOptions." + error;
                }
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions")) {
                    var error = $root.protos.opts.WriteCLIOptions.verify(message._cliOptions);
                    if (error)
                        return "_cliOptions." + error;
                }
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    var error = $root.protos.opts.WriteGroupKafkaOptions.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.activemq != null && message.hasOwnProperty("activemq")) {
                    var error = $root.protos.opts.WriteGroupActiveMQOptions.verify(message.activemq);
                    if (error)
                        return "activemq." + error;
                }
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs")) {
                    var error = $root.protos.opts.WriteGroupAWSSQSOptions.verify(message.awsSqs);
                    if (error)
                        return "awsSqs." + error;
                }
                if (message.awsSns != null && message.hasOwnProperty("awsSns")) {
                    var error = $root.protos.opts.WriteGroupAWSSNSOptions.verify(message.awsSns);
                    if (error)
                        return "awsSns." + error;
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    var error = $root.protos.opts.WriteGroupNatsOptions.verify(message.nats);
                    if (error)
                        return "nats." + error;
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    var error = $root.protos.opts.WriteGroupNatsStreamingOptions.verify(message.natsStreaming);
                    if (error)
                        return "natsStreaming." + error;
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    var error = $root.protos.opts.WriteGroupNSQOptions.verify(message.nsq);
                    if (error)
                        return "nsq." + error;
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    var error = $root.protos.opts.WriteGroupPulsarOptions.verify(message.pulsar);
                    if (error)
                        return "pulsar." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    var error = $root.protos.opts.WriteGroupRabbitOptions.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    var error = $root.protos.opts.WriteGroupRabbitStreamsOptions.verify(message.rabbitStreams);
                    if (error)
                        return "rabbitStreams." + error;
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    var error = $root.protos.opts.WriteGroupMQTTOptions.verify(message.mqtt);
                    if (error)
                        return "mqtt." + error;
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    var error = $root.protos.opts.WriteGroupAzureServiceBusOptions.verify(message.azureServiceBus);
                    if (error)
                        return "azureServiceBus." + error;
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    var error = $root.protos.opts.WriteGroupAzureEventHubOptions.verify(message.azureEventHub);
                    if (error)
                        return "azureEventHub." + error;
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    var error = $root.protos.opts.WriteGroupGCPPubSubOptions.verify(message.gcpPubsub);
                    if (error)
                        return "gcpPubsub." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    var error = $root.protos.opts.WriteGroupKubeMQQueueOptions.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    var error = $root.protos.opts.WriteGroupRedisPubSubOptions.verify(message.redisPubsub);
                    if (error)
                        return "redisPubsub." + error;
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    var error = $root.protos.opts.WriteGroupRedisStreamsOptions.verify(message.redisStreams);
                    if (error)
                        return "redisStreams." + error;
                }
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream")) {
                    var error = $root.protos.opts.WriteGroupNatsJetstreamOptions.verify(message.natsJetstream);
                    if (error)
                        return "natsJetstream." + error;
                }
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis")) {
                    var error = $root.protos.opts.WriteGroupAWSKinesisOptions.verify(message.awsKinesis);
                    if (error)
                        return "awsKinesis." + error;
                }
                return null;
            };

            /**
             * Creates a WriteOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteOptions} WriteOptions
             */
            WriteOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteOptions)
                    return object;
                var message = new $root.protos.opts.WriteOptions();
                if (object.connectionId != null)
                    message.connectionId = String(object.connectionId);
                if (object.record != null) {
                    if (typeof object.record !== "object")
                        throw TypeError(".protos.opts.WriteOptions.record: object expected");
                    message.record = $root.protos.records.WriteRecord.fromObject(object.record);
                }
                if (object.encodeOptions != null) {
                    if (typeof object.encodeOptions !== "object")
                        throw TypeError(".protos.opts.WriteOptions.encodeOptions: object expected");
                    message.encodeOptions = $root.protos.encoding.EncodeOptions.fromObject(object.encodeOptions);
                }
                if (object._cliOptions != null) {
                    if (typeof object._cliOptions !== "object")
                        throw TypeError(".protos.opts.WriteOptions._cliOptions: object expected");
                    message._cliOptions = $root.protos.opts.WriteCLIOptions.fromObject(object._cliOptions);
                }
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.WriteOptions.kafka: object expected");
                    message.kafka = $root.protos.opts.WriteGroupKafkaOptions.fromObject(object.kafka);
                }
                if (object.activemq != null) {
                    if (typeof object.activemq !== "object")
                        throw TypeError(".protos.opts.WriteOptions.activemq: object expected");
                    message.activemq = $root.protos.opts.WriteGroupActiveMQOptions.fromObject(object.activemq);
                }
                if (object.awsSqs != null) {
                    if (typeof object.awsSqs !== "object")
                        throw TypeError(".protos.opts.WriteOptions.awsSqs: object expected");
                    message.awsSqs = $root.protos.opts.WriteGroupAWSSQSOptions.fromObject(object.awsSqs);
                }
                if (object.awsSns != null) {
                    if (typeof object.awsSns !== "object")
                        throw TypeError(".protos.opts.WriteOptions.awsSns: object expected");
                    message.awsSns = $root.protos.opts.WriteGroupAWSSNSOptions.fromObject(object.awsSns);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.opts.WriteOptions.nats: object expected");
                    message.nats = $root.protos.opts.WriteGroupNatsOptions.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.opts.WriteOptions.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.opts.WriteGroupNatsStreamingOptions.fromObject(object.natsStreaming);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.WriteOptions.nsq: object expected");
                    message.nsq = $root.protos.opts.WriteGroupNSQOptions.fromObject(object.nsq);
                }
                if (object.pulsar != null) {
                    if (typeof object.pulsar !== "object")
                        throw TypeError(".protos.opts.WriteOptions.pulsar: object expected");
                    message.pulsar = $root.protos.opts.WriteGroupPulsarOptions.fromObject(object.pulsar);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.WriteOptions.rabbit: object expected");
                    message.rabbit = $root.protos.opts.WriteGroupRabbitOptions.fromObject(object.rabbit);
                }
                if (object.rabbitStreams != null) {
                    if (typeof object.rabbitStreams !== "object")
                        throw TypeError(".protos.opts.WriteOptions.rabbitStreams: object expected");
                    message.rabbitStreams = $root.protos.opts.WriteGroupRabbitStreamsOptions.fromObject(object.rabbitStreams);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.WriteOptions.mqtt: object expected");
                    message.mqtt = $root.protos.opts.WriteGroupMQTTOptions.fromObject(object.mqtt);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.WriteOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.opts.WriteGroupAzureServiceBusOptions.fromObject(object.azureServiceBus);
                }
                if (object.azureEventHub != null) {
                    if (typeof object.azureEventHub !== "object")
                        throw TypeError(".protos.opts.WriteOptions.azureEventHub: object expected");
                    message.azureEventHub = $root.protos.opts.WriteGroupAzureEventHubOptions.fromObject(object.azureEventHub);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.WriteOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.opts.WriteGroupGCPPubSubOptions.fromObject(object.gcpPubsub);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.WriteOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.fromObject(object.kubemqQueue);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.WriteOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.opts.WriteGroupRedisPubSubOptions.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.WriteOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.opts.WriteGroupRedisStreamsOptions.fromObject(object.redisStreams);
                }
                if (object.natsJetstream != null) {
                    if (typeof object.natsJetstream !== "object")
                        throw TypeError(".protos.opts.WriteOptions.natsJetstream: object expected");
                    message.natsJetstream = $root.protos.opts.WriteGroupNatsJetstreamOptions.fromObject(object.natsJetstream);
                }
                if (object.awsKinesis != null) {
                    if (typeof object.awsKinesis !== "object")
                        throw TypeError(".protos.opts.WriteOptions.awsKinesis: object expected");
                    message.awsKinesis = $root.protos.opts.WriteGroupAWSKinesisOptions.fromObject(object.awsKinesis);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteOptions
             * @static
             * @param {protos.opts.WriteOptions} message WriteOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.connectionId = "";
                    object.record = null;
                    object.encodeOptions = null;
                    object.kafka = null;
                    object.activemq = null;
                    object.awsSqs = null;
                    object.awsSns = null;
                    object.nats = null;
                    object.natsStreaming = null;
                    object.nsq = null;
                    object.pulsar = null;
                    object.rabbit = null;
                    object.rabbitStreams = null;
                    object.mqtt = null;
                    object.azureServiceBus = null;
                    object.azureEventHub = null;
                    object.gcpPubsub = null;
                    object.kubemqQueue = null;
                    object.redisPubsub = null;
                    object.redisStreams = null;
                    object.natsJetstream = null;
                    object.awsKinesis = null;
                    object._cliOptions = null;
                }
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    object.connectionId = message.connectionId;
                if (message.record != null && message.hasOwnProperty("record"))
                    object.record = $root.protos.records.WriteRecord.toObject(message.record, options);
                if (message.encodeOptions != null && message.hasOwnProperty("encodeOptions"))
                    object.encodeOptions = $root.protos.encoding.EncodeOptions.toObject(message.encodeOptions, options);
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.opts.WriteGroupKafkaOptions.toObject(message.kafka, options);
                if (message.activemq != null && message.hasOwnProperty("activemq"))
                    object.activemq = $root.protos.opts.WriteGroupActiveMQOptions.toObject(message.activemq, options);
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs"))
                    object.awsSqs = $root.protos.opts.WriteGroupAWSSQSOptions.toObject(message.awsSqs, options);
                if (message.awsSns != null && message.hasOwnProperty("awsSns"))
                    object.awsSns = $root.protos.opts.WriteGroupAWSSNSOptions.toObject(message.awsSns, options);
                if (message.nats != null && message.hasOwnProperty("nats"))
                    object.nats = $root.protos.opts.WriteGroupNatsOptions.toObject(message.nats, options);
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming"))
                    object.natsStreaming = $root.protos.opts.WriteGroupNatsStreamingOptions.toObject(message.natsStreaming, options);
                if (message.nsq != null && message.hasOwnProperty("nsq"))
                    object.nsq = $root.protos.opts.WriteGroupNSQOptions.toObject(message.nsq, options);
                if (message.pulsar != null && message.hasOwnProperty("pulsar"))
                    object.pulsar = $root.protos.opts.WriteGroupPulsarOptions.toObject(message.pulsar, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.opts.WriteGroupRabbitOptions.toObject(message.rabbit, options);
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams"))
                    object.rabbitStreams = $root.protos.opts.WriteGroupRabbitStreamsOptions.toObject(message.rabbitStreams, options);
                if (message.mqtt != null && message.hasOwnProperty("mqtt"))
                    object.mqtt = $root.protos.opts.WriteGroupMQTTOptions.toObject(message.mqtt, options);
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus"))
                    object.azureServiceBus = $root.protos.opts.WriteGroupAzureServiceBusOptions.toObject(message.azureServiceBus, options);
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub"))
                    object.azureEventHub = $root.protos.opts.WriteGroupAzureEventHubOptions.toObject(message.azureEventHub, options);
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub"))
                    object.gcpPubsub = $root.protos.opts.WriteGroupGCPPubSubOptions.toObject(message.gcpPubsub, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.opts.WriteGroupKubeMQQueueOptions.toObject(message.kubemqQueue, options);
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub"))
                    object.redisPubsub = $root.protos.opts.WriteGroupRedisPubSubOptions.toObject(message.redisPubsub, options);
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams"))
                    object.redisStreams = $root.protos.opts.WriteGroupRedisStreamsOptions.toObject(message.redisStreams, options);
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream"))
                    object.natsJetstream = $root.protos.opts.WriteGroupNatsJetstreamOptions.toObject(message.natsJetstream, options);
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis"))
                    object.awsKinesis = $root.protos.opts.WriteGroupAWSKinesisOptions.toObject(message.awsKinesis, options);
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions"))
                    object._cliOptions = $root.protos.opts.WriteCLIOptions.toObject(message._cliOptions, options);
                return object;
            };

            /**
             * Converts this WriteOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteOptions;
        })();

        opts.WriteGroupKafkaOptions = (function() {

            /**
             * Properties of a WriteGroupKafkaOptions.
             * @memberof protos.opts
             * @interface IWriteGroupKafkaOptions
             * @property {protos.args.IKafkaConn|null} [_conn] WriteGroupKafkaOptions _conn
             * @property {protos.args.IKafkaWriteArgs|null} [args] WriteGroupKafkaOptions args
             */

            /**
             * Constructs a new WriteGroupKafkaOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupKafkaOptions.
             * @implements IWriteGroupKafkaOptions
             * @constructor
             * @param {protos.opts.IWriteGroupKafkaOptions=} [properties] Properties to set
             */
            function WriteGroupKafkaOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupKafkaOptions _conn.
             * @member {protos.args.IKafkaConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @instance
             */
            WriteGroupKafkaOptions.prototype._conn = null;

            /**
             * WriteGroupKafkaOptions args.
             * @member {protos.args.IKafkaWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @instance
             */
            WriteGroupKafkaOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupKafkaOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {protos.opts.IWriteGroupKafkaOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupKafkaOptions} WriteGroupKafkaOptions instance
             */
            WriteGroupKafkaOptions.create = function create(properties) {
                return new WriteGroupKafkaOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupKafkaOptions message. Does not implicitly {@link protos.opts.WriteGroupKafkaOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {protos.opts.IWriteGroupKafkaOptions} message WriteGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupKafkaOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KafkaConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KafkaWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupKafkaOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupKafkaOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {protos.opts.IWriteGroupKafkaOptions} message WriteGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupKafkaOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupKafkaOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupKafkaOptions} WriteGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupKafkaOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupKafkaOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KafkaConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KafkaWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupKafkaOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupKafkaOptions} WriteGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupKafkaOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupKafkaOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupKafkaOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KafkaConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KafkaWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupKafkaOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupKafkaOptions} WriteGroupKafkaOptions
             */
            WriteGroupKafkaOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupKafkaOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupKafkaOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupKafkaOptions._conn: object expected");
                    message._conn = $root.protos.args.KafkaConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupKafkaOptions.args: object expected");
                    message.args = $root.protos.args.KafkaWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupKafkaOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @static
             * @param {protos.opts.WriteGroupKafkaOptions} message WriteGroupKafkaOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupKafkaOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KafkaConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KafkaWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupKafkaOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupKafkaOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupKafkaOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupKafkaOptions;
        })();

        opts.WriteGroupActiveMQOptions = (function() {

            /**
             * Properties of a WriteGroupActiveMQOptions.
             * @memberof protos.opts
             * @interface IWriteGroupActiveMQOptions
             * @property {protos.args.IActiveMQConn|null} [_conn] WriteGroupActiveMQOptions _conn
             * @property {protos.args.IActiveMQWriteArgs|null} [args] WriteGroupActiveMQOptions args
             */

            /**
             * Constructs a new WriteGroupActiveMQOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupActiveMQOptions.
             * @implements IWriteGroupActiveMQOptions
             * @constructor
             * @param {protos.opts.IWriteGroupActiveMQOptions=} [properties] Properties to set
             */
            function WriteGroupActiveMQOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupActiveMQOptions _conn.
             * @member {protos.args.IActiveMQConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @instance
             */
            WriteGroupActiveMQOptions.prototype._conn = null;

            /**
             * WriteGroupActiveMQOptions args.
             * @member {protos.args.IActiveMQWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @instance
             */
            WriteGroupActiveMQOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupActiveMQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {protos.opts.IWriteGroupActiveMQOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupActiveMQOptions} WriteGroupActiveMQOptions instance
             */
            WriteGroupActiveMQOptions.create = function create(properties) {
                return new WriteGroupActiveMQOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupActiveMQOptions message. Does not implicitly {@link protos.opts.WriteGroupActiveMQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {protos.opts.IWriteGroupActiveMQOptions} message WriteGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupActiveMQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.ActiveMQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.ActiveMQWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupActiveMQOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupActiveMQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {protos.opts.IWriteGroupActiveMQOptions} message WriteGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupActiveMQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupActiveMQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupActiveMQOptions} WriteGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupActiveMQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupActiveMQOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.ActiveMQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.ActiveMQWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupActiveMQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupActiveMQOptions} WriteGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupActiveMQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupActiveMQOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupActiveMQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.ActiveMQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.ActiveMQWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupActiveMQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupActiveMQOptions} WriteGroupActiveMQOptions
             */
            WriteGroupActiveMQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupActiveMQOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupActiveMQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupActiveMQOptions._conn: object expected");
                    message._conn = $root.protos.args.ActiveMQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupActiveMQOptions.args: object expected");
                    message.args = $root.protos.args.ActiveMQWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupActiveMQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @static
             * @param {protos.opts.WriteGroupActiveMQOptions} message WriteGroupActiveMQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupActiveMQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.ActiveMQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.ActiveMQWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupActiveMQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupActiveMQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupActiveMQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupActiveMQOptions;
        })();

        opts.WriteGroupAWSSQSOptions = (function() {

            /**
             * Properties of a WriteGroupAWSSQSOptions.
             * @memberof protos.opts
             * @interface IWriteGroupAWSSQSOptions
             * @property {protos.args.IAWSSQSConn|null} [_conn] WriteGroupAWSSQSOptions _conn
             * @property {protos.args.IAWSSQSWriteArgs|null} [args] WriteGroupAWSSQSOptions args
             */

            /**
             * Constructs a new WriteGroupAWSSQSOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupAWSSQSOptions.
             * @implements IWriteGroupAWSSQSOptions
             * @constructor
             * @param {protos.opts.IWriteGroupAWSSQSOptions=} [properties] Properties to set
             */
            function WriteGroupAWSSQSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupAWSSQSOptions _conn.
             * @member {protos.args.IAWSSQSConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @instance
             */
            WriteGroupAWSSQSOptions.prototype._conn = null;

            /**
             * WriteGroupAWSSQSOptions args.
             * @member {protos.args.IAWSSQSWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @instance
             */
            WriteGroupAWSSQSOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupAWSSQSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSQSOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupAWSSQSOptions} WriteGroupAWSSQSOptions instance
             */
            WriteGroupAWSSQSOptions.create = function create(properties) {
                return new WriteGroupAWSSQSOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupAWSSQSOptions message. Does not implicitly {@link protos.opts.WriteGroupAWSSQSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSQSOptions} message WriteGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAWSSQSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSQSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSQSWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupAWSSQSOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupAWSSQSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSQSOptions} message WriteGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAWSSQSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupAWSSQSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupAWSSQSOptions} WriteGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAWSSQSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupAWSSQSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSQSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSQSWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupAWSSQSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupAWSSQSOptions} WriteGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAWSSQSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupAWSSQSOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupAWSSQSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSSQSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSSQSWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupAWSSQSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupAWSSQSOptions} WriteGroupAWSSQSOptions
             */
            WriteGroupAWSSQSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupAWSSQSOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupAWSSQSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupAWSSQSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSQSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupAWSSQSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSQSWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupAWSSQSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @static
             * @param {protos.opts.WriteGroupAWSSQSOptions} message WriteGroupAWSSQSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupAWSSQSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSQSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSQSWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupAWSSQSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupAWSSQSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupAWSSQSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupAWSSQSOptions;
        })();

        opts.WriteGroupAWSSNSOptions = (function() {

            /**
             * Properties of a WriteGroupAWSSNSOptions.
             * @memberof protos.opts
             * @interface IWriteGroupAWSSNSOptions
             * @property {protos.args.IAWSSNSConn|null} [_conn] WriteGroupAWSSNSOptions _conn
             * @property {protos.args.IAWSSNSWriteArgs|null} [args] WriteGroupAWSSNSOptions args
             */

            /**
             * Constructs a new WriteGroupAWSSNSOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupAWSSNSOptions.
             * @implements IWriteGroupAWSSNSOptions
             * @constructor
             * @param {protos.opts.IWriteGroupAWSSNSOptions=} [properties] Properties to set
             */
            function WriteGroupAWSSNSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupAWSSNSOptions _conn.
             * @member {protos.args.IAWSSNSConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @instance
             */
            WriteGroupAWSSNSOptions.prototype._conn = null;

            /**
             * WriteGroupAWSSNSOptions args.
             * @member {protos.args.IAWSSNSWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @instance
             */
            WriteGroupAWSSNSOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupAWSSNSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSNSOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupAWSSNSOptions} WriteGroupAWSSNSOptions instance
             */
            WriteGroupAWSSNSOptions.create = function create(properties) {
                return new WriteGroupAWSSNSOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupAWSSNSOptions message. Does not implicitly {@link protos.opts.WriteGroupAWSSNSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSNSOptions} message WriteGroupAWSSNSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAWSSNSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSNSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSNSWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupAWSSNSOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupAWSSNSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSSNSOptions} message WriteGroupAWSSNSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAWSSNSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupAWSSNSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupAWSSNSOptions} WriteGroupAWSSNSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAWSSNSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupAWSSNSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSNSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSNSWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupAWSSNSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupAWSSNSOptions} WriteGroupAWSSNSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAWSSNSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupAWSSNSOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupAWSSNSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSSNSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSSNSWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupAWSSNSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupAWSSNSOptions} WriteGroupAWSSNSOptions
             */
            WriteGroupAWSSNSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupAWSSNSOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupAWSSNSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupAWSSNSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSNSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupAWSSNSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSNSWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupAWSSNSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @static
             * @param {protos.opts.WriteGroupAWSSNSOptions} message WriteGroupAWSSNSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupAWSSNSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSNSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSNSWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupAWSSNSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupAWSSNSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupAWSSNSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupAWSSNSOptions;
        })();

        opts.WriteGroupNatsOptions = (function() {

            /**
             * Properties of a WriteGroupNatsOptions.
             * @memberof protos.opts
             * @interface IWriteGroupNatsOptions
             * @property {protos.args.INatsConn|null} [_conn] WriteGroupNatsOptions _conn
             * @property {protos.args.INatsWriteArgs|null} [args] WriteGroupNatsOptions args
             */

            /**
             * Constructs a new WriteGroupNatsOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupNatsOptions.
             * @implements IWriteGroupNatsOptions
             * @constructor
             * @param {protos.opts.IWriteGroupNatsOptions=} [properties] Properties to set
             */
            function WriteGroupNatsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupNatsOptions _conn.
             * @member {protos.args.INatsConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupNatsOptions
             * @instance
             */
            WriteGroupNatsOptions.prototype._conn = null;

            /**
             * WriteGroupNatsOptions args.
             * @member {protos.args.INatsWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupNatsOptions
             * @instance
             */
            WriteGroupNatsOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupNatsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupNatsOptions} WriteGroupNatsOptions instance
             */
            WriteGroupNatsOptions.create = function create(properties) {
                return new WriteGroupNatsOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupNatsOptions message. Does not implicitly {@link protos.opts.WriteGroupNatsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsOptions} message WriteGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNatsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupNatsOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupNatsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsOptions} message WriteGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNatsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupNatsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupNatsOptions} WriteGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNatsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupNatsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupNatsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupNatsOptions} WriteGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNatsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupNatsOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupNatsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupNatsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupNatsOptions} WriteGroupNatsOptions
             */
            WriteGroupNatsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupNatsOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupNatsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupNatsOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupNatsOptions.args: object expected");
                    message.args = $root.protos.args.NatsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupNatsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupNatsOptions
             * @static
             * @param {protos.opts.WriteGroupNatsOptions} message WriteGroupNatsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupNatsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupNatsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupNatsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupNatsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupNatsOptions;
        })();

        opts.WriteGroupNatsJetstreamOptions = (function() {

            /**
             * Properties of a WriteGroupNatsJetstreamOptions.
             * @memberof protos.opts
             * @interface IWriteGroupNatsJetstreamOptions
             * @property {protos.args.INatsJetstreamConn|null} [_conn] WriteGroupNatsJetstreamOptions _conn
             * @property {protos.args.INatsJetstreamWriteArgs|null} [args] WriteGroupNatsJetstreamOptions args
             */

            /**
             * Constructs a new WriteGroupNatsJetstreamOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupNatsJetstreamOptions.
             * @implements IWriteGroupNatsJetstreamOptions
             * @constructor
             * @param {protos.opts.IWriteGroupNatsJetstreamOptions=} [properties] Properties to set
             */
            function WriteGroupNatsJetstreamOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupNatsJetstreamOptions _conn.
             * @member {protos.args.INatsJetstreamConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @instance
             */
            WriteGroupNatsJetstreamOptions.prototype._conn = null;

            /**
             * WriteGroupNatsJetstreamOptions args.
             * @member {protos.args.INatsJetstreamWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @instance
             */
            WriteGroupNatsJetstreamOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupNatsJetstreamOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsJetstreamOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupNatsJetstreamOptions} WriteGroupNatsJetstreamOptions instance
             */
            WriteGroupNatsJetstreamOptions.create = function create(properties) {
                return new WriteGroupNatsJetstreamOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupNatsJetstreamOptions message. Does not implicitly {@link protos.opts.WriteGroupNatsJetstreamOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsJetstreamOptions} message WriteGroupNatsJetstreamOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNatsJetstreamOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsJetstreamConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsJetstreamWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupNatsJetstreamOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupNatsJetstreamOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsJetstreamOptions} message WriteGroupNatsJetstreamOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNatsJetstreamOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupNatsJetstreamOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupNatsJetstreamOptions} WriteGroupNatsJetstreamOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNatsJetstreamOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupNatsJetstreamOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsJetstreamConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsJetstreamWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupNatsJetstreamOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupNatsJetstreamOptions} WriteGroupNatsJetstreamOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNatsJetstreamOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupNatsJetstreamOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupNatsJetstreamOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsJetstreamConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsJetstreamWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupNatsJetstreamOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupNatsJetstreamOptions} WriteGroupNatsJetstreamOptions
             */
            WriteGroupNatsJetstreamOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupNatsJetstreamOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupNatsJetstreamOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupNatsJetstreamOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsJetstreamConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupNatsJetstreamOptions.args: object expected");
                    message.args = $root.protos.args.NatsJetstreamWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupNatsJetstreamOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.WriteGroupNatsJetstreamOptions} message WriteGroupNatsJetstreamOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupNatsJetstreamOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsJetstreamConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsJetstreamWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupNatsJetstreamOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupNatsJetstreamOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupNatsJetstreamOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupNatsJetstreamOptions;
        })();

        opts.WriteGroupNatsStreamingOptions = (function() {

            /**
             * Properties of a WriteGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @interface IWriteGroupNatsStreamingOptions
             * @property {protos.args.INatsStreamingConn|null} [_conn] WriteGroupNatsStreamingOptions _conn
             * @property {protos.args.INatsStreamingWriteArgs|null} [args] WriteGroupNatsStreamingOptions args
             */

            /**
             * Constructs a new WriteGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupNatsStreamingOptions.
             * @implements IWriteGroupNatsStreamingOptions
             * @constructor
             * @param {protos.opts.IWriteGroupNatsStreamingOptions=} [properties] Properties to set
             */
            function WriteGroupNatsStreamingOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupNatsStreamingOptions _conn.
             * @member {protos.args.INatsStreamingConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @instance
             */
            WriteGroupNatsStreamingOptions.prototype._conn = null;

            /**
             * WriteGroupNatsStreamingOptions args.
             * @member {protos.args.INatsStreamingWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @instance
             */
            WriteGroupNatsStreamingOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupNatsStreamingOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsStreamingOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupNatsStreamingOptions} WriteGroupNatsStreamingOptions instance
             */
            WriteGroupNatsStreamingOptions.create = function create(properties) {
                return new WriteGroupNatsStreamingOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupNatsStreamingOptions message. Does not implicitly {@link protos.opts.WriteGroupNatsStreamingOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsStreamingOptions} message WriteGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNatsStreamingOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsStreamingConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsStreamingWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupNatsStreamingOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupNatsStreamingOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IWriteGroupNatsStreamingOptions} message WriteGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNatsStreamingOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupNatsStreamingOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupNatsStreamingOptions} WriteGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNatsStreamingOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupNatsStreamingOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsStreamingConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsStreamingWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupNatsStreamingOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupNatsStreamingOptions} WriteGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNatsStreamingOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupNatsStreamingOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupNatsStreamingOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsStreamingConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsStreamingWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupNatsStreamingOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupNatsStreamingOptions} WriteGroupNatsStreamingOptions
             */
            WriteGroupNatsStreamingOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupNatsStreamingOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupNatsStreamingOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupNatsStreamingOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsStreamingConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupNatsStreamingOptions.args: object expected");
                    message.args = $root.protos.args.NatsStreamingWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupNatsStreamingOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.WriteGroupNatsStreamingOptions} message WriteGroupNatsStreamingOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupNatsStreamingOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsStreamingConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsStreamingWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupNatsStreamingOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupNatsStreamingOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupNatsStreamingOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupNatsStreamingOptions;
        })();

        opts.WriteGroupNSQOptions = (function() {

            /**
             * Properties of a WriteGroupNSQOptions.
             * @memberof protos.opts
             * @interface IWriteGroupNSQOptions
             * @property {protos.args.INSQConn|null} [_conn] WriteGroupNSQOptions _conn
             * @property {protos.args.INSQWriteArgs|null} [args] WriteGroupNSQOptions args
             */

            /**
             * Constructs a new WriteGroupNSQOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupNSQOptions.
             * @implements IWriteGroupNSQOptions
             * @constructor
             * @param {protos.opts.IWriteGroupNSQOptions=} [properties] Properties to set
             */
            function WriteGroupNSQOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupNSQOptions _conn.
             * @member {protos.args.INSQConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupNSQOptions
             * @instance
             */
            WriteGroupNSQOptions.prototype._conn = null;

            /**
             * WriteGroupNSQOptions args.
             * @member {protos.args.INSQWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupNSQOptions
             * @instance
             */
            WriteGroupNSQOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupNSQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {protos.opts.IWriteGroupNSQOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupNSQOptions} WriteGroupNSQOptions instance
             */
            WriteGroupNSQOptions.create = function create(properties) {
                return new WriteGroupNSQOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupNSQOptions message. Does not implicitly {@link protos.opts.WriteGroupNSQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {protos.opts.IWriteGroupNSQOptions} message WriteGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNSQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NSQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NSQWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupNSQOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupNSQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {protos.opts.IWriteGroupNSQOptions} message WriteGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupNSQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupNSQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupNSQOptions} WriteGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNSQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupNSQOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NSQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NSQWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupNSQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupNSQOptions} WriteGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupNSQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupNSQOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupNSQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NSQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NSQWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupNSQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupNSQOptions} WriteGroupNSQOptions
             */
            WriteGroupNSQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupNSQOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupNSQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupNSQOptions._conn: object expected");
                    message._conn = $root.protos.args.NSQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupNSQOptions.args: object expected");
                    message.args = $root.protos.args.NSQWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupNSQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupNSQOptions
             * @static
             * @param {protos.opts.WriteGroupNSQOptions} message WriteGroupNSQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupNSQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NSQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NSQWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupNSQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupNSQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupNSQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupNSQOptions;
        })();

        opts.WriteGroupPulsarOptions = (function() {

            /**
             * Properties of a WriteGroupPulsarOptions.
             * @memberof protos.opts
             * @interface IWriteGroupPulsarOptions
             * @property {protos.args.IPulsarConn|null} [_conn] WriteGroupPulsarOptions _conn
             * @property {protos.args.IPulsarWriteArgs|null} [args] WriteGroupPulsarOptions args
             */

            /**
             * Constructs a new WriteGroupPulsarOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupPulsarOptions.
             * @implements IWriteGroupPulsarOptions
             * @constructor
             * @param {protos.opts.IWriteGroupPulsarOptions=} [properties] Properties to set
             */
            function WriteGroupPulsarOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupPulsarOptions _conn.
             * @member {protos.args.IPulsarConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @instance
             */
            WriteGroupPulsarOptions.prototype._conn = null;

            /**
             * WriteGroupPulsarOptions args.
             * @member {protos.args.IPulsarWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @instance
             */
            WriteGroupPulsarOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupPulsarOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {protos.opts.IWriteGroupPulsarOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupPulsarOptions} WriteGroupPulsarOptions instance
             */
            WriteGroupPulsarOptions.create = function create(properties) {
                return new WriteGroupPulsarOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupPulsarOptions message. Does not implicitly {@link protos.opts.WriteGroupPulsarOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {protos.opts.IWriteGroupPulsarOptions} message WriteGroupPulsarOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupPulsarOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.PulsarConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.PulsarWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupPulsarOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupPulsarOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {protos.opts.IWriteGroupPulsarOptions} message WriteGroupPulsarOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupPulsarOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupPulsarOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupPulsarOptions} WriteGroupPulsarOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupPulsarOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupPulsarOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.PulsarConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.PulsarWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupPulsarOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupPulsarOptions} WriteGroupPulsarOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupPulsarOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupPulsarOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupPulsarOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.PulsarConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.PulsarWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupPulsarOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupPulsarOptions} WriteGroupPulsarOptions
             */
            WriteGroupPulsarOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupPulsarOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupPulsarOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupPulsarOptions._conn: object expected");
                    message._conn = $root.protos.args.PulsarConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupPulsarOptions.args: object expected");
                    message.args = $root.protos.args.PulsarWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupPulsarOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @static
             * @param {protos.opts.WriteGroupPulsarOptions} message WriteGroupPulsarOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupPulsarOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.PulsarConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.PulsarWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupPulsarOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupPulsarOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupPulsarOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupPulsarOptions;
        })();

        opts.WriteGroupRabbitOptions = (function() {

            /**
             * Properties of a WriteGroupRabbitOptions.
             * @memberof protos.opts
             * @interface IWriteGroupRabbitOptions
             * @property {protos.args.IRabbitConn|null} [_conn] WriteGroupRabbitOptions _conn
             * @property {protos.args.IRabbitWriteArgs|null} [args] WriteGroupRabbitOptions args
             */

            /**
             * Constructs a new WriteGroupRabbitOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupRabbitOptions.
             * @implements IWriteGroupRabbitOptions
             * @constructor
             * @param {protos.opts.IWriteGroupRabbitOptions=} [properties] Properties to set
             */
            function WriteGroupRabbitOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupRabbitOptions _conn.
             * @member {protos.args.IRabbitConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @instance
             */
            WriteGroupRabbitOptions.prototype._conn = null;

            /**
             * WriteGroupRabbitOptions args.
             * @member {protos.args.IRabbitWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @instance
             */
            WriteGroupRabbitOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupRabbitOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupRabbitOptions} WriteGroupRabbitOptions instance
             */
            WriteGroupRabbitOptions.create = function create(properties) {
                return new WriteGroupRabbitOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupRabbitOptions message. Does not implicitly {@link protos.opts.WriteGroupRabbitOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitOptions} message WriteGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRabbitOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupRabbitOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupRabbitOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitOptions} message WriteGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRabbitOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupRabbitOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupRabbitOptions} WriteGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRabbitOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupRabbitOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupRabbitOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupRabbitOptions} WriteGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRabbitOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupRabbitOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupRabbitOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RabbitConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RabbitWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupRabbitOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupRabbitOptions} WriteGroupRabbitOptions
             */
            WriteGroupRabbitOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupRabbitOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupRabbitOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupRabbitOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupRabbitOptions.args: object expected");
                    message.args = $root.protos.args.RabbitWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupRabbitOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @static
             * @param {protos.opts.WriteGroupRabbitOptions} message WriteGroupRabbitOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupRabbitOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupRabbitOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupRabbitOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupRabbitOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupRabbitOptions;
        })();

        opts.WriteGroupRabbitStreamsOptions = (function() {

            /**
             * Properties of a WriteGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @interface IWriteGroupRabbitStreamsOptions
             * @property {protos.args.IRabbitStreamsConn|null} [_conn] WriteGroupRabbitStreamsOptions _conn
             * @property {protos.args.IRabbitStreamsWriteArgs|null} [args] WriteGroupRabbitStreamsOptions args
             */

            /**
             * Constructs a new WriteGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupRabbitStreamsOptions.
             * @implements IWriteGroupRabbitStreamsOptions
             * @constructor
             * @param {protos.opts.IWriteGroupRabbitStreamsOptions=} [properties] Properties to set
             */
            function WriteGroupRabbitStreamsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupRabbitStreamsOptions _conn.
             * @member {protos.args.IRabbitStreamsConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @instance
             */
            WriteGroupRabbitStreamsOptions.prototype._conn = null;

            /**
             * WriteGroupRabbitStreamsOptions args.
             * @member {protos.args.IRabbitStreamsWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @instance
             */
            WriteGroupRabbitStreamsOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupRabbitStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupRabbitStreamsOptions} WriteGroupRabbitStreamsOptions instance
             */
            WriteGroupRabbitStreamsOptions.create = function create(properties) {
                return new WriteGroupRabbitStreamsOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupRabbitStreamsOptions message. Does not implicitly {@link protos.opts.WriteGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitStreamsOptions} message WriteGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRabbitStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitStreamsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupRabbitStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRabbitStreamsOptions} message WriteGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRabbitStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupRabbitStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupRabbitStreamsOptions} WriteGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRabbitStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupRabbitStreamsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitStreamsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupRabbitStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupRabbitStreamsOptions} WriteGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRabbitStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupRabbitStreamsOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupRabbitStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RabbitStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RabbitStreamsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupRabbitStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupRabbitStreamsOptions} WriteGroupRabbitStreamsOptions
             */
            WriteGroupRabbitStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupRabbitStreamsOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupRabbitStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupRabbitStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupRabbitStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RabbitStreamsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupRabbitStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.WriteGroupRabbitStreamsOptions} message WriteGroupRabbitStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupRabbitStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitStreamsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupRabbitStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupRabbitStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupRabbitStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupRabbitStreamsOptions;
        })();

        opts.WriteGroupRedisPubSubOptions = (function() {

            /**
             * Properties of a WriteGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @interface IWriteGroupRedisPubSubOptions
             * @property {protos.args.IRedisPubSubConn|null} [_conn] WriteGroupRedisPubSubOptions _conn
             * @property {protos.args.IRedisPubSubWriteArgs|null} [args] WriteGroupRedisPubSubOptions args
             */

            /**
             * Constructs a new WriteGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupRedisPubSubOptions.
             * @implements IWriteGroupRedisPubSubOptions
             * @constructor
             * @param {protos.opts.IWriteGroupRedisPubSubOptions=} [properties] Properties to set
             */
            function WriteGroupRedisPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupRedisPubSubOptions _conn.
             * @member {protos.args.IRedisPubSubConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @instance
             */
            WriteGroupRedisPubSubOptions.prototype._conn = null;

            /**
             * WriteGroupRedisPubSubOptions args.
             * @member {protos.args.IRedisPubSubWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @instance
             */
            WriteGroupRedisPubSubOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupRedisPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupRedisPubSubOptions} WriteGroupRedisPubSubOptions instance
             */
            WriteGroupRedisPubSubOptions.create = function create(properties) {
                return new WriteGroupRedisPubSubOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupRedisPubSubOptions message. Does not implicitly {@link protos.opts.WriteGroupRedisPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisPubSubOptions} message WriteGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRedisPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisPubSubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupRedisPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupRedisPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisPubSubOptions} message WriteGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRedisPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupRedisPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupRedisPubSubOptions} WriteGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRedisPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupRedisPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisPubSubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupRedisPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupRedisPubSubOptions} WriteGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRedisPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupRedisPubSubOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupRedisPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisPubSubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupRedisPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupRedisPubSubOptions} WriteGroupRedisPubSubOptions
             */
            WriteGroupRedisPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupRedisPubSubOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupRedisPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupRedisPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupRedisPubSubOptions.args: object expected");
                    message.args = $root.protos.args.RedisPubSubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupRedisPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.WriteGroupRedisPubSubOptions} message WriteGroupRedisPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupRedisPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisPubSubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupRedisPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupRedisPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupRedisPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupRedisPubSubOptions;
        })();

        opts.WriteGroupRedisStreamsOptions = (function() {

            /**
             * Properties of a WriteGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @interface IWriteGroupRedisStreamsOptions
             * @property {protos.args.IRedisStreamsConn|null} [_conn] WriteGroupRedisStreamsOptions _conn
             * @property {protos.args.IRedisStreamsWriteArgs|null} [args] WriteGroupRedisStreamsOptions args
             */

            /**
             * Constructs a new WriteGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupRedisStreamsOptions.
             * @implements IWriteGroupRedisStreamsOptions
             * @constructor
             * @param {protos.opts.IWriteGroupRedisStreamsOptions=} [properties] Properties to set
             */
            function WriteGroupRedisStreamsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupRedisStreamsOptions _conn.
             * @member {protos.args.IRedisStreamsConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @instance
             */
            WriteGroupRedisStreamsOptions.prototype._conn = null;

            /**
             * WriteGroupRedisStreamsOptions args.
             * @member {protos.args.IRedisStreamsWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @instance
             */
            WriteGroupRedisStreamsOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupRedisStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupRedisStreamsOptions} WriteGroupRedisStreamsOptions instance
             */
            WriteGroupRedisStreamsOptions.create = function create(properties) {
                return new WriteGroupRedisStreamsOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupRedisStreamsOptions message. Does not implicitly {@link protos.opts.WriteGroupRedisStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisStreamsOptions} message WriteGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRedisStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisStreamsWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupRedisStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupRedisStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IWriteGroupRedisStreamsOptions} message WriteGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupRedisStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupRedisStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupRedisStreamsOptions} WriteGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRedisStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupRedisStreamsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisStreamsWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupRedisStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupRedisStreamsOptions} WriteGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupRedisStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupRedisStreamsOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupRedisStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisStreamsWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupRedisStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupRedisStreamsOptions} WriteGroupRedisStreamsOptions
             */
            WriteGroupRedisStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupRedisStreamsOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupRedisStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupRedisStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupRedisStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RedisStreamsWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupRedisStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.WriteGroupRedisStreamsOptions} message WriteGroupRedisStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupRedisStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisStreamsWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupRedisStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupRedisStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupRedisStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupRedisStreamsOptions;
        })();

        opts.WriteGroupAzureEventHubOptions = (function() {

            /**
             * Properties of a WriteGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @interface IWriteGroupAzureEventHubOptions
             * @property {protos.args.IAzureEventHubConn|null} [_conn] WriteGroupAzureEventHubOptions _conn
             * @property {protos.args.IAzureEventHubWriteArgs|null} [args] WriteGroupAzureEventHubOptions args
             */

            /**
             * Constructs a new WriteGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupAzureEventHubOptions.
             * @implements IWriteGroupAzureEventHubOptions
             * @constructor
             * @param {protos.opts.IWriteGroupAzureEventHubOptions=} [properties] Properties to set
             */
            function WriteGroupAzureEventHubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupAzureEventHubOptions _conn.
             * @member {protos.args.IAzureEventHubConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @instance
             */
            WriteGroupAzureEventHubOptions.prototype._conn = null;

            /**
             * WriteGroupAzureEventHubOptions args.
             * @member {protos.args.IAzureEventHubWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @instance
             */
            WriteGroupAzureEventHubOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupAzureEventHubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureEventHubOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupAzureEventHubOptions} WriteGroupAzureEventHubOptions instance
             */
            WriteGroupAzureEventHubOptions.create = function create(properties) {
                return new WriteGroupAzureEventHubOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupAzureEventHubOptions message. Does not implicitly {@link protos.opts.WriteGroupAzureEventHubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureEventHubOptions} message WriteGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAzureEventHubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureEventHubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureEventHubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupAzureEventHubOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupAzureEventHubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureEventHubOptions} message WriteGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAzureEventHubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupAzureEventHubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupAzureEventHubOptions} WriteGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAzureEventHubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupAzureEventHubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureEventHubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureEventHubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupAzureEventHubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupAzureEventHubOptions} WriteGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAzureEventHubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupAzureEventHubOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupAzureEventHubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AzureEventHubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AzureEventHubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupAzureEventHubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupAzureEventHubOptions} WriteGroupAzureEventHubOptions
             */
            WriteGroupAzureEventHubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupAzureEventHubOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupAzureEventHubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupAzureEventHubOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureEventHubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupAzureEventHubOptions.args: object expected");
                    message.args = $root.protos.args.AzureEventHubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupAzureEventHubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.WriteGroupAzureEventHubOptions} message WriteGroupAzureEventHubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupAzureEventHubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureEventHubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureEventHubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupAzureEventHubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupAzureEventHubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupAzureEventHubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupAzureEventHubOptions;
        })();

        opts.WriteGroupAzureServiceBusOptions = (function() {

            /**
             * Properties of a WriteGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @interface IWriteGroupAzureServiceBusOptions
             * @property {protos.args.IAzureServiceBusConn|null} [_conn] WriteGroupAzureServiceBusOptions _conn
             * @property {protos.args.IAzureServiceBusWriteArgs|null} [args] WriteGroupAzureServiceBusOptions args
             */

            /**
             * Constructs a new WriteGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupAzureServiceBusOptions.
             * @implements IWriteGroupAzureServiceBusOptions
             * @constructor
             * @param {protos.opts.IWriteGroupAzureServiceBusOptions=} [properties] Properties to set
             */
            function WriteGroupAzureServiceBusOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupAzureServiceBusOptions _conn.
             * @member {protos.args.IAzureServiceBusConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @instance
             */
            WriteGroupAzureServiceBusOptions.prototype._conn = null;

            /**
             * WriteGroupAzureServiceBusOptions args.
             * @member {protos.args.IAzureServiceBusWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @instance
             */
            WriteGroupAzureServiceBusOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupAzureServiceBusOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureServiceBusOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupAzureServiceBusOptions} WriteGroupAzureServiceBusOptions instance
             */
            WriteGroupAzureServiceBusOptions.create = function create(properties) {
                return new WriteGroupAzureServiceBusOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupAzureServiceBusOptions message. Does not implicitly {@link protos.opts.WriteGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureServiceBusOptions} message WriteGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAzureServiceBusOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureServiceBusConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureServiceBusWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupAzureServiceBusOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IWriteGroupAzureServiceBusOptions} message WriteGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAzureServiceBusOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupAzureServiceBusOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupAzureServiceBusOptions} WriteGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAzureServiceBusOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupAzureServiceBusOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureServiceBusConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureServiceBusWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupAzureServiceBusOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupAzureServiceBusOptions} WriteGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAzureServiceBusOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupAzureServiceBusOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupAzureServiceBusOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AzureServiceBusConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AzureServiceBusWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupAzureServiceBusOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupAzureServiceBusOptions} WriteGroupAzureServiceBusOptions
             */
            WriteGroupAzureServiceBusOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupAzureServiceBusOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupAzureServiceBusOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupAzureServiceBusOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureServiceBusConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupAzureServiceBusOptions.args: object expected");
                    message.args = $root.protos.args.AzureServiceBusWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupAzureServiceBusOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.WriteGroupAzureServiceBusOptions} message WriteGroupAzureServiceBusOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupAzureServiceBusOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureServiceBusConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureServiceBusWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupAzureServiceBusOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupAzureServiceBusOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupAzureServiceBusOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupAzureServiceBusOptions;
        })();

        opts.WriteGroupMQTTOptions = (function() {

            /**
             * Properties of a WriteGroupMQTTOptions.
             * @memberof protos.opts
             * @interface IWriteGroupMQTTOptions
             * @property {protos.args.IMQTTConn|null} [_conn] WriteGroupMQTTOptions _conn
             * @property {protos.args.IMQTTWriteArgs|null} [args] WriteGroupMQTTOptions args
             */

            /**
             * Constructs a new WriteGroupMQTTOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupMQTTOptions.
             * @implements IWriteGroupMQTTOptions
             * @constructor
             * @param {protos.opts.IWriteGroupMQTTOptions=} [properties] Properties to set
             */
            function WriteGroupMQTTOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupMQTTOptions _conn.
             * @member {protos.args.IMQTTConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @instance
             */
            WriteGroupMQTTOptions.prototype._conn = null;

            /**
             * WriteGroupMQTTOptions args.
             * @member {protos.args.IMQTTWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @instance
             */
            WriteGroupMQTTOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupMQTTOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {protos.opts.IWriteGroupMQTTOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupMQTTOptions} WriteGroupMQTTOptions instance
             */
            WriteGroupMQTTOptions.create = function create(properties) {
                return new WriteGroupMQTTOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupMQTTOptions message. Does not implicitly {@link protos.opts.WriteGroupMQTTOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {protos.opts.IWriteGroupMQTTOptions} message WriteGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupMQTTOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MQTTConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MQTTWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupMQTTOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupMQTTOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {protos.opts.IWriteGroupMQTTOptions} message WriteGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupMQTTOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupMQTTOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupMQTTOptions} WriteGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupMQTTOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupMQTTOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MQTTConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MQTTWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupMQTTOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupMQTTOptions} WriteGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupMQTTOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupMQTTOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupMQTTOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.MQTTConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.MQTTWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupMQTTOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupMQTTOptions} WriteGroupMQTTOptions
             */
            WriteGroupMQTTOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupMQTTOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupMQTTOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupMQTTOptions._conn: object expected");
                    message._conn = $root.protos.args.MQTTConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupMQTTOptions.args: object expected");
                    message.args = $root.protos.args.MQTTWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupMQTTOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @static
             * @param {protos.opts.WriteGroupMQTTOptions} message WriteGroupMQTTOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupMQTTOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MQTTConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MQTTWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupMQTTOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupMQTTOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupMQTTOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupMQTTOptions;
        })();

        opts.WriteGroupGCPPubSubOptions = (function() {

            /**
             * Properties of a WriteGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @interface IWriteGroupGCPPubSubOptions
             * @property {protos.args.IGCPPubSubConn|null} [_conn] WriteGroupGCPPubSubOptions _conn
             * @property {protos.args.IGCPPubSubWriteArgs|null} [args] WriteGroupGCPPubSubOptions args
             */

            /**
             * Constructs a new WriteGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupGCPPubSubOptions.
             * @implements IWriteGroupGCPPubSubOptions
             * @constructor
             * @param {protos.opts.IWriteGroupGCPPubSubOptions=} [properties] Properties to set
             */
            function WriteGroupGCPPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupGCPPubSubOptions _conn.
             * @member {protos.args.IGCPPubSubConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @instance
             */
            WriteGroupGCPPubSubOptions.prototype._conn = null;

            /**
             * WriteGroupGCPPubSubOptions args.
             * @member {protos.args.IGCPPubSubWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @instance
             */
            WriteGroupGCPPubSubOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupGCPPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupGCPPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupGCPPubSubOptions} WriteGroupGCPPubSubOptions instance
             */
            WriteGroupGCPPubSubOptions.create = function create(properties) {
                return new WriteGroupGCPPubSubOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupGCPPubSubOptions message. Does not implicitly {@link protos.opts.WriteGroupGCPPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupGCPPubSubOptions} message WriteGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupGCPPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.GCPPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.GCPPubSubWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupGCPPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupGCPPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IWriteGroupGCPPubSubOptions} message WriteGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupGCPPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupGCPPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupGCPPubSubOptions} WriteGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupGCPPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupGCPPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.GCPPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.GCPPubSubWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupGCPPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupGCPPubSubOptions} WriteGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupGCPPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupGCPPubSubOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupGCPPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.GCPPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.GCPPubSubWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupGCPPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupGCPPubSubOptions} WriteGroupGCPPubSubOptions
             */
            WriteGroupGCPPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupGCPPubSubOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupGCPPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupGCPPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.GCPPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupGCPPubSubOptions.args: object expected");
                    message.args = $root.protos.args.GCPPubSubWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupGCPPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.WriteGroupGCPPubSubOptions} message WriteGroupGCPPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupGCPPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.GCPPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.GCPPubSubWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupGCPPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupGCPPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupGCPPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupGCPPubSubOptions;
        })();

        opts.WriteGroupKubeMQQueueOptions = (function() {

            /**
             * Properties of a WriteGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @interface IWriteGroupKubeMQQueueOptions
             * @property {protos.args.IKubeMQQueueConn|null} [_conn] WriteGroupKubeMQQueueOptions _conn
             * @property {protos.args.IKubeMQQueueWriteArgs|null} [args] WriteGroupKubeMQQueueOptions args
             */

            /**
             * Constructs a new WriteGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupKubeMQQueueOptions.
             * @implements IWriteGroupKubeMQQueueOptions
             * @constructor
             * @param {protos.opts.IWriteGroupKubeMQQueueOptions=} [properties] Properties to set
             */
            function WriteGroupKubeMQQueueOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupKubeMQQueueOptions _conn.
             * @member {protos.args.IKubeMQQueueConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @instance
             */
            WriteGroupKubeMQQueueOptions.prototype._conn = null;

            /**
             * WriteGroupKubeMQQueueOptions args.
             * @member {protos.args.IKubeMQQueueWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @instance
             */
            WriteGroupKubeMQQueueOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupKubeMQQueueOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IWriteGroupKubeMQQueueOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupKubeMQQueueOptions} WriteGroupKubeMQQueueOptions instance
             */
            WriteGroupKubeMQQueueOptions.create = function create(properties) {
                return new WriteGroupKubeMQQueueOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupKubeMQQueueOptions message. Does not implicitly {@link protos.opts.WriteGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IWriteGroupKubeMQQueueOptions} message WriteGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupKubeMQQueueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KubeMQQueueConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KubeMQQueueWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupKubeMQQueueOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IWriteGroupKubeMQQueueOptions} message WriteGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupKubeMQQueueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupKubeMQQueueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupKubeMQQueueOptions} WriteGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupKubeMQQueueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupKubeMQQueueOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KubeMQQueueConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KubeMQQueueWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupKubeMQQueueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupKubeMQQueueOptions} WriteGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupKubeMQQueueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupKubeMQQueueOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupKubeMQQueueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KubeMQQueueConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KubeMQQueueWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupKubeMQQueueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupKubeMQQueueOptions} WriteGroupKubeMQQueueOptions
             */
            WriteGroupKubeMQQueueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupKubeMQQueueOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupKubeMQQueueOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupKubeMQQueueOptions._conn: object expected");
                    message._conn = $root.protos.args.KubeMQQueueConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupKubeMQQueueOptions.args: object expected");
                    message.args = $root.protos.args.KubeMQQueueWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupKubeMQQueueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.WriteGroupKubeMQQueueOptions} message WriteGroupKubeMQQueueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupKubeMQQueueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KubeMQQueueConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KubeMQQueueWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupKubeMQQueueOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupKubeMQQueueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupKubeMQQueueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupKubeMQQueueOptions;
        })();

        opts.WriteGroupAWSKinesisOptions = (function() {

            /**
             * Properties of a WriteGroupAWSKinesisOptions.
             * @memberof protos.opts
             * @interface IWriteGroupAWSKinesisOptions
             * @property {protos.args.IAWSKinesisConn|null} [_conn] WriteGroupAWSKinesisOptions _conn
             * @property {protos.args.IAWSKinesisWriteArgs|null} [args] WriteGroupAWSKinesisOptions args
             */

            /**
             * Constructs a new WriteGroupAWSKinesisOptions.
             * @memberof protos.opts
             * @classdesc Represents a WriteGroupAWSKinesisOptions.
             * @implements IWriteGroupAWSKinesisOptions
             * @constructor
             * @param {protos.opts.IWriteGroupAWSKinesisOptions=} [properties] Properties to set
             */
            function WriteGroupAWSKinesisOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteGroupAWSKinesisOptions _conn.
             * @member {protos.args.IAWSKinesisConn|null|undefined} _conn
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @instance
             */
            WriteGroupAWSKinesisOptions.prototype._conn = null;

            /**
             * WriteGroupAWSKinesisOptions args.
             * @member {protos.args.IAWSKinesisWriteArgs|null|undefined} args
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @instance
             */
            WriteGroupAWSKinesisOptions.prototype.args = null;

            /**
             * Creates a new WriteGroupAWSKinesisOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSKinesisOptions=} [properties] Properties to set
             * @returns {protos.opts.WriteGroupAWSKinesisOptions} WriteGroupAWSKinesisOptions instance
             */
            WriteGroupAWSKinesisOptions.create = function create(properties) {
                return new WriteGroupAWSKinesisOptions(properties);
            };

            /**
             * Encodes the specified WriteGroupAWSKinesisOptions message. Does not implicitly {@link protos.opts.WriteGroupAWSKinesisOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSKinesisOptions} message WriteGroupAWSKinesisOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAWSKinesisOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSKinesisConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSKinesisWriteArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteGroupAWSKinesisOptions message, length delimited. Does not implicitly {@link protos.opts.WriteGroupAWSKinesisOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.IWriteGroupAWSKinesisOptions} message WriteGroupAWSKinesisOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteGroupAWSKinesisOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteGroupAWSKinesisOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.WriteGroupAWSKinesisOptions} WriteGroupAWSKinesisOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAWSKinesisOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.WriteGroupAWSKinesisOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSKinesisConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSKinesisWriteArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteGroupAWSKinesisOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.WriteGroupAWSKinesisOptions} WriteGroupAWSKinesisOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteGroupAWSKinesisOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteGroupAWSKinesisOptions message.
             * @function verify
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteGroupAWSKinesisOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSKinesisConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSKinesisWriteArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a WriteGroupAWSKinesisOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.WriteGroupAWSKinesisOptions} WriteGroupAWSKinesisOptions
             */
            WriteGroupAWSKinesisOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.WriteGroupAWSKinesisOptions)
                    return object;
                var message = new $root.protos.opts.WriteGroupAWSKinesisOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.WriteGroupAWSKinesisOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSKinesisConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.WriteGroupAWSKinesisOptions.args: object expected");
                    message.args = $root.protos.args.AWSKinesisWriteArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteGroupAWSKinesisOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.WriteGroupAWSKinesisOptions} message WriteGroupAWSKinesisOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteGroupAWSKinesisOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSKinesisConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSKinesisWriteArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this WriteGroupAWSKinesisOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.WriteGroupAWSKinesisOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteGroupAWSKinesisOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteGroupAWSKinesisOptions;
        })();

        opts.GlobalCLIOptions = (function() {

            /**
             * Properties of a GlobalCLIOptions.
             * @memberof protos.opts
             * @interface IGlobalCLIOptions
             * @property {boolean|null} [debug] GlobalCLIOptions debug
             * @property {boolean|null} [quiet] GlobalCLIOptions quiet
             * @property {boolean|null} [version] GlobalCLIOptions version
             * @property {string|null} [_fullCommand] GlobalCLIOptions _fullCommand
             * @property {string|null} [_action] GlobalCLIOptions _action
             * @property {string|null} [_backend] GlobalCLIOptions _backend
             */

            /**
             * Constructs a new GlobalCLIOptions.
             * @memberof protos.opts
             * @classdesc Represents a GlobalCLIOptions.
             * @implements IGlobalCLIOptions
             * @constructor
             * @param {protos.opts.IGlobalCLIOptions=} [properties] Properties to set
             */
            function GlobalCLIOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GlobalCLIOptions debug.
             * @member {boolean} debug
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype.debug = false;

            /**
             * GlobalCLIOptions quiet.
             * @member {boolean} quiet
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype.quiet = false;

            /**
             * GlobalCLIOptions version.
             * @member {boolean} version
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype.version = false;

            /**
             * GlobalCLIOptions _fullCommand.
             * @member {string} _fullCommand
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype._fullCommand = "";

            /**
             * GlobalCLIOptions _action.
             * @member {string} _action
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype._action = "";

            /**
             * GlobalCLIOptions _backend.
             * @member {string} _backend
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             */
            GlobalCLIOptions.prototype._backend = "";

            /**
             * Creates a new GlobalCLIOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {protos.opts.IGlobalCLIOptions=} [properties] Properties to set
             * @returns {protos.opts.GlobalCLIOptions} GlobalCLIOptions instance
             */
            GlobalCLIOptions.create = function create(properties) {
                return new GlobalCLIOptions(properties);
            };

            /**
             * Encodes the specified GlobalCLIOptions message. Does not implicitly {@link protos.opts.GlobalCLIOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {protos.opts.IGlobalCLIOptions} message GlobalCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlobalCLIOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.debug != null && Object.hasOwnProperty.call(message, "debug"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.debug);
                if (message.quiet != null && Object.hasOwnProperty.call(message, "quiet"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.quiet);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.version);
                if (message._fullCommand != null && Object.hasOwnProperty.call(message, "_fullCommand"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._fullCommand);
                if (message._action != null && Object.hasOwnProperty.call(message, "_action"))
                    writer.uint32(/* id 1001, wireType 2 =*/8010).string(message._action);
                if (message._backend != null && Object.hasOwnProperty.call(message, "_backend"))
                    writer.uint32(/* id 1002, wireType 2 =*/8018).string(message._backend);
                return writer;
            };

            /**
             * Encodes the specified GlobalCLIOptions message, length delimited. Does not implicitly {@link protos.opts.GlobalCLIOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {protos.opts.IGlobalCLIOptions} message GlobalCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlobalCLIOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GlobalCLIOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.GlobalCLIOptions} GlobalCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlobalCLIOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.GlobalCLIOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.debug = reader.bool();
                        break;
                    case 2:
                        message.quiet = reader.bool();
                        break;
                    case 3:
                        message.version = reader.bool();
                        break;
                    case 1000:
                        message._fullCommand = reader.string();
                        break;
                    case 1001:
                        message._action = reader.string();
                        break;
                    case 1002:
                        message._backend = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GlobalCLIOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.GlobalCLIOptions} GlobalCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlobalCLIOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GlobalCLIOptions message.
             * @function verify
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GlobalCLIOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.debug != null && message.hasOwnProperty("debug"))
                    if (typeof message.debug !== "boolean")
                        return "debug: boolean expected";
                if (message.quiet != null && message.hasOwnProperty("quiet"))
                    if (typeof message.quiet !== "boolean")
                        return "quiet: boolean expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (typeof message.version !== "boolean")
                        return "version: boolean expected";
                if (message._fullCommand != null && message.hasOwnProperty("_fullCommand"))
                    if (!$util.isString(message._fullCommand))
                        return "_fullCommand: string expected";
                if (message._action != null && message.hasOwnProperty("_action"))
                    if (!$util.isString(message._action))
                        return "_action: string expected";
                if (message._backend != null && message.hasOwnProperty("_backend"))
                    if (!$util.isString(message._backend))
                        return "_backend: string expected";
                return null;
            };

            /**
             * Creates a GlobalCLIOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.GlobalCLIOptions} GlobalCLIOptions
             */
            GlobalCLIOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.GlobalCLIOptions)
                    return object;
                var message = new $root.protos.opts.GlobalCLIOptions();
                if (object.debug != null)
                    message.debug = Boolean(object.debug);
                if (object.quiet != null)
                    message.quiet = Boolean(object.quiet);
                if (object.version != null)
                    message.version = Boolean(object.version);
                if (object._fullCommand != null)
                    message._fullCommand = String(object._fullCommand);
                if (object._action != null)
                    message._action = String(object._action);
                if (object._backend != null)
                    message._backend = String(object._backend);
                return message;
            };

            /**
             * Creates a plain object from a GlobalCLIOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.GlobalCLIOptions
             * @static
             * @param {protos.opts.GlobalCLIOptions} message GlobalCLIOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GlobalCLIOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.debug = false;
                    object.quiet = false;
                    object.version = false;
                    object._fullCommand = "";
                    object._action = "";
                    object._backend = "";
                }
                if (message.debug != null && message.hasOwnProperty("debug"))
                    object.debug = message.debug;
                if (message.quiet != null && message.hasOwnProperty("quiet"))
                    object.quiet = message.quiet;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message._fullCommand != null && message.hasOwnProperty("_fullCommand"))
                    object._fullCommand = message._fullCommand;
                if (message._action != null && message.hasOwnProperty("_action"))
                    object._action = message._action;
                if (message._backend != null && message.hasOwnProperty("_backend"))
                    object._backend = message._backend;
                return object;
            };

            /**
             * Converts this GlobalCLIOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.GlobalCLIOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GlobalCLIOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GlobalCLIOptions;
        })();

        opts.CLIOptions = (function() {

            /**
             * Properties of a CLIOptions.
             * @memberof protos.opts
             * @interface ICLIOptions
             * @property {protos.opts.IGlobalCLIOptions|null} [global] CLIOptions global
             * @property {protos.opts.IReadOptions|null} [read] CLIOptions read
             * @property {protos.opts.IWriteOptions|null} [write] CLIOptions write
             * @property {protos.opts.IRelayOptions|null} [relay] CLIOptions relay
             * @property {protos.opts.IDynamicOptions|null} [dynamic] CLIOptions dynamic
             * @property {protos.opts.IBatchOptions|null} [batch] CLIOptions batch
             * @property {protos.opts.IServerOptions|null} [server] CLIOptions server
             */

            /**
             * Constructs a new CLIOptions.
             * @memberof protos.opts
             * @classdesc Represents a CLIOptions.
             * @implements ICLIOptions
             * @constructor
             * @param {protos.opts.ICLIOptions=} [properties] Properties to set
             */
            function CLIOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CLIOptions global.
             * @member {protos.opts.IGlobalCLIOptions|null|undefined} global
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.global = null;

            /**
             * CLIOptions read.
             * @member {protos.opts.IReadOptions|null|undefined} read
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.read = null;

            /**
             * CLIOptions write.
             * @member {protos.opts.IWriteOptions|null|undefined} write
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.write = null;

            /**
             * CLIOptions relay.
             * @member {protos.opts.IRelayOptions|null|undefined} relay
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.relay = null;

            /**
             * CLIOptions dynamic.
             * @member {protos.opts.IDynamicOptions|null|undefined} dynamic
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.dynamic = null;

            /**
             * CLIOptions batch.
             * @member {protos.opts.IBatchOptions|null|undefined} batch
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.batch = null;

            /**
             * CLIOptions server.
             * @member {protos.opts.IServerOptions|null|undefined} server
             * @memberof protos.opts.CLIOptions
             * @instance
             */
            CLIOptions.prototype.server = null;

            /**
             * Creates a new CLIOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {protos.opts.ICLIOptions=} [properties] Properties to set
             * @returns {protos.opts.CLIOptions} CLIOptions instance
             */
            CLIOptions.create = function create(properties) {
                return new CLIOptions(properties);
            };

            /**
             * Encodes the specified CLIOptions message. Does not implicitly {@link protos.opts.CLIOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {protos.opts.ICLIOptions} message CLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CLIOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.global != null && Object.hasOwnProperty.call(message, "global"))
                    $root.protos.opts.GlobalCLIOptions.encode(message.global, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.read != null && Object.hasOwnProperty.call(message, "read"))
                    $root.protos.opts.ReadOptions.encode(message.read, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.write != null && Object.hasOwnProperty.call(message, "write"))
                    $root.protos.opts.WriteOptions.encode(message.write, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.relay != null && Object.hasOwnProperty.call(message, "relay"))
                    $root.protos.opts.RelayOptions.encode(message.relay, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.dynamic != null && Object.hasOwnProperty.call(message, "dynamic"))
                    $root.protos.opts.DynamicOptions.encode(message.dynamic, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.batch != null && Object.hasOwnProperty.call(message, "batch"))
                    $root.protos.opts.BatchOptions.encode(message.batch, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.server != null && Object.hasOwnProperty.call(message, "server"))
                    $root.protos.opts.ServerOptions.encode(message.server, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CLIOptions message, length delimited. Does not implicitly {@link protos.opts.CLIOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {protos.opts.ICLIOptions} message CLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CLIOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CLIOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.CLIOptions} CLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CLIOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.CLIOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.global = $root.protos.opts.GlobalCLIOptions.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.read = $root.protos.opts.ReadOptions.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.write = $root.protos.opts.WriteOptions.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.relay = $root.protos.opts.RelayOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.dynamic = $root.protos.opts.DynamicOptions.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.batch = $root.protos.opts.BatchOptions.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.server = $root.protos.opts.ServerOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CLIOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.CLIOptions} CLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CLIOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CLIOptions message.
             * @function verify
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CLIOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.global != null && message.hasOwnProperty("global")) {
                    var error = $root.protos.opts.GlobalCLIOptions.verify(message.global);
                    if (error)
                        return "global." + error;
                }
                if (message.read != null && message.hasOwnProperty("read")) {
                    var error = $root.protos.opts.ReadOptions.verify(message.read);
                    if (error)
                        return "read." + error;
                }
                if (message.write != null && message.hasOwnProperty("write")) {
                    var error = $root.protos.opts.WriteOptions.verify(message.write);
                    if (error)
                        return "write." + error;
                }
                if (message.relay != null && message.hasOwnProperty("relay")) {
                    var error = $root.protos.opts.RelayOptions.verify(message.relay);
                    if (error)
                        return "relay." + error;
                }
                if (message.dynamic != null && message.hasOwnProperty("dynamic")) {
                    var error = $root.protos.opts.DynamicOptions.verify(message.dynamic);
                    if (error)
                        return "dynamic." + error;
                }
                if (message.batch != null && message.hasOwnProperty("batch")) {
                    var error = $root.protos.opts.BatchOptions.verify(message.batch);
                    if (error)
                        return "batch." + error;
                }
                if (message.server != null && message.hasOwnProperty("server")) {
                    var error = $root.protos.opts.ServerOptions.verify(message.server);
                    if (error)
                        return "server." + error;
                }
                return null;
            };

            /**
             * Creates a CLIOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.CLIOptions} CLIOptions
             */
            CLIOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.CLIOptions)
                    return object;
                var message = new $root.protos.opts.CLIOptions();
                if (object.global != null) {
                    if (typeof object.global !== "object")
                        throw TypeError(".protos.opts.CLIOptions.global: object expected");
                    message.global = $root.protos.opts.GlobalCLIOptions.fromObject(object.global);
                }
                if (object.read != null) {
                    if (typeof object.read !== "object")
                        throw TypeError(".protos.opts.CLIOptions.read: object expected");
                    message.read = $root.protos.opts.ReadOptions.fromObject(object.read);
                }
                if (object.write != null) {
                    if (typeof object.write !== "object")
                        throw TypeError(".protos.opts.CLIOptions.write: object expected");
                    message.write = $root.protos.opts.WriteOptions.fromObject(object.write);
                }
                if (object.relay != null) {
                    if (typeof object.relay !== "object")
                        throw TypeError(".protos.opts.CLIOptions.relay: object expected");
                    message.relay = $root.protos.opts.RelayOptions.fromObject(object.relay);
                }
                if (object.dynamic != null) {
                    if (typeof object.dynamic !== "object")
                        throw TypeError(".protos.opts.CLIOptions.dynamic: object expected");
                    message.dynamic = $root.protos.opts.DynamicOptions.fromObject(object.dynamic);
                }
                if (object.batch != null) {
                    if (typeof object.batch !== "object")
                        throw TypeError(".protos.opts.CLIOptions.batch: object expected");
                    message.batch = $root.protos.opts.BatchOptions.fromObject(object.batch);
                }
                if (object.server != null) {
                    if (typeof object.server !== "object")
                        throw TypeError(".protos.opts.CLIOptions.server: object expected");
                    message.server = $root.protos.opts.ServerOptions.fromObject(object.server);
                }
                return message;
            };

            /**
             * Creates a plain object from a CLIOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.CLIOptions
             * @static
             * @param {protos.opts.CLIOptions} message CLIOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CLIOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.global = null;
                    object.read = null;
                    object.write = null;
                    object.relay = null;
                    object.dynamic = null;
                    object.batch = null;
                    object.server = null;
                }
                if (message.global != null && message.hasOwnProperty("global"))
                    object.global = $root.protos.opts.GlobalCLIOptions.toObject(message.global, options);
                if (message.read != null && message.hasOwnProperty("read"))
                    object.read = $root.protos.opts.ReadOptions.toObject(message.read, options);
                if (message.write != null && message.hasOwnProperty("write"))
                    object.write = $root.protos.opts.WriteOptions.toObject(message.write, options);
                if (message.relay != null && message.hasOwnProperty("relay"))
                    object.relay = $root.protos.opts.RelayOptions.toObject(message.relay, options);
                if (message.dynamic != null && message.hasOwnProperty("dynamic"))
                    object.dynamic = $root.protos.opts.DynamicOptions.toObject(message.dynamic, options);
                if (message.batch != null && message.hasOwnProperty("batch"))
                    object.batch = $root.protos.opts.BatchOptions.toObject(message.batch, options);
                if (message.server != null && message.hasOwnProperty("server"))
                    object.server = $root.protos.opts.ServerOptions.toObject(message.server, options);
                return object;
            };

            /**
             * Converts this CLIOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.CLIOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CLIOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CLIOptions;
        })();

        /**
         * ConvertOption enum.
         * @name protos.opts.ConvertOption
         * @enum {number}
         * @property {number} CONVERT_OPTION_UNSET=0 CONVERT_OPTION_UNSET value
         * @property {number} CONVERT_OPTION_BASE64=1 CONVERT_OPTION_BASE64 value
         * @property {number} CONVERT_OPTION_GZIP=2 CONVERT_OPTION_GZIP value
         */
        opts.ConvertOption = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CONVERT_OPTION_UNSET"] = 0;
            values[valuesById[1] = "CONVERT_OPTION_BASE64"] = 1;
            values[valuesById[2] = "CONVERT_OPTION_GZIP"] = 2;
            return values;
        })();

        opts.ReadCLIOptions = (function() {

            /**
             * Properties of a ReadCLIOptions.
             * @memberof protos.opts
             * @interface IReadCLIOptions
             * @property {boolean|null} [verboseOutput] ReadCLIOptions verboseOutput
             * @property {boolean|null} [pretty] ReadCLIOptions pretty
             * @property {boolean|null} [json] ReadCLIOptions json
             */

            /**
             * Constructs a new ReadCLIOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadCLIOptions.
             * @implements IReadCLIOptions
             * @constructor
             * @param {protos.opts.IReadCLIOptions=} [properties] Properties to set
             */
            function ReadCLIOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadCLIOptions verboseOutput.
             * @member {boolean} verboseOutput
             * @memberof protos.opts.ReadCLIOptions
             * @instance
             */
            ReadCLIOptions.prototype.verboseOutput = false;

            /**
             * ReadCLIOptions pretty.
             * @member {boolean} pretty
             * @memberof protos.opts.ReadCLIOptions
             * @instance
             */
            ReadCLIOptions.prototype.pretty = false;

            /**
             * ReadCLIOptions json.
             * @member {boolean} json
             * @memberof protos.opts.ReadCLIOptions
             * @instance
             */
            ReadCLIOptions.prototype.json = false;

            /**
             * Creates a new ReadCLIOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {protos.opts.IReadCLIOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadCLIOptions} ReadCLIOptions instance
             */
            ReadCLIOptions.create = function create(properties) {
                return new ReadCLIOptions(properties);
            };

            /**
             * Encodes the specified ReadCLIOptions message. Does not implicitly {@link protos.opts.ReadCLIOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {protos.opts.IReadCLIOptions} message ReadCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadCLIOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.verboseOutput != null && Object.hasOwnProperty.call(message, "verboseOutput"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.verboseOutput);
                if (message.pretty != null && Object.hasOwnProperty.call(message, "pretty"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.pretty);
                if (message.json != null && Object.hasOwnProperty.call(message, "json"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.json);
                return writer;
            };

            /**
             * Encodes the specified ReadCLIOptions message, length delimited. Does not implicitly {@link protos.opts.ReadCLIOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {protos.opts.IReadCLIOptions} message ReadCLIOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadCLIOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadCLIOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadCLIOptions} ReadCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadCLIOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadCLIOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.verboseOutput = reader.bool();
                        break;
                    case 2:
                        message.pretty = reader.bool();
                        break;
                    case 3:
                        message.json = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadCLIOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadCLIOptions} ReadCLIOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadCLIOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadCLIOptions message.
             * @function verify
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadCLIOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.verboseOutput != null && message.hasOwnProperty("verboseOutput"))
                    if (typeof message.verboseOutput !== "boolean")
                        return "verboseOutput: boolean expected";
                if (message.pretty != null && message.hasOwnProperty("pretty"))
                    if (typeof message.pretty !== "boolean")
                        return "pretty: boolean expected";
                if (message.json != null && message.hasOwnProperty("json"))
                    if (typeof message.json !== "boolean")
                        return "json: boolean expected";
                return null;
            };

            /**
             * Creates a ReadCLIOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadCLIOptions} ReadCLIOptions
             */
            ReadCLIOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadCLIOptions)
                    return object;
                var message = new $root.protos.opts.ReadCLIOptions();
                if (object.verboseOutput != null)
                    message.verboseOutput = Boolean(object.verboseOutput);
                if (object.pretty != null)
                    message.pretty = Boolean(object.pretty);
                if (object.json != null)
                    message.json = Boolean(object.json);
                return message;
            };

            /**
             * Creates a plain object from a ReadCLIOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadCLIOptions
             * @static
             * @param {protos.opts.ReadCLIOptions} message ReadCLIOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadCLIOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.verboseOutput = false;
                    object.pretty = false;
                    object.json = false;
                }
                if (message.verboseOutput != null && message.hasOwnProperty("verboseOutput"))
                    object.verboseOutput = message.verboseOutput;
                if (message.pretty != null && message.hasOwnProperty("pretty"))
                    object.pretty = message.pretty;
                if (message.json != null && message.hasOwnProperty("json"))
                    object.json = message.json;
                return object;
            };

            /**
             * Converts this ReadCLIOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadCLIOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadCLIOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadCLIOptions;
        })();

        opts.ReadSampleOptions = (function() {

            /**
             * Properties of a ReadSampleOptions.
             * @memberof protos.opts
             * @interface IReadSampleOptions
             * @property {number|null} [sampleRate] ReadSampleOptions sampleRate
             * @property {number|null} [sampleIntervalSeconds] ReadSampleOptions sampleIntervalSeconds
             */

            /**
             * Constructs a new ReadSampleOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadSampleOptions.
             * @implements IReadSampleOptions
             * @constructor
             * @param {protos.opts.IReadSampleOptions=} [properties] Properties to set
             */
            function ReadSampleOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadSampleOptions sampleRate.
             * @member {number} sampleRate
             * @memberof protos.opts.ReadSampleOptions
             * @instance
             */
            ReadSampleOptions.prototype.sampleRate = 0;

            /**
             * ReadSampleOptions sampleIntervalSeconds.
             * @member {number} sampleIntervalSeconds
             * @memberof protos.opts.ReadSampleOptions
             * @instance
             */
            ReadSampleOptions.prototype.sampleIntervalSeconds = 0;

            /**
             * Creates a new ReadSampleOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {protos.opts.IReadSampleOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadSampleOptions} ReadSampleOptions instance
             */
            ReadSampleOptions.create = function create(properties) {
                return new ReadSampleOptions(properties);
            };

            /**
             * Encodes the specified ReadSampleOptions message. Does not implicitly {@link protos.opts.ReadSampleOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {protos.opts.IReadSampleOptions} message ReadSampleOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadSampleOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sampleRate != null && Object.hasOwnProperty.call(message, "sampleRate"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.sampleRate);
                if (message.sampleIntervalSeconds != null && Object.hasOwnProperty.call(message, "sampleIntervalSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.sampleIntervalSeconds);
                return writer;
            };

            /**
             * Encodes the specified ReadSampleOptions message, length delimited. Does not implicitly {@link protos.opts.ReadSampleOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {protos.opts.IReadSampleOptions} message ReadSampleOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadSampleOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadSampleOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadSampleOptions} ReadSampleOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadSampleOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadSampleOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sampleRate = reader.uint32();
                        break;
                    case 2:
                        message.sampleIntervalSeconds = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadSampleOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadSampleOptions} ReadSampleOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadSampleOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadSampleOptions message.
             * @function verify
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadSampleOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sampleRate != null && message.hasOwnProperty("sampleRate"))
                    if (!$util.isInteger(message.sampleRate))
                        return "sampleRate: integer expected";
                if (message.sampleIntervalSeconds != null && message.hasOwnProperty("sampleIntervalSeconds"))
                    if (!$util.isInteger(message.sampleIntervalSeconds))
                        return "sampleIntervalSeconds: integer expected";
                return null;
            };

            /**
             * Creates a ReadSampleOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadSampleOptions} ReadSampleOptions
             */
            ReadSampleOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadSampleOptions)
                    return object;
                var message = new $root.protos.opts.ReadSampleOptions();
                if (object.sampleRate != null)
                    message.sampleRate = object.sampleRate >>> 0;
                if (object.sampleIntervalSeconds != null)
                    message.sampleIntervalSeconds = object.sampleIntervalSeconds >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a ReadSampleOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadSampleOptions
             * @static
             * @param {protos.opts.ReadSampleOptions} message ReadSampleOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadSampleOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sampleRate = 0;
                    object.sampleIntervalSeconds = 0;
                }
                if (message.sampleRate != null && message.hasOwnProperty("sampleRate"))
                    object.sampleRate = message.sampleRate;
                if (message.sampleIntervalSeconds != null && message.hasOwnProperty("sampleIntervalSeconds"))
                    object.sampleIntervalSeconds = message.sampleIntervalSeconds;
                return object;
            };

            /**
             * Converts this ReadSampleOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadSampleOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadSampleOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadSampleOptions;
        })();

        opts.ReadFilterOptions = (function() {

            /**
             * Properties of a ReadFilterOptions.
             * @memberof protos.opts
             * @interface IReadFilterOptions
             * @property {string|null} [query] ReadFilterOptions query
             */

            /**
             * Constructs a new ReadFilterOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadFilterOptions.
             * @implements IReadFilterOptions
             * @constructor
             * @param {protos.opts.IReadFilterOptions=} [properties] Properties to set
             */
            function ReadFilterOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadFilterOptions query.
             * @member {string} query
             * @memberof protos.opts.ReadFilterOptions
             * @instance
             */
            ReadFilterOptions.prototype.query = "";

            /**
             * Creates a new ReadFilterOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {protos.opts.IReadFilterOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadFilterOptions} ReadFilterOptions instance
             */
            ReadFilterOptions.create = function create(properties) {
                return new ReadFilterOptions(properties);
            };

            /**
             * Encodes the specified ReadFilterOptions message. Does not implicitly {@link protos.opts.ReadFilterOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {protos.opts.IReadFilterOptions} message ReadFilterOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadFilterOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.query);
                return writer;
            };

            /**
             * Encodes the specified ReadFilterOptions message, length delimited. Does not implicitly {@link protos.opts.ReadFilterOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {protos.opts.IReadFilterOptions} message ReadFilterOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadFilterOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadFilterOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadFilterOptions} ReadFilterOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadFilterOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadFilterOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.query = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadFilterOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadFilterOptions} ReadFilterOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadFilterOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadFilterOptions message.
             * @function verify
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadFilterOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.query != null && message.hasOwnProperty("query"))
                    if (!$util.isString(message.query))
                        return "query: string expected";
                return null;
            };

            /**
             * Creates a ReadFilterOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadFilterOptions} ReadFilterOptions
             */
            ReadFilterOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadFilterOptions)
                    return object;
                var message = new $root.protos.opts.ReadFilterOptions();
                if (object.query != null)
                    message.query = String(object.query);
                return message;
            };

            /**
             * Creates a plain object from a ReadFilterOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadFilterOptions
             * @static
             * @param {protos.opts.ReadFilterOptions} message ReadFilterOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadFilterOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.query = "";
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = message.query;
                return object;
            };

            /**
             * Converts this ReadFilterOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadFilterOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadFilterOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadFilterOptions;
        })();

        opts.ReadOptions = (function() {

            /**
             * Properties of a ReadOptions.
             * @memberof protos.opts
             * @interface IReadOptions
             * @property {string|null} [name] ReadOptions name
             * @property {string|null} [connectionId] ReadOptions connectionId
             * @property {boolean|null} [continuous] ReadOptions continuous
             * @property {protos.opts.IReadSampleOptions|null} [sampleOptions] ReadOptions sampleOptions
             * @property {protos.encoding.IDecodeOptions|null} [decodeOptions] ReadOptions decodeOptions
             * @property {protos.opts.ConvertOption|null} [convertOutput] ReadOptions convertOutput
             * @property {protos.opts.IReadFilterOptions|null} [filter] ReadOptions filter
             * @property {protos.opts.IInferSchemaOptions|null} [inferSchemaOptions] ReadOptions inferSchemaOptions
             * @property {string|null} [_id] ReadOptions _id
             * @property {boolean|null} [_active] ReadOptions _active
             * @property {protos.opts.IReadCLIOptions|null} [_cliOptions] ReadOptions _cliOptions
             * @property {protos.opts.IReadGroupKafkaOptions|null} [kafka] ReadOptions kafka
             * @property {protos.opts.IReadGroupActiveMQOptions|null} [activemq] ReadOptions activemq
             * @property {protos.opts.IReadGroupAWSSQSOptions|null} [awsSqs] ReadOptions awsSqs
             * @property {protos.opts.IReadGroupMongoOptions|null} [mongo] ReadOptions mongo
             * @property {protos.opts.IReadGroupNatsOptions|null} [nats] ReadOptions nats
             * @property {protos.opts.IReadGroupNatsStreamingOptions|null} [natsStreaming] ReadOptions natsStreaming
             * @property {protos.opts.IReadGroupNSQOptions|null} [nsq] ReadOptions nsq
             * @property {protos.opts.IReadGroupPulsarOptions|null} [pulsar] ReadOptions pulsar
             * @property {protos.opts.IReadGroupRabbitOptions|null} [rabbit] ReadOptions rabbit
             * @property {protos.opts.IReadGroupRabbitStreamsOptions|null} [rabbitStreams] ReadOptions rabbitStreams
             * @property {protos.opts.IReadGroupMQTTOptions|null} [mqtt] ReadOptions mqtt
             * @property {protos.opts.IReadGroupAzureServiceBusOptions|null} [azureServiceBus] ReadOptions azureServiceBus
             * @property {protos.opts.IReadGroupAzureEventHubOptions|null} [azureEventHub] ReadOptions azureEventHub
             * @property {protos.opts.IReadGroupGCPPubSubOptions|null} [gcpPubsub] ReadOptions gcpPubsub
             * @property {protos.opts.IReadGroupKubeMQQueueOptions|null} [kubemqQueue] ReadOptions kubemqQueue
             * @property {protos.opts.IReadGroupRedisPubSubOptions|null} [redisPubsub] ReadOptions redisPubsub
             * @property {protos.opts.IReadGroupRedisStreamsOptions|null} [redisStreams] ReadOptions redisStreams
             * @property {protos.opts.IReadGroupPostgresOptions|null} [postgres] ReadOptions postgres
             * @property {protos.opts.IReadGroupNatsJetstreamOptions|null} [natsJetstream] ReadOptions natsJetstream
             * @property {protos.opts.IReadGroupAWSKinesisOptions|null} [awsKinesis] ReadOptions awsKinesis
             */

            /**
             * Constructs a new ReadOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadOptions.
             * @implements IReadOptions
             * @constructor
             * @param {protos.opts.IReadOptions=} [properties] Properties to set
             */
            function ReadOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadOptions name.
             * @member {string} name
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.name = "";

            /**
             * ReadOptions connectionId.
             * @member {string} connectionId
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.connectionId = "";

            /**
             * ReadOptions continuous.
             * @member {boolean} continuous
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.continuous = false;

            /**
             * ReadOptions sampleOptions.
             * @member {protos.opts.IReadSampleOptions|null|undefined} sampleOptions
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.sampleOptions = null;

            /**
             * ReadOptions decodeOptions.
             * @member {protos.encoding.IDecodeOptions|null|undefined} decodeOptions
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.decodeOptions = null;

            /**
             * ReadOptions convertOutput.
             * @member {protos.opts.ConvertOption} convertOutput
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.convertOutput = 0;

            /**
             * ReadOptions filter.
             * @member {protos.opts.IReadFilterOptions|null|undefined} filter
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.filter = null;

            /**
             * ReadOptions inferSchemaOptions.
             * @member {protos.opts.IInferSchemaOptions|null|undefined} inferSchemaOptions
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.inferSchemaOptions = null;

            /**
             * ReadOptions _id.
             * @member {string} _id
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype._id = "";

            /**
             * ReadOptions _active.
             * @member {boolean} _active
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype._active = false;

            /**
             * ReadOptions _cliOptions.
             * @member {protos.opts.IReadCLIOptions|null|undefined} _cliOptions
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype._cliOptions = null;

            /**
             * ReadOptions kafka.
             * @member {protos.opts.IReadGroupKafkaOptions|null|undefined} kafka
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.kafka = null;

            /**
             * ReadOptions activemq.
             * @member {protos.opts.IReadGroupActiveMQOptions|null|undefined} activemq
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.activemq = null;

            /**
             * ReadOptions awsSqs.
             * @member {protos.opts.IReadGroupAWSSQSOptions|null|undefined} awsSqs
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.awsSqs = null;

            /**
             * ReadOptions mongo.
             * @member {protos.opts.IReadGroupMongoOptions|null|undefined} mongo
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.mongo = null;

            /**
             * ReadOptions nats.
             * @member {protos.opts.IReadGroupNatsOptions|null|undefined} nats
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.nats = null;

            /**
             * ReadOptions natsStreaming.
             * @member {protos.opts.IReadGroupNatsStreamingOptions|null|undefined} natsStreaming
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.natsStreaming = null;

            /**
             * ReadOptions nsq.
             * @member {protos.opts.IReadGroupNSQOptions|null|undefined} nsq
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.nsq = null;

            /**
             * ReadOptions pulsar.
             * @member {protos.opts.IReadGroupPulsarOptions|null|undefined} pulsar
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.pulsar = null;

            /**
             * ReadOptions rabbit.
             * @member {protos.opts.IReadGroupRabbitOptions|null|undefined} rabbit
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.rabbit = null;

            /**
             * ReadOptions rabbitStreams.
             * @member {protos.opts.IReadGroupRabbitStreamsOptions|null|undefined} rabbitStreams
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.rabbitStreams = null;

            /**
             * ReadOptions mqtt.
             * @member {protos.opts.IReadGroupMQTTOptions|null|undefined} mqtt
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.mqtt = null;

            /**
             * ReadOptions azureServiceBus.
             * @member {protos.opts.IReadGroupAzureServiceBusOptions|null|undefined} azureServiceBus
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.azureServiceBus = null;

            /**
             * ReadOptions azureEventHub.
             * @member {protos.opts.IReadGroupAzureEventHubOptions|null|undefined} azureEventHub
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.azureEventHub = null;

            /**
             * ReadOptions gcpPubsub.
             * @member {protos.opts.IReadGroupGCPPubSubOptions|null|undefined} gcpPubsub
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.gcpPubsub = null;

            /**
             * ReadOptions kubemqQueue.
             * @member {protos.opts.IReadGroupKubeMQQueueOptions|null|undefined} kubemqQueue
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.kubemqQueue = null;

            /**
             * ReadOptions redisPubsub.
             * @member {protos.opts.IReadGroupRedisPubSubOptions|null|undefined} redisPubsub
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.redisPubsub = null;

            /**
             * ReadOptions redisStreams.
             * @member {protos.opts.IReadGroupRedisStreamsOptions|null|undefined} redisStreams
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.redisStreams = null;

            /**
             * ReadOptions postgres.
             * @member {protos.opts.IReadGroupPostgresOptions|null|undefined} postgres
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.postgres = null;

            /**
             * ReadOptions natsJetstream.
             * @member {protos.opts.IReadGroupNatsJetstreamOptions|null|undefined} natsJetstream
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.natsJetstream = null;

            /**
             * ReadOptions awsKinesis.
             * @member {protos.opts.IReadGroupAWSKinesisOptions|null|undefined} awsKinesis
             * @memberof protos.opts.ReadOptions
             * @instance
             */
            ReadOptions.prototype.awsKinesis = null;

            /**
             * Creates a new ReadOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {protos.opts.IReadOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadOptions} ReadOptions instance
             */
            ReadOptions.create = function create(properties) {
                return new ReadOptions(properties);
            };

            /**
             * Encodes the specified ReadOptions message. Does not implicitly {@link protos.opts.ReadOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {protos.opts.IReadOptions} message ReadOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.connectionId);
                if (message.continuous != null && Object.hasOwnProperty.call(message, "continuous"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.continuous);
                if (message.sampleOptions != null && Object.hasOwnProperty.call(message, "sampleOptions"))
                    $root.protos.opts.ReadSampleOptions.encode(message.sampleOptions, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.decodeOptions != null && Object.hasOwnProperty.call(message, "decodeOptions"))
                    $root.protos.encoding.DecodeOptions.encode(message.decodeOptions, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.convertOutput != null && Object.hasOwnProperty.call(message, "convertOutput"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.convertOutput);
                if (message.filter != null && Object.hasOwnProperty.call(message, "filter"))
                    $root.protos.opts.ReadFilterOptions.encode(message.filter, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.inferSchemaOptions != null && Object.hasOwnProperty.call(message, "inferSchemaOptions"))
                    $root.protos.opts.InferSchemaOptions.encode(message.inferSchemaOptions, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.opts.ReadGroupKafkaOptions.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.activemq != null && Object.hasOwnProperty.call(message, "activemq"))
                    $root.protos.opts.ReadGroupActiveMQOptions.encode(message.activemq, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.awsSqs != null && Object.hasOwnProperty.call(message, "awsSqs"))
                    $root.protos.opts.ReadGroupAWSSQSOptions.encode(message.awsSqs, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.mongo != null && Object.hasOwnProperty.call(message, "mongo"))
                    $root.protos.opts.ReadGroupMongoOptions.encode(message.mongo, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.opts.ReadGroupNatsOptions.encode(message.nats, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.opts.ReadGroupNatsStreamingOptions.encode(message.natsStreaming, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.opts.ReadGroupNSQOptions.encode(message.nsq, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.pulsar != null && Object.hasOwnProperty.call(message, "pulsar"))
                    $root.protos.opts.ReadGroupPulsarOptions.encode(message.pulsar, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.opts.ReadGroupRabbitOptions.encode(message.rabbit, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.rabbitStreams != null && Object.hasOwnProperty.call(message, "rabbitStreams"))
                    $root.protos.opts.ReadGroupRabbitStreamsOptions.encode(message.rabbitStreams, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.opts.ReadGroupMQTTOptions.encode(message.mqtt, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.opts.ReadGroupAzureServiceBusOptions.encode(message.azureServiceBus, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.azureEventHub != null && Object.hasOwnProperty.call(message, "azureEventHub"))
                    $root.protos.opts.ReadGroupAzureEventHubOptions.encode(message.azureEventHub, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.opts.ReadGroupGCPPubSubOptions.encode(message.gcpPubsub, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.kubemqQueue != null && Object.hasOwnProperty.call(message, "kubemqQueue"))
                    $root.protos.opts.ReadGroupKubeMQQueueOptions.encode(message.kubemqQueue, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.opts.ReadGroupRedisPubSubOptions.encode(message.redisPubsub, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.opts.ReadGroupRedisStreamsOptions.encode(message.redisStreams, writer.uint32(/* id 116, wireType 2 =*/930).fork()).ldelim();
                if (message.postgres != null && Object.hasOwnProperty.call(message, "postgres"))
                    $root.protos.opts.ReadGroupPostgresOptions.encode(message.postgres, writer.uint32(/* id 117, wireType 2 =*/938).fork()).ldelim();
                if (message.natsJetstream != null && Object.hasOwnProperty.call(message, "natsJetstream"))
                    $root.protos.opts.ReadGroupNatsJetstreamOptions.encode(message.natsJetstream, writer.uint32(/* id 118, wireType 2 =*/946).fork()).ldelim();
                if (message.awsKinesis != null && Object.hasOwnProperty.call(message, "awsKinesis"))
                    $root.protos.opts.ReadGroupAWSKinesisOptions.encode(message.awsKinesis, writer.uint32(/* id 119, wireType 2 =*/954).fork()).ldelim();
                if (message._id != null && Object.hasOwnProperty.call(message, "_id"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).string(message._id);
                if (message._active != null && Object.hasOwnProperty.call(message, "_active"))
                    writer.uint32(/* id 1001, wireType 0 =*/8008).bool(message._active);
                if (message._cliOptions != null && Object.hasOwnProperty.call(message, "_cliOptions"))
                    $root.protos.opts.ReadCLIOptions.encode(message._cliOptions, writer.uint32(/* id 1002, wireType 2 =*/8018).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadOptions message, length delimited. Does not implicitly {@link protos.opts.ReadOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {protos.opts.IReadOptions} message ReadOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadOptions} ReadOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.connectionId = reader.string();
                        break;
                    case 3:
                        message.continuous = reader.bool();
                        break;
                    case 4:
                        message.sampleOptions = $root.protos.opts.ReadSampleOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.decodeOptions = $root.protos.encoding.DecodeOptions.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.convertOutput = reader.int32();
                        break;
                    case 7:
                        message.filter = $root.protos.opts.ReadFilterOptions.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.inferSchemaOptions = $root.protos.opts.InferSchemaOptions.decode(reader, reader.uint32());
                        break;
                    case 1000:
                        message._id = reader.string();
                        break;
                    case 1001:
                        message._active = reader.bool();
                        break;
                    case 1002:
                        message._cliOptions = $root.protos.opts.ReadCLIOptions.decode(reader, reader.uint32());
                        break;
                    case 100:
                        message.kafka = $root.protos.opts.ReadGroupKafkaOptions.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.activemq = $root.protos.opts.ReadGroupActiveMQOptions.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.awsSqs = $root.protos.opts.ReadGroupAWSSQSOptions.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.mongo = $root.protos.opts.ReadGroupMongoOptions.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.nats = $root.protos.opts.ReadGroupNatsOptions.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.natsStreaming = $root.protos.opts.ReadGroupNatsStreamingOptions.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.nsq = $root.protos.opts.ReadGroupNSQOptions.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.pulsar = $root.protos.opts.ReadGroupPulsarOptions.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.rabbit = $root.protos.opts.ReadGroupRabbitOptions.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.rabbitStreams = $root.protos.opts.ReadGroupRabbitStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 110:
                        message.mqtt = $root.protos.opts.ReadGroupMQTTOptions.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.azureServiceBus = $root.protos.opts.ReadGroupAzureServiceBusOptions.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.azureEventHub = $root.protos.opts.ReadGroupAzureEventHubOptions.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.gcpPubsub = $root.protos.opts.ReadGroupGCPPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.kubemqQueue = $root.protos.opts.ReadGroupKubeMQQueueOptions.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.redisPubsub = $root.protos.opts.ReadGroupRedisPubSubOptions.decode(reader, reader.uint32());
                        break;
                    case 116:
                        message.redisStreams = $root.protos.opts.ReadGroupRedisStreamsOptions.decode(reader, reader.uint32());
                        break;
                    case 117:
                        message.postgres = $root.protos.opts.ReadGroupPostgresOptions.decode(reader, reader.uint32());
                        break;
                    case 118:
                        message.natsJetstream = $root.protos.opts.ReadGroupNatsJetstreamOptions.decode(reader, reader.uint32());
                        break;
                    case 119:
                        message.awsKinesis = $root.protos.opts.ReadGroupAWSKinesisOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadOptions} ReadOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadOptions message.
             * @function verify
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    if (!$util.isString(message.connectionId))
                        return "connectionId: string expected";
                if (message.continuous != null && message.hasOwnProperty("continuous"))
                    if (typeof message.continuous !== "boolean")
                        return "continuous: boolean expected";
                if (message.sampleOptions != null && message.hasOwnProperty("sampleOptions")) {
                    var error = $root.protos.opts.ReadSampleOptions.verify(message.sampleOptions);
                    if (error)
                        return "sampleOptions." + error;
                }
                if (message.decodeOptions != null && message.hasOwnProperty("decodeOptions")) {
                    var error = $root.protos.encoding.DecodeOptions.verify(message.decodeOptions);
                    if (error)
                        return "decodeOptions." + error;
                }
                if (message.convertOutput != null && message.hasOwnProperty("convertOutput"))
                    switch (message.convertOutput) {
                    default:
                        return "convertOutput: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.filter != null && message.hasOwnProperty("filter")) {
                    var error = $root.protos.opts.ReadFilterOptions.verify(message.filter);
                    if (error)
                        return "filter." + error;
                }
                if (message.inferSchemaOptions != null && message.hasOwnProperty("inferSchemaOptions")) {
                    var error = $root.protos.opts.InferSchemaOptions.verify(message.inferSchemaOptions);
                    if (error)
                        return "inferSchemaOptions." + error;
                }
                if (message._id != null && message.hasOwnProperty("_id"))
                    if (!$util.isString(message._id))
                        return "_id: string expected";
                if (message._active != null && message.hasOwnProperty("_active"))
                    if (typeof message._active !== "boolean")
                        return "_active: boolean expected";
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions")) {
                    var error = $root.protos.opts.ReadCLIOptions.verify(message._cliOptions);
                    if (error)
                        return "_cliOptions." + error;
                }
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    var error = $root.protos.opts.ReadGroupKafkaOptions.verify(message.kafka);
                    if (error)
                        return "kafka." + error;
                }
                if (message.activemq != null && message.hasOwnProperty("activemq")) {
                    var error = $root.protos.opts.ReadGroupActiveMQOptions.verify(message.activemq);
                    if (error)
                        return "activemq." + error;
                }
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs")) {
                    var error = $root.protos.opts.ReadGroupAWSSQSOptions.verify(message.awsSqs);
                    if (error)
                        return "awsSqs." + error;
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    var error = $root.protos.opts.ReadGroupMongoOptions.verify(message.mongo);
                    if (error)
                        return "mongo." + error;
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    var error = $root.protos.opts.ReadGroupNatsOptions.verify(message.nats);
                    if (error)
                        return "nats." + error;
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    var error = $root.protos.opts.ReadGroupNatsStreamingOptions.verify(message.natsStreaming);
                    if (error)
                        return "natsStreaming." + error;
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    var error = $root.protos.opts.ReadGroupNSQOptions.verify(message.nsq);
                    if (error)
                        return "nsq." + error;
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    var error = $root.protos.opts.ReadGroupPulsarOptions.verify(message.pulsar);
                    if (error)
                        return "pulsar." + error;
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    var error = $root.protos.opts.ReadGroupRabbitOptions.verify(message.rabbit);
                    if (error)
                        return "rabbit." + error;
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    var error = $root.protos.opts.ReadGroupRabbitStreamsOptions.verify(message.rabbitStreams);
                    if (error)
                        return "rabbitStreams." + error;
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    var error = $root.protos.opts.ReadGroupMQTTOptions.verify(message.mqtt);
                    if (error)
                        return "mqtt." + error;
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    var error = $root.protos.opts.ReadGroupAzureServiceBusOptions.verify(message.azureServiceBus);
                    if (error)
                        return "azureServiceBus." + error;
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    var error = $root.protos.opts.ReadGroupAzureEventHubOptions.verify(message.azureEventHub);
                    if (error)
                        return "azureEventHub." + error;
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    var error = $root.protos.opts.ReadGroupGCPPubSubOptions.verify(message.gcpPubsub);
                    if (error)
                        return "gcpPubsub." + error;
                }
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue")) {
                    var error = $root.protos.opts.ReadGroupKubeMQQueueOptions.verify(message.kubemqQueue);
                    if (error)
                        return "kubemqQueue." + error;
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    var error = $root.protos.opts.ReadGroupRedisPubSubOptions.verify(message.redisPubsub);
                    if (error)
                        return "redisPubsub." + error;
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    var error = $root.protos.opts.ReadGroupRedisStreamsOptions.verify(message.redisStreams);
                    if (error)
                        return "redisStreams." + error;
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    var error = $root.protos.opts.ReadGroupPostgresOptions.verify(message.postgres);
                    if (error)
                        return "postgres." + error;
                }
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream")) {
                    var error = $root.protos.opts.ReadGroupNatsJetstreamOptions.verify(message.natsJetstream);
                    if (error)
                        return "natsJetstream." + error;
                }
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis")) {
                    var error = $root.protos.opts.ReadGroupAWSKinesisOptions.verify(message.awsKinesis);
                    if (error)
                        return "awsKinesis." + error;
                }
                return null;
            };

            /**
             * Creates a ReadOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadOptions} ReadOptions
             */
            ReadOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadOptions)
                    return object;
                var message = new $root.protos.opts.ReadOptions();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.connectionId != null)
                    message.connectionId = String(object.connectionId);
                if (object.continuous != null)
                    message.continuous = Boolean(object.continuous);
                if (object.sampleOptions != null) {
                    if (typeof object.sampleOptions !== "object")
                        throw TypeError(".protos.opts.ReadOptions.sampleOptions: object expected");
                    message.sampleOptions = $root.protos.opts.ReadSampleOptions.fromObject(object.sampleOptions);
                }
                if (object.decodeOptions != null) {
                    if (typeof object.decodeOptions !== "object")
                        throw TypeError(".protos.opts.ReadOptions.decodeOptions: object expected");
                    message.decodeOptions = $root.protos.encoding.DecodeOptions.fromObject(object.decodeOptions);
                }
                switch (object.convertOutput) {
                case "CONVERT_OPTION_UNSET":
                case 0:
                    message.convertOutput = 0;
                    break;
                case "CONVERT_OPTION_BASE64":
                case 1:
                    message.convertOutput = 1;
                    break;
                case "CONVERT_OPTION_GZIP":
                case 2:
                    message.convertOutput = 2;
                    break;
                }
                if (object.filter != null) {
                    if (typeof object.filter !== "object")
                        throw TypeError(".protos.opts.ReadOptions.filter: object expected");
                    message.filter = $root.protos.opts.ReadFilterOptions.fromObject(object.filter);
                }
                if (object.inferSchemaOptions != null) {
                    if (typeof object.inferSchemaOptions !== "object")
                        throw TypeError(".protos.opts.ReadOptions.inferSchemaOptions: object expected");
                    message.inferSchemaOptions = $root.protos.opts.InferSchemaOptions.fromObject(object.inferSchemaOptions);
                }
                if (object._id != null)
                    message._id = String(object._id);
                if (object._active != null)
                    message._active = Boolean(object._active);
                if (object._cliOptions != null) {
                    if (typeof object._cliOptions !== "object")
                        throw TypeError(".protos.opts.ReadOptions._cliOptions: object expected");
                    message._cliOptions = $root.protos.opts.ReadCLIOptions.fromObject(object._cliOptions);
                }
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.opts.ReadOptions.kafka: object expected");
                    message.kafka = $root.protos.opts.ReadGroupKafkaOptions.fromObject(object.kafka);
                }
                if (object.activemq != null) {
                    if (typeof object.activemq !== "object")
                        throw TypeError(".protos.opts.ReadOptions.activemq: object expected");
                    message.activemq = $root.protos.opts.ReadGroupActiveMQOptions.fromObject(object.activemq);
                }
                if (object.awsSqs != null) {
                    if (typeof object.awsSqs !== "object")
                        throw TypeError(".protos.opts.ReadOptions.awsSqs: object expected");
                    message.awsSqs = $root.protos.opts.ReadGroupAWSSQSOptions.fromObject(object.awsSqs);
                }
                if (object.mongo != null) {
                    if (typeof object.mongo !== "object")
                        throw TypeError(".protos.opts.ReadOptions.mongo: object expected");
                    message.mongo = $root.protos.opts.ReadGroupMongoOptions.fromObject(object.mongo);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.opts.ReadOptions.nats: object expected");
                    message.nats = $root.protos.opts.ReadGroupNatsOptions.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.opts.ReadOptions.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.opts.ReadGroupNatsStreamingOptions.fromObject(object.natsStreaming);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.opts.ReadOptions.nsq: object expected");
                    message.nsq = $root.protos.opts.ReadGroupNSQOptions.fromObject(object.nsq);
                }
                if (object.pulsar != null) {
                    if (typeof object.pulsar !== "object")
                        throw TypeError(".protos.opts.ReadOptions.pulsar: object expected");
                    message.pulsar = $root.protos.opts.ReadGroupPulsarOptions.fromObject(object.pulsar);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.opts.ReadOptions.rabbit: object expected");
                    message.rabbit = $root.protos.opts.ReadGroupRabbitOptions.fromObject(object.rabbit);
                }
                if (object.rabbitStreams != null) {
                    if (typeof object.rabbitStreams !== "object")
                        throw TypeError(".protos.opts.ReadOptions.rabbitStreams: object expected");
                    message.rabbitStreams = $root.protos.opts.ReadGroupRabbitStreamsOptions.fromObject(object.rabbitStreams);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.opts.ReadOptions.mqtt: object expected");
                    message.mqtt = $root.protos.opts.ReadGroupMQTTOptions.fromObject(object.mqtt);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.opts.ReadOptions.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.opts.ReadGroupAzureServiceBusOptions.fromObject(object.azureServiceBus);
                }
                if (object.azureEventHub != null) {
                    if (typeof object.azureEventHub !== "object")
                        throw TypeError(".protos.opts.ReadOptions.azureEventHub: object expected");
                    message.azureEventHub = $root.protos.opts.ReadGroupAzureEventHubOptions.fromObject(object.azureEventHub);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.opts.ReadOptions.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.opts.ReadGroupGCPPubSubOptions.fromObject(object.gcpPubsub);
                }
                if (object.kubemqQueue != null) {
                    if (typeof object.kubemqQueue !== "object")
                        throw TypeError(".protos.opts.ReadOptions.kubemqQueue: object expected");
                    message.kubemqQueue = $root.protos.opts.ReadGroupKubeMQQueueOptions.fromObject(object.kubemqQueue);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.opts.ReadOptions.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.opts.ReadGroupRedisPubSubOptions.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.opts.ReadOptions.redisStreams: object expected");
                    message.redisStreams = $root.protos.opts.ReadGroupRedisStreamsOptions.fromObject(object.redisStreams);
                }
                if (object.postgres != null) {
                    if (typeof object.postgres !== "object")
                        throw TypeError(".protos.opts.ReadOptions.postgres: object expected");
                    message.postgres = $root.protos.opts.ReadGroupPostgresOptions.fromObject(object.postgres);
                }
                if (object.natsJetstream != null) {
                    if (typeof object.natsJetstream !== "object")
                        throw TypeError(".protos.opts.ReadOptions.natsJetstream: object expected");
                    message.natsJetstream = $root.protos.opts.ReadGroupNatsJetstreamOptions.fromObject(object.natsJetstream);
                }
                if (object.awsKinesis != null) {
                    if (typeof object.awsKinesis !== "object")
                        throw TypeError(".protos.opts.ReadOptions.awsKinesis: object expected");
                    message.awsKinesis = $root.protos.opts.ReadGroupAWSKinesisOptions.fromObject(object.awsKinesis);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadOptions
             * @static
             * @param {protos.opts.ReadOptions} message ReadOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.connectionId = "";
                    object.continuous = false;
                    object.sampleOptions = null;
                    object.decodeOptions = null;
                    object.convertOutput = options.enums === String ? "CONVERT_OPTION_UNSET" : 0;
                    object.filter = null;
                    object.inferSchemaOptions = null;
                    object.kafka = null;
                    object.activemq = null;
                    object.awsSqs = null;
                    object.mongo = null;
                    object.nats = null;
                    object.natsStreaming = null;
                    object.nsq = null;
                    object.pulsar = null;
                    object.rabbit = null;
                    object.rabbitStreams = null;
                    object.mqtt = null;
                    object.azureServiceBus = null;
                    object.azureEventHub = null;
                    object.gcpPubsub = null;
                    object.kubemqQueue = null;
                    object.redisPubsub = null;
                    object.redisStreams = null;
                    object.postgres = null;
                    object.natsJetstream = null;
                    object.awsKinesis = null;
                    object._id = "";
                    object._active = false;
                    object._cliOptions = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.connectionId != null && message.hasOwnProperty("connectionId"))
                    object.connectionId = message.connectionId;
                if (message.continuous != null && message.hasOwnProperty("continuous"))
                    object.continuous = message.continuous;
                if (message.sampleOptions != null && message.hasOwnProperty("sampleOptions"))
                    object.sampleOptions = $root.protos.opts.ReadSampleOptions.toObject(message.sampleOptions, options);
                if (message.decodeOptions != null && message.hasOwnProperty("decodeOptions"))
                    object.decodeOptions = $root.protos.encoding.DecodeOptions.toObject(message.decodeOptions, options);
                if (message.convertOutput != null && message.hasOwnProperty("convertOutput"))
                    object.convertOutput = options.enums === String ? $root.protos.opts.ConvertOption[message.convertOutput] : message.convertOutput;
                if (message.filter != null && message.hasOwnProperty("filter"))
                    object.filter = $root.protos.opts.ReadFilterOptions.toObject(message.filter, options);
                if (message.inferSchemaOptions != null && message.hasOwnProperty("inferSchemaOptions"))
                    object.inferSchemaOptions = $root.protos.opts.InferSchemaOptions.toObject(message.inferSchemaOptions, options);
                if (message.kafka != null && message.hasOwnProperty("kafka"))
                    object.kafka = $root.protos.opts.ReadGroupKafkaOptions.toObject(message.kafka, options);
                if (message.activemq != null && message.hasOwnProperty("activemq"))
                    object.activemq = $root.protos.opts.ReadGroupActiveMQOptions.toObject(message.activemq, options);
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs"))
                    object.awsSqs = $root.protos.opts.ReadGroupAWSSQSOptions.toObject(message.awsSqs, options);
                if (message.mongo != null && message.hasOwnProperty("mongo"))
                    object.mongo = $root.protos.opts.ReadGroupMongoOptions.toObject(message.mongo, options);
                if (message.nats != null && message.hasOwnProperty("nats"))
                    object.nats = $root.protos.opts.ReadGroupNatsOptions.toObject(message.nats, options);
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming"))
                    object.natsStreaming = $root.protos.opts.ReadGroupNatsStreamingOptions.toObject(message.natsStreaming, options);
                if (message.nsq != null && message.hasOwnProperty("nsq"))
                    object.nsq = $root.protos.opts.ReadGroupNSQOptions.toObject(message.nsq, options);
                if (message.pulsar != null && message.hasOwnProperty("pulsar"))
                    object.pulsar = $root.protos.opts.ReadGroupPulsarOptions.toObject(message.pulsar, options);
                if (message.rabbit != null && message.hasOwnProperty("rabbit"))
                    object.rabbit = $root.protos.opts.ReadGroupRabbitOptions.toObject(message.rabbit, options);
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams"))
                    object.rabbitStreams = $root.protos.opts.ReadGroupRabbitStreamsOptions.toObject(message.rabbitStreams, options);
                if (message.mqtt != null && message.hasOwnProperty("mqtt"))
                    object.mqtt = $root.protos.opts.ReadGroupMQTTOptions.toObject(message.mqtt, options);
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus"))
                    object.azureServiceBus = $root.protos.opts.ReadGroupAzureServiceBusOptions.toObject(message.azureServiceBus, options);
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub"))
                    object.azureEventHub = $root.protos.opts.ReadGroupAzureEventHubOptions.toObject(message.azureEventHub, options);
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub"))
                    object.gcpPubsub = $root.protos.opts.ReadGroupGCPPubSubOptions.toObject(message.gcpPubsub, options);
                if (message.kubemqQueue != null && message.hasOwnProperty("kubemqQueue"))
                    object.kubemqQueue = $root.protos.opts.ReadGroupKubeMQQueueOptions.toObject(message.kubemqQueue, options);
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub"))
                    object.redisPubsub = $root.protos.opts.ReadGroupRedisPubSubOptions.toObject(message.redisPubsub, options);
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams"))
                    object.redisStreams = $root.protos.opts.ReadGroupRedisStreamsOptions.toObject(message.redisStreams, options);
                if (message.postgres != null && message.hasOwnProperty("postgres"))
                    object.postgres = $root.protos.opts.ReadGroupPostgresOptions.toObject(message.postgres, options);
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream"))
                    object.natsJetstream = $root.protos.opts.ReadGroupNatsJetstreamOptions.toObject(message.natsJetstream, options);
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis"))
                    object.awsKinesis = $root.protos.opts.ReadGroupAWSKinesisOptions.toObject(message.awsKinesis, options);
                if (message._id != null && message.hasOwnProperty("_id"))
                    object._id = message._id;
                if (message._active != null && message.hasOwnProperty("_active"))
                    object._active = message._active;
                if (message._cliOptions != null && message.hasOwnProperty("_cliOptions"))
                    object._cliOptions = $root.protos.opts.ReadCLIOptions.toObject(message._cliOptions, options);
                return object;
            };

            /**
             * Converts this ReadOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadOptions;
        })();

        opts.ReadGroupKafkaOptions = (function() {

            /**
             * Properties of a ReadGroupKafkaOptions.
             * @memberof protos.opts
             * @interface IReadGroupKafkaOptions
             * @property {protos.args.IKafkaConn|null} [_conn] ReadGroupKafkaOptions _conn
             * @property {protos.args.IKafkaReadArgs|null} [args] ReadGroupKafkaOptions args
             */

            /**
             * Constructs a new ReadGroupKafkaOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupKafkaOptions.
             * @implements IReadGroupKafkaOptions
             * @constructor
             * @param {protos.opts.IReadGroupKafkaOptions=} [properties] Properties to set
             */
            function ReadGroupKafkaOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupKafkaOptions _conn.
             * @member {protos.args.IKafkaConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @instance
             */
            ReadGroupKafkaOptions.prototype._conn = null;

            /**
             * ReadGroupKafkaOptions args.
             * @member {protos.args.IKafkaReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @instance
             */
            ReadGroupKafkaOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupKafkaOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {protos.opts.IReadGroupKafkaOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupKafkaOptions} ReadGroupKafkaOptions instance
             */
            ReadGroupKafkaOptions.create = function create(properties) {
                return new ReadGroupKafkaOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupKafkaOptions message. Does not implicitly {@link protos.opts.ReadGroupKafkaOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {protos.opts.IReadGroupKafkaOptions} message ReadGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupKafkaOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KafkaConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KafkaReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupKafkaOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupKafkaOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {protos.opts.IReadGroupKafkaOptions} message ReadGroupKafkaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupKafkaOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupKafkaOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupKafkaOptions} ReadGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupKafkaOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupKafkaOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KafkaConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KafkaReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupKafkaOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupKafkaOptions} ReadGroupKafkaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupKafkaOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupKafkaOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupKafkaOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KafkaConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KafkaReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupKafkaOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupKafkaOptions} ReadGroupKafkaOptions
             */
            ReadGroupKafkaOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupKafkaOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupKafkaOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupKafkaOptions._conn: object expected");
                    message._conn = $root.protos.args.KafkaConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupKafkaOptions.args: object expected");
                    message.args = $root.protos.args.KafkaReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupKafkaOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @static
             * @param {protos.opts.ReadGroupKafkaOptions} message ReadGroupKafkaOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupKafkaOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KafkaConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KafkaReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupKafkaOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupKafkaOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupKafkaOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupKafkaOptions;
        })();

        opts.ReadGroupActiveMQOptions = (function() {

            /**
             * Properties of a ReadGroupActiveMQOptions.
             * @memberof protos.opts
             * @interface IReadGroupActiveMQOptions
             * @property {protos.args.IActiveMQConn|null} [_conn] ReadGroupActiveMQOptions _conn
             * @property {protos.args.IActiveMQReadArgs|null} [args] ReadGroupActiveMQOptions args
             */

            /**
             * Constructs a new ReadGroupActiveMQOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupActiveMQOptions.
             * @implements IReadGroupActiveMQOptions
             * @constructor
             * @param {protos.opts.IReadGroupActiveMQOptions=} [properties] Properties to set
             */
            function ReadGroupActiveMQOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupActiveMQOptions _conn.
             * @member {protos.args.IActiveMQConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @instance
             */
            ReadGroupActiveMQOptions.prototype._conn = null;

            /**
             * ReadGroupActiveMQOptions args.
             * @member {protos.args.IActiveMQReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @instance
             */
            ReadGroupActiveMQOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupActiveMQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {protos.opts.IReadGroupActiveMQOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupActiveMQOptions} ReadGroupActiveMQOptions instance
             */
            ReadGroupActiveMQOptions.create = function create(properties) {
                return new ReadGroupActiveMQOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupActiveMQOptions message. Does not implicitly {@link protos.opts.ReadGroupActiveMQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {protos.opts.IReadGroupActiveMQOptions} message ReadGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupActiveMQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.ActiveMQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.ActiveMQReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupActiveMQOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupActiveMQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {protos.opts.IReadGroupActiveMQOptions} message ReadGroupActiveMQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupActiveMQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupActiveMQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupActiveMQOptions} ReadGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupActiveMQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupActiveMQOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.ActiveMQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.ActiveMQReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupActiveMQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupActiveMQOptions} ReadGroupActiveMQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupActiveMQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupActiveMQOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupActiveMQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.ActiveMQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.ActiveMQReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupActiveMQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupActiveMQOptions} ReadGroupActiveMQOptions
             */
            ReadGroupActiveMQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupActiveMQOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupActiveMQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupActiveMQOptions._conn: object expected");
                    message._conn = $root.protos.args.ActiveMQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupActiveMQOptions.args: object expected");
                    message.args = $root.protos.args.ActiveMQReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupActiveMQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @static
             * @param {protos.opts.ReadGroupActiveMQOptions} message ReadGroupActiveMQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupActiveMQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.ActiveMQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.ActiveMQReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupActiveMQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupActiveMQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupActiveMQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupActiveMQOptions;
        })();

        opts.ReadGroupAWSSQSOptions = (function() {

            /**
             * Properties of a ReadGroupAWSSQSOptions.
             * @memberof protos.opts
             * @interface IReadGroupAWSSQSOptions
             * @property {protos.args.IAWSSQSConn|null} [_conn] ReadGroupAWSSQSOptions _conn
             * @property {protos.args.IAWSSQSReadArgs|null} [args] ReadGroupAWSSQSOptions args
             */

            /**
             * Constructs a new ReadGroupAWSSQSOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupAWSSQSOptions.
             * @implements IReadGroupAWSSQSOptions
             * @constructor
             * @param {protos.opts.IReadGroupAWSSQSOptions=} [properties] Properties to set
             */
            function ReadGroupAWSSQSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupAWSSQSOptions _conn.
             * @member {protos.args.IAWSSQSConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @instance
             */
            ReadGroupAWSSQSOptions.prototype._conn = null;

            /**
             * ReadGroupAWSSQSOptions args.
             * @member {protos.args.IAWSSQSReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @instance
             */
            ReadGroupAWSSQSOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupAWSSQSOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IReadGroupAWSSQSOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupAWSSQSOptions} ReadGroupAWSSQSOptions instance
             */
            ReadGroupAWSSQSOptions.create = function create(properties) {
                return new ReadGroupAWSSQSOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupAWSSQSOptions message. Does not implicitly {@link protos.opts.ReadGroupAWSSQSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IReadGroupAWSSQSOptions} message ReadGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAWSSQSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSSQSConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSSQSReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupAWSSQSOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupAWSSQSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {protos.opts.IReadGroupAWSSQSOptions} message ReadGroupAWSSQSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAWSSQSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupAWSSQSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupAWSSQSOptions} ReadGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAWSSQSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupAWSSQSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSSQSConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSSQSReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupAWSSQSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupAWSSQSOptions} ReadGroupAWSSQSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAWSSQSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupAWSSQSOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupAWSSQSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSSQSConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSSQSReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupAWSSQSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupAWSSQSOptions} ReadGroupAWSSQSOptions
             */
            ReadGroupAWSSQSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupAWSSQSOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupAWSSQSOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupAWSSQSOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSSQSConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupAWSSQSOptions.args: object expected");
                    message.args = $root.protos.args.AWSSQSReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupAWSSQSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @static
             * @param {protos.opts.ReadGroupAWSSQSOptions} message ReadGroupAWSSQSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupAWSSQSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSSQSConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSSQSReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupAWSSQSOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupAWSSQSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupAWSSQSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupAWSSQSOptions;
        })();

        opts.ReadGroupMongoOptions = (function() {

            /**
             * Properties of a ReadGroupMongoOptions.
             * @memberof protos.opts
             * @interface IReadGroupMongoOptions
             * @property {protos.args.IMongoConn|null} [_conn] ReadGroupMongoOptions _conn
             * @property {protos.args.IMongoReadArgs|null} [args] ReadGroupMongoOptions args
             */

            /**
             * Constructs a new ReadGroupMongoOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupMongoOptions.
             * @implements IReadGroupMongoOptions
             * @constructor
             * @param {protos.opts.IReadGroupMongoOptions=} [properties] Properties to set
             */
            function ReadGroupMongoOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupMongoOptions _conn.
             * @member {protos.args.IMongoConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupMongoOptions
             * @instance
             */
            ReadGroupMongoOptions.prototype._conn = null;

            /**
             * ReadGroupMongoOptions args.
             * @member {protos.args.IMongoReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupMongoOptions
             * @instance
             */
            ReadGroupMongoOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupMongoOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {protos.opts.IReadGroupMongoOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupMongoOptions} ReadGroupMongoOptions instance
             */
            ReadGroupMongoOptions.create = function create(properties) {
                return new ReadGroupMongoOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupMongoOptions message. Does not implicitly {@link protos.opts.ReadGroupMongoOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {protos.opts.IReadGroupMongoOptions} message ReadGroupMongoOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupMongoOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MongoConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MongoReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupMongoOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupMongoOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {protos.opts.IReadGroupMongoOptions} message ReadGroupMongoOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupMongoOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupMongoOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupMongoOptions} ReadGroupMongoOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupMongoOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupMongoOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MongoConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MongoReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupMongoOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupMongoOptions} ReadGroupMongoOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupMongoOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupMongoOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupMongoOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.MongoConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.MongoReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupMongoOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupMongoOptions} ReadGroupMongoOptions
             */
            ReadGroupMongoOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupMongoOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupMongoOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupMongoOptions._conn: object expected");
                    message._conn = $root.protos.args.MongoConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupMongoOptions.args: object expected");
                    message.args = $root.protos.args.MongoReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupMongoOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupMongoOptions
             * @static
             * @param {protos.opts.ReadGroupMongoOptions} message ReadGroupMongoOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupMongoOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MongoConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MongoReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupMongoOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupMongoOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupMongoOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupMongoOptions;
        })();

        opts.ReadGroupNatsOptions = (function() {

            /**
             * Properties of a ReadGroupNatsOptions.
             * @memberof protos.opts
             * @interface IReadGroupNatsOptions
             * @property {protos.args.INatsConn|null} [_conn] ReadGroupNatsOptions _conn
             * @property {protos.args.INatsReadArgs|null} [args] ReadGroupNatsOptions args
             */

            /**
             * Constructs a new ReadGroupNatsOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupNatsOptions.
             * @implements IReadGroupNatsOptions
             * @constructor
             * @param {protos.opts.IReadGroupNatsOptions=} [properties] Properties to set
             */
            function ReadGroupNatsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupNatsOptions _conn.
             * @member {protos.args.INatsConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupNatsOptions
             * @instance
             */
            ReadGroupNatsOptions.prototype._conn = null;

            /**
             * ReadGroupNatsOptions args.
             * @member {protos.args.INatsReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupNatsOptions
             * @instance
             */
            ReadGroupNatsOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupNatsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {protos.opts.IReadGroupNatsOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupNatsOptions} ReadGroupNatsOptions instance
             */
            ReadGroupNatsOptions.create = function create(properties) {
                return new ReadGroupNatsOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupNatsOptions message. Does not implicitly {@link protos.opts.ReadGroupNatsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {protos.opts.IReadGroupNatsOptions} message ReadGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNatsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupNatsOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupNatsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {protos.opts.IReadGroupNatsOptions} message ReadGroupNatsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNatsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupNatsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupNatsOptions} ReadGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNatsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupNatsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupNatsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupNatsOptions} ReadGroupNatsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNatsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupNatsOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupNatsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupNatsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupNatsOptions} ReadGroupNatsOptions
             */
            ReadGroupNatsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupNatsOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupNatsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupNatsOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupNatsOptions.args: object expected");
                    message.args = $root.protos.args.NatsReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupNatsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupNatsOptions
             * @static
             * @param {protos.opts.ReadGroupNatsOptions} message ReadGroupNatsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupNatsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupNatsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupNatsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupNatsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupNatsOptions;
        })();

        opts.ReadGroupNatsStreamingOptions = (function() {

            /**
             * Properties of a ReadGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @interface IReadGroupNatsStreamingOptions
             * @property {protos.args.INatsStreamingConn|null} [_conn] ReadGroupNatsStreamingOptions _conn
             * @property {protos.args.INatsStreamingReadArgs|null} [args] ReadGroupNatsStreamingOptions args
             */

            /**
             * Constructs a new ReadGroupNatsStreamingOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupNatsStreamingOptions.
             * @implements IReadGroupNatsStreamingOptions
             * @constructor
             * @param {protos.opts.IReadGroupNatsStreamingOptions=} [properties] Properties to set
             */
            function ReadGroupNatsStreamingOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupNatsStreamingOptions _conn.
             * @member {protos.args.INatsStreamingConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @instance
             */
            ReadGroupNatsStreamingOptions.prototype._conn = null;

            /**
             * ReadGroupNatsStreamingOptions args.
             * @member {protos.args.INatsStreamingReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @instance
             */
            ReadGroupNatsStreamingOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupNatsStreamingOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IReadGroupNatsStreamingOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupNatsStreamingOptions} ReadGroupNatsStreamingOptions instance
             */
            ReadGroupNatsStreamingOptions.create = function create(properties) {
                return new ReadGroupNatsStreamingOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupNatsStreamingOptions message. Does not implicitly {@link protos.opts.ReadGroupNatsStreamingOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IReadGroupNatsStreamingOptions} message ReadGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNatsStreamingOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsStreamingConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsStreamingReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupNatsStreamingOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupNatsStreamingOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.IReadGroupNatsStreamingOptions} message ReadGroupNatsStreamingOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNatsStreamingOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupNatsStreamingOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupNatsStreamingOptions} ReadGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNatsStreamingOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupNatsStreamingOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsStreamingConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsStreamingReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupNatsStreamingOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupNatsStreamingOptions} ReadGroupNatsStreamingOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNatsStreamingOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupNatsStreamingOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupNatsStreamingOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsStreamingConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsStreamingReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupNatsStreamingOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupNatsStreamingOptions} ReadGroupNatsStreamingOptions
             */
            ReadGroupNatsStreamingOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupNatsStreamingOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupNatsStreamingOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupNatsStreamingOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsStreamingConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupNatsStreamingOptions.args: object expected");
                    message.args = $root.protos.args.NatsStreamingReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupNatsStreamingOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @static
             * @param {protos.opts.ReadGroupNatsStreamingOptions} message ReadGroupNatsStreamingOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupNatsStreamingOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsStreamingConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsStreamingReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupNatsStreamingOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupNatsStreamingOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupNatsStreamingOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupNatsStreamingOptions;
        })();

        opts.ReadGroupNatsJetstreamOptions = (function() {

            /**
             * Properties of a ReadGroupNatsJetstreamOptions.
             * @memberof protos.opts
             * @interface IReadGroupNatsJetstreamOptions
             * @property {protos.args.INatsJetstreamConn|null} [_conn] ReadGroupNatsJetstreamOptions _conn
             * @property {protos.args.INatsJetstreamReadArgs|null} [args] ReadGroupNatsJetstreamOptions args
             */

            /**
             * Constructs a new ReadGroupNatsJetstreamOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupNatsJetstreamOptions.
             * @implements IReadGroupNatsJetstreamOptions
             * @constructor
             * @param {protos.opts.IReadGroupNatsJetstreamOptions=} [properties] Properties to set
             */
            function ReadGroupNatsJetstreamOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupNatsJetstreamOptions _conn.
             * @member {protos.args.INatsJetstreamConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @instance
             */
            ReadGroupNatsJetstreamOptions.prototype._conn = null;

            /**
             * ReadGroupNatsJetstreamOptions args.
             * @member {protos.args.INatsJetstreamReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @instance
             */
            ReadGroupNatsJetstreamOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupNatsJetstreamOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.IReadGroupNatsJetstreamOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupNatsJetstreamOptions} ReadGroupNatsJetstreamOptions instance
             */
            ReadGroupNatsJetstreamOptions.create = function create(properties) {
                return new ReadGroupNatsJetstreamOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupNatsJetstreamOptions message. Does not implicitly {@link protos.opts.ReadGroupNatsJetstreamOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.IReadGroupNatsJetstreamOptions} message ReadGroupNatsJetstreamOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNatsJetstreamOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NatsJetstreamConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NatsJetstreamReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupNatsJetstreamOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupNatsJetstreamOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.IReadGroupNatsJetstreamOptions} message ReadGroupNatsJetstreamOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNatsJetstreamOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupNatsJetstreamOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupNatsJetstreamOptions} ReadGroupNatsJetstreamOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNatsJetstreamOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupNatsJetstreamOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NatsJetstreamConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NatsJetstreamReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupNatsJetstreamOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupNatsJetstreamOptions} ReadGroupNatsJetstreamOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNatsJetstreamOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupNatsJetstreamOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupNatsJetstreamOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NatsJetstreamConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NatsJetstreamReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupNatsJetstreamOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupNatsJetstreamOptions} ReadGroupNatsJetstreamOptions
             */
            ReadGroupNatsJetstreamOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupNatsJetstreamOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupNatsJetstreamOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupNatsJetstreamOptions._conn: object expected");
                    message._conn = $root.protos.args.NatsJetstreamConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupNatsJetstreamOptions.args: object expected");
                    message.args = $root.protos.args.NatsJetstreamReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupNatsJetstreamOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @static
             * @param {protos.opts.ReadGroupNatsJetstreamOptions} message ReadGroupNatsJetstreamOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupNatsJetstreamOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NatsJetstreamConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NatsJetstreamReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupNatsJetstreamOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupNatsJetstreamOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupNatsJetstreamOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupNatsJetstreamOptions;
        })();

        opts.ReadGroupNSQOptions = (function() {

            /**
             * Properties of a ReadGroupNSQOptions.
             * @memberof protos.opts
             * @interface IReadGroupNSQOptions
             * @property {protos.args.INSQConn|null} [_conn] ReadGroupNSQOptions _conn
             * @property {protos.args.INSQReadArgs|null} [args] ReadGroupNSQOptions args
             */

            /**
             * Constructs a new ReadGroupNSQOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupNSQOptions.
             * @implements IReadGroupNSQOptions
             * @constructor
             * @param {protos.opts.IReadGroupNSQOptions=} [properties] Properties to set
             */
            function ReadGroupNSQOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupNSQOptions _conn.
             * @member {protos.args.INSQConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupNSQOptions
             * @instance
             */
            ReadGroupNSQOptions.prototype._conn = null;

            /**
             * ReadGroupNSQOptions args.
             * @member {protos.args.INSQReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupNSQOptions
             * @instance
             */
            ReadGroupNSQOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupNSQOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {protos.opts.IReadGroupNSQOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupNSQOptions} ReadGroupNSQOptions instance
             */
            ReadGroupNSQOptions.create = function create(properties) {
                return new ReadGroupNSQOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupNSQOptions message. Does not implicitly {@link protos.opts.ReadGroupNSQOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {protos.opts.IReadGroupNSQOptions} message ReadGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNSQOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.NSQConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.NSQReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupNSQOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupNSQOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {protos.opts.IReadGroupNSQOptions} message ReadGroupNSQOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupNSQOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupNSQOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupNSQOptions} ReadGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNSQOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupNSQOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.NSQConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.NSQReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupNSQOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupNSQOptions} ReadGroupNSQOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupNSQOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupNSQOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupNSQOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.NSQConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.NSQReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupNSQOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupNSQOptions} ReadGroupNSQOptions
             */
            ReadGroupNSQOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupNSQOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupNSQOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupNSQOptions._conn: object expected");
                    message._conn = $root.protos.args.NSQConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupNSQOptions.args: object expected");
                    message.args = $root.protos.args.NSQReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupNSQOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupNSQOptions
             * @static
             * @param {protos.opts.ReadGroupNSQOptions} message ReadGroupNSQOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupNSQOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.NSQConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.NSQReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupNSQOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupNSQOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupNSQOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupNSQOptions;
        })();

        opts.ReadGroupPostgresOptions = (function() {

            /**
             * Properties of a ReadGroupPostgresOptions.
             * @memberof protos.opts
             * @interface IReadGroupPostgresOptions
             * @property {protos.args.IPostgresConn|null} [_conn] ReadGroupPostgresOptions _conn
             * @property {protos.args.IPostgresReadArgs|null} [args] ReadGroupPostgresOptions args
             */

            /**
             * Constructs a new ReadGroupPostgresOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupPostgresOptions.
             * @implements IReadGroupPostgresOptions
             * @constructor
             * @param {protos.opts.IReadGroupPostgresOptions=} [properties] Properties to set
             */
            function ReadGroupPostgresOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupPostgresOptions _conn.
             * @member {protos.args.IPostgresConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @instance
             */
            ReadGroupPostgresOptions.prototype._conn = null;

            /**
             * ReadGroupPostgresOptions args.
             * @member {protos.args.IPostgresReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @instance
             */
            ReadGroupPostgresOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupPostgresOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {protos.opts.IReadGroupPostgresOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupPostgresOptions} ReadGroupPostgresOptions instance
             */
            ReadGroupPostgresOptions.create = function create(properties) {
                return new ReadGroupPostgresOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupPostgresOptions message. Does not implicitly {@link protos.opts.ReadGroupPostgresOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {protos.opts.IReadGroupPostgresOptions} message ReadGroupPostgresOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupPostgresOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.PostgresConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.PostgresReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupPostgresOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupPostgresOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {protos.opts.IReadGroupPostgresOptions} message ReadGroupPostgresOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupPostgresOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupPostgresOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupPostgresOptions} ReadGroupPostgresOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupPostgresOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupPostgresOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.PostgresConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.PostgresReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupPostgresOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupPostgresOptions} ReadGroupPostgresOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupPostgresOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupPostgresOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupPostgresOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.PostgresConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.PostgresReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupPostgresOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupPostgresOptions} ReadGroupPostgresOptions
             */
            ReadGroupPostgresOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupPostgresOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupPostgresOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupPostgresOptions._conn: object expected");
                    message._conn = $root.protos.args.PostgresConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupPostgresOptions.args: object expected");
                    message.args = $root.protos.args.PostgresReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupPostgresOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @static
             * @param {protos.opts.ReadGroupPostgresOptions} message ReadGroupPostgresOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupPostgresOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.PostgresConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.PostgresReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupPostgresOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupPostgresOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupPostgresOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupPostgresOptions;
        })();

        opts.ReadGroupPulsarOptions = (function() {

            /**
             * Properties of a ReadGroupPulsarOptions.
             * @memberof protos.opts
             * @interface IReadGroupPulsarOptions
             * @property {protos.args.IPulsarConn|null} [_conn] ReadGroupPulsarOptions _conn
             * @property {protos.args.IPulsarReadArgs|null} [args] ReadGroupPulsarOptions args
             */

            /**
             * Constructs a new ReadGroupPulsarOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupPulsarOptions.
             * @implements IReadGroupPulsarOptions
             * @constructor
             * @param {protos.opts.IReadGroupPulsarOptions=} [properties] Properties to set
             */
            function ReadGroupPulsarOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupPulsarOptions _conn.
             * @member {protos.args.IPulsarConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @instance
             */
            ReadGroupPulsarOptions.prototype._conn = null;

            /**
             * ReadGroupPulsarOptions args.
             * @member {protos.args.IPulsarReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @instance
             */
            ReadGroupPulsarOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupPulsarOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {protos.opts.IReadGroupPulsarOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupPulsarOptions} ReadGroupPulsarOptions instance
             */
            ReadGroupPulsarOptions.create = function create(properties) {
                return new ReadGroupPulsarOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupPulsarOptions message. Does not implicitly {@link protos.opts.ReadGroupPulsarOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {protos.opts.IReadGroupPulsarOptions} message ReadGroupPulsarOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupPulsarOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.PulsarConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.PulsarReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupPulsarOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupPulsarOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {protos.opts.IReadGroupPulsarOptions} message ReadGroupPulsarOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupPulsarOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupPulsarOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupPulsarOptions} ReadGroupPulsarOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupPulsarOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupPulsarOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.PulsarConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.PulsarReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupPulsarOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupPulsarOptions} ReadGroupPulsarOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupPulsarOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupPulsarOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupPulsarOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.PulsarConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.PulsarReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupPulsarOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupPulsarOptions} ReadGroupPulsarOptions
             */
            ReadGroupPulsarOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupPulsarOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupPulsarOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupPulsarOptions._conn: object expected");
                    message._conn = $root.protos.args.PulsarConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupPulsarOptions.args: object expected");
                    message.args = $root.protos.args.PulsarReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupPulsarOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @static
             * @param {protos.opts.ReadGroupPulsarOptions} message ReadGroupPulsarOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupPulsarOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.PulsarConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.PulsarReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupPulsarOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupPulsarOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupPulsarOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupPulsarOptions;
        })();

        opts.ReadGroupRabbitOptions = (function() {

            /**
             * Properties of a ReadGroupRabbitOptions.
             * @memberof protos.opts
             * @interface IReadGroupRabbitOptions
             * @property {protos.args.IRabbitConn|null} [_conn] ReadGroupRabbitOptions _conn
             * @property {protos.args.IRabbitReadArgs|null} [args] ReadGroupRabbitOptions args
             */

            /**
             * Constructs a new ReadGroupRabbitOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupRabbitOptions.
             * @implements IReadGroupRabbitOptions
             * @constructor
             * @param {protos.opts.IReadGroupRabbitOptions=} [properties] Properties to set
             */
            function ReadGroupRabbitOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupRabbitOptions _conn.
             * @member {protos.args.IRabbitConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @instance
             */
            ReadGroupRabbitOptions.prototype._conn = null;

            /**
             * ReadGroupRabbitOptions args.
             * @member {protos.args.IRabbitReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @instance
             */
            ReadGroupRabbitOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupRabbitOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupRabbitOptions} ReadGroupRabbitOptions instance
             */
            ReadGroupRabbitOptions.create = function create(properties) {
                return new ReadGroupRabbitOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupRabbitOptions message. Does not implicitly {@link protos.opts.ReadGroupRabbitOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitOptions} message ReadGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRabbitOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupRabbitOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupRabbitOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitOptions} message ReadGroupRabbitOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRabbitOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupRabbitOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupRabbitOptions} ReadGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRabbitOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupRabbitOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupRabbitOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupRabbitOptions} ReadGroupRabbitOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRabbitOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupRabbitOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupRabbitOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RabbitConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RabbitReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupRabbitOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupRabbitOptions} ReadGroupRabbitOptions
             */
            ReadGroupRabbitOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupRabbitOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupRabbitOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupRabbitOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupRabbitOptions.args: object expected");
                    message.args = $root.protos.args.RabbitReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupRabbitOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @static
             * @param {protos.opts.ReadGroupRabbitOptions} message ReadGroupRabbitOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupRabbitOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupRabbitOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupRabbitOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupRabbitOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupRabbitOptions;
        })();

        opts.ReadGroupRabbitStreamsOptions = (function() {

            /**
             * Properties of a ReadGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @interface IReadGroupRabbitStreamsOptions
             * @property {protos.args.IRabbitStreamsConn|null} [_conn] ReadGroupRabbitStreamsOptions _conn
             * @property {protos.args.IRabbitStreamsReadArgs|null} [args] ReadGroupRabbitStreamsOptions args
             */

            /**
             * Constructs a new ReadGroupRabbitStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupRabbitStreamsOptions.
             * @implements IReadGroupRabbitStreamsOptions
             * @constructor
             * @param {protos.opts.IReadGroupRabbitStreamsOptions=} [properties] Properties to set
             */
            function ReadGroupRabbitStreamsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupRabbitStreamsOptions _conn.
             * @member {protos.args.IRabbitStreamsConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @instance
             */
            ReadGroupRabbitStreamsOptions.prototype._conn = null;

            /**
             * ReadGroupRabbitStreamsOptions args.
             * @member {protos.args.IRabbitStreamsReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @instance
             */
            ReadGroupRabbitStreamsOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupRabbitStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupRabbitStreamsOptions} ReadGroupRabbitStreamsOptions instance
             */
            ReadGroupRabbitStreamsOptions.create = function create(properties) {
                return new ReadGroupRabbitStreamsOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupRabbitStreamsOptions message. Does not implicitly {@link protos.opts.ReadGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitStreamsOptions} message ReadGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRabbitStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RabbitStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RabbitStreamsReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupRabbitStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupRabbitStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRabbitStreamsOptions} message ReadGroupRabbitStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRabbitStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupRabbitStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupRabbitStreamsOptions} ReadGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRabbitStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupRabbitStreamsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RabbitStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RabbitStreamsReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupRabbitStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupRabbitStreamsOptions} ReadGroupRabbitStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRabbitStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupRabbitStreamsOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupRabbitStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RabbitStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RabbitStreamsReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupRabbitStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupRabbitStreamsOptions} ReadGroupRabbitStreamsOptions
             */
            ReadGroupRabbitStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupRabbitStreamsOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupRabbitStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupRabbitStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RabbitStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupRabbitStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RabbitStreamsReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupRabbitStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @static
             * @param {protos.opts.ReadGroupRabbitStreamsOptions} message ReadGroupRabbitStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupRabbitStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RabbitStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RabbitStreamsReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupRabbitStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupRabbitStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupRabbitStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupRabbitStreamsOptions;
        })();

        opts.ReadGroupRedisPubSubOptions = (function() {

            /**
             * Properties of a ReadGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @interface IReadGroupRedisPubSubOptions
             * @property {protos.args.IRedisPubSubConn|null} [_conn] ReadGroupRedisPubSubOptions _conn
             * @property {protos.args.IRedisPubSubReadArgs|null} [args] ReadGroupRedisPubSubOptions args
             */

            /**
             * Constructs a new ReadGroupRedisPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupRedisPubSubOptions.
             * @implements IReadGroupRedisPubSubOptions
             * @constructor
             * @param {protos.opts.IReadGroupRedisPubSubOptions=} [properties] Properties to set
             */
            function ReadGroupRedisPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupRedisPubSubOptions _conn.
             * @member {protos.args.IRedisPubSubConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @instance
             */
            ReadGroupRedisPubSubOptions.prototype._conn = null;

            /**
             * ReadGroupRedisPubSubOptions args.
             * @member {protos.args.IRedisPubSubReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @instance
             */
            ReadGroupRedisPubSubOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupRedisPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupRedisPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupRedisPubSubOptions} ReadGroupRedisPubSubOptions instance
             */
            ReadGroupRedisPubSubOptions.create = function create(properties) {
                return new ReadGroupRedisPubSubOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupRedisPubSubOptions message. Does not implicitly {@link protos.opts.ReadGroupRedisPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupRedisPubSubOptions} message ReadGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRedisPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisPubSubReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupRedisPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupRedisPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupRedisPubSubOptions} message ReadGroupRedisPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRedisPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupRedisPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupRedisPubSubOptions} ReadGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRedisPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupRedisPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisPubSubReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupRedisPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupRedisPubSubOptions} ReadGroupRedisPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRedisPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupRedisPubSubOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupRedisPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisPubSubReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupRedisPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupRedisPubSubOptions} ReadGroupRedisPubSubOptions
             */
            ReadGroupRedisPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupRedisPubSubOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupRedisPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupRedisPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupRedisPubSubOptions.args: object expected");
                    message.args = $root.protos.args.RedisPubSubReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupRedisPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @static
             * @param {protos.opts.ReadGroupRedisPubSubOptions} message ReadGroupRedisPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupRedisPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisPubSubReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupRedisPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupRedisPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupRedisPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupRedisPubSubOptions;
        })();

        opts.ReadGroupRedisStreamsOptions = (function() {

            /**
             * Properties of a ReadGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @interface IReadGroupRedisStreamsOptions
             * @property {protos.args.IRedisStreamsConn|null} [_conn] ReadGroupRedisStreamsOptions _conn
             * @property {protos.args.IRedisStreamsReadArgs|null} [args] ReadGroupRedisStreamsOptions args
             */

            /**
             * Constructs a new ReadGroupRedisStreamsOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupRedisStreamsOptions.
             * @implements IReadGroupRedisStreamsOptions
             * @constructor
             * @param {protos.opts.IReadGroupRedisStreamsOptions=} [properties] Properties to set
             */
            function ReadGroupRedisStreamsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupRedisStreamsOptions _conn.
             * @member {protos.args.IRedisStreamsConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @instance
             */
            ReadGroupRedisStreamsOptions.prototype._conn = null;

            /**
             * ReadGroupRedisStreamsOptions args.
             * @member {protos.args.IRedisStreamsReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @instance
             */
            ReadGroupRedisStreamsOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupRedisStreamsOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRedisStreamsOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupRedisStreamsOptions} ReadGroupRedisStreamsOptions instance
             */
            ReadGroupRedisStreamsOptions.create = function create(properties) {
                return new ReadGroupRedisStreamsOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupRedisStreamsOptions message. Does not implicitly {@link protos.opts.ReadGroupRedisStreamsOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRedisStreamsOptions} message ReadGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRedisStreamsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.RedisStreamsConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.RedisStreamsReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupRedisStreamsOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupRedisStreamsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.IReadGroupRedisStreamsOptions} message ReadGroupRedisStreamsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupRedisStreamsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupRedisStreamsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupRedisStreamsOptions} ReadGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRedisStreamsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupRedisStreamsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.RedisStreamsConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.RedisStreamsReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupRedisStreamsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupRedisStreamsOptions} ReadGroupRedisStreamsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupRedisStreamsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupRedisStreamsOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupRedisStreamsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.RedisStreamsConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.RedisStreamsReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupRedisStreamsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupRedisStreamsOptions} ReadGroupRedisStreamsOptions
             */
            ReadGroupRedisStreamsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupRedisStreamsOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupRedisStreamsOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupRedisStreamsOptions._conn: object expected");
                    message._conn = $root.protos.args.RedisStreamsConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupRedisStreamsOptions.args: object expected");
                    message.args = $root.protos.args.RedisStreamsReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupRedisStreamsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @static
             * @param {protos.opts.ReadGroupRedisStreamsOptions} message ReadGroupRedisStreamsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupRedisStreamsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.RedisStreamsConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.RedisStreamsReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupRedisStreamsOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupRedisStreamsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupRedisStreamsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupRedisStreamsOptions;
        })();

        opts.ReadGroupAzureEventHubOptions = (function() {

            /**
             * Properties of a ReadGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @interface IReadGroupAzureEventHubOptions
             * @property {protos.args.IAzureEventHubConn|null} [_conn] ReadGroupAzureEventHubOptions _conn
             * @property {protos.args.IAzureEventHubReadArgs|null} [args] ReadGroupAzureEventHubOptions args
             */

            /**
             * Constructs a new ReadGroupAzureEventHubOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupAzureEventHubOptions.
             * @implements IReadGroupAzureEventHubOptions
             * @constructor
             * @param {protos.opts.IReadGroupAzureEventHubOptions=} [properties] Properties to set
             */
            function ReadGroupAzureEventHubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupAzureEventHubOptions _conn.
             * @member {protos.args.IAzureEventHubConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @instance
             */
            ReadGroupAzureEventHubOptions.prototype._conn = null;

            /**
             * ReadGroupAzureEventHubOptions args.
             * @member {protos.args.IAzureEventHubReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @instance
             */
            ReadGroupAzureEventHubOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupAzureEventHubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IReadGroupAzureEventHubOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupAzureEventHubOptions} ReadGroupAzureEventHubOptions instance
             */
            ReadGroupAzureEventHubOptions.create = function create(properties) {
                return new ReadGroupAzureEventHubOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupAzureEventHubOptions message. Does not implicitly {@link protos.opts.ReadGroupAzureEventHubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IReadGroupAzureEventHubOptions} message ReadGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAzureEventHubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureEventHubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureEventHubReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupAzureEventHubOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupAzureEventHubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.IReadGroupAzureEventHubOptions} message ReadGroupAzureEventHubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAzureEventHubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupAzureEventHubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupAzureEventHubOptions} ReadGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAzureEventHubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupAzureEventHubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureEventHubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureEventHubReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupAzureEventHubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupAzureEventHubOptions} ReadGroupAzureEventHubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAzureEventHubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupAzureEventHubOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupAzureEventHubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AzureEventHubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AzureEventHubReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupAzureEventHubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupAzureEventHubOptions} ReadGroupAzureEventHubOptions
             */
            ReadGroupAzureEventHubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupAzureEventHubOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupAzureEventHubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupAzureEventHubOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureEventHubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupAzureEventHubOptions.args: object expected");
                    message.args = $root.protos.args.AzureEventHubReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupAzureEventHubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @static
             * @param {protos.opts.ReadGroupAzureEventHubOptions} message ReadGroupAzureEventHubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupAzureEventHubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureEventHubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureEventHubReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupAzureEventHubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupAzureEventHubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupAzureEventHubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupAzureEventHubOptions;
        })();

        opts.ReadGroupAzureServiceBusOptions = (function() {

            /**
             * Properties of a ReadGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @interface IReadGroupAzureServiceBusOptions
             * @property {protos.args.IAzureServiceBusConn|null} [_conn] ReadGroupAzureServiceBusOptions _conn
             * @property {protos.args.IAzureServiceBusReadArgs|null} [args] ReadGroupAzureServiceBusOptions args
             */

            /**
             * Constructs a new ReadGroupAzureServiceBusOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupAzureServiceBusOptions.
             * @implements IReadGroupAzureServiceBusOptions
             * @constructor
             * @param {protos.opts.IReadGroupAzureServiceBusOptions=} [properties] Properties to set
             */
            function ReadGroupAzureServiceBusOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupAzureServiceBusOptions _conn.
             * @member {protos.args.IAzureServiceBusConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @instance
             */
            ReadGroupAzureServiceBusOptions.prototype._conn = null;

            /**
             * ReadGroupAzureServiceBusOptions args.
             * @member {protos.args.IAzureServiceBusReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @instance
             */
            ReadGroupAzureServiceBusOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupAzureServiceBusOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IReadGroupAzureServiceBusOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupAzureServiceBusOptions} ReadGroupAzureServiceBusOptions instance
             */
            ReadGroupAzureServiceBusOptions.create = function create(properties) {
                return new ReadGroupAzureServiceBusOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupAzureServiceBusOptions message. Does not implicitly {@link protos.opts.ReadGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IReadGroupAzureServiceBusOptions} message ReadGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAzureServiceBusOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AzureServiceBusConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AzureServiceBusReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupAzureServiceBusOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupAzureServiceBusOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.IReadGroupAzureServiceBusOptions} message ReadGroupAzureServiceBusOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAzureServiceBusOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupAzureServiceBusOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupAzureServiceBusOptions} ReadGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAzureServiceBusOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupAzureServiceBusOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AzureServiceBusConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AzureServiceBusReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupAzureServiceBusOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupAzureServiceBusOptions} ReadGroupAzureServiceBusOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAzureServiceBusOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupAzureServiceBusOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupAzureServiceBusOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AzureServiceBusConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AzureServiceBusReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupAzureServiceBusOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupAzureServiceBusOptions} ReadGroupAzureServiceBusOptions
             */
            ReadGroupAzureServiceBusOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupAzureServiceBusOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupAzureServiceBusOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupAzureServiceBusOptions._conn: object expected");
                    message._conn = $root.protos.args.AzureServiceBusConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupAzureServiceBusOptions.args: object expected");
                    message.args = $root.protos.args.AzureServiceBusReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupAzureServiceBusOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @static
             * @param {protos.opts.ReadGroupAzureServiceBusOptions} message ReadGroupAzureServiceBusOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupAzureServiceBusOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AzureServiceBusConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AzureServiceBusReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupAzureServiceBusOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupAzureServiceBusOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupAzureServiceBusOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupAzureServiceBusOptions;
        })();

        opts.ReadGroupMQTTOptions = (function() {

            /**
             * Properties of a ReadGroupMQTTOptions.
             * @memberof protos.opts
             * @interface IReadGroupMQTTOptions
             * @property {protos.args.IMQTTConn|null} [_conn] ReadGroupMQTTOptions _conn
             * @property {protos.args.IMQTTReadArgs|null} [args] ReadGroupMQTTOptions args
             */

            /**
             * Constructs a new ReadGroupMQTTOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupMQTTOptions.
             * @implements IReadGroupMQTTOptions
             * @constructor
             * @param {protos.opts.IReadGroupMQTTOptions=} [properties] Properties to set
             */
            function ReadGroupMQTTOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupMQTTOptions _conn.
             * @member {protos.args.IMQTTConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @instance
             */
            ReadGroupMQTTOptions.prototype._conn = null;

            /**
             * ReadGroupMQTTOptions args.
             * @member {protos.args.IMQTTReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @instance
             */
            ReadGroupMQTTOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupMQTTOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {protos.opts.IReadGroupMQTTOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupMQTTOptions} ReadGroupMQTTOptions instance
             */
            ReadGroupMQTTOptions.create = function create(properties) {
                return new ReadGroupMQTTOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupMQTTOptions message. Does not implicitly {@link protos.opts.ReadGroupMQTTOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {protos.opts.IReadGroupMQTTOptions} message ReadGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupMQTTOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.MQTTConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.MQTTReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupMQTTOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupMQTTOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {protos.opts.IReadGroupMQTTOptions} message ReadGroupMQTTOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupMQTTOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupMQTTOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupMQTTOptions} ReadGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupMQTTOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupMQTTOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.MQTTConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.MQTTReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupMQTTOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupMQTTOptions} ReadGroupMQTTOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupMQTTOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupMQTTOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupMQTTOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.MQTTConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.MQTTReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupMQTTOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupMQTTOptions} ReadGroupMQTTOptions
             */
            ReadGroupMQTTOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupMQTTOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupMQTTOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupMQTTOptions._conn: object expected");
                    message._conn = $root.protos.args.MQTTConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupMQTTOptions.args: object expected");
                    message.args = $root.protos.args.MQTTReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupMQTTOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @static
             * @param {protos.opts.ReadGroupMQTTOptions} message ReadGroupMQTTOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupMQTTOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.MQTTConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.MQTTReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupMQTTOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupMQTTOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupMQTTOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupMQTTOptions;
        })();

        opts.ReadGroupGCPPubSubOptions = (function() {

            /**
             * Properties of a ReadGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @interface IReadGroupGCPPubSubOptions
             * @property {protos.args.IGCPPubSubConn|null} [_conn] ReadGroupGCPPubSubOptions _conn
             * @property {protos.args.IGCPPubSubReadArgs|null} [args] ReadGroupGCPPubSubOptions args
             */

            /**
             * Constructs a new ReadGroupGCPPubSubOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupGCPPubSubOptions.
             * @implements IReadGroupGCPPubSubOptions
             * @constructor
             * @param {protos.opts.IReadGroupGCPPubSubOptions=} [properties] Properties to set
             */
            function ReadGroupGCPPubSubOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupGCPPubSubOptions _conn.
             * @member {protos.args.IGCPPubSubConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @instance
             */
            ReadGroupGCPPubSubOptions.prototype._conn = null;

            /**
             * ReadGroupGCPPubSubOptions args.
             * @member {protos.args.IGCPPubSubReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @instance
             */
            ReadGroupGCPPubSubOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupGCPPubSubOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupGCPPubSubOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupGCPPubSubOptions} ReadGroupGCPPubSubOptions instance
             */
            ReadGroupGCPPubSubOptions.create = function create(properties) {
                return new ReadGroupGCPPubSubOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupGCPPubSubOptions message. Does not implicitly {@link protos.opts.ReadGroupGCPPubSubOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupGCPPubSubOptions} message ReadGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupGCPPubSubOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.GCPPubSubConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.GCPPubSubReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupGCPPubSubOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupGCPPubSubOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.IReadGroupGCPPubSubOptions} message ReadGroupGCPPubSubOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupGCPPubSubOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupGCPPubSubOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupGCPPubSubOptions} ReadGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupGCPPubSubOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupGCPPubSubOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.GCPPubSubConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.GCPPubSubReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupGCPPubSubOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupGCPPubSubOptions} ReadGroupGCPPubSubOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupGCPPubSubOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupGCPPubSubOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupGCPPubSubOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.GCPPubSubConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.GCPPubSubReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupGCPPubSubOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupGCPPubSubOptions} ReadGroupGCPPubSubOptions
             */
            ReadGroupGCPPubSubOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupGCPPubSubOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupGCPPubSubOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupGCPPubSubOptions._conn: object expected");
                    message._conn = $root.protos.args.GCPPubSubConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupGCPPubSubOptions.args: object expected");
                    message.args = $root.protos.args.GCPPubSubReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupGCPPubSubOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @static
             * @param {protos.opts.ReadGroupGCPPubSubOptions} message ReadGroupGCPPubSubOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupGCPPubSubOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.GCPPubSubConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.GCPPubSubReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupGCPPubSubOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupGCPPubSubOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupGCPPubSubOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupGCPPubSubOptions;
        })();

        opts.ReadGroupKubeMQQueueOptions = (function() {

            /**
             * Properties of a ReadGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @interface IReadGroupKubeMQQueueOptions
             * @property {protos.args.IKubeMQQueueConn|null} [_conn] ReadGroupKubeMQQueueOptions _conn
             * @property {protos.args.IKubeMQQueueReadArgs|null} [args] ReadGroupKubeMQQueueOptions args
             */

            /**
             * Constructs a new ReadGroupKubeMQQueueOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupKubeMQQueueOptions.
             * @implements IReadGroupKubeMQQueueOptions
             * @constructor
             * @param {protos.opts.IReadGroupKubeMQQueueOptions=} [properties] Properties to set
             */
            function ReadGroupKubeMQQueueOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupKubeMQQueueOptions _conn.
             * @member {protos.args.IKubeMQQueueConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @instance
             */
            ReadGroupKubeMQQueueOptions.prototype._conn = null;

            /**
             * ReadGroupKubeMQQueueOptions args.
             * @member {protos.args.IKubeMQQueueReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @instance
             */
            ReadGroupKubeMQQueueOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupKubeMQQueueOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IReadGroupKubeMQQueueOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupKubeMQQueueOptions} ReadGroupKubeMQQueueOptions instance
             */
            ReadGroupKubeMQQueueOptions.create = function create(properties) {
                return new ReadGroupKubeMQQueueOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupKubeMQQueueOptions message. Does not implicitly {@link protos.opts.ReadGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IReadGroupKubeMQQueueOptions} message ReadGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupKubeMQQueueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.KubeMQQueueConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.KubeMQQueueReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupKubeMQQueueOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupKubeMQQueueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.IReadGroupKubeMQQueueOptions} message ReadGroupKubeMQQueueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupKubeMQQueueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupKubeMQQueueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupKubeMQQueueOptions} ReadGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupKubeMQQueueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupKubeMQQueueOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.KubeMQQueueConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.KubeMQQueueReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupKubeMQQueueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupKubeMQQueueOptions} ReadGroupKubeMQQueueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupKubeMQQueueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupKubeMQQueueOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupKubeMQQueueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.KubeMQQueueConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.KubeMQQueueReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupKubeMQQueueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupKubeMQQueueOptions} ReadGroupKubeMQQueueOptions
             */
            ReadGroupKubeMQQueueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupKubeMQQueueOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupKubeMQQueueOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupKubeMQQueueOptions._conn: object expected");
                    message._conn = $root.protos.args.KubeMQQueueConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupKubeMQQueueOptions.args: object expected");
                    message.args = $root.protos.args.KubeMQQueueReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupKubeMQQueueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @static
             * @param {protos.opts.ReadGroupKubeMQQueueOptions} message ReadGroupKubeMQQueueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupKubeMQQueueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.KubeMQQueueConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.KubeMQQueueReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupKubeMQQueueOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupKubeMQQueueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupKubeMQQueueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupKubeMQQueueOptions;
        })();

        opts.ReadGroupAWSKinesisOptions = (function() {

            /**
             * Properties of a ReadGroupAWSKinesisOptions.
             * @memberof protos.opts
             * @interface IReadGroupAWSKinesisOptions
             * @property {protos.args.IAWSKinesisConn|null} [_conn] ReadGroupAWSKinesisOptions _conn
             * @property {protos.args.IAWSKinesisReadArgs|null} [args] ReadGroupAWSKinesisOptions args
             */

            /**
             * Constructs a new ReadGroupAWSKinesisOptions.
             * @memberof protos.opts
             * @classdesc Represents a ReadGroupAWSKinesisOptions.
             * @implements IReadGroupAWSKinesisOptions
             * @constructor
             * @param {protos.opts.IReadGroupAWSKinesisOptions=} [properties] Properties to set
             */
            function ReadGroupAWSKinesisOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadGroupAWSKinesisOptions _conn.
             * @member {protos.args.IAWSKinesisConn|null|undefined} _conn
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @instance
             */
            ReadGroupAWSKinesisOptions.prototype._conn = null;

            /**
             * ReadGroupAWSKinesisOptions args.
             * @member {protos.args.IAWSKinesisReadArgs|null|undefined} args
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @instance
             */
            ReadGroupAWSKinesisOptions.prototype.args = null;

            /**
             * Creates a new ReadGroupAWSKinesisOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.IReadGroupAWSKinesisOptions=} [properties] Properties to set
             * @returns {protos.opts.ReadGroupAWSKinesisOptions} ReadGroupAWSKinesisOptions instance
             */
            ReadGroupAWSKinesisOptions.create = function create(properties) {
                return new ReadGroupAWSKinesisOptions(properties);
            };

            /**
             * Encodes the specified ReadGroupAWSKinesisOptions message. Does not implicitly {@link protos.opts.ReadGroupAWSKinesisOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.IReadGroupAWSKinesisOptions} message ReadGroupAWSKinesisOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAWSKinesisOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message._conn != null && Object.hasOwnProperty.call(message, "_conn"))
                    $root.protos.args.AWSKinesisConn.encode(message._conn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                    $root.protos.args.AWSKinesisReadArgs.encode(message.args, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadGroupAWSKinesisOptions message, length delimited. Does not implicitly {@link protos.opts.ReadGroupAWSKinesisOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.IReadGroupAWSKinesisOptions} message ReadGroupAWSKinesisOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadGroupAWSKinesisOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadGroupAWSKinesisOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.ReadGroupAWSKinesisOptions} ReadGroupAWSKinesisOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAWSKinesisOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.ReadGroupAWSKinesisOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message._conn = $root.protos.args.AWSKinesisConn.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.args = $root.protos.args.AWSKinesisReadArgs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadGroupAWSKinesisOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.ReadGroupAWSKinesisOptions} ReadGroupAWSKinesisOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadGroupAWSKinesisOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadGroupAWSKinesisOptions message.
             * @function verify
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadGroupAWSKinesisOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message._conn != null && message.hasOwnProperty("_conn")) {
                    var error = $root.protos.args.AWSKinesisConn.verify(message._conn);
                    if (error)
                        return "_conn." + error;
                }
                if (message.args != null && message.hasOwnProperty("args")) {
                    var error = $root.protos.args.AWSKinesisReadArgs.verify(message.args);
                    if (error)
                        return "args." + error;
                }
                return null;
            };

            /**
             * Creates a ReadGroupAWSKinesisOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.ReadGroupAWSKinesisOptions} ReadGroupAWSKinesisOptions
             */
            ReadGroupAWSKinesisOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.ReadGroupAWSKinesisOptions)
                    return object;
                var message = new $root.protos.opts.ReadGroupAWSKinesisOptions();
                if (object._conn != null) {
                    if (typeof object._conn !== "object")
                        throw TypeError(".protos.opts.ReadGroupAWSKinesisOptions._conn: object expected");
                    message._conn = $root.protos.args.AWSKinesisConn.fromObject(object._conn);
                }
                if (object.args != null) {
                    if (typeof object.args !== "object")
                        throw TypeError(".protos.opts.ReadGroupAWSKinesisOptions.args: object expected");
                    message.args = $root.protos.args.AWSKinesisReadArgs.fromObject(object.args);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadGroupAWSKinesisOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @static
             * @param {protos.opts.ReadGroupAWSKinesisOptions} message ReadGroupAWSKinesisOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadGroupAWSKinesisOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object._conn = null;
                    object.args = null;
                }
                if (message._conn != null && message.hasOwnProperty("_conn"))
                    object._conn = $root.protos.args.AWSKinesisConn.toObject(message._conn, options);
                if (message.args != null && message.hasOwnProperty("args"))
                    object.args = $root.protos.args.AWSKinesisReadArgs.toObject(message.args, options);
                return object;
            };

            /**
             * Converts this ReadGroupAWSKinesisOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.ReadGroupAWSKinesisOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadGroupAWSKinesisOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadGroupAWSKinesisOptions;
        })();

        opts.InferSchemaOptions = (function() {

            /**
             * Properties of an InferSchemaOptions.
             * @memberof protos.opts
             * @interface IInferSchemaOptions
             * @property {protos.opts.InferSchemaOptions.Type|null} [type] InferSchemaOptions type
             * @property {string|null} [schemaId] InferSchemaOptions schemaId
             */

            /**
             * Constructs a new InferSchemaOptions.
             * @memberof protos.opts
             * @classdesc Represents an InferSchemaOptions.
             * @implements IInferSchemaOptions
             * @constructor
             * @param {protos.opts.IInferSchemaOptions=} [properties] Properties to set
             */
            function InferSchemaOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InferSchemaOptions type.
             * @member {protos.opts.InferSchemaOptions.Type} type
             * @memberof protos.opts.InferSchemaOptions
             * @instance
             */
            InferSchemaOptions.prototype.type = 0;

            /**
             * InferSchemaOptions schemaId.
             * @member {string} schemaId
             * @memberof protos.opts.InferSchemaOptions
             * @instance
             */
            InferSchemaOptions.prototype.schemaId = "";

            /**
             * Creates a new InferSchemaOptions instance using the specified properties.
             * @function create
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {protos.opts.IInferSchemaOptions=} [properties] Properties to set
             * @returns {protos.opts.InferSchemaOptions} InferSchemaOptions instance
             */
            InferSchemaOptions.create = function create(properties) {
                return new InferSchemaOptions(properties);
            };

            /**
             * Encodes the specified InferSchemaOptions message. Does not implicitly {@link protos.opts.InferSchemaOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {protos.opts.IInferSchemaOptions} message InferSchemaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InferSchemaOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.schemaId != null && Object.hasOwnProperty.call(message, "schemaId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.schemaId);
                return writer;
            };

            /**
             * Encodes the specified InferSchemaOptions message, length delimited. Does not implicitly {@link protos.opts.InferSchemaOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {protos.opts.IInferSchemaOptions} message InferSchemaOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InferSchemaOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InferSchemaOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.opts.InferSchemaOptions} InferSchemaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InferSchemaOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.opts.InferSchemaOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.schemaId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InferSchemaOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.opts.InferSchemaOptions} InferSchemaOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InferSchemaOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InferSchemaOptions message.
             * @function verify
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InferSchemaOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    if (!$util.isString(message.schemaId))
                        return "schemaId: string expected";
                return null;
            };

            /**
             * Creates an InferSchemaOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.opts.InferSchemaOptions} InferSchemaOptions
             */
            InferSchemaOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.opts.InferSchemaOptions)
                    return object;
                var message = new $root.protos.opts.InferSchemaOptions();
                switch (object.type) {
                case "UNSET":
                case 0:
                    message.type = 0;
                    break;
                case "JSONSCHEMA":
                case 1:
                    message.type = 1;
                    break;
                }
                if (object.schemaId != null)
                    message.schemaId = String(object.schemaId);
                return message;
            };

            /**
             * Creates a plain object from an InferSchemaOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.opts.InferSchemaOptions
             * @static
             * @param {protos.opts.InferSchemaOptions} message InferSchemaOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InferSchemaOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNSET" : 0;
                    object.schemaId = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.protos.opts.InferSchemaOptions.Type[message.type] : message.type;
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    object.schemaId = message.schemaId;
                return object;
            };

            /**
             * Converts this InferSchemaOptions to JSON.
             * @function toJSON
             * @memberof protos.opts.InferSchemaOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InferSchemaOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name protos.opts.InferSchemaOptions.Type
             * @enum {number}
             * @property {number} UNSET=0 UNSET value
             * @property {number} JSONSCHEMA=1 JSONSCHEMA value
             */
            InferSchemaOptions.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSET"] = 0;
                values[valuesById[1] = "JSONSCHEMA"] = 1;
                return values;
            })();

            return InferSchemaOptions;
        })();

        return opts;
    })();

    protos.args = (function() {

        /**
         * Namespace args.
         * @memberof protos
         * @namespace
         */
        var args = {};

        args.ActiveMQConn = (function() {

            /**
             * Properties of an ActiveMQConn.
             * @memberof protos.args
             * @interface IActiveMQConn
             * @property {string|null} [address] ActiveMQConn address
             */

            /**
             * Constructs a new ActiveMQConn.
             * @memberof protos.args
             * @classdesc Represents an ActiveMQConn.
             * @implements IActiveMQConn
             * @constructor
             * @param {protos.args.IActiveMQConn=} [properties] Properties to set
             */
            function ActiveMQConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActiveMQConn address.
             * @member {string} address
             * @memberof protos.args.ActiveMQConn
             * @instance
             */
            ActiveMQConn.prototype.address = "";

            /**
             * Creates a new ActiveMQConn instance using the specified properties.
             * @function create
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {protos.args.IActiveMQConn=} [properties] Properties to set
             * @returns {protos.args.ActiveMQConn} ActiveMQConn instance
             */
            ActiveMQConn.create = function create(properties) {
                return new ActiveMQConn(properties);
            };

            /**
             * Encodes the specified ActiveMQConn message. Does not implicitly {@link protos.args.ActiveMQConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {protos.args.IActiveMQConn} message ActiveMQConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                return writer;
            };

            /**
             * Encodes the specified ActiveMQConn message, length delimited. Does not implicitly {@link protos.args.ActiveMQConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {protos.args.IActiveMQConn} message ActiveMQConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ActiveMQConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.ActiveMQConn} ActiveMQConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.ActiveMQConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ActiveMQConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.ActiveMQConn} ActiveMQConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ActiveMQConn message.
             * @function verify
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActiveMQConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                return null;
            };

            /**
             * Creates an ActiveMQConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.ActiveMQConn} ActiveMQConn
             */
            ActiveMQConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.ActiveMQConn)
                    return object;
                var message = new $root.protos.args.ActiveMQConn();
                if (object.address != null)
                    message.address = String(object.address);
                return message;
            };

            /**
             * Creates a plain object from an ActiveMQConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.ActiveMQConn
             * @static
             * @param {protos.args.ActiveMQConn} message ActiveMQConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ActiveMQConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.address = "";
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                return object;
            };

            /**
             * Converts this ActiveMQConn to JSON.
             * @function toJSON
             * @memberof protos.args.ActiveMQConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ActiveMQConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ActiveMQConn;
        })();

        args.ActiveMQReadArgs = (function() {

            /**
             * Properties of an ActiveMQReadArgs.
             * @memberof protos.args
             * @interface IActiveMQReadArgs
             * @property {string|null} [topic] ActiveMQReadArgs topic
             * @property {string|null} [queue] ActiveMQReadArgs queue
             */

            /**
             * Constructs a new ActiveMQReadArgs.
             * @memberof protos.args
             * @classdesc Represents an ActiveMQReadArgs.
             * @implements IActiveMQReadArgs
             * @constructor
             * @param {protos.args.IActiveMQReadArgs=} [properties] Properties to set
             */
            function ActiveMQReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActiveMQReadArgs topic.
             * @member {string} topic
             * @memberof protos.args.ActiveMQReadArgs
             * @instance
             */
            ActiveMQReadArgs.prototype.topic = "";

            /**
             * ActiveMQReadArgs queue.
             * @member {string} queue
             * @memberof protos.args.ActiveMQReadArgs
             * @instance
             */
            ActiveMQReadArgs.prototype.queue = "";

            /**
             * Creates a new ActiveMQReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {protos.args.IActiveMQReadArgs=} [properties] Properties to set
             * @returns {protos.args.ActiveMQReadArgs} ActiveMQReadArgs instance
             */
            ActiveMQReadArgs.create = function create(properties) {
                return new ActiveMQReadArgs(properties);
            };

            /**
             * Encodes the specified ActiveMQReadArgs message. Does not implicitly {@link protos.args.ActiveMQReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {protos.args.IActiveMQReadArgs} message ActiveMQReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.queue != null && Object.hasOwnProperty.call(message, "queue"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.queue);
                return writer;
            };

            /**
             * Encodes the specified ActiveMQReadArgs message, length delimited. Does not implicitly {@link protos.args.ActiveMQReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {protos.args.IActiveMQReadArgs} message ActiveMQReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ActiveMQReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.ActiveMQReadArgs} ActiveMQReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.ActiveMQReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.queue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ActiveMQReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.ActiveMQReadArgs} ActiveMQReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ActiveMQReadArgs message.
             * @function verify
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActiveMQReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.queue != null && message.hasOwnProperty("queue"))
                    if (!$util.isString(message.queue))
                        return "queue: string expected";
                return null;
            };

            /**
             * Creates an ActiveMQReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.ActiveMQReadArgs} ActiveMQReadArgs
             */
            ActiveMQReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.ActiveMQReadArgs)
                    return object;
                var message = new $root.protos.args.ActiveMQReadArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.queue != null)
                    message.queue = String(object.queue);
                return message;
            };

            /**
             * Creates a plain object from an ActiveMQReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.ActiveMQReadArgs
             * @static
             * @param {protos.args.ActiveMQReadArgs} message ActiveMQReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ActiveMQReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.queue = "";
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.queue != null && message.hasOwnProperty("queue"))
                    object.queue = message.queue;
                return object;
            };

            /**
             * Converts this ActiveMQReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.ActiveMQReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ActiveMQReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ActiveMQReadArgs;
        })();

        args.ActiveMQWriteArgs = (function() {

            /**
             * Properties of an ActiveMQWriteArgs.
             * @memberof protos.args
             * @interface IActiveMQWriteArgs
             * @property {string|null} [topic] ActiveMQWriteArgs topic
             * @property {string|null} [queue] ActiveMQWriteArgs queue
             */

            /**
             * Constructs a new ActiveMQWriteArgs.
             * @memberof protos.args
             * @classdesc Represents an ActiveMQWriteArgs.
             * @implements IActiveMQWriteArgs
             * @constructor
             * @param {protos.args.IActiveMQWriteArgs=} [properties] Properties to set
             */
            function ActiveMQWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActiveMQWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.ActiveMQWriteArgs
             * @instance
             */
            ActiveMQWriteArgs.prototype.topic = "";

            /**
             * ActiveMQWriteArgs queue.
             * @member {string} queue
             * @memberof protos.args.ActiveMQWriteArgs
             * @instance
             */
            ActiveMQWriteArgs.prototype.queue = "";

            /**
             * Creates a new ActiveMQWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {protos.args.IActiveMQWriteArgs=} [properties] Properties to set
             * @returns {protos.args.ActiveMQWriteArgs} ActiveMQWriteArgs instance
             */
            ActiveMQWriteArgs.create = function create(properties) {
                return new ActiveMQWriteArgs(properties);
            };

            /**
             * Encodes the specified ActiveMQWriteArgs message. Does not implicitly {@link protos.args.ActiveMQWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {protos.args.IActiveMQWriteArgs} message ActiveMQWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.queue != null && Object.hasOwnProperty.call(message, "queue"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.queue);
                return writer;
            };

            /**
             * Encodes the specified ActiveMQWriteArgs message, length delimited. Does not implicitly {@link protos.args.ActiveMQWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {protos.args.IActiveMQWriteArgs} message ActiveMQWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ActiveMQWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.ActiveMQWriteArgs} ActiveMQWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.ActiveMQWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.queue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ActiveMQWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.ActiveMQWriteArgs} ActiveMQWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ActiveMQWriteArgs message.
             * @function verify
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActiveMQWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.queue != null && message.hasOwnProperty("queue"))
                    if (!$util.isString(message.queue))
                        return "queue: string expected";
                return null;
            };

            /**
             * Creates an ActiveMQWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.ActiveMQWriteArgs} ActiveMQWriteArgs
             */
            ActiveMQWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.ActiveMQWriteArgs)
                    return object;
                var message = new $root.protos.args.ActiveMQWriteArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.queue != null)
                    message.queue = String(object.queue);
                return message;
            };

            /**
             * Creates a plain object from an ActiveMQWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.ActiveMQWriteArgs
             * @static
             * @param {protos.args.ActiveMQWriteArgs} message ActiveMQWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ActiveMQWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.queue = "";
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.queue != null && message.hasOwnProperty("queue"))
                    object.queue = message.queue;
                return object;
            };

            /**
             * Converts this ActiveMQWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.ActiveMQWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ActiveMQWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ActiveMQWriteArgs;
        })();

        args.AWSKinesisConn = (function() {

            /**
             * Properties of a AWSKinesisConn.
             * @memberof protos.args
             * @interface IAWSKinesisConn
             * @property {string|null} [awsRegion] AWSKinesisConn awsRegion
             * @property {string|null} [awsAccessKeyId] AWSKinesisConn awsAccessKeyId
             * @property {string|null} [awsSecretAccessKey] AWSKinesisConn awsSecretAccessKey
             * @property {string|null} [awsProfile] AWSKinesisConn awsProfile
             */

            /**
             * Constructs a new AWSKinesisConn.
             * @memberof protos.args
             * @classdesc Represents a AWSKinesisConn.
             * @implements IAWSKinesisConn
             * @constructor
             * @param {protos.args.IAWSKinesisConn=} [properties] Properties to set
             */
            function AWSKinesisConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSKinesisConn awsRegion.
             * @member {string} awsRegion
             * @memberof protos.args.AWSKinesisConn
             * @instance
             */
            AWSKinesisConn.prototype.awsRegion = "";

            /**
             * AWSKinesisConn awsAccessKeyId.
             * @member {string} awsAccessKeyId
             * @memberof protos.args.AWSKinesisConn
             * @instance
             */
            AWSKinesisConn.prototype.awsAccessKeyId = "";

            /**
             * AWSKinesisConn awsSecretAccessKey.
             * @member {string} awsSecretAccessKey
             * @memberof protos.args.AWSKinesisConn
             * @instance
             */
            AWSKinesisConn.prototype.awsSecretAccessKey = "";

            /**
             * AWSKinesisConn awsProfile.
             * @member {string} awsProfile
             * @memberof protos.args.AWSKinesisConn
             * @instance
             */
            AWSKinesisConn.prototype.awsProfile = "";

            /**
             * Creates a new AWSKinesisConn instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSKinesisConn
             * @static
             * @param {protos.args.IAWSKinesisConn=} [properties] Properties to set
             * @returns {protos.args.AWSKinesisConn} AWSKinesisConn instance
             */
            AWSKinesisConn.create = function create(properties) {
                return new AWSKinesisConn(properties);
            };

            /**
             * Encodes the specified AWSKinesisConn message. Does not implicitly {@link protos.args.AWSKinesisConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSKinesisConn
             * @static
             * @param {protos.args.IAWSKinesisConn} message AWSKinesisConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSKinesisConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.awsRegion != null && Object.hasOwnProperty.call(message, "awsRegion"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.awsRegion);
                if (message.awsAccessKeyId != null && Object.hasOwnProperty.call(message, "awsAccessKeyId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.awsAccessKeyId);
                if (message.awsSecretAccessKey != null && Object.hasOwnProperty.call(message, "awsSecretAccessKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.awsSecretAccessKey);
                if (message.awsProfile != null && Object.hasOwnProperty.call(message, "awsProfile"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.awsProfile);
                return writer;
            };

            /**
             * Encodes the specified AWSKinesisConn message, length delimited. Does not implicitly {@link protos.args.AWSKinesisConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSKinesisConn
             * @static
             * @param {protos.args.IAWSKinesisConn} message AWSKinesisConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSKinesisConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSKinesisConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSKinesisConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSKinesisConn} AWSKinesisConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSKinesisConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSKinesisConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.awsRegion = reader.string();
                        break;
                    case 2:
                        message.awsAccessKeyId = reader.string();
                        break;
                    case 3:
                        message.awsSecretAccessKey = reader.string();
                        break;
                    case 4:
                        message.awsProfile = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSKinesisConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSKinesisConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSKinesisConn} AWSKinesisConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSKinesisConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSKinesisConn message.
             * @function verify
             * @memberof protos.args.AWSKinesisConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSKinesisConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.awsRegion != null && message.hasOwnProperty("awsRegion"))
                    if (!$util.isString(message.awsRegion))
                        return "awsRegion: string expected";
                if (message.awsAccessKeyId != null && message.hasOwnProperty("awsAccessKeyId"))
                    if (!$util.isString(message.awsAccessKeyId))
                        return "awsAccessKeyId: string expected";
                if (message.awsSecretAccessKey != null && message.hasOwnProperty("awsSecretAccessKey"))
                    if (!$util.isString(message.awsSecretAccessKey))
                        return "awsSecretAccessKey: string expected";
                if (message.awsProfile != null && message.hasOwnProperty("awsProfile"))
                    if (!$util.isString(message.awsProfile))
                        return "awsProfile: string expected";
                return null;
            };

            /**
             * Creates a AWSKinesisConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSKinesisConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSKinesisConn} AWSKinesisConn
             */
            AWSKinesisConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSKinesisConn)
                    return object;
                var message = new $root.protos.args.AWSKinesisConn();
                if (object.awsRegion != null)
                    message.awsRegion = String(object.awsRegion);
                if (object.awsAccessKeyId != null)
                    message.awsAccessKeyId = String(object.awsAccessKeyId);
                if (object.awsSecretAccessKey != null)
                    message.awsSecretAccessKey = String(object.awsSecretAccessKey);
                if (object.awsProfile != null)
                    message.awsProfile = String(object.awsProfile);
                return message;
            };

            /**
             * Creates a plain object from a AWSKinesisConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSKinesisConn
             * @static
             * @param {protos.args.AWSKinesisConn} message AWSKinesisConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSKinesisConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.awsRegion = "";
                    object.awsAccessKeyId = "";
                    object.awsSecretAccessKey = "";
                    object.awsProfile = "";
                }
                if (message.awsRegion != null && message.hasOwnProperty("awsRegion"))
                    object.awsRegion = message.awsRegion;
                if (message.awsAccessKeyId != null && message.hasOwnProperty("awsAccessKeyId"))
                    object.awsAccessKeyId = message.awsAccessKeyId;
                if (message.awsSecretAccessKey != null && message.hasOwnProperty("awsSecretAccessKey"))
                    object.awsSecretAccessKey = message.awsSecretAccessKey;
                if (message.awsProfile != null && message.hasOwnProperty("awsProfile"))
                    object.awsProfile = message.awsProfile;
                return object;
            };

            /**
             * Converts this AWSKinesisConn to JSON.
             * @function toJSON
             * @memberof protos.args.AWSKinesisConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSKinesisConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSKinesisConn;
        })();

        args.AWSKinesisReadArgs = (function() {

            /**
             * Properties of a AWSKinesisReadArgs.
             * @memberof protos.args
             * @interface IAWSKinesisReadArgs
             * @property {string|null} [stream] AWSKinesisReadArgs stream
             * @property {string|null} [shard] AWSKinesisReadArgs shard
             * @property {number|Long|null} [maxRecords] AWSKinesisReadArgs maxRecords
             * @property {number|Long|null} [readFromTimestamp] AWSKinesisReadArgs readFromTimestamp
             * @property {string|null} [readSequenceNumber] AWSKinesisReadArgs readSequenceNumber
             * @property {string|null} [readAfterSequenceNumber] AWSKinesisReadArgs readAfterSequenceNumber
             * @property {boolean|null} [readTrimHorizon] AWSKinesisReadArgs readTrimHorizon
             * @property {boolean|null} [readLatest] AWSKinesisReadArgs readLatest
             */

            /**
             * Constructs a new AWSKinesisReadArgs.
             * @memberof protos.args
             * @classdesc Represents a AWSKinesisReadArgs.
             * @implements IAWSKinesisReadArgs
             * @constructor
             * @param {protos.args.IAWSKinesisReadArgs=} [properties] Properties to set
             */
            function AWSKinesisReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSKinesisReadArgs stream.
             * @member {string} stream
             * @memberof protos.args.AWSKinesisReadArgs
             * @instance
             */
            AWSKinesisReadArgs.prototype.stream = "";

            /**
             * AWSKinesisReadArgs shard.
             * @member {string} shard
             * @memberof protos.args.AWSKinesisReadArgs
             * @instance
             */
            AWSKinesisReadArgs.prototype.shard = "";

            /**
             * AWSKinesisReadArgs maxRecords.
             * @member {number|Long} maxRecords
             * @memberof protos.args.AWSKinesisReadArgs
             * @instance
             */
            AWSKinesisReadArgs.prototype.maxRecords = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AWSKinesisReadArgs readFromTimestamp.
             * @member {number|Long} readFromTimestamp
             * @memberof protos.args.AWSKinesisReadArgs
             * @instance
             */
            AWSKinesisReadArgs.prototype.readFromTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AWSKinesisReadArgs readSequenceNumber.
             * @member {string} readSequenceNumber
             * @memberof protos.args.AWSKinesisReadArgs
             * @instance
             */
            AWSKinesisReadArgs.prototype.readSequenceNumber = "";

            /**
             * AWSKinesisReadArgs readAfterSequenceNumber.
             * @member {string} readAfterSequenceNumber
             * @memberof protos.args.AWSKinesisReadArgs
             * @instance
             */
            AWSKinesisReadArgs.prototype.readAfterSequenceNumber = "";

            /**
             * AWSKinesisReadArgs readTrimHorizon.
             * @member {boolean} readTrimHorizon
             * @memberof protos.args.AWSKinesisReadArgs
             * @instance
             */
            AWSKinesisReadArgs.prototype.readTrimHorizon = false;

            /**
             * AWSKinesisReadArgs readLatest.
             * @member {boolean} readLatest
             * @memberof protos.args.AWSKinesisReadArgs
             * @instance
             */
            AWSKinesisReadArgs.prototype.readLatest = false;

            /**
             * Creates a new AWSKinesisReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSKinesisReadArgs
             * @static
             * @param {protos.args.IAWSKinesisReadArgs=} [properties] Properties to set
             * @returns {protos.args.AWSKinesisReadArgs} AWSKinesisReadArgs instance
             */
            AWSKinesisReadArgs.create = function create(properties) {
                return new AWSKinesisReadArgs(properties);
            };

            /**
             * Encodes the specified AWSKinesisReadArgs message. Does not implicitly {@link protos.args.AWSKinesisReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSKinesisReadArgs
             * @static
             * @param {protos.args.IAWSKinesisReadArgs} message AWSKinesisReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSKinesisReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stream);
                if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.shard);
                if (message.maxRecords != null && Object.hasOwnProperty.call(message, "maxRecords"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.maxRecords);
                if (message.readFromTimestamp != null && Object.hasOwnProperty.call(message, "readFromTimestamp"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.readFromTimestamp);
                if (message.readSequenceNumber != null && Object.hasOwnProperty.call(message, "readSequenceNumber"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.readSequenceNumber);
                if (message.readAfterSequenceNumber != null && Object.hasOwnProperty.call(message, "readAfterSequenceNumber"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.readAfterSequenceNumber);
                if (message.readTrimHorizon != null && Object.hasOwnProperty.call(message, "readTrimHorizon"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.readTrimHorizon);
                if (message.readLatest != null && Object.hasOwnProperty.call(message, "readLatest"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.readLatest);
                return writer;
            };

            /**
             * Encodes the specified AWSKinesisReadArgs message, length delimited. Does not implicitly {@link protos.args.AWSKinesisReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSKinesisReadArgs
             * @static
             * @param {protos.args.IAWSKinesisReadArgs} message AWSKinesisReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSKinesisReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSKinesisReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSKinesisReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSKinesisReadArgs} AWSKinesisReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSKinesisReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSKinesisReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stream = reader.string();
                        break;
                    case 2:
                        message.shard = reader.string();
                        break;
                    case 3:
                        message.maxRecords = reader.int64();
                        break;
                    case 4:
                        message.readFromTimestamp = reader.int64();
                        break;
                    case 5:
                        message.readSequenceNumber = reader.string();
                        break;
                    case 6:
                        message.readAfterSequenceNumber = reader.string();
                        break;
                    case 7:
                        message.readTrimHorizon = reader.bool();
                        break;
                    case 8:
                        message.readLatest = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSKinesisReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSKinesisReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSKinesisReadArgs} AWSKinesisReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSKinesisReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSKinesisReadArgs message.
             * @function verify
             * @memberof protos.args.AWSKinesisReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSKinesisReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isString(message.stream))
                        return "stream: string expected";
                if (message.shard != null && message.hasOwnProperty("shard"))
                    if (!$util.isString(message.shard))
                        return "shard: string expected";
                if (message.maxRecords != null && message.hasOwnProperty("maxRecords"))
                    if (!$util.isInteger(message.maxRecords) && !(message.maxRecords && $util.isInteger(message.maxRecords.low) && $util.isInteger(message.maxRecords.high)))
                        return "maxRecords: integer|Long expected";
                if (message.readFromTimestamp != null && message.hasOwnProperty("readFromTimestamp"))
                    if (!$util.isInteger(message.readFromTimestamp) && !(message.readFromTimestamp && $util.isInteger(message.readFromTimestamp.low) && $util.isInteger(message.readFromTimestamp.high)))
                        return "readFromTimestamp: integer|Long expected";
                if (message.readSequenceNumber != null && message.hasOwnProperty("readSequenceNumber"))
                    if (!$util.isString(message.readSequenceNumber))
                        return "readSequenceNumber: string expected";
                if (message.readAfterSequenceNumber != null && message.hasOwnProperty("readAfterSequenceNumber"))
                    if (!$util.isString(message.readAfterSequenceNumber))
                        return "readAfterSequenceNumber: string expected";
                if (message.readTrimHorizon != null && message.hasOwnProperty("readTrimHorizon"))
                    if (typeof message.readTrimHorizon !== "boolean")
                        return "readTrimHorizon: boolean expected";
                if (message.readLatest != null && message.hasOwnProperty("readLatest"))
                    if (typeof message.readLatest !== "boolean")
                        return "readLatest: boolean expected";
                return null;
            };

            /**
             * Creates a AWSKinesisReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSKinesisReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSKinesisReadArgs} AWSKinesisReadArgs
             */
            AWSKinesisReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSKinesisReadArgs)
                    return object;
                var message = new $root.protos.args.AWSKinesisReadArgs();
                if (object.stream != null)
                    message.stream = String(object.stream);
                if (object.shard != null)
                    message.shard = String(object.shard);
                if (object.maxRecords != null)
                    if ($util.Long)
                        (message.maxRecords = $util.Long.fromValue(object.maxRecords)).unsigned = false;
                    else if (typeof object.maxRecords === "string")
                        message.maxRecords = parseInt(object.maxRecords, 10);
                    else if (typeof object.maxRecords === "number")
                        message.maxRecords = object.maxRecords;
                    else if (typeof object.maxRecords === "object")
                        message.maxRecords = new $util.LongBits(object.maxRecords.low >>> 0, object.maxRecords.high >>> 0).toNumber();
                if (object.readFromTimestamp != null)
                    if ($util.Long)
                        (message.readFromTimestamp = $util.Long.fromValue(object.readFromTimestamp)).unsigned = false;
                    else if (typeof object.readFromTimestamp === "string")
                        message.readFromTimestamp = parseInt(object.readFromTimestamp, 10);
                    else if (typeof object.readFromTimestamp === "number")
                        message.readFromTimestamp = object.readFromTimestamp;
                    else if (typeof object.readFromTimestamp === "object")
                        message.readFromTimestamp = new $util.LongBits(object.readFromTimestamp.low >>> 0, object.readFromTimestamp.high >>> 0).toNumber();
                if (object.readSequenceNumber != null)
                    message.readSequenceNumber = String(object.readSequenceNumber);
                if (object.readAfterSequenceNumber != null)
                    message.readAfterSequenceNumber = String(object.readAfterSequenceNumber);
                if (object.readTrimHorizon != null)
                    message.readTrimHorizon = Boolean(object.readTrimHorizon);
                if (object.readLatest != null)
                    message.readLatest = Boolean(object.readLatest);
                return message;
            };

            /**
             * Creates a plain object from a AWSKinesisReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSKinesisReadArgs
             * @static
             * @param {protos.args.AWSKinesisReadArgs} message AWSKinesisReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSKinesisReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.stream = "";
                    object.shard = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.maxRecords = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.maxRecords = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.readFromTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.readFromTimestamp = options.longs === String ? "0" : 0;
                    object.readSequenceNumber = "";
                    object.readAfterSequenceNumber = "";
                    object.readTrimHorizon = false;
                    object.readLatest = false;
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                if (message.shard != null && message.hasOwnProperty("shard"))
                    object.shard = message.shard;
                if (message.maxRecords != null && message.hasOwnProperty("maxRecords"))
                    if (typeof message.maxRecords === "number")
                        object.maxRecords = options.longs === String ? String(message.maxRecords) : message.maxRecords;
                    else
                        object.maxRecords = options.longs === String ? $util.Long.prototype.toString.call(message.maxRecords) : options.longs === Number ? new $util.LongBits(message.maxRecords.low >>> 0, message.maxRecords.high >>> 0).toNumber() : message.maxRecords;
                if (message.readFromTimestamp != null && message.hasOwnProperty("readFromTimestamp"))
                    if (typeof message.readFromTimestamp === "number")
                        object.readFromTimestamp = options.longs === String ? String(message.readFromTimestamp) : message.readFromTimestamp;
                    else
                        object.readFromTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.readFromTimestamp) : options.longs === Number ? new $util.LongBits(message.readFromTimestamp.low >>> 0, message.readFromTimestamp.high >>> 0).toNumber() : message.readFromTimestamp;
                if (message.readSequenceNumber != null && message.hasOwnProperty("readSequenceNumber"))
                    object.readSequenceNumber = message.readSequenceNumber;
                if (message.readAfterSequenceNumber != null && message.hasOwnProperty("readAfterSequenceNumber"))
                    object.readAfterSequenceNumber = message.readAfterSequenceNumber;
                if (message.readTrimHorizon != null && message.hasOwnProperty("readTrimHorizon"))
                    object.readTrimHorizon = message.readTrimHorizon;
                if (message.readLatest != null && message.hasOwnProperty("readLatest"))
                    object.readLatest = message.readLatest;
                return object;
            };

            /**
             * Converts this AWSKinesisReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AWSKinesisReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSKinesisReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSKinesisReadArgs;
        })();

        args.AWSKinesisWriteArgs = (function() {

            /**
             * Properties of a AWSKinesisWriteArgs.
             * @memberof protos.args
             * @interface IAWSKinesisWriteArgs
             * @property {string|null} [stream] AWSKinesisWriteArgs stream
             * @property {string|null} [partitionKey] AWSKinesisWriteArgs partitionKey
             * @property {string|null} [sequenceNumber] AWSKinesisWriteArgs sequenceNumber
             */

            /**
             * Constructs a new AWSKinesisWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a AWSKinesisWriteArgs.
             * @implements IAWSKinesisWriteArgs
             * @constructor
             * @param {protos.args.IAWSKinesisWriteArgs=} [properties] Properties to set
             */
            function AWSKinesisWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSKinesisWriteArgs stream.
             * @member {string} stream
             * @memberof protos.args.AWSKinesisWriteArgs
             * @instance
             */
            AWSKinesisWriteArgs.prototype.stream = "";

            /**
             * AWSKinesisWriteArgs partitionKey.
             * @member {string} partitionKey
             * @memberof protos.args.AWSKinesisWriteArgs
             * @instance
             */
            AWSKinesisWriteArgs.prototype.partitionKey = "";

            /**
             * AWSKinesisWriteArgs sequenceNumber.
             * @member {string} sequenceNumber
             * @memberof protos.args.AWSKinesisWriteArgs
             * @instance
             */
            AWSKinesisWriteArgs.prototype.sequenceNumber = "";

            /**
             * Creates a new AWSKinesisWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSKinesisWriteArgs
             * @static
             * @param {protos.args.IAWSKinesisWriteArgs=} [properties] Properties to set
             * @returns {protos.args.AWSKinesisWriteArgs} AWSKinesisWriteArgs instance
             */
            AWSKinesisWriteArgs.create = function create(properties) {
                return new AWSKinesisWriteArgs(properties);
            };

            /**
             * Encodes the specified AWSKinesisWriteArgs message. Does not implicitly {@link protos.args.AWSKinesisWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSKinesisWriteArgs
             * @static
             * @param {protos.args.IAWSKinesisWriteArgs} message AWSKinesisWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSKinesisWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stream);
                if (message.partitionKey != null && Object.hasOwnProperty.call(message, "partitionKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.partitionKey);
                if (message.sequenceNumber != null && Object.hasOwnProperty.call(message, "sequenceNumber"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.sequenceNumber);
                return writer;
            };

            /**
             * Encodes the specified AWSKinesisWriteArgs message, length delimited. Does not implicitly {@link protos.args.AWSKinesisWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSKinesisWriteArgs
             * @static
             * @param {protos.args.IAWSKinesisWriteArgs} message AWSKinesisWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSKinesisWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSKinesisWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSKinesisWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSKinesisWriteArgs} AWSKinesisWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSKinesisWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSKinesisWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stream = reader.string();
                        break;
                    case 2:
                        message.partitionKey = reader.string();
                        break;
                    case 3:
                        message.sequenceNumber = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSKinesisWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSKinesisWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSKinesisWriteArgs} AWSKinesisWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSKinesisWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSKinesisWriteArgs message.
             * @function verify
             * @memberof protos.args.AWSKinesisWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSKinesisWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isString(message.stream))
                        return "stream: string expected";
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    if (!$util.isString(message.partitionKey))
                        return "partitionKey: string expected";
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    if (!$util.isString(message.sequenceNumber))
                        return "sequenceNumber: string expected";
                return null;
            };

            /**
             * Creates a AWSKinesisWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSKinesisWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSKinesisWriteArgs} AWSKinesisWriteArgs
             */
            AWSKinesisWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSKinesisWriteArgs)
                    return object;
                var message = new $root.protos.args.AWSKinesisWriteArgs();
                if (object.stream != null)
                    message.stream = String(object.stream);
                if (object.partitionKey != null)
                    message.partitionKey = String(object.partitionKey);
                if (object.sequenceNumber != null)
                    message.sequenceNumber = String(object.sequenceNumber);
                return message;
            };

            /**
             * Creates a plain object from a AWSKinesisWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSKinesisWriteArgs
             * @static
             * @param {protos.args.AWSKinesisWriteArgs} message AWSKinesisWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSKinesisWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.stream = "";
                    object.partitionKey = "";
                    object.sequenceNumber = "";
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    object.partitionKey = message.partitionKey;
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    object.sequenceNumber = message.sequenceNumber;
                return object;
            };

            /**
             * Converts this AWSKinesisWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AWSKinesisWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSKinesisWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSKinesisWriteArgs;
        })();

        args.AWSSNSConn = (function() {

            /**
             * Properties of a AWSSNSConn.
             * @memberof protos.args
             * @interface IAWSSNSConn
             * @property {string|null} [awsRegion] AWSSNSConn awsRegion
             * @property {string|null} [awsAccessKeyId] AWSSNSConn awsAccessKeyId
             * @property {string|null} [awsSecretAccessKey] AWSSNSConn awsSecretAccessKey
             * @property {string|null} [awsProfile] AWSSNSConn awsProfile
             */

            /**
             * Constructs a new AWSSNSConn.
             * @memberof protos.args
             * @classdesc Represents a AWSSNSConn.
             * @implements IAWSSNSConn
             * @constructor
             * @param {protos.args.IAWSSNSConn=} [properties] Properties to set
             */
            function AWSSNSConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSNSConn awsRegion.
             * @member {string} awsRegion
             * @memberof protos.args.AWSSNSConn
             * @instance
             */
            AWSSNSConn.prototype.awsRegion = "";

            /**
             * AWSSNSConn awsAccessKeyId.
             * @member {string} awsAccessKeyId
             * @memberof protos.args.AWSSNSConn
             * @instance
             */
            AWSSNSConn.prototype.awsAccessKeyId = "";

            /**
             * AWSSNSConn awsSecretAccessKey.
             * @member {string} awsSecretAccessKey
             * @memberof protos.args.AWSSNSConn
             * @instance
             */
            AWSSNSConn.prototype.awsSecretAccessKey = "";

            /**
             * AWSSNSConn awsProfile.
             * @member {string} awsProfile
             * @memberof protos.args.AWSSNSConn
             * @instance
             */
            AWSSNSConn.prototype.awsProfile = "";

            /**
             * Creates a new AWSSNSConn instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {protos.args.IAWSSNSConn=} [properties] Properties to set
             * @returns {protos.args.AWSSNSConn} AWSSNSConn instance
             */
            AWSSNSConn.create = function create(properties) {
                return new AWSSNSConn(properties);
            };

            /**
             * Encodes the specified AWSSNSConn message. Does not implicitly {@link protos.args.AWSSNSConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {protos.args.IAWSSNSConn} message AWSSNSConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSNSConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.awsRegion != null && Object.hasOwnProperty.call(message, "awsRegion"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.awsRegion);
                if (message.awsAccessKeyId != null && Object.hasOwnProperty.call(message, "awsAccessKeyId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.awsAccessKeyId);
                if (message.awsSecretAccessKey != null && Object.hasOwnProperty.call(message, "awsSecretAccessKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.awsSecretAccessKey);
                if (message.awsProfile != null && Object.hasOwnProperty.call(message, "awsProfile"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.awsProfile);
                return writer;
            };

            /**
             * Encodes the specified AWSSNSConn message, length delimited. Does not implicitly {@link protos.args.AWSSNSConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {protos.args.IAWSSNSConn} message AWSSNSConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSNSConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSNSConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSNSConn} AWSSNSConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSNSConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSNSConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.awsRegion = reader.string();
                        break;
                    case 2:
                        message.awsAccessKeyId = reader.string();
                        break;
                    case 3:
                        message.awsSecretAccessKey = reader.string();
                        break;
                    case 4:
                        message.awsProfile = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSNSConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSNSConn} AWSSNSConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSNSConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSNSConn message.
             * @function verify
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSNSConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.awsRegion != null && message.hasOwnProperty("awsRegion"))
                    if (!$util.isString(message.awsRegion))
                        return "awsRegion: string expected";
                if (message.awsAccessKeyId != null && message.hasOwnProperty("awsAccessKeyId"))
                    if (!$util.isString(message.awsAccessKeyId))
                        return "awsAccessKeyId: string expected";
                if (message.awsSecretAccessKey != null && message.hasOwnProperty("awsSecretAccessKey"))
                    if (!$util.isString(message.awsSecretAccessKey))
                        return "awsSecretAccessKey: string expected";
                if (message.awsProfile != null && message.hasOwnProperty("awsProfile"))
                    if (!$util.isString(message.awsProfile))
                        return "awsProfile: string expected";
                return null;
            };

            /**
             * Creates a AWSSNSConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSNSConn} AWSSNSConn
             */
            AWSSNSConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSNSConn)
                    return object;
                var message = new $root.protos.args.AWSSNSConn();
                if (object.awsRegion != null)
                    message.awsRegion = String(object.awsRegion);
                if (object.awsAccessKeyId != null)
                    message.awsAccessKeyId = String(object.awsAccessKeyId);
                if (object.awsSecretAccessKey != null)
                    message.awsSecretAccessKey = String(object.awsSecretAccessKey);
                if (object.awsProfile != null)
                    message.awsProfile = String(object.awsProfile);
                return message;
            };

            /**
             * Creates a plain object from a AWSSNSConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSNSConn
             * @static
             * @param {protos.args.AWSSNSConn} message AWSSNSConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSNSConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.awsRegion = "";
                    object.awsAccessKeyId = "";
                    object.awsSecretAccessKey = "";
                    object.awsProfile = "";
                }
                if (message.awsRegion != null && message.hasOwnProperty("awsRegion"))
                    object.awsRegion = message.awsRegion;
                if (message.awsAccessKeyId != null && message.hasOwnProperty("awsAccessKeyId"))
                    object.awsAccessKeyId = message.awsAccessKeyId;
                if (message.awsSecretAccessKey != null && message.hasOwnProperty("awsSecretAccessKey"))
                    object.awsSecretAccessKey = message.awsSecretAccessKey;
                if (message.awsProfile != null && message.hasOwnProperty("awsProfile"))
                    object.awsProfile = message.awsProfile;
                return object;
            };

            /**
             * Converts this AWSSNSConn to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSNSConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSNSConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSNSConn;
        })();

        args.AWSSNSWriteArgs = (function() {

            /**
             * Properties of a AWSSNSWriteArgs.
             * @memberof protos.args
             * @interface IAWSSNSWriteArgs
             * @property {string|null} [topic] AWSSNSWriteArgs topic
             */

            /**
             * Constructs a new AWSSNSWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a AWSSNSWriteArgs.
             * @implements IAWSSNSWriteArgs
             * @constructor
             * @param {protos.args.IAWSSNSWriteArgs=} [properties] Properties to set
             */
            function AWSSNSWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSNSWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.AWSSNSWriteArgs
             * @instance
             */
            AWSSNSWriteArgs.prototype.topic = "";

            /**
             * Creates a new AWSSNSWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {protos.args.IAWSSNSWriteArgs=} [properties] Properties to set
             * @returns {protos.args.AWSSNSWriteArgs} AWSSNSWriteArgs instance
             */
            AWSSNSWriteArgs.create = function create(properties) {
                return new AWSSNSWriteArgs(properties);
            };

            /**
             * Encodes the specified AWSSNSWriteArgs message. Does not implicitly {@link protos.args.AWSSNSWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {protos.args.IAWSSNSWriteArgs} message AWSSNSWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSNSWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                return writer;
            };

            /**
             * Encodes the specified AWSSNSWriteArgs message, length delimited. Does not implicitly {@link protos.args.AWSSNSWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {protos.args.IAWSSNSWriteArgs} message AWSSNSWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSNSWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSNSWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSNSWriteArgs} AWSSNSWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSNSWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSNSWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSNSWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSNSWriteArgs} AWSSNSWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSNSWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSNSWriteArgs message.
             * @function verify
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSNSWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                return null;
            };

            /**
             * Creates a AWSSNSWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSNSWriteArgs} AWSSNSWriteArgs
             */
            AWSSNSWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSNSWriteArgs)
                    return object;
                var message = new $root.protos.args.AWSSNSWriteArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                return message;
            };

            /**
             * Creates a plain object from a AWSSNSWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSNSWriteArgs
             * @static
             * @param {protos.args.AWSSNSWriteArgs} message AWSSNSWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSNSWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.topic = "";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                return object;
            };

            /**
             * Converts this AWSSNSWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSNSWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSNSWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSNSWriteArgs;
        })();

        args.AWSSQSConn = (function() {

            /**
             * Properties of a AWSSQSConn.
             * @memberof protos.args
             * @interface IAWSSQSConn
             * @property {string|null} [awsRegion] AWSSQSConn awsRegion
             * @property {string|null} [awsAccessKeyId] AWSSQSConn awsAccessKeyId
             * @property {string|null} [awsSecretAccessKey] AWSSQSConn awsSecretAccessKey
             * @property {string|null} [awsProfile] AWSSQSConn awsProfile
             */

            /**
             * Constructs a new AWSSQSConn.
             * @memberof protos.args
             * @classdesc Represents a AWSSQSConn.
             * @implements IAWSSQSConn
             * @constructor
             * @param {protos.args.IAWSSQSConn=} [properties] Properties to set
             */
            function AWSSQSConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSQSConn awsRegion.
             * @member {string} awsRegion
             * @memberof protos.args.AWSSQSConn
             * @instance
             */
            AWSSQSConn.prototype.awsRegion = "";

            /**
             * AWSSQSConn awsAccessKeyId.
             * @member {string} awsAccessKeyId
             * @memberof protos.args.AWSSQSConn
             * @instance
             */
            AWSSQSConn.prototype.awsAccessKeyId = "";

            /**
             * AWSSQSConn awsSecretAccessKey.
             * @member {string} awsSecretAccessKey
             * @memberof protos.args.AWSSQSConn
             * @instance
             */
            AWSSQSConn.prototype.awsSecretAccessKey = "";

            /**
             * AWSSQSConn awsProfile.
             * @member {string} awsProfile
             * @memberof protos.args.AWSSQSConn
             * @instance
             */
            AWSSQSConn.prototype.awsProfile = "";

            /**
             * Creates a new AWSSQSConn instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {protos.args.IAWSSQSConn=} [properties] Properties to set
             * @returns {protos.args.AWSSQSConn} AWSSQSConn instance
             */
            AWSSQSConn.create = function create(properties) {
                return new AWSSQSConn(properties);
            };

            /**
             * Encodes the specified AWSSQSConn message. Does not implicitly {@link protos.args.AWSSQSConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {protos.args.IAWSSQSConn} message AWSSQSConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.awsRegion != null && Object.hasOwnProperty.call(message, "awsRegion"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.awsRegion);
                if (message.awsAccessKeyId != null && Object.hasOwnProperty.call(message, "awsAccessKeyId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.awsAccessKeyId);
                if (message.awsSecretAccessKey != null && Object.hasOwnProperty.call(message, "awsSecretAccessKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.awsSecretAccessKey);
                if (message.awsProfile != null && Object.hasOwnProperty.call(message, "awsProfile"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.awsProfile);
                return writer;
            };

            /**
             * Encodes the specified AWSSQSConn message, length delimited. Does not implicitly {@link protos.args.AWSSQSConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {protos.args.IAWSSQSConn} message AWSSQSConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSQSConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSQSConn} AWSSQSConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSQSConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.awsRegion = reader.string();
                        break;
                    case 2:
                        message.awsAccessKeyId = reader.string();
                        break;
                    case 3:
                        message.awsSecretAccessKey = reader.string();
                        break;
                    case 4:
                        message.awsProfile = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSQSConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSQSConn} AWSSQSConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSQSConn message.
             * @function verify
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSQSConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.awsRegion != null && message.hasOwnProperty("awsRegion"))
                    if (!$util.isString(message.awsRegion))
                        return "awsRegion: string expected";
                if (message.awsAccessKeyId != null && message.hasOwnProperty("awsAccessKeyId"))
                    if (!$util.isString(message.awsAccessKeyId))
                        return "awsAccessKeyId: string expected";
                if (message.awsSecretAccessKey != null && message.hasOwnProperty("awsSecretAccessKey"))
                    if (!$util.isString(message.awsSecretAccessKey))
                        return "awsSecretAccessKey: string expected";
                if (message.awsProfile != null && message.hasOwnProperty("awsProfile"))
                    if (!$util.isString(message.awsProfile))
                        return "awsProfile: string expected";
                return null;
            };

            /**
             * Creates a AWSSQSConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSQSConn} AWSSQSConn
             */
            AWSSQSConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSQSConn)
                    return object;
                var message = new $root.protos.args.AWSSQSConn();
                if (object.awsRegion != null)
                    message.awsRegion = String(object.awsRegion);
                if (object.awsAccessKeyId != null)
                    message.awsAccessKeyId = String(object.awsAccessKeyId);
                if (object.awsSecretAccessKey != null)
                    message.awsSecretAccessKey = String(object.awsSecretAccessKey);
                if (object.awsProfile != null)
                    message.awsProfile = String(object.awsProfile);
                return message;
            };

            /**
             * Creates a plain object from a AWSSQSConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSQSConn
             * @static
             * @param {protos.args.AWSSQSConn} message AWSSQSConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSQSConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.awsRegion = "";
                    object.awsAccessKeyId = "";
                    object.awsSecretAccessKey = "";
                    object.awsProfile = "";
                }
                if (message.awsRegion != null && message.hasOwnProperty("awsRegion"))
                    object.awsRegion = message.awsRegion;
                if (message.awsAccessKeyId != null && message.hasOwnProperty("awsAccessKeyId"))
                    object.awsAccessKeyId = message.awsAccessKeyId;
                if (message.awsSecretAccessKey != null && message.hasOwnProperty("awsSecretAccessKey"))
                    object.awsSecretAccessKey = message.awsSecretAccessKey;
                if (message.awsProfile != null && message.hasOwnProperty("awsProfile"))
                    object.awsProfile = message.awsProfile;
                return object;
            };

            /**
             * Converts this AWSSQSConn to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSQSConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSQSConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSQSConn;
        })();

        args.AWSSQSReadArgs = (function() {

            /**
             * Properties of a AWSSQSReadArgs.
             * @memberof protos.args
             * @interface IAWSSQSReadArgs
             * @property {string|null} [queueName] AWSSQSReadArgs queueName
             * @property {string|null} [remoteAccountId] AWSSQSReadArgs remoteAccountId
             * @property {number|Long|null} [maxNumMessages] AWSSQSReadArgs maxNumMessages
             * @property {string|null} [receiveRequestAttemptId] AWSSQSReadArgs receiveRequestAttemptId
             * @property {boolean|null} [autoDelete] AWSSQSReadArgs autoDelete
             * @property {number|Long|null} [waitTimeSeconds] AWSSQSReadArgs waitTimeSeconds
             */

            /**
             * Constructs a new AWSSQSReadArgs.
             * @memberof protos.args
             * @classdesc Represents a AWSSQSReadArgs.
             * @implements IAWSSQSReadArgs
             * @constructor
             * @param {protos.args.IAWSSQSReadArgs=} [properties] Properties to set
             */
            function AWSSQSReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSQSReadArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.queueName = "";

            /**
             * AWSSQSReadArgs remoteAccountId.
             * @member {string} remoteAccountId
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.remoteAccountId = "";

            /**
             * AWSSQSReadArgs maxNumMessages.
             * @member {number|Long} maxNumMessages
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.maxNumMessages = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AWSSQSReadArgs receiveRequestAttemptId.
             * @member {string} receiveRequestAttemptId
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.receiveRequestAttemptId = "";

            /**
             * AWSSQSReadArgs autoDelete.
             * @member {boolean} autoDelete
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.autoDelete = false;

            /**
             * AWSSQSReadArgs waitTimeSeconds.
             * @member {number|Long} waitTimeSeconds
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             */
            AWSSQSReadArgs.prototype.waitTimeSeconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new AWSSQSReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {protos.args.IAWSSQSReadArgs=} [properties] Properties to set
             * @returns {protos.args.AWSSQSReadArgs} AWSSQSReadArgs instance
             */
            AWSSQSReadArgs.create = function create(properties) {
                return new AWSSQSReadArgs(properties);
            };

            /**
             * Encodes the specified AWSSQSReadArgs message. Does not implicitly {@link protos.args.AWSSQSReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {protos.args.IAWSSQSReadArgs} message AWSSQSReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queueName);
                if (message.remoteAccountId != null && Object.hasOwnProperty.call(message, "remoteAccountId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.remoteAccountId);
                if (message.maxNumMessages != null && Object.hasOwnProperty.call(message, "maxNumMessages"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.maxNumMessages);
                if (message.receiveRequestAttemptId != null && Object.hasOwnProperty.call(message, "receiveRequestAttemptId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.receiveRequestAttemptId);
                if (message.autoDelete != null && Object.hasOwnProperty.call(message, "autoDelete"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.autoDelete);
                if (message.waitTimeSeconds != null && Object.hasOwnProperty.call(message, "waitTimeSeconds"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.waitTimeSeconds);
                return writer;
            };

            /**
             * Encodes the specified AWSSQSReadArgs message, length delimited. Does not implicitly {@link protos.args.AWSSQSReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {protos.args.IAWSSQSReadArgs} message AWSSQSReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSQSReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSQSReadArgs} AWSSQSReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSQSReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queueName = reader.string();
                        break;
                    case 2:
                        message.remoteAccountId = reader.string();
                        break;
                    case 3:
                        message.maxNumMessages = reader.int64();
                        break;
                    case 4:
                        message.receiveRequestAttemptId = reader.string();
                        break;
                    case 5:
                        message.autoDelete = reader.bool();
                        break;
                    case 6:
                        message.waitTimeSeconds = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSQSReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSQSReadArgs} AWSSQSReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSQSReadArgs message.
             * @function verify
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSQSReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    if (!$util.isString(message.remoteAccountId))
                        return "remoteAccountId: string expected";
                if (message.maxNumMessages != null && message.hasOwnProperty("maxNumMessages"))
                    if (!$util.isInteger(message.maxNumMessages) && !(message.maxNumMessages && $util.isInteger(message.maxNumMessages.low) && $util.isInteger(message.maxNumMessages.high)))
                        return "maxNumMessages: integer|Long expected";
                if (message.receiveRequestAttemptId != null && message.hasOwnProperty("receiveRequestAttemptId"))
                    if (!$util.isString(message.receiveRequestAttemptId))
                        return "receiveRequestAttemptId: string expected";
                if (message.autoDelete != null && message.hasOwnProperty("autoDelete"))
                    if (typeof message.autoDelete !== "boolean")
                        return "autoDelete: boolean expected";
                if (message.waitTimeSeconds != null && message.hasOwnProperty("waitTimeSeconds"))
                    if (!$util.isInteger(message.waitTimeSeconds) && !(message.waitTimeSeconds && $util.isInteger(message.waitTimeSeconds.low) && $util.isInteger(message.waitTimeSeconds.high)))
                        return "waitTimeSeconds: integer|Long expected";
                return null;
            };

            /**
             * Creates a AWSSQSReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSQSReadArgs} AWSSQSReadArgs
             */
            AWSSQSReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSQSReadArgs)
                    return object;
                var message = new $root.protos.args.AWSSQSReadArgs();
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                if (object.remoteAccountId != null)
                    message.remoteAccountId = String(object.remoteAccountId);
                if (object.maxNumMessages != null)
                    if ($util.Long)
                        (message.maxNumMessages = $util.Long.fromValue(object.maxNumMessages)).unsigned = false;
                    else if (typeof object.maxNumMessages === "string")
                        message.maxNumMessages = parseInt(object.maxNumMessages, 10);
                    else if (typeof object.maxNumMessages === "number")
                        message.maxNumMessages = object.maxNumMessages;
                    else if (typeof object.maxNumMessages === "object")
                        message.maxNumMessages = new $util.LongBits(object.maxNumMessages.low >>> 0, object.maxNumMessages.high >>> 0).toNumber();
                if (object.receiveRequestAttemptId != null)
                    message.receiveRequestAttemptId = String(object.receiveRequestAttemptId);
                if (object.autoDelete != null)
                    message.autoDelete = Boolean(object.autoDelete);
                if (object.waitTimeSeconds != null)
                    if ($util.Long)
                        (message.waitTimeSeconds = $util.Long.fromValue(object.waitTimeSeconds)).unsigned = false;
                    else if (typeof object.waitTimeSeconds === "string")
                        message.waitTimeSeconds = parseInt(object.waitTimeSeconds, 10);
                    else if (typeof object.waitTimeSeconds === "number")
                        message.waitTimeSeconds = object.waitTimeSeconds;
                    else if (typeof object.waitTimeSeconds === "object")
                        message.waitTimeSeconds = new $util.LongBits(object.waitTimeSeconds.low >>> 0, object.waitTimeSeconds.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a AWSSQSReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSQSReadArgs
             * @static
             * @param {protos.args.AWSSQSReadArgs} message AWSSQSReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSQSReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.queueName = "";
                    object.remoteAccountId = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.maxNumMessages = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.maxNumMessages = options.longs === String ? "0" : 0;
                    object.receiveRequestAttemptId = "";
                    object.autoDelete = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.waitTimeSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.waitTimeSeconds = options.longs === String ? "0" : 0;
                }
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    object.remoteAccountId = message.remoteAccountId;
                if (message.maxNumMessages != null && message.hasOwnProperty("maxNumMessages"))
                    if (typeof message.maxNumMessages === "number")
                        object.maxNumMessages = options.longs === String ? String(message.maxNumMessages) : message.maxNumMessages;
                    else
                        object.maxNumMessages = options.longs === String ? $util.Long.prototype.toString.call(message.maxNumMessages) : options.longs === Number ? new $util.LongBits(message.maxNumMessages.low >>> 0, message.maxNumMessages.high >>> 0).toNumber() : message.maxNumMessages;
                if (message.receiveRequestAttemptId != null && message.hasOwnProperty("receiveRequestAttemptId"))
                    object.receiveRequestAttemptId = message.receiveRequestAttemptId;
                if (message.autoDelete != null && message.hasOwnProperty("autoDelete"))
                    object.autoDelete = message.autoDelete;
                if (message.waitTimeSeconds != null && message.hasOwnProperty("waitTimeSeconds"))
                    if (typeof message.waitTimeSeconds === "number")
                        object.waitTimeSeconds = options.longs === String ? String(message.waitTimeSeconds) : message.waitTimeSeconds;
                    else
                        object.waitTimeSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.waitTimeSeconds) : options.longs === Number ? new $util.LongBits(message.waitTimeSeconds.low >>> 0, message.waitTimeSeconds.high >>> 0).toNumber() : message.waitTimeSeconds;
                return object;
            };

            /**
             * Converts this AWSSQSReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSQSReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSQSReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSQSReadArgs;
        })();

        args.AWSSQSWriteArgs = (function() {

            /**
             * Properties of a AWSSQSWriteArgs.
             * @memberof protos.args
             * @interface IAWSSQSWriteArgs
             * @property {string|null} [queueName] AWSSQSWriteArgs queueName
             * @property {string|null} [remoteAccountId] AWSSQSWriteArgs remoteAccountId
             * @property {number|Long|null} [delaySeconds] AWSSQSWriteArgs delaySeconds
             * @property {Object.<string,string>|null} [attributes] AWSSQSWriteArgs attributes
             * @property {string|null} [messageGroupId] AWSSQSWriteArgs messageGroupId
             * @property {string|null} [messageDeduplicationId] AWSSQSWriteArgs messageDeduplicationId
             */

            /**
             * Constructs a new AWSSQSWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a AWSSQSWriteArgs.
             * @implements IAWSSQSWriteArgs
             * @constructor
             * @param {protos.args.IAWSSQSWriteArgs=} [properties] Properties to set
             */
            function AWSSQSWriteArgs(properties) {
                this.attributes = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSQSWriteArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.queueName = "";

            /**
             * AWSSQSWriteArgs remoteAccountId.
             * @member {string} remoteAccountId
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.remoteAccountId = "";

            /**
             * AWSSQSWriteArgs delaySeconds.
             * @member {number|Long} delaySeconds
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.delaySeconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AWSSQSWriteArgs attributes.
             * @member {Object.<string,string>} attributes
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.attributes = $util.emptyObject;

            /**
             * AWSSQSWriteArgs messageGroupId.
             * @member {string} messageGroupId
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.messageGroupId = "";

            /**
             * AWSSQSWriteArgs messageDeduplicationId.
             * @member {string} messageDeduplicationId
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             */
            AWSSQSWriteArgs.prototype.messageDeduplicationId = "";

            /**
             * Creates a new AWSSQSWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {protos.args.IAWSSQSWriteArgs=} [properties] Properties to set
             * @returns {protos.args.AWSSQSWriteArgs} AWSSQSWriteArgs instance
             */
            AWSSQSWriteArgs.create = function create(properties) {
                return new AWSSQSWriteArgs(properties);
            };

            /**
             * Encodes the specified AWSSQSWriteArgs message. Does not implicitly {@link protos.args.AWSSQSWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {protos.args.IAWSSQSWriteArgs} message AWSSQSWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queueName);
                if (message.remoteAccountId != null && Object.hasOwnProperty.call(message, "remoteAccountId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.remoteAccountId);
                if (message.delaySeconds != null && Object.hasOwnProperty.call(message, "delaySeconds"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.delaySeconds);
                if (message.attributes != null && Object.hasOwnProperty.call(message, "attributes"))
                    for (var keys = Object.keys(message.attributes), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.attributes[keys[i]]).ldelim();
                if (message.messageGroupId != null && Object.hasOwnProperty.call(message, "messageGroupId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.messageGroupId);
                if (message.messageDeduplicationId != null && Object.hasOwnProperty.call(message, "messageDeduplicationId"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.messageDeduplicationId);
                return writer;
            };

            /**
             * Encodes the specified AWSSQSWriteArgs message, length delimited. Does not implicitly {@link protos.args.AWSSQSWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {protos.args.IAWSSQSWriteArgs} message AWSSQSWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSQSWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSQSWriteArgs} AWSSQSWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSQSWriteArgs(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queueName = reader.string();
                        break;
                    case 2:
                        message.remoteAccountId = reader.string();
                        break;
                    case 3:
                        message.delaySeconds = reader.int64();
                        break;
                    case 4:
                        if (message.attributes === $util.emptyObject)
                            message.attributes = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.attributes[key] = value;
                        break;
                    case 5:
                        message.messageGroupId = reader.string();
                        break;
                    case 6:
                        message.messageDeduplicationId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSQSWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSQSWriteArgs} AWSSQSWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSQSWriteArgs message.
             * @function verify
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSQSWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    if (!$util.isString(message.remoteAccountId))
                        return "remoteAccountId: string expected";
                if (message.delaySeconds != null && message.hasOwnProperty("delaySeconds"))
                    if (!$util.isInteger(message.delaySeconds) && !(message.delaySeconds && $util.isInteger(message.delaySeconds.low) && $util.isInteger(message.delaySeconds.high)))
                        return "delaySeconds: integer|Long expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    if (!$util.isObject(message.attributes))
                        return "attributes: object expected";
                    var key = Object.keys(message.attributes);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.attributes[key[i]]))
                            return "attributes: string{k:string} expected";
                }
                if (message.messageGroupId != null && message.hasOwnProperty("messageGroupId"))
                    if (!$util.isString(message.messageGroupId))
                        return "messageGroupId: string expected";
                if (message.messageDeduplicationId != null && message.hasOwnProperty("messageDeduplicationId"))
                    if (!$util.isString(message.messageDeduplicationId))
                        return "messageDeduplicationId: string expected";
                return null;
            };

            /**
             * Creates a AWSSQSWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSQSWriteArgs} AWSSQSWriteArgs
             */
            AWSSQSWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSQSWriteArgs)
                    return object;
                var message = new $root.protos.args.AWSSQSWriteArgs();
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                if (object.remoteAccountId != null)
                    message.remoteAccountId = String(object.remoteAccountId);
                if (object.delaySeconds != null)
                    if ($util.Long)
                        (message.delaySeconds = $util.Long.fromValue(object.delaySeconds)).unsigned = false;
                    else if (typeof object.delaySeconds === "string")
                        message.delaySeconds = parseInt(object.delaySeconds, 10);
                    else if (typeof object.delaySeconds === "number")
                        message.delaySeconds = object.delaySeconds;
                    else if (typeof object.delaySeconds === "object")
                        message.delaySeconds = new $util.LongBits(object.delaySeconds.low >>> 0, object.delaySeconds.high >>> 0).toNumber();
                if (object.attributes) {
                    if (typeof object.attributes !== "object")
                        throw TypeError(".protos.args.AWSSQSWriteArgs.attributes: object expected");
                    message.attributes = {};
                    for (var keys = Object.keys(object.attributes), i = 0; i < keys.length; ++i)
                        message.attributes[keys[i]] = String(object.attributes[keys[i]]);
                }
                if (object.messageGroupId != null)
                    message.messageGroupId = String(object.messageGroupId);
                if (object.messageDeduplicationId != null)
                    message.messageDeduplicationId = String(object.messageDeduplicationId);
                return message;
            };

            /**
             * Creates a plain object from a AWSSQSWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSQSWriteArgs
             * @static
             * @param {protos.args.AWSSQSWriteArgs} message AWSSQSWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSQSWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.attributes = {};
                if (options.defaults) {
                    object.queueName = "";
                    object.remoteAccountId = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.delaySeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.delaySeconds = options.longs === String ? "0" : 0;
                    object.messageGroupId = "";
                    object.messageDeduplicationId = "";
                }
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    object.remoteAccountId = message.remoteAccountId;
                if (message.delaySeconds != null && message.hasOwnProperty("delaySeconds"))
                    if (typeof message.delaySeconds === "number")
                        object.delaySeconds = options.longs === String ? String(message.delaySeconds) : message.delaySeconds;
                    else
                        object.delaySeconds = options.longs === String ? $util.Long.prototype.toString.call(message.delaySeconds) : options.longs === Number ? new $util.LongBits(message.delaySeconds.low >>> 0, message.delaySeconds.high >>> 0).toNumber() : message.delaySeconds;
                var keys2;
                if (message.attributes && (keys2 = Object.keys(message.attributes)).length) {
                    object.attributes = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.attributes[keys2[j]] = message.attributes[keys2[j]];
                }
                if (message.messageGroupId != null && message.hasOwnProperty("messageGroupId"))
                    object.messageGroupId = message.messageGroupId;
                if (message.messageDeduplicationId != null && message.hasOwnProperty("messageDeduplicationId"))
                    object.messageDeduplicationId = message.messageDeduplicationId;
                return object;
            };

            /**
             * Converts this AWSSQSWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSQSWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSQSWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSQSWriteArgs;
        })();

        args.AWSSQSRelayArgs = (function() {

            /**
             * Properties of a AWSSQSRelayArgs.
             * @memberof protos.args
             * @interface IAWSSQSRelayArgs
             * @property {string|null} [queueName] AWSSQSRelayArgs queueName
             * @property {string|null} [remoteAccountId] AWSSQSRelayArgs remoteAccountId
             * @property {number|Long|null} [maxNumMessages] AWSSQSRelayArgs maxNumMessages
             * @property {string|null} [receiveRequestAttemptId] AWSSQSRelayArgs receiveRequestAttemptId
             * @property {boolean|null} [autoDelete] AWSSQSRelayArgs autoDelete
             * @property {number|Long|null} [waitTimeSeconds] AWSSQSRelayArgs waitTimeSeconds
             */

            /**
             * Constructs a new AWSSQSRelayArgs.
             * @memberof protos.args
             * @classdesc Represents a AWSSQSRelayArgs.
             * @implements IAWSSQSRelayArgs
             * @constructor
             * @param {protos.args.IAWSSQSRelayArgs=} [properties] Properties to set
             */
            function AWSSQSRelayArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSQSRelayArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.queueName = "";

            /**
             * AWSSQSRelayArgs remoteAccountId.
             * @member {string} remoteAccountId
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.remoteAccountId = "";

            /**
             * AWSSQSRelayArgs maxNumMessages.
             * @member {number|Long} maxNumMessages
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.maxNumMessages = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AWSSQSRelayArgs receiveRequestAttemptId.
             * @member {string} receiveRequestAttemptId
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.receiveRequestAttemptId = "";

            /**
             * AWSSQSRelayArgs autoDelete.
             * @member {boolean} autoDelete
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.autoDelete = false;

            /**
             * AWSSQSRelayArgs waitTimeSeconds.
             * @member {number|Long} waitTimeSeconds
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             */
            AWSSQSRelayArgs.prototype.waitTimeSeconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new AWSSQSRelayArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {protos.args.IAWSSQSRelayArgs=} [properties] Properties to set
             * @returns {protos.args.AWSSQSRelayArgs} AWSSQSRelayArgs instance
             */
            AWSSQSRelayArgs.create = function create(properties) {
                return new AWSSQSRelayArgs(properties);
            };

            /**
             * Encodes the specified AWSSQSRelayArgs message. Does not implicitly {@link protos.args.AWSSQSRelayArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {protos.args.IAWSSQSRelayArgs} message AWSSQSRelayArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSRelayArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queueName);
                if (message.remoteAccountId != null && Object.hasOwnProperty.call(message, "remoteAccountId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.remoteAccountId);
                if (message.maxNumMessages != null && Object.hasOwnProperty.call(message, "maxNumMessages"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.maxNumMessages);
                if (message.receiveRequestAttemptId != null && Object.hasOwnProperty.call(message, "receiveRequestAttemptId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.receiveRequestAttemptId);
                if (message.autoDelete != null && Object.hasOwnProperty.call(message, "autoDelete"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.autoDelete);
                if (message.waitTimeSeconds != null && Object.hasOwnProperty.call(message, "waitTimeSeconds"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.waitTimeSeconds);
                return writer;
            };

            /**
             * Encodes the specified AWSSQSRelayArgs message, length delimited. Does not implicitly {@link protos.args.AWSSQSRelayArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {protos.args.IAWSSQSRelayArgs} message AWSSQSRelayArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQSRelayArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSQSRelayArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AWSSQSRelayArgs} AWSSQSRelayArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSRelayArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AWSSQSRelayArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queueName = reader.string();
                        break;
                    case 2:
                        message.remoteAccountId = reader.string();
                        break;
                    case 3:
                        message.maxNumMessages = reader.int64();
                        break;
                    case 4:
                        message.receiveRequestAttemptId = reader.string();
                        break;
                    case 5:
                        message.autoDelete = reader.bool();
                        break;
                    case 6:
                        message.waitTimeSeconds = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSQSRelayArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AWSSQSRelayArgs} AWSSQSRelayArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQSRelayArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSQSRelayArgs message.
             * @function verify
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSQSRelayArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    if (!$util.isString(message.remoteAccountId))
                        return "remoteAccountId: string expected";
                if (message.maxNumMessages != null && message.hasOwnProperty("maxNumMessages"))
                    if (!$util.isInteger(message.maxNumMessages) && !(message.maxNumMessages && $util.isInteger(message.maxNumMessages.low) && $util.isInteger(message.maxNumMessages.high)))
                        return "maxNumMessages: integer|Long expected";
                if (message.receiveRequestAttemptId != null && message.hasOwnProperty("receiveRequestAttemptId"))
                    if (!$util.isString(message.receiveRequestAttemptId))
                        return "receiveRequestAttemptId: string expected";
                if (message.autoDelete != null && message.hasOwnProperty("autoDelete"))
                    if (typeof message.autoDelete !== "boolean")
                        return "autoDelete: boolean expected";
                if (message.waitTimeSeconds != null && message.hasOwnProperty("waitTimeSeconds"))
                    if (!$util.isInteger(message.waitTimeSeconds) && !(message.waitTimeSeconds && $util.isInteger(message.waitTimeSeconds.low) && $util.isInteger(message.waitTimeSeconds.high)))
                        return "waitTimeSeconds: integer|Long expected";
                return null;
            };

            /**
             * Creates a AWSSQSRelayArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AWSSQSRelayArgs} AWSSQSRelayArgs
             */
            AWSSQSRelayArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AWSSQSRelayArgs)
                    return object;
                var message = new $root.protos.args.AWSSQSRelayArgs();
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                if (object.remoteAccountId != null)
                    message.remoteAccountId = String(object.remoteAccountId);
                if (object.maxNumMessages != null)
                    if ($util.Long)
                        (message.maxNumMessages = $util.Long.fromValue(object.maxNumMessages)).unsigned = false;
                    else if (typeof object.maxNumMessages === "string")
                        message.maxNumMessages = parseInt(object.maxNumMessages, 10);
                    else if (typeof object.maxNumMessages === "number")
                        message.maxNumMessages = object.maxNumMessages;
                    else if (typeof object.maxNumMessages === "object")
                        message.maxNumMessages = new $util.LongBits(object.maxNumMessages.low >>> 0, object.maxNumMessages.high >>> 0).toNumber();
                if (object.receiveRequestAttemptId != null)
                    message.receiveRequestAttemptId = String(object.receiveRequestAttemptId);
                if (object.autoDelete != null)
                    message.autoDelete = Boolean(object.autoDelete);
                if (object.waitTimeSeconds != null)
                    if ($util.Long)
                        (message.waitTimeSeconds = $util.Long.fromValue(object.waitTimeSeconds)).unsigned = false;
                    else if (typeof object.waitTimeSeconds === "string")
                        message.waitTimeSeconds = parseInt(object.waitTimeSeconds, 10);
                    else if (typeof object.waitTimeSeconds === "number")
                        message.waitTimeSeconds = object.waitTimeSeconds;
                    else if (typeof object.waitTimeSeconds === "object")
                        message.waitTimeSeconds = new $util.LongBits(object.waitTimeSeconds.low >>> 0, object.waitTimeSeconds.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a AWSSQSRelayArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AWSSQSRelayArgs
             * @static
             * @param {protos.args.AWSSQSRelayArgs} message AWSSQSRelayArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSQSRelayArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.queueName = "";
                    object.remoteAccountId = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.maxNumMessages = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.maxNumMessages = options.longs === String ? "0" : 0;
                    object.receiveRequestAttemptId = "";
                    object.autoDelete = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.waitTimeSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.waitTimeSeconds = options.longs === String ? "0" : 0;
                }
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                if (message.remoteAccountId != null && message.hasOwnProperty("remoteAccountId"))
                    object.remoteAccountId = message.remoteAccountId;
                if (message.maxNumMessages != null && message.hasOwnProperty("maxNumMessages"))
                    if (typeof message.maxNumMessages === "number")
                        object.maxNumMessages = options.longs === String ? String(message.maxNumMessages) : message.maxNumMessages;
                    else
                        object.maxNumMessages = options.longs === String ? $util.Long.prototype.toString.call(message.maxNumMessages) : options.longs === Number ? new $util.LongBits(message.maxNumMessages.low >>> 0, message.maxNumMessages.high >>> 0).toNumber() : message.maxNumMessages;
                if (message.receiveRequestAttemptId != null && message.hasOwnProperty("receiveRequestAttemptId"))
                    object.receiveRequestAttemptId = message.receiveRequestAttemptId;
                if (message.autoDelete != null && message.hasOwnProperty("autoDelete"))
                    object.autoDelete = message.autoDelete;
                if (message.waitTimeSeconds != null && message.hasOwnProperty("waitTimeSeconds"))
                    if (typeof message.waitTimeSeconds === "number")
                        object.waitTimeSeconds = options.longs === String ? String(message.waitTimeSeconds) : message.waitTimeSeconds;
                    else
                        object.waitTimeSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.waitTimeSeconds) : options.longs === Number ? new $util.LongBits(message.waitTimeSeconds.low >>> 0, message.waitTimeSeconds.high >>> 0).toNumber() : message.waitTimeSeconds;
                return object;
            };

            /**
             * Converts this AWSSQSRelayArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AWSSQSRelayArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSQSRelayArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSQSRelayArgs;
        })();

        args.AzureEventHubConn = (function() {

            /**
             * Properties of an AzureEventHubConn.
             * @memberof protos.args
             * @interface IAzureEventHubConn
             * @property {string|null} [connectionString] AzureEventHubConn connectionString
             */

            /**
             * Constructs a new AzureEventHubConn.
             * @memberof protos.args
             * @classdesc Represents an AzureEventHubConn.
             * @implements IAzureEventHubConn
             * @constructor
             * @param {protos.args.IAzureEventHubConn=} [properties] Properties to set
             */
            function AzureEventHubConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureEventHubConn connectionString.
             * @member {string} connectionString
             * @memberof protos.args.AzureEventHubConn
             * @instance
             */
            AzureEventHubConn.prototype.connectionString = "";

            /**
             * Creates a new AzureEventHubConn instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {protos.args.IAzureEventHubConn=} [properties] Properties to set
             * @returns {protos.args.AzureEventHubConn} AzureEventHubConn instance
             */
            AzureEventHubConn.create = function create(properties) {
                return new AzureEventHubConn(properties);
            };

            /**
             * Encodes the specified AzureEventHubConn message. Does not implicitly {@link protos.args.AzureEventHubConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {protos.args.IAzureEventHubConn} message AzureEventHubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.connectionString != null && Object.hasOwnProperty.call(message, "connectionString"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionString);
                return writer;
            };

            /**
             * Encodes the specified AzureEventHubConn message, length delimited. Does not implicitly {@link protos.args.AzureEventHubConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {protos.args.IAzureEventHubConn} message AzureEventHubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureEventHubConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureEventHubConn} AzureEventHubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureEventHubConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.connectionString = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureEventHubConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureEventHubConn} AzureEventHubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureEventHubConn message.
             * @function verify
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureEventHubConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.connectionString != null && message.hasOwnProperty("connectionString"))
                    if (!$util.isString(message.connectionString))
                        return "connectionString: string expected";
                return null;
            };

            /**
             * Creates an AzureEventHubConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureEventHubConn} AzureEventHubConn
             */
            AzureEventHubConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureEventHubConn)
                    return object;
                var message = new $root.protos.args.AzureEventHubConn();
                if (object.connectionString != null)
                    message.connectionString = String(object.connectionString);
                return message;
            };

            /**
             * Creates a plain object from an AzureEventHubConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureEventHubConn
             * @static
             * @param {protos.args.AzureEventHubConn} message AzureEventHubConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureEventHubConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.connectionString = "";
                if (message.connectionString != null && message.hasOwnProperty("connectionString"))
                    object.connectionString = message.connectionString;
                return object;
            };

            /**
             * Converts this AzureEventHubConn to JSON.
             * @function toJSON
             * @memberof protos.args.AzureEventHubConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureEventHubConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureEventHubConn;
        })();

        args.AzureEventHubReadArgs = (function() {

            /**
             * Properties of an AzureEventHubReadArgs.
             * @memberof protos.args
             * @interface IAzureEventHubReadArgs
             */

            /**
             * Constructs a new AzureEventHubReadArgs.
             * @memberof protos.args
             * @classdesc Represents an AzureEventHubReadArgs.
             * @implements IAzureEventHubReadArgs
             * @constructor
             * @param {protos.args.IAzureEventHubReadArgs=} [properties] Properties to set
             */
            function AzureEventHubReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new AzureEventHubReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {protos.args.IAzureEventHubReadArgs=} [properties] Properties to set
             * @returns {protos.args.AzureEventHubReadArgs} AzureEventHubReadArgs instance
             */
            AzureEventHubReadArgs.create = function create(properties) {
                return new AzureEventHubReadArgs(properties);
            };

            /**
             * Encodes the specified AzureEventHubReadArgs message. Does not implicitly {@link protos.args.AzureEventHubReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {protos.args.IAzureEventHubReadArgs} message AzureEventHubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified AzureEventHubReadArgs message, length delimited. Does not implicitly {@link protos.args.AzureEventHubReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {protos.args.IAzureEventHubReadArgs} message AzureEventHubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureEventHubReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureEventHubReadArgs} AzureEventHubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureEventHubReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureEventHubReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureEventHubReadArgs} AzureEventHubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureEventHubReadArgs message.
             * @function verify
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureEventHubReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an AzureEventHubReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureEventHubReadArgs} AzureEventHubReadArgs
             */
            AzureEventHubReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureEventHubReadArgs)
                    return object;
                return new $root.protos.args.AzureEventHubReadArgs();
            };

            /**
             * Creates a plain object from an AzureEventHubReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureEventHubReadArgs
             * @static
             * @param {protos.args.AzureEventHubReadArgs} message AzureEventHubReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureEventHubReadArgs.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this AzureEventHubReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AzureEventHubReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureEventHubReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureEventHubReadArgs;
        })();

        args.AzureEventHubWriteArgs = (function() {

            /**
             * Properties of an AzureEventHubWriteArgs.
             * @memberof protos.args
             * @interface IAzureEventHubWriteArgs
             * @property {string|null} [messageId] AzureEventHubWriteArgs messageId
             * @property {string|null} [partitionKey] AzureEventHubWriteArgs partitionKey
             */

            /**
             * Constructs a new AzureEventHubWriteArgs.
             * @memberof protos.args
             * @classdesc Represents an AzureEventHubWriteArgs.
             * @implements IAzureEventHubWriteArgs
             * @constructor
             * @param {protos.args.IAzureEventHubWriteArgs=} [properties] Properties to set
             */
            function AzureEventHubWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureEventHubWriteArgs messageId.
             * @member {string} messageId
             * @memberof protos.args.AzureEventHubWriteArgs
             * @instance
             */
            AzureEventHubWriteArgs.prototype.messageId = "";

            /**
             * AzureEventHubWriteArgs partitionKey.
             * @member {string} partitionKey
             * @memberof protos.args.AzureEventHubWriteArgs
             * @instance
             */
            AzureEventHubWriteArgs.prototype.partitionKey = "";

            /**
             * Creates a new AzureEventHubWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {protos.args.IAzureEventHubWriteArgs=} [properties] Properties to set
             * @returns {protos.args.AzureEventHubWriteArgs} AzureEventHubWriteArgs instance
             */
            AzureEventHubWriteArgs.create = function create(properties) {
                return new AzureEventHubWriteArgs(properties);
            };

            /**
             * Encodes the specified AzureEventHubWriteArgs message. Does not implicitly {@link protos.args.AzureEventHubWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {protos.args.IAzureEventHubWriteArgs} message AzureEventHubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.messageId);
                if (message.partitionKey != null && Object.hasOwnProperty.call(message, "partitionKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.partitionKey);
                return writer;
            };

            /**
             * Encodes the specified AzureEventHubWriteArgs message, length delimited. Does not implicitly {@link protos.args.AzureEventHubWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {protos.args.IAzureEventHubWriteArgs} message AzureEventHubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHubWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureEventHubWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureEventHubWriteArgs} AzureEventHubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureEventHubWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageId = reader.string();
                        break;
                    case 2:
                        message.partitionKey = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureEventHubWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureEventHubWriteArgs} AzureEventHubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHubWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureEventHubWriteArgs message.
             * @function verify
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureEventHubWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    if (!$util.isString(message.partitionKey))
                        return "partitionKey: string expected";
                return null;
            };

            /**
             * Creates an AzureEventHubWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureEventHubWriteArgs} AzureEventHubWriteArgs
             */
            AzureEventHubWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureEventHubWriteArgs)
                    return object;
                var message = new $root.protos.args.AzureEventHubWriteArgs();
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.partitionKey != null)
                    message.partitionKey = String(object.partitionKey);
                return message;
            };

            /**
             * Creates a plain object from an AzureEventHubWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureEventHubWriteArgs
             * @static
             * @param {protos.args.AzureEventHubWriteArgs} message AzureEventHubWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureEventHubWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.messageId = "";
                    object.partitionKey = "";
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    object.partitionKey = message.partitionKey;
                return object;
            };

            /**
             * Converts this AzureEventHubWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AzureEventHubWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureEventHubWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureEventHubWriteArgs;
        })();

        args.AzureServiceBusConn = (function() {

            /**
             * Properties of an AzureServiceBusConn.
             * @memberof protos.args
             * @interface IAzureServiceBusConn
             * @property {string|null} [connectionString] AzureServiceBusConn connectionString
             */

            /**
             * Constructs a new AzureServiceBusConn.
             * @memberof protos.args
             * @classdesc Represents an AzureServiceBusConn.
             * @implements IAzureServiceBusConn
             * @constructor
             * @param {protos.args.IAzureServiceBusConn=} [properties] Properties to set
             */
            function AzureServiceBusConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureServiceBusConn connectionString.
             * @member {string} connectionString
             * @memberof protos.args.AzureServiceBusConn
             * @instance
             */
            AzureServiceBusConn.prototype.connectionString = "";

            /**
             * Creates a new AzureServiceBusConn instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {protos.args.IAzureServiceBusConn=} [properties] Properties to set
             * @returns {protos.args.AzureServiceBusConn} AzureServiceBusConn instance
             */
            AzureServiceBusConn.create = function create(properties) {
                return new AzureServiceBusConn(properties);
            };

            /**
             * Encodes the specified AzureServiceBusConn message. Does not implicitly {@link protos.args.AzureServiceBusConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {protos.args.IAzureServiceBusConn} message AzureServiceBusConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.connectionString != null && Object.hasOwnProperty.call(message, "connectionString"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionString);
                return writer;
            };

            /**
             * Encodes the specified AzureServiceBusConn message, length delimited. Does not implicitly {@link protos.args.AzureServiceBusConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {protos.args.IAzureServiceBusConn} message AzureServiceBusConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureServiceBusConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureServiceBusConn} AzureServiceBusConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureServiceBusConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.connectionString = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureServiceBusConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureServiceBusConn} AzureServiceBusConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureServiceBusConn message.
             * @function verify
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureServiceBusConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.connectionString != null && message.hasOwnProperty("connectionString"))
                    if (!$util.isString(message.connectionString))
                        return "connectionString: string expected";
                return null;
            };

            /**
             * Creates an AzureServiceBusConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureServiceBusConn} AzureServiceBusConn
             */
            AzureServiceBusConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureServiceBusConn)
                    return object;
                var message = new $root.protos.args.AzureServiceBusConn();
                if (object.connectionString != null)
                    message.connectionString = String(object.connectionString);
                return message;
            };

            /**
             * Creates a plain object from an AzureServiceBusConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureServiceBusConn
             * @static
             * @param {protos.args.AzureServiceBusConn} message AzureServiceBusConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureServiceBusConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.connectionString = "";
                if (message.connectionString != null && message.hasOwnProperty("connectionString"))
                    object.connectionString = message.connectionString;
                return object;
            };

            /**
             * Converts this AzureServiceBusConn to JSON.
             * @function toJSON
             * @memberof protos.args.AzureServiceBusConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureServiceBusConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureServiceBusConn;
        })();

        args.AzureServiceBusReadArgs = (function() {

            /**
             * Properties of an AzureServiceBusReadArgs.
             * @memberof protos.args
             * @interface IAzureServiceBusReadArgs
             * @property {string|null} [queue] AzureServiceBusReadArgs queue
             * @property {string|null} [topic] AzureServiceBusReadArgs topic
             * @property {string|null} [subscriptionName] AzureServiceBusReadArgs subscriptionName
             */

            /**
             * Constructs a new AzureServiceBusReadArgs.
             * @memberof protos.args
             * @classdesc Represents an AzureServiceBusReadArgs.
             * @implements IAzureServiceBusReadArgs
             * @constructor
             * @param {protos.args.IAzureServiceBusReadArgs=} [properties] Properties to set
             */
            function AzureServiceBusReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureServiceBusReadArgs queue.
             * @member {string} queue
             * @memberof protos.args.AzureServiceBusReadArgs
             * @instance
             */
            AzureServiceBusReadArgs.prototype.queue = "";

            /**
             * AzureServiceBusReadArgs topic.
             * @member {string} topic
             * @memberof protos.args.AzureServiceBusReadArgs
             * @instance
             */
            AzureServiceBusReadArgs.prototype.topic = "";

            /**
             * AzureServiceBusReadArgs subscriptionName.
             * @member {string} subscriptionName
             * @memberof protos.args.AzureServiceBusReadArgs
             * @instance
             */
            AzureServiceBusReadArgs.prototype.subscriptionName = "";

            /**
             * Creates a new AzureServiceBusReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {protos.args.IAzureServiceBusReadArgs=} [properties] Properties to set
             * @returns {protos.args.AzureServiceBusReadArgs} AzureServiceBusReadArgs instance
             */
            AzureServiceBusReadArgs.create = function create(properties) {
                return new AzureServiceBusReadArgs(properties);
            };

            /**
             * Encodes the specified AzureServiceBusReadArgs message. Does not implicitly {@link protos.args.AzureServiceBusReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {protos.args.IAzureServiceBusReadArgs} message AzureServiceBusReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queue != null && Object.hasOwnProperty.call(message, "queue"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queue);
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.topic);
                if (message.subscriptionName != null && Object.hasOwnProperty.call(message, "subscriptionName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.subscriptionName);
                return writer;
            };

            /**
             * Encodes the specified AzureServiceBusReadArgs message, length delimited. Does not implicitly {@link protos.args.AzureServiceBusReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {protos.args.IAzureServiceBusReadArgs} message AzureServiceBusReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureServiceBusReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureServiceBusReadArgs} AzureServiceBusReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureServiceBusReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queue = reader.string();
                        break;
                    case 2:
                        message.topic = reader.string();
                        break;
                    case 3:
                        message.subscriptionName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureServiceBusReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureServiceBusReadArgs} AzureServiceBusReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureServiceBusReadArgs message.
             * @function verify
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureServiceBusReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queue != null && message.hasOwnProperty("queue"))
                    if (!$util.isString(message.queue))
                        return "queue: string expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.subscriptionName != null && message.hasOwnProperty("subscriptionName"))
                    if (!$util.isString(message.subscriptionName))
                        return "subscriptionName: string expected";
                return null;
            };

            /**
             * Creates an AzureServiceBusReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureServiceBusReadArgs} AzureServiceBusReadArgs
             */
            AzureServiceBusReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureServiceBusReadArgs)
                    return object;
                var message = new $root.protos.args.AzureServiceBusReadArgs();
                if (object.queue != null)
                    message.queue = String(object.queue);
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.subscriptionName != null)
                    message.subscriptionName = String(object.subscriptionName);
                return message;
            };

            /**
             * Creates a plain object from an AzureServiceBusReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureServiceBusReadArgs
             * @static
             * @param {protos.args.AzureServiceBusReadArgs} message AzureServiceBusReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureServiceBusReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.queue = "";
                    object.topic = "";
                    object.subscriptionName = "";
                }
                if (message.queue != null && message.hasOwnProperty("queue"))
                    object.queue = message.queue;
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.subscriptionName != null && message.hasOwnProperty("subscriptionName"))
                    object.subscriptionName = message.subscriptionName;
                return object;
            };

            /**
             * Converts this AzureServiceBusReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AzureServiceBusReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureServiceBusReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureServiceBusReadArgs;
        })();

        args.AzureServiceBusWriteArgs = (function() {

            /**
             * Properties of an AzureServiceBusWriteArgs.
             * @memberof protos.args
             * @interface IAzureServiceBusWriteArgs
             * @property {string|null} [queue] AzureServiceBusWriteArgs queue
             * @property {string|null} [topic] AzureServiceBusWriteArgs topic
             */

            /**
             * Constructs a new AzureServiceBusWriteArgs.
             * @memberof protos.args
             * @classdesc Represents an AzureServiceBusWriteArgs.
             * @implements IAzureServiceBusWriteArgs
             * @constructor
             * @param {protos.args.IAzureServiceBusWriteArgs=} [properties] Properties to set
             */
            function AzureServiceBusWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureServiceBusWriteArgs queue.
             * @member {string} queue
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @instance
             */
            AzureServiceBusWriteArgs.prototype.queue = "";

            /**
             * AzureServiceBusWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @instance
             */
            AzureServiceBusWriteArgs.prototype.topic = "";

            /**
             * Creates a new AzureServiceBusWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {protos.args.IAzureServiceBusWriteArgs=} [properties] Properties to set
             * @returns {protos.args.AzureServiceBusWriteArgs} AzureServiceBusWriteArgs instance
             */
            AzureServiceBusWriteArgs.create = function create(properties) {
                return new AzureServiceBusWriteArgs(properties);
            };

            /**
             * Encodes the specified AzureServiceBusWriteArgs message. Does not implicitly {@link protos.args.AzureServiceBusWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {protos.args.IAzureServiceBusWriteArgs} message AzureServiceBusWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queue != null && Object.hasOwnProperty.call(message, "queue"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queue);
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.topic);
                return writer;
            };

            /**
             * Encodes the specified AzureServiceBusWriteArgs message, length delimited. Does not implicitly {@link protos.args.AzureServiceBusWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {protos.args.IAzureServiceBusWriteArgs} message AzureServiceBusWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBusWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureServiceBusWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.AzureServiceBusWriteArgs} AzureServiceBusWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.AzureServiceBusWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queue = reader.string();
                        break;
                    case 2:
                        message.topic = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureServiceBusWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.AzureServiceBusWriteArgs} AzureServiceBusWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBusWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureServiceBusWriteArgs message.
             * @function verify
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureServiceBusWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queue != null && message.hasOwnProperty("queue"))
                    if (!$util.isString(message.queue))
                        return "queue: string expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                return null;
            };

            /**
             * Creates an AzureServiceBusWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.AzureServiceBusWriteArgs} AzureServiceBusWriteArgs
             */
            AzureServiceBusWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.AzureServiceBusWriteArgs)
                    return object;
                var message = new $root.protos.args.AzureServiceBusWriteArgs();
                if (object.queue != null)
                    message.queue = String(object.queue);
                if (object.topic != null)
                    message.topic = String(object.topic);
                return message;
            };

            /**
             * Creates a plain object from an AzureServiceBusWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @static
             * @param {protos.args.AzureServiceBusWriteArgs} message AzureServiceBusWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureServiceBusWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.queue = "";
                    object.topic = "";
                }
                if (message.queue != null && message.hasOwnProperty("queue"))
                    object.queue = message.queue;
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                return object;
            };

            /**
             * Converts this AzureServiceBusWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.AzureServiceBusWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureServiceBusWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureServiceBusWriteArgs;
        })();

        args.GCPPubSubConn = (function() {

            /**
             * Properties of a GCPPubSubConn.
             * @memberof protos.args
             * @interface IGCPPubSubConn
             * @property {string|null} [projectId] GCPPubSubConn projectId
             * @property {string|null} [credentialsJson] GCPPubSubConn credentialsJson
             * @property {string|null} [credentialsFile] GCPPubSubConn credentialsFile
             */

            /**
             * Constructs a new GCPPubSubConn.
             * @memberof protos.args
             * @classdesc Represents a GCPPubSubConn.
             * @implements IGCPPubSubConn
             * @constructor
             * @param {protos.args.IGCPPubSubConn=} [properties] Properties to set
             */
            function GCPPubSubConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GCPPubSubConn projectId.
             * @member {string} projectId
             * @memberof protos.args.GCPPubSubConn
             * @instance
             */
            GCPPubSubConn.prototype.projectId = "";

            /**
             * GCPPubSubConn credentialsJson.
             * @member {string} credentialsJson
             * @memberof protos.args.GCPPubSubConn
             * @instance
             */
            GCPPubSubConn.prototype.credentialsJson = "";

            /**
             * GCPPubSubConn credentialsFile.
             * @member {string} credentialsFile
             * @memberof protos.args.GCPPubSubConn
             * @instance
             */
            GCPPubSubConn.prototype.credentialsFile = "";

            /**
             * Creates a new GCPPubSubConn instance using the specified properties.
             * @function create
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {protos.args.IGCPPubSubConn=} [properties] Properties to set
             * @returns {protos.args.GCPPubSubConn} GCPPubSubConn instance
             */
            GCPPubSubConn.create = function create(properties) {
                return new GCPPubSubConn(properties);
            };

            /**
             * Encodes the specified GCPPubSubConn message. Does not implicitly {@link protos.args.GCPPubSubConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {protos.args.IGCPPubSubConn} message GCPPubSubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.projectId != null && Object.hasOwnProperty.call(message, "projectId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.projectId);
                if (message.credentialsJson != null && Object.hasOwnProperty.call(message, "credentialsJson"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.credentialsJson);
                if (message.credentialsFile != null && Object.hasOwnProperty.call(message, "credentialsFile"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.credentialsFile);
                return writer;
            };

            /**
             * Encodes the specified GCPPubSubConn message, length delimited. Does not implicitly {@link protos.args.GCPPubSubConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {protos.args.IGCPPubSubConn} message GCPPubSubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GCPPubSubConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.GCPPubSubConn} GCPPubSubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.GCPPubSubConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.projectId = reader.string();
                        break;
                    case 2:
                        message.credentialsJson = reader.string();
                        break;
                    case 3:
                        message.credentialsFile = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GCPPubSubConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.GCPPubSubConn} GCPPubSubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GCPPubSubConn message.
             * @function verify
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GCPPubSubConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.projectId != null && message.hasOwnProperty("projectId"))
                    if (!$util.isString(message.projectId))
                        return "projectId: string expected";
                if (message.credentialsJson != null && message.hasOwnProperty("credentialsJson"))
                    if (!$util.isString(message.credentialsJson))
                        return "credentialsJson: string expected";
                if (message.credentialsFile != null && message.hasOwnProperty("credentialsFile"))
                    if (!$util.isString(message.credentialsFile))
                        return "credentialsFile: string expected";
                return null;
            };

            /**
             * Creates a GCPPubSubConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.GCPPubSubConn} GCPPubSubConn
             */
            GCPPubSubConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.GCPPubSubConn)
                    return object;
                var message = new $root.protos.args.GCPPubSubConn();
                if (object.projectId != null)
                    message.projectId = String(object.projectId);
                if (object.credentialsJson != null)
                    message.credentialsJson = String(object.credentialsJson);
                if (object.credentialsFile != null)
                    message.credentialsFile = String(object.credentialsFile);
                return message;
            };

            /**
             * Creates a plain object from a GCPPubSubConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.GCPPubSubConn
             * @static
             * @param {protos.args.GCPPubSubConn} message GCPPubSubConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GCPPubSubConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.projectId = "";
                    object.credentialsJson = "";
                    object.credentialsFile = "";
                }
                if (message.projectId != null && message.hasOwnProperty("projectId"))
                    object.projectId = message.projectId;
                if (message.credentialsJson != null && message.hasOwnProperty("credentialsJson"))
                    object.credentialsJson = message.credentialsJson;
                if (message.credentialsFile != null && message.hasOwnProperty("credentialsFile"))
                    object.credentialsFile = message.credentialsFile;
                return object;
            };

            /**
             * Converts this GCPPubSubConn to JSON.
             * @function toJSON
             * @memberof protos.args.GCPPubSubConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GCPPubSubConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GCPPubSubConn;
        })();

        args.GCPPubSubReadArgs = (function() {

            /**
             * Properties of a GCPPubSubReadArgs.
             * @memberof protos.args
             * @interface IGCPPubSubReadArgs
             * @property {string|null} [subscriptionId] GCPPubSubReadArgs subscriptionId
             * @property {boolean|null} [ackMessages] GCPPubSubReadArgs ackMessages
             */

            /**
             * Constructs a new GCPPubSubReadArgs.
             * @memberof protos.args
             * @classdesc Represents a GCPPubSubReadArgs.
             * @implements IGCPPubSubReadArgs
             * @constructor
             * @param {protos.args.IGCPPubSubReadArgs=} [properties] Properties to set
             */
            function GCPPubSubReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GCPPubSubReadArgs subscriptionId.
             * @member {string} subscriptionId
             * @memberof protos.args.GCPPubSubReadArgs
             * @instance
             */
            GCPPubSubReadArgs.prototype.subscriptionId = "";

            /**
             * GCPPubSubReadArgs ackMessages.
             * @member {boolean} ackMessages
             * @memberof protos.args.GCPPubSubReadArgs
             * @instance
             */
            GCPPubSubReadArgs.prototype.ackMessages = false;

            /**
             * Creates a new GCPPubSubReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {protos.args.IGCPPubSubReadArgs=} [properties] Properties to set
             * @returns {protos.args.GCPPubSubReadArgs} GCPPubSubReadArgs instance
             */
            GCPPubSubReadArgs.create = function create(properties) {
                return new GCPPubSubReadArgs(properties);
            };

            /**
             * Encodes the specified GCPPubSubReadArgs message. Does not implicitly {@link protos.args.GCPPubSubReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {protos.args.IGCPPubSubReadArgs} message GCPPubSubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subscriptionId != null && Object.hasOwnProperty.call(message, "subscriptionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.subscriptionId);
                if (message.ackMessages != null && Object.hasOwnProperty.call(message, "ackMessages"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.ackMessages);
                return writer;
            };

            /**
             * Encodes the specified GCPPubSubReadArgs message, length delimited. Does not implicitly {@link protos.args.GCPPubSubReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {protos.args.IGCPPubSubReadArgs} message GCPPubSubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GCPPubSubReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.GCPPubSubReadArgs} GCPPubSubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.GCPPubSubReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subscriptionId = reader.string();
                        break;
                    case 2:
                        message.ackMessages = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GCPPubSubReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.GCPPubSubReadArgs} GCPPubSubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GCPPubSubReadArgs message.
             * @function verify
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GCPPubSubReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subscriptionId != null && message.hasOwnProperty("subscriptionId"))
                    if (!$util.isString(message.subscriptionId))
                        return "subscriptionId: string expected";
                if (message.ackMessages != null && message.hasOwnProperty("ackMessages"))
                    if (typeof message.ackMessages !== "boolean")
                        return "ackMessages: boolean expected";
                return null;
            };

            /**
             * Creates a GCPPubSubReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.GCPPubSubReadArgs} GCPPubSubReadArgs
             */
            GCPPubSubReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.GCPPubSubReadArgs)
                    return object;
                var message = new $root.protos.args.GCPPubSubReadArgs();
                if (object.subscriptionId != null)
                    message.subscriptionId = String(object.subscriptionId);
                if (object.ackMessages != null)
                    message.ackMessages = Boolean(object.ackMessages);
                return message;
            };

            /**
             * Creates a plain object from a GCPPubSubReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.GCPPubSubReadArgs
             * @static
             * @param {protos.args.GCPPubSubReadArgs} message GCPPubSubReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GCPPubSubReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.subscriptionId = "";
                    object.ackMessages = false;
                }
                if (message.subscriptionId != null && message.hasOwnProperty("subscriptionId"))
                    object.subscriptionId = message.subscriptionId;
                if (message.ackMessages != null && message.hasOwnProperty("ackMessages"))
                    object.ackMessages = message.ackMessages;
                return object;
            };

            /**
             * Converts this GCPPubSubReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.GCPPubSubReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GCPPubSubReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GCPPubSubReadArgs;
        })();

        args.GCPPubSubWriteArgs = (function() {

            /**
             * Properties of a GCPPubSubWriteArgs.
             * @memberof protos.args
             * @interface IGCPPubSubWriteArgs
             * @property {string|null} [topicId] GCPPubSubWriteArgs topicId
             */

            /**
             * Constructs a new GCPPubSubWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a GCPPubSubWriteArgs.
             * @implements IGCPPubSubWriteArgs
             * @constructor
             * @param {protos.args.IGCPPubSubWriteArgs=} [properties] Properties to set
             */
            function GCPPubSubWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GCPPubSubWriteArgs topicId.
             * @member {string} topicId
             * @memberof protos.args.GCPPubSubWriteArgs
             * @instance
             */
            GCPPubSubWriteArgs.prototype.topicId = "";

            /**
             * Creates a new GCPPubSubWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {protos.args.IGCPPubSubWriteArgs=} [properties] Properties to set
             * @returns {protos.args.GCPPubSubWriteArgs} GCPPubSubWriteArgs instance
             */
            GCPPubSubWriteArgs.create = function create(properties) {
                return new GCPPubSubWriteArgs(properties);
            };

            /**
             * Encodes the specified GCPPubSubWriteArgs message. Does not implicitly {@link protos.args.GCPPubSubWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {protos.args.IGCPPubSubWriteArgs} message GCPPubSubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topicId != null && Object.hasOwnProperty.call(message, "topicId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topicId);
                return writer;
            };

            /**
             * Encodes the specified GCPPubSubWriteArgs message, length delimited. Does not implicitly {@link protos.args.GCPPubSubWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {protos.args.IGCPPubSubWriteArgs} message GCPPubSubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSubWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GCPPubSubWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.GCPPubSubWriteArgs} GCPPubSubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.GCPPubSubWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topicId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GCPPubSubWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.GCPPubSubWriteArgs} GCPPubSubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSubWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GCPPubSubWriteArgs message.
             * @function verify
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GCPPubSubWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topicId != null && message.hasOwnProperty("topicId"))
                    if (!$util.isString(message.topicId))
                        return "topicId: string expected";
                return null;
            };

            /**
             * Creates a GCPPubSubWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.GCPPubSubWriteArgs} GCPPubSubWriteArgs
             */
            GCPPubSubWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.GCPPubSubWriteArgs)
                    return object;
                var message = new $root.protos.args.GCPPubSubWriteArgs();
                if (object.topicId != null)
                    message.topicId = String(object.topicId);
                return message;
            };

            /**
             * Creates a plain object from a GCPPubSubWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.GCPPubSubWriteArgs
             * @static
             * @param {protos.args.GCPPubSubWriteArgs} message GCPPubSubWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GCPPubSubWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.topicId = "";
                if (message.topicId != null && message.hasOwnProperty("topicId"))
                    object.topicId = message.topicId;
                return object;
            };

            /**
             * Converts this GCPPubSubWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.GCPPubSubWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GCPPubSubWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GCPPubSubWriteArgs;
        })();

        /**
         * SASLType enum.
         * @name protos.args.SASLType
         * @enum {number}
         * @property {number} NONE=0 NONE value
         * @property {number} PLAIN=1 PLAIN value
         * @property {number} SCRAM=2 SCRAM value
         */
        args.SASLType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NONE"] = 0;
            values[valuesById[1] = "PLAIN"] = 1;
            values[valuesById[2] = "SCRAM"] = 2;
            return values;
        })();

        args.KafkaConn = (function() {

            /**
             * Properties of a KafkaConn.
             * @memberof protos.args
             * @interface IKafkaConn
             * @property {Array.<string>|null} [address] KafkaConn address
             * @property {number|null} [timeoutSeconds] KafkaConn timeoutSeconds
             * @property {boolean|null} [useTls] KafkaConn useTls
             * @property {boolean|null} [tlsSkipVerify] KafkaConn tlsSkipVerify
             * @property {protos.args.SASLType|null} [saslType] KafkaConn saslType
             * @property {string|null} [saslUsername] KafkaConn saslUsername
             * @property {string|null} [saslPassword] KafkaConn saslPassword
             */

            /**
             * Constructs a new KafkaConn.
             * @memberof protos.args
             * @classdesc Represents a KafkaConn.
             * @implements IKafkaConn
             * @constructor
             * @param {protos.args.IKafkaConn=} [properties] Properties to set
             */
            function KafkaConn(properties) {
                this.address = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KafkaConn address.
             * @member {Array.<string>} address
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.address = $util.emptyArray;

            /**
             * KafkaConn timeoutSeconds.
             * @member {number} timeoutSeconds
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.timeoutSeconds = 0;

            /**
             * KafkaConn useTls.
             * @member {boolean} useTls
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.useTls = false;

            /**
             * KafkaConn tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.tlsSkipVerify = false;

            /**
             * KafkaConn saslType.
             * @member {protos.args.SASLType} saslType
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.saslType = 0;

            /**
             * KafkaConn saslUsername.
             * @member {string} saslUsername
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.saslUsername = "";

            /**
             * KafkaConn saslPassword.
             * @member {string} saslPassword
             * @memberof protos.args.KafkaConn
             * @instance
             */
            KafkaConn.prototype.saslPassword = "";

            /**
             * Creates a new KafkaConn instance using the specified properties.
             * @function create
             * @memberof protos.args.KafkaConn
             * @static
             * @param {protos.args.IKafkaConn=} [properties] Properties to set
             * @returns {protos.args.KafkaConn} KafkaConn instance
             */
            KafkaConn.create = function create(properties) {
                return new KafkaConn(properties);
            };

            /**
             * Encodes the specified KafkaConn message. Does not implicitly {@link protos.args.KafkaConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KafkaConn
             * @static
             * @param {protos.args.IKafkaConn} message KafkaConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && message.address.length)
                    for (var i = 0; i < message.address.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.address[i]);
                if (message.timeoutSeconds != null && Object.hasOwnProperty.call(message, "timeoutSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.timeoutSeconds);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.useTls);
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.tlsSkipVerify);
                if (message.saslType != null && Object.hasOwnProperty.call(message, "saslType"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.saslType);
                if (message.saslUsername != null && Object.hasOwnProperty.call(message, "saslUsername"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.saslUsername);
                if (message.saslPassword != null && Object.hasOwnProperty.call(message, "saslPassword"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.saslPassword);
                return writer;
            };

            /**
             * Encodes the specified KafkaConn message, length delimited. Does not implicitly {@link protos.args.KafkaConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KafkaConn
             * @static
             * @param {protos.args.IKafkaConn} message KafkaConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KafkaConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KafkaConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KafkaConn} KafkaConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KafkaConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.address && message.address.length))
                            message.address = [];
                        message.address.push(reader.string());
                        break;
                    case 2:
                        message.timeoutSeconds = reader.int32();
                        break;
                    case 3:
                        message.useTls = reader.bool();
                        break;
                    case 4:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    case 5:
                        message.saslType = reader.int32();
                        break;
                    case 6:
                        message.saslUsername = reader.string();
                        break;
                    case 7:
                        message.saslPassword = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KafkaConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KafkaConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KafkaConn} KafkaConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KafkaConn message.
             * @function verify
             * @memberof protos.args.KafkaConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address")) {
                    if (!Array.isArray(message.address))
                        return "address: array expected";
                    for (var i = 0; i < message.address.length; ++i)
                        if (!$util.isString(message.address[i]))
                            return "address: string[] expected";
                }
                if (message.timeoutSeconds != null && message.hasOwnProperty("timeoutSeconds"))
                    if (!$util.isInteger(message.timeoutSeconds))
                        return "timeoutSeconds: integer expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                if (message.saslType != null && message.hasOwnProperty("saslType"))
                    switch (message.saslType) {
                    default:
                        return "saslType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.saslUsername != null && message.hasOwnProperty("saslUsername"))
                    if (!$util.isString(message.saslUsername))
                        return "saslUsername: string expected";
                if (message.saslPassword != null && message.hasOwnProperty("saslPassword"))
                    if (!$util.isString(message.saslPassword))
                        return "saslPassword: string expected";
                return null;
            };

            /**
             * Creates a KafkaConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KafkaConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KafkaConn} KafkaConn
             */
            KafkaConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KafkaConn)
                    return object;
                var message = new $root.protos.args.KafkaConn();
                if (object.address) {
                    if (!Array.isArray(object.address))
                        throw TypeError(".protos.args.KafkaConn.address: array expected");
                    message.address = [];
                    for (var i = 0; i < object.address.length; ++i)
                        message.address[i] = String(object.address[i]);
                }
                if (object.timeoutSeconds != null)
                    message.timeoutSeconds = object.timeoutSeconds | 0;
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                switch (object.saslType) {
                case "NONE":
                case 0:
                    message.saslType = 0;
                    break;
                case "PLAIN":
                case 1:
                    message.saslType = 1;
                    break;
                case "SCRAM":
                case 2:
                    message.saslType = 2;
                    break;
                }
                if (object.saslUsername != null)
                    message.saslUsername = String(object.saslUsername);
                if (object.saslPassword != null)
                    message.saslPassword = String(object.saslPassword);
                return message;
            };

            /**
             * Creates a plain object from a KafkaConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KafkaConn
             * @static
             * @param {protos.args.KafkaConn} message KafkaConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.address = [];
                if (options.defaults) {
                    object.timeoutSeconds = 0;
                    object.useTls = false;
                    object.tlsSkipVerify = false;
                    object.saslType = options.enums === String ? "NONE" : 0;
                    object.saslUsername = "";
                    object.saslPassword = "";
                }
                if (message.address && message.address.length) {
                    object.address = [];
                    for (var j = 0; j < message.address.length; ++j)
                        object.address[j] = message.address[j];
                }
                if (message.timeoutSeconds != null && message.hasOwnProperty("timeoutSeconds"))
                    object.timeoutSeconds = message.timeoutSeconds;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                if (message.saslType != null && message.hasOwnProperty("saslType"))
                    object.saslType = options.enums === String ? $root.protos.args.SASLType[message.saslType] : message.saslType;
                if (message.saslUsername != null && message.hasOwnProperty("saslUsername"))
                    object.saslUsername = message.saslUsername;
                if (message.saslPassword != null && message.hasOwnProperty("saslPassword"))
                    object.saslPassword = message.saslPassword;
                return object;
            };

            /**
             * Converts this KafkaConn to JSON.
             * @function toJSON
             * @memberof protos.args.KafkaConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KafkaConn;
        })();

        args.KafkaReadArgs = (function() {

            /**
             * Properties of a KafkaReadArgs.
             * @memberof protos.args
             * @interface IKafkaReadArgs
             * @property {Array.<string>|null} [topics] KafkaReadArgs topics
             * @property {number|Long|null} [readOffset] KafkaReadArgs readOffset
             * @property {boolean|null} [useConsumerGroup] KafkaReadArgs useConsumerGroup
             * @property {string|null} [consumerGroupName] KafkaReadArgs consumerGroupName
             * @property {number|null} [maxWaitSeconds] KafkaReadArgs maxWaitSeconds
             * @property {number|null} [minBytes] KafkaReadArgs minBytes
             * @property {number|null} [maxBytes] KafkaReadArgs maxBytes
             * @property {number|null} [commitIntervalSeconds] KafkaReadArgs commitIntervalSeconds
             * @property {number|null} [rebalanceTimeoutSeconds] KafkaReadArgs rebalanceTimeoutSeconds
             * @property {number|null} [queueCapacity] KafkaReadArgs queueCapacity
             * @property {boolean|null} [includeOffsetInfo] KafkaReadArgs includeOffsetInfo
             * @property {boolean|null} [lag] KafkaReadArgs lag
             * @property {string|null} [lagConsumerGroup] KafkaReadArgs lagConsumerGroup
             */

            /**
             * Constructs a new KafkaReadArgs.
             * @memberof protos.args
             * @classdesc Represents a KafkaReadArgs.
             * @implements IKafkaReadArgs
             * @constructor
             * @param {protos.args.IKafkaReadArgs=} [properties] Properties to set
             */
            function KafkaReadArgs(properties) {
                this.topics = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KafkaReadArgs topics.
             * @member {Array.<string>} topics
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.topics = $util.emptyArray;

            /**
             * KafkaReadArgs readOffset.
             * @member {number|Long} readOffset
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.readOffset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * KafkaReadArgs useConsumerGroup.
             * @member {boolean} useConsumerGroup
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.useConsumerGroup = false;

            /**
             * KafkaReadArgs consumerGroupName.
             * @member {string} consumerGroupName
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.consumerGroupName = "";

            /**
             * KafkaReadArgs maxWaitSeconds.
             * @member {number} maxWaitSeconds
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.maxWaitSeconds = 0;

            /**
             * KafkaReadArgs minBytes.
             * @member {number} minBytes
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.minBytes = 0;

            /**
             * KafkaReadArgs maxBytes.
             * @member {number} maxBytes
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.maxBytes = 0;

            /**
             * KafkaReadArgs commitIntervalSeconds.
             * @member {number} commitIntervalSeconds
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.commitIntervalSeconds = 0;

            /**
             * KafkaReadArgs rebalanceTimeoutSeconds.
             * @member {number} rebalanceTimeoutSeconds
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.rebalanceTimeoutSeconds = 0;

            /**
             * KafkaReadArgs queueCapacity.
             * @member {number} queueCapacity
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.queueCapacity = 0;

            /**
             * KafkaReadArgs includeOffsetInfo.
             * @member {boolean} includeOffsetInfo
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.includeOffsetInfo = false;

            /**
             * KafkaReadArgs lag.
             * @member {boolean} lag
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.lag = false;

            /**
             * KafkaReadArgs lagConsumerGroup.
             * @member {string} lagConsumerGroup
             * @memberof protos.args.KafkaReadArgs
             * @instance
             */
            KafkaReadArgs.prototype.lagConsumerGroup = "";

            /**
             * Creates a new KafkaReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {protos.args.IKafkaReadArgs=} [properties] Properties to set
             * @returns {protos.args.KafkaReadArgs} KafkaReadArgs instance
             */
            KafkaReadArgs.create = function create(properties) {
                return new KafkaReadArgs(properties);
            };

            /**
             * Encodes the specified KafkaReadArgs message. Does not implicitly {@link protos.args.KafkaReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {protos.args.IKafkaReadArgs} message KafkaReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topics != null && message.topics.length)
                    for (var i = 0; i < message.topics.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.topics[i]);
                if (message.readOffset != null && Object.hasOwnProperty.call(message, "readOffset"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.readOffset);
                if (message.useConsumerGroup != null && Object.hasOwnProperty.call(message, "useConsumerGroup"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.useConsumerGroup);
                if (message.consumerGroupName != null && Object.hasOwnProperty.call(message, "consumerGroupName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.consumerGroupName);
                if (message.maxWaitSeconds != null && Object.hasOwnProperty.call(message, "maxWaitSeconds"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.maxWaitSeconds);
                if (message.minBytes != null && Object.hasOwnProperty.call(message, "minBytes"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.minBytes);
                if (message.maxBytes != null && Object.hasOwnProperty.call(message, "maxBytes"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.maxBytes);
                if (message.commitIntervalSeconds != null && Object.hasOwnProperty.call(message, "commitIntervalSeconds"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.commitIntervalSeconds);
                if (message.rebalanceTimeoutSeconds != null && Object.hasOwnProperty.call(message, "rebalanceTimeoutSeconds"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.rebalanceTimeoutSeconds);
                if (message.queueCapacity != null && Object.hasOwnProperty.call(message, "queueCapacity"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.queueCapacity);
                if (message.includeOffsetInfo != null && Object.hasOwnProperty.call(message, "includeOffsetInfo"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.includeOffsetInfo);
                if (message.lag != null && Object.hasOwnProperty.call(message, "lag"))
                    writer.uint32(/* id 12, wireType 0 =*/96).bool(message.lag);
                if (message.lagConsumerGroup != null && Object.hasOwnProperty.call(message, "lagConsumerGroup"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.lagConsumerGroup);
                return writer;
            };

            /**
             * Encodes the specified KafkaReadArgs message, length delimited. Does not implicitly {@link protos.args.KafkaReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {protos.args.IKafkaReadArgs} message KafkaReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KafkaReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KafkaReadArgs} KafkaReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KafkaReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.topics && message.topics.length))
                            message.topics = [];
                        message.topics.push(reader.string());
                        break;
                    case 2:
                        message.readOffset = reader.int64();
                        break;
                    case 3:
                        message.useConsumerGroup = reader.bool();
                        break;
                    case 4:
                        message.consumerGroupName = reader.string();
                        break;
                    case 5:
                        message.maxWaitSeconds = reader.int32();
                        break;
                    case 6:
                        message.minBytes = reader.int32();
                        break;
                    case 7:
                        message.maxBytes = reader.int32();
                        break;
                    case 8:
                        message.commitIntervalSeconds = reader.int32();
                        break;
                    case 9:
                        message.rebalanceTimeoutSeconds = reader.int32();
                        break;
                    case 10:
                        message.queueCapacity = reader.int32();
                        break;
                    case 11:
                        message.includeOffsetInfo = reader.bool();
                        break;
                    case 12:
                        message.lag = reader.bool();
                        break;
                    case 13:
                        message.lagConsumerGroup = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KafkaReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KafkaReadArgs} KafkaReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KafkaReadArgs message.
             * @function verify
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topics != null && message.hasOwnProperty("topics")) {
                    if (!Array.isArray(message.topics))
                        return "topics: array expected";
                    for (var i = 0; i < message.topics.length; ++i)
                        if (!$util.isString(message.topics[i]))
                            return "topics: string[] expected";
                }
                if (message.readOffset != null && message.hasOwnProperty("readOffset"))
                    if (!$util.isInteger(message.readOffset) && !(message.readOffset && $util.isInteger(message.readOffset.low) && $util.isInteger(message.readOffset.high)))
                        return "readOffset: integer|Long expected";
                if (message.useConsumerGroup != null && message.hasOwnProperty("useConsumerGroup"))
                    if (typeof message.useConsumerGroup !== "boolean")
                        return "useConsumerGroup: boolean expected";
                if (message.consumerGroupName != null && message.hasOwnProperty("consumerGroupName"))
                    if (!$util.isString(message.consumerGroupName))
                        return "consumerGroupName: string expected";
                if (message.maxWaitSeconds != null && message.hasOwnProperty("maxWaitSeconds"))
                    if (!$util.isInteger(message.maxWaitSeconds))
                        return "maxWaitSeconds: integer expected";
                if (message.minBytes != null && message.hasOwnProperty("minBytes"))
                    if (!$util.isInteger(message.minBytes))
                        return "minBytes: integer expected";
                if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
                    if (!$util.isInteger(message.maxBytes))
                        return "maxBytes: integer expected";
                if (message.commitIntervalSeconds != null && message.hasOwnProperty("commitIntervalSeconds"))
                    if (!$util.isInteger(message.commitIntervalSeconds))
                        return "commitIntervalSeconds: integer expected";
                if (message.rebalanceTimeoutSeconds != null && message.hasOwnProperty("rebalanceTimeoutSeconds"))
                    if (!$util.isInteger(message.rebalanceTimeoutSeconds))
                        return "rebalanceTimeoutSeconds: integer expected";
                if (message.queueCapacity != null && message.hasOwnProperty("queueCapacity"))
                    if (!$util.isInteger(message.queueCapacity))
                        return "queueCapacity: integer expected";
                if (message.includeOffsetInfo != null && message.hasOwnProperty("includeOffsetInfo"))
                    if (typeof message.includeOffsetInfo !== "boolean")
                        return "includeOffsetInfo: boolean expected";
                if (message.lag != null && message.hasOwnProperty("lag"))
                    if (typeof message.lag !== "boolean")
                        return "lag: boolean expected";
                if (message.lagConsumerGroup != null && message.hasOwnProperty("lagConsumerGroup"))
                    if (!$util.isString(message.lagConsumerGroup))
                        return "lagConsumerGroup: string expected";
                return null;
            };

            /**
             * Creates a KafkaReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KafkaReadArgs} KafkaReadArgs
             */
            KafkaReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KafkaReadArgs)
                    return object;
                var message = new $root.protos.args.KafkaReadArgs();
                if (object.topics) {
                    if (!Array.isArray(object.topics))
                        throw TypeError(".protos.args.KafkaReadArgs.topics: array expected");
                    message.topics = [];
                    for (var i = 0; i < object.topics.length; ++i)
                        message.topics[i] = String(object.topics[i]);
                }
                if (object.readOffset != null)
                    if ($util.Long)
                        (message.readOffset = $util.Long.fromValue(object.readOffset)).unsigned = false;
                    else if (typeof object.readOffset === "string")
                        message.readOffset = parseInt(object.readOffset, 10);
                    else if (typeof object.readOffset === "number")
                        message.readOffset = object.readOffset;
                    else if (typeof object.readOffset === "object")
                        message.readOffset = new $util.LongBits(object.readOffset.low >>> 0, object.readOffset.high >>> 0).toNumber();
                if (object.useConsumerGroup != null)
                    message.useConsumerGroup = Boolean(object.useConsumerGroup);
                if (object.consumerGroupName != null)
                    message.consumerGroupName = String(object.consumerGroupName);
                if (object.maxWaitSeconds != null)
                    message.maxWaitSeconds = object.maxWaitSeconds | 0;
                if (object.minBytes != null)
                    message.minBytes = object.minBytes | 0;
                if (object.maxBytes != null)
                    message.maxBytes = object.maxBytes | 0;
                if (object.commitIntervalSeconds != null)
                    message.commitIntervalSeconds = object.commitIntervalSeconds | 0;
                if (object.rebalanceTimeoutSeconds != null)
                    message.rebalanceTimeoutSeconds = object.rebalanceTimeoutSeconds | 0;
                if (object.queueCapacity != null)
                    message.queueCapacity = object.queueCapacity | 0;
                if (object.includeOffsetInfo != null)
                    message.includeOffsetInfo = Boolean(object.includeOffsetInfo);
                if (object.lag != null)
                    message.lag = Boolean(object.lag);
                if (object.lagConsumerGroup != null)
                    message.lagConsumerGroup = String(object.lagConsumerGroup);
                return message;
            };

            /**
             * Creates a plain object from a KafkaReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KafkaReadArgs
             * @static
             * @param {protos.args.KafkaReadArgs} message KafkaReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.topics = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.readOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.readOffset = options.longs === String ? "0" : 0;
                    object.useConsumerGroup = false;
                    object.consumerGroupName = "";
                    object.maxWaitSeconds = 0;
                    object.minBytes = 0;
                    object.maxBytes = 0;
                    object.commitIntervalSeconds = 0;
                    object.rebalanceTimeoutSeconds = 0;
                    object.queueCapacity = 0;
                    object.includeOffsetInfo = false;
                    object.lag = false;
                    object.lagConsumerGroup = "";
                }
                if (message.topics && message.topics.length) {
                    object.topics = [];
                    for (var j = 0; j < message.topics.length; ++j)
                        object.topics[j] = message.topics[j];
                }
                if (message.readOffset != null && message.hasOwnProperty("readOffset"))
                    if (typeof message.readOffset === "number")
                        object.readOffset = options.longs === String ? String(message.readOffset) : message.readOffset;
                    else
                        object.readOffset = options.longs === String ? $util.Long.prototype.toString.call(message.readOffset) : options.longs === Number ? new $util.LongBits(message.readOffset.low >>> 0, message.readOffset.high >>> 0).toNumber() : message.readOffset;
                if (message.useConsumerGroup != null && message.hasOwnProperty("useConsumerGroup"))
                    object.useConsumerGroup = message.useConsumerGroup;
                if (message.consumerGroupName != null && message.hasOwnProperty("consumerGroupName"))
                    object.consumerGroupName = message.consumerGroupName;
                if (message.maxWaitSeconds != null && message.hasOwnProperty("maxWaitSeconds"))
                    object.maxWaitSeconds = message.maxWaitSeconds;
                if (message.minBytes != null && message.hasOwnProperty("minBytes"))
                    object.minBytes = message.minBytes;
                if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
                    object.maxBytes = message.maxBytes;
                if (message.commitIntervalSeconds != null && message.hasOwnProperty("commitIntervalSeconds"))
                    object.commitIntervalSeconds = message.commitIntervalSeconds;
                if (message.rebalanceTimeoutSeconds != null && message.hasOwnProperty("rebalanceTimeoutSeconds"))
                    object.rebalanceTimeoutSeconds = message.rebalanceTimeoutSeconds;
                if (message.queueCapacity != null && message.hasOwnProperty("queueCapacity"))
                    object.queueCapacity = message.queueCapacity;
                if (message.includeOffsetInfo != null && message.hasOwnProperty("includeOffsetInfo"))
                    object.includeOffsetInfo = message.includeOffsetInfo;
                if (message.lag != null && message.hasOwnProperty("lag"))
                    object.lag = message.lag;
                if (message.lagConsumerGroup != null && message.hasOwnProperty("lagConsumerGroup"))
                    object.lagConsumerGroup = message.lagConsumerGroup;
                return object;
            };

            /**
             * Converts this KafkaReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.KafkaReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KafkaReadArgs;
        })();

        args.KafkaWriteArgs = (function() {

            /**
             * Properties of a KafkaWriteArgs.
             * @memberof protos.args
             * @interface IKafkaWriteArgs
             * @property {string|null} [key] KafkaWriteArgs key
             * @property {Object.<string,string>|null} [headers] KafkaWriteArgs headers
             * @property {Array.<string>|null} [topics] KafkaWriteArgs topics
             */

            /**
             * Constructs a new KafkaWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a KafkaWriteArgs.
             * @implements IKafkaWriteArgs
             * @constructor
             * @param {protos.args.IKafkaWriteArgs=} [properties] Properties to set
             */
            function KafkaWriteArgs(properties) {
                this.headers = {};
                this.topics = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KafkaWriteArgs key.
             * @member {string} key
             * @memberof protos.args.KafkaWriteArgs
             * @instance
             */
            KafkaWriteArgs.prototype.key = "";

            /**
             * KafkaWriteArgs headers.
             * @member {Object.<string,string>} headers
             * @memberof protos.args.KafkaWriteArgs
             * @instance
             */
            KafkaWriteArgs.prototype.headers = $util.emptyObject;

            /**
             * KafkaWriteArgs topics.
             * @member {Array.<string>} topics
             * @memberof protos.args.KafkaWriteArgs
             * @instance
             */
            KafkaWriteArgs.prototype.topics = $util.emptyArray;

            /**
             * Creates a new KafkaWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {protos.args.IKafkaWriteArgs=} [properties] Properties to set
             * @returns {protos.args.KafkaWriteArgs} KafkaWriteArgs instance
             */
            KafkaWriteArgs.create = function create(properties) {
                return new KafkaWriteArgs(properties);
            };

            /**
             * Encodes the specified KafkaWriteArgs message. Does not implicitly {@link protos.args.KafkaWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {protos.args.IKafkaWriteArgs} message KafkaWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.headers != null && Object.hasOwnProperty.call(message, "headers"))
                    for (var keys = Object.keys(message.headers), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.headers[keys[i]]).ldelim();
                if (message.topics != null && message.topics.length)
                    for (var i = 0; i < message.topics.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.topics[i]);
                return writer;
            };

            /**
             * Encodes the specified KafkaWriteArgs message, length delimited. Does not implicitly {@link protos.args.KafkaWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {protos.args.IKafkaWriteArgs} message KafkaWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KafkaWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KafkaWriteArgs} KafkaWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KafkaWriteArgs(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        if (message.headers === $util.emptyObject)
                            message.headers = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.headers[key] = value;
                        break;
                    case 3:
                        if (!(message.topics && message.topics.length))
                            message.topics = [];
                        message.topics.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KafkaWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KafkaWriteArgs} KafkaWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KafkaWriteArgs message.
             * @function verify
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    if (!$util.isObject(message.headers))
                        return "headers: object expected";
                    var key = Object.keys(message.headers);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.headers[key[i]]))
                            return "headers: string{k:string} expected";
                }
                if (message.topics != null && message.hasOwnProperty("topics")) {
                    if (!Array.isArray(message.topics))
                        return "topics: array expected";
                    for (var i = 0; i < message.topics.length; ++i)
                        if (!$util.isString(message.topics[i]))
                            return "topics: string[] expected";
                }
                return null;
            };

            /**
             * Creates a KafkaWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KafkaWriteArgs} KafkaWriteArgs
             */
            KafkaWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KafkaWriteArgs)
                    return object;
                var message = new $root.protos.args.KafkaWriteArgs();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.headers) {
                    if (typeof object.headers !== "object")
                        throw TypeError(".protos.args.KafkaWriteArgs.headers: object expected");
                    message.headers = {};
                    for (var keys = Object.keys(object.headers), i = 0; i < keys.length; ++i)
                        message.headers[keys[i]] = String(object.headers[keys[i]]);
                }
                if (object.topics) {
                    if (!Array.isArray(object.topics))
                        throw TypeError(".protos.args.KafkaWriteArgs.topics: array expected");
                    message.topics = [];
                    for (var i = 0; i < object.topics.length; ++i)
                        message.topics[i] = String(object.topics[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a KafkaWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KafkaWriteArgs
             * @static
             * @param {protos.args.KafkaWriteArgs} message KafkaWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.topics = [];
                if (options.objects || options.defaults)
                    object.headers = {};
                if (options.defaults)
                    object.key = "";
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                var keys2;
                if (message.headers && (keys2 = Object.keys(message.headers)).length) {
                    object.headers = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.headers[keys2[j]] = message.headers[keys2[j]];
                }
                if (message.topics && message.topics.length) {
                    object.topics = [];
                    for (var j = 0; j < message.topics.length; ++j)
                        object.topics[j] = message.topics[j];
                }
                return object;
            };

            /**
             * Converts this KafkaWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.KafkaWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KafkaWriteArgs;
        })();

        args.KafkaRelayArgs = (function() {

            /**
             * Properties of a KafkaRelayArgs.
             * @memberof protos.args
             * @interface IKafkaRelayArgs
             * @property {Array.<string>|null} [topics] KafkaRelayArgs topics
             * @property {number|Long|null} [readOffset] KafkaRelayArgs readOffset
             * @property {boolean|null} [useConsumerGroup] KafkaRelayArgs useConsumerGroup
             * @property {string|null} [consumerGroupName] KafkaRelayArgs consumerGroupName
             * @property {number|null} [maxWaitSeconds] KafkaRelayArgs maxWaitSeconds
             * @property {number|null} [minBytes] KafkaRelayArgs minBytes
             * @property {number|null} [maxBytes] KafkaRelayArgs maxBytes
             * @property {number|null} [commitIntervalSeconds] KafkaRelayArgs commitIntervalSeconds
             * @property {number|null} [rebalanceTimeoutSeconds] KafkaRelayArgs rebalanceTimeoutSeconds
             * @property {number|null} [queueCapacity] KafkaRelayArgs queueCapacity
             */

            /**
             * Constructs a new KafkaRelayArgs.
             * @memberof protos.args
             * @classdesc Represents a KafkaRelayArgs.
             * @implements IKafkaRelayArgs
             * @constructor
             * @param {protos.args.IKafkaRelayArgs=} [properties] Properties to set
             */
            function KafkaRelayArgs(properties) {
                this.topics = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KafkaRelayArgs topics.
             * @member {Array.<string>} topics
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.topics = $util.emptyArray;

            /**
             * KafkaRelayArgs readOffset.
             * @member {number|Long} readOffset
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.readOffset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * KafkaRelayArgs useConsumerGroup.
             * @member {boolean} useConsumerGroup
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.useConsumerGroup = false;

            /**
             * KafkaRelayArgs consumerGroupName.
             * @member {string} consumerGroupName
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.consumerGroupName = "";

            /**
             * KafkaRelayArgs maxWaitSeconds.
             * @member {number} maxWaitSeconds
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.maxWaitSeconds = 0;

            /**
             * KafkaRelayArgs minBytes.
             * @member {number} minBytes
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.minBytes = 0;

            /**
             * KafkaRelayArgs maxBytes.
             * @member {number} maxBytes
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.maxBytes = 0;

            /**
             * KafkaRelayArgs commitIntervalSeconds.
             * @member {number} commitIntervalSeconds
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.commitIntervalSeconds = 0;

            /**
             * KafkaRelayArgs rebalanceTimeoutSeconds.
             * @member {number} rebalanceTimeoutSeconds
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.rebalanceTimeoutSeconds = 0;

            /**
             * KafkaRelayArgs queueCapacity.
             * @member {number} queueCapacity
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             */
            KafkaRelayArgs.prototype.queueCapacity = 0;

            /**
             * Creates a new KafkaRelayArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {protos.args.IKafkaRelayArgs=} [properties] Properties to set
             * @returns {protos.args.KafkaRelayArgs} KafkaRelayArgs instance
             */
            KafkaRelayArgs.create = function create(properties) {
                return new KafkaRelayArgs(properties);
            };

            /**
             * Encodes the specified KafkaRelayArgs message. Does not implicitly {@link protos.args.KafkaRelayArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {protos.args.IKafkaRelayArgs} message KafkaRelayArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaRelayArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topics != null && message.topics.length)
                    for (var i = 0; i < message.topics.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.topics[i]);
                if (message.readOffset != null && Object.hasOwnProperty.call(message, "readOffset"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.readOffset);
                if (message.useConsumerGroup != null && Object.hasOwnProperty.call(message, "useConsumerGroup"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.useConsumerGroup);
                if (message.consumerGroupName != null && Object.hasOwnProperty.call(message, "consumerGroupName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.consumerGroupName);
                if (message.maxWaitSeconds != null && Object.hasOwnProperty.call(message, "maxWaitSeconds"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.maxWaitSeconds);
                if (message.minBytes != null && Object.hasOwnProperty.call(message, "minBytes"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.minBytes);
                if (message.maxBytes != null && Object.hasOwnProperty.call(message, "maxBytes"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.maxBytes);
                if (message.commitIntervalSeconds != null && Object.hasOwnProperty.call(message, "commitIntervalSeconds"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.commitIntervalSeconds);
                if (message.rebalanceTimeoutSeconds != null && Object.hasOwnProperty.call(message, "rebalanceTimeoutSeconds"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.rebalanceTimeoutSeconds);
                if (message.queueCapacity != null && Object.hasOwnProperty.call(message, "queueCapacity"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.queueCapacity);
                return writer;
            };

            /**
             * Encodes the specified KafkaRelayArgs message, length delimited. Does not implicitly {@link protos.args.KafkaRelayArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {protos.args.IKafkaRelayArgs} message KafkaRelayArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaRelayArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KafkaRelayArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KafkaRelayArgs} KafkaRelayArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaRelayArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KafkaRelayArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.topics && message.topics.length))
                            message.topics = [];
                        message.topics.push(reader.string());
                        break;
                    case 2:
                        message.readOffset = reader.int64();
                        break;
                    case 3:
                        message.useConsumerGroup = reader.bool();
                        break;
                    case 4:
                        message.consumerGroupName = reader.string();
                        break;
                    case 5:
                        message.maxWaitSeconds = reader.int32();
                        break;
                    case 6:
                        message.minBytes = reader.int32();
                        break;
                    case 7:
                        message.maxBytes = reader.int32();
                        break;
                    case 8:
                        message.commitIntervalSeconds = reader.int32();
                        break;
                    case 9:
                        message.rebalanceTimeoutSeconds = reader.int32();
                        break;
                    case 10:
                        message.queueCapacity = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KafkaRelayArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KafkaRelayArgs} KafkaRelayArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaRelayArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KafkaRelayArgs message.
             * @function verify
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaRelayArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topics != null && message.hasOwnProperty("topics")) {
                    if (!Array.isArray(message.topics))
                        return "topics: array expected";
                    for (var i = 0; i < message.topics.length; ++i)
                        if (!$util.isString(message.topics[i]))
                            return "topics: string[] expected";
                }
                if (message.readOffset != null && message.hasOwnProperty("readOffset"))
                    if (!$util.isInteger(message.readOffset) && !(message.readOffset && $util.isInteger(message.readOffset.low) && $util.isInteger(message.readOffset.high)))
                        return "readOffset: integer|Long expected";
                if (message.useConsumerGroup != null && message.hasOwnProperty("useConsumerGroup"))
                    if (typeof message.useConsumerGroup !== "boolean")
                        return "useConsumerGroup: boolean expected";
                if (message.consumerGroupName != null && message.hasOwnProperty("consumerGroupName"))
                    if (!$util.isString(message.consumerGroupName))
                        return "consumerGroupName: string expected";
                if (message.maxWaitSeconds != null && message.hasOwnProperty("maxWaitSeconds"))
                    if (!$util.isInteger(message.maxWaitSeconds))
                        return "maxWaitSeconds: integer expected";
                if (message.minBytes != null && message.hasOwnProperty("minBytes"))
                    if (!$util.isInteger(message.minBytes))
                        return "minBytes: integer expected";
                if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
                    if (!$util.isInteger(message.maxBytes))
                        return "maxBytes: integer expected";
                if (message.commitIntervalSeconds != null && message.hasOwnProperty("commitIntervalSeconds"))
                    if (!$util.isInteger(message.commitIntervalSeconds))
                        return "commitIntervalSeconds: integer expected";
                if (message.rebalanceTimeoutSeconds != null && message.hasOwnProperty("rebalanceTimeoutSeconds"))
                    if (!$util.isInteger(message.rebalanceTimeoutSeconds))
                        return "rebalanceTimeoutSeconds: integer expected";
                if (message.queueCapacity != null && message.hasOwnProperty("queueCapacity"))
                    if (!$util.isInteger(message.queueCapacity))
                        return "queueCapacity: integer expected";
                return null;
            };

            /**
             * Creates a KafkaRelayArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KafkaRelayArgs} KafkaRelayArgs
             */
            KafkaRelayArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KafkaRelayArgs)
                    return object;
                var message = new $root.protos.args.KafkaRelayArgs();
                if (object.topics) {
                    if (!Array.isArray(object.topics))
                        throw TypeError(".protos.args.KafkaRelayArgs.topics: array expected");
                    message.topics = [];
                    for (var i = 0; i < object.topics.length; ++i)
                        message.topics[i] = String(object.topics[i]);
                }
                if (object.readOffset != null)
                    if ($util.Long)
                        (message.readOffset = $util.Long.fromValue(object.readOffset)).unsigned = false;
                    else if (typeof object.readOffset === "string")
                        message.readOffset = parseInt(object.readOffset, 10);
                    else if (typeof object.readOffset === "number")
                        message.readOffset = object.readOffset;
                    else if (typeof object.readOffset === "object")
                        message.readOffset = new $util.LongBits(object.readOffset.low >>> 0, object.readOffset.high >>> 0).toNumber();
                if (object.useConsumerGroup != null)
                    message.useConsumerGroup = Boolean(object.useConsumerGroup);
                if (object.consumerGroupName != null)
                    message.consumerGroupName = String(object.consumerGroupName);
                if (object.maxWaitSeconds != null)
                    message.maxWaitSeconds = object.maxWaitSeconds | 0;
                if (object.minBytes != null)
                    message.minBytes = object.minBytes | 0;
                if (object.maxBytes != null)
                    message.maxBytes = object.maxBytes | 0;
                if (object.commitIntervalSeconds != null)
                    message.commitIntervalSeconds = object.commitIntervalSeconds | 0;
                if (object.rebalanceTimeoutSeconds != null)
                    message.rebalanceTimeoutSeconds = object.rebalanceTimeoutSeconds | 0;
                if (object.queueCapacity != null)
                    message.queueCapacity = object.queueCapacity | 0;
                return message;
            };

            /**
             * Creates a plain object from a KafkaRelayArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KafkaRelayArgs
             * @static
             * @param {protos.args.KafkaRelayArgs} message KafkaRelayArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaRelayArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.topics = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.readOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.readOffset = options.longs === String ? "0" : 0;
                    object.useConsumerGroup = false;
                    object.consumerGroupName = "";
                    object.maxWaitSeconds = 0;
                    object.minBytes = 0;
                    object.maxBytes = 0;
                    object.commitIntervalSeconds = 0;
                    object.rebalanceTimeoutSeconds = 0;
                    object.queueCapacity = 0;
                }
                if (message.topics && message.topics.length) {
                    object.topics = [];
                    for (var j = 0; j < message.topics.length; ++j)
                        object.topics[j] = message.topics[j];
                }
                if (message.readOffset != null && message.hasOwnProperty("readOffset"))
                    if (typeof message.readOffset === "number")
                        object.readOffset = options.longs === String ? String(message.readOffset) : message.readOffset;
                    else
                        object.readOffset = options.longs === String ? $util.Long.prototype.toString.call(message.readOffset) : options.longs === Number ? new $util.LongBits(message.readOffset.low >>> 0, message.readOffset.high >>> 0).toNumber() : message.readOffset;
                if (message.useConsumerGroup != null && message.hasOwnProperty("useConsumerGroup"))
                    object.useConsumerGroup = message.useConsumerGroup;
                if (message.consumerGroupName != null && message.hasOwnProperty("consumerGroupName"))
                    object.consumerGroupName = message.consumerGroupName;
                if (message.maxWaitSeconds != null && message.hasOwnProperty("maxWaitSeconds"))
                    object.maxWaitSeconds = message.maxWaitSeconds;
                if (message.minBytes != null && message.hasOwnProperty("minBytes"))
                    object.minBytes = message.minBytes;
                if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
                    object.maxBytes = message.maxBytes;
                if (message.commitIntervalSeconds != null && message.hasOwnProperty("commitIntervalSeconds"))
                    object.commitIntervalSeconds = message.commitIntervalSeconds;
                if (message.rebalanceTimeoutSeconds != null && message.hasOwnProperty("rebalanceTimeoutSeconds"))
                    object.rebalanceTimeoutSeconds = message.rebalanceTimeoutSeconds;
                if (message.queueCapacity != null && message.hasOwnProperty("queueCapacity"))
                    object.queueCapacity = message.queueCapacity;
                return object;
            };

            /**
             * Converts this KafkaRelayArgs to JSON.
             * @function toJSON
             * @memberof protos.args.KafkaRelayArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaRelayArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KafkaRelayArgs;
        })();

        args.KubeMQQueueConn = (function() {

            /**
             * Properties of a KubeMQQueueConn.
             * @memberof protos.args
             * @interface IKubeMQQueueConn
             * @property {string|null} [address] KubeMQQueueConn address
             * @property {string|null} [authToken] KubeMQQueueConn authToken
             * @property {string|null} [tlsClientCert] KubeMQQueueConn tlsClientCert
             * @property {string|null} [clientId] KubeMQQueueConn clientId
             */

            /**
             * Constructs a new KubeMQQueueConn.
             * @memberof protos.args
             * @classdesc Represents a KubeMQQueueConn.
             * @implements IKubeMQQueueConn
             * @constructor
             * @param {protos.args.IKubeMQQueueConn=} [properties] Properties to set
             */
            function KubeMQQueueConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KubeMQQueueConn address.
             * @member {string} address
             * @memberof protos.args.KubeMQQueueConn
             * @instance
             */
            KubeMQQueueConn.prototype.address = "";

            /**
             * KubeMQQueueConn authToken.
             * @member {string} authToken
             * @memberof protos.args.KubeMQQueueConn
             * @instance
             */
            KubeMQQueueConn.prototype.authToken = "";

            /**
             * KubeMQQueueConn tlsClientCert.
             * @member {string} tlsClientCert
             * @memberof protos.args.KubeMQQueueConn
             * @instance
             */
            KubeMQQueueConn.prototype.tlsClientCert = "";

            /**
             * KubeMQQueueConn clientId.
             * @member {string} clientId
             * @memberof protos.args.KubeMQQueueConn
             * @instance
             */
            KubeMQQueueConn.prototype.clientId = "";

            /**
             * Creates a new KubeMQQueueConn instance using the specified properties.
             * @function create
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {protos.args.IKubeMQQueueConn=} [properties] Properties to set
             * @returns {protos.args.KubeMQQueueConn} KubeMQQueueConn instance
             */
            KubeMQQueueConn.create = function create(properties) {
                return new KubeMQQueueConn(properties);
            };

            /**
             * Encodes the specified KubeMQQueueConn message. Does not implicitly {@link protos.args.KubeMQQueueConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {protos.args.IKubeMQQueueConn} message KubeMQQueueConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.authToken != null && Object.hasOwnProperty.call(message, "authToken"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.authToken);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.tlsClientCert);
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.clientId);
                return writer;
            };

            /**
             * Encodes the specified KubeMQQueueConn message, length delimited. Does not implicitly {@link protos.args.KubeMQQueueConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {protos.args.IKubeMQQueueConn} message KubeMQQueueConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KubeMQQueueConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KubeMQQueueConn} KubeMQQueueConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KubeMQQueueConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.authToken = reader.string();
                        break;
                    case 3:
                        message.tlsClientCert = reader.string();
                        break;
                    case 4:
                        message.clientId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KubeMQQueueConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KubeMQQueueConn} KubeMQQueueConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KubeMQQueueConn message.
             * @function verify
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KubeMQQueueConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.authToken != null && message.hasOwnProperty("authToken"))
                    if (!$util.isString(message.authToken))
                        return "authToken: string expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!$util.isString(message.tlsClientCert))
                        return "tlsClientCert: string expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                return null;
            };

            /**
             * Creates a KubeMQQueueConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KubeMQQueueConn} KubeMQQueueConn
             */
            KubeMQQueueConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KubeMQQueueConn)
                    return object;
                var message = new $root.protos.args.KubeMQQueueConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.authToken != null)
                    message.authToken = String(object.authToken);
                if (object.tlsClientCert != null)
                    message.tlsClientCert = String(object.tlsClientCert);
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                return message;
            };

            /**
             * Creates a plain object from a KubeMQQueueConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KubeMQQueueConn
             * @static
             * @param {protos.args.KubeMQQueueConn} message KubeMQQueueConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KubeMQQueueConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = "";
                    object.authToken = "";
                    object.tlsClientCert = "";
                    object.clientId = "";
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.authToken != null && message.hasOwnProperty("authToken"))
                    object.authToken = message.authToken;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = message.tlsClientCert;
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                return object;
            };

            /**
             * Converts this KubeMQQueueConn to JSON.
             * @function toJSON
             * @memberof protos.args.KubeMQQueueConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KubeMQQueueConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KubeMQQueueConn;
        })();

        args.KubeMQQueueReadArgs = (function() {

            /**
             * Properties of a KubeMQQueueReadArgs.
             * @memberof protos.args
             * @interface IKubeMQQueueReadArgs
             * @property {string|null} [queueName] KubeMQQueueReadArgs queueName
             */

            /**
             * Constructs a new KubeMQQueueReadArgs.
             * @memberof protos.args
             * @classdesc Represents a KubeMQQueueReadArgs.
             * @implements IKubeMQQueueReadArgs
             * @constructor
             * @param {protos.args.IKubeMQQueueReadArgs=} [properties] Properties to set
             */
            function KubeMQQueueReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KubeMQQueueReadArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.KubeMQQueueReadArgs
             * @instance
             */
            KubeMQQueueReadArgs.prototype.queueName = "";

            /**
             * Creates a new KubeMQQueueReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {protos.args.IKubeMQQueueReadArgs=} [properties] Properties to set
             * @returns {protos.args.KubeMQQueueReadArgs} KubeMQQueueReadArgs instance
             */
            KubeMQQueueReadArgs.create = function create(properties) {
                return new KubeMQQueueReadArgs(properties);
            };

            /**
             * Encodes the specified KubeMQQueueReadArgs message. Does not implicitly {@link protos.args.KubeMQQueueReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {protos.args.IKubeMQQueueReadArgs} message KubeMQQueueReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queueName);
                return writer;
            };

            /**
             * Encodes the specified KubeMQQueueReadArgs message, length delimited. Does not implicitly {@link protos.args.KubeMQQueueReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {protos.args.IKubeMQQueueReadArgs} message KubeMQQueueReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KubeMQQueueReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KubeMQQueueReadArgs} KubeMQQueueReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KubeMQQueueReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queueName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KubeMQQueueReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KubeMQQueueReadArgs} KubeMQQueueReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KubeMQQueueReadArgs message.
             * @function verify
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KubeMQQueueReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                return null;
            };

            /**
             * Creates a KubeMQQueueReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KubeMQQueueReadArgs} KubeMQQueueReadArgs
             */
            KubeMQQueueReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KubeMQQueueReadArgs)
                    return object;
                var message = new $root.protos.args.KubeMQQueueReadArgs();
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                return message;
            };

            /**
             * Creates a plain object from a KubeMQQueueReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KubeMQQueueReadArgs
             * @static
             * @param {protos.args.KubeMQQueueReadArgs} message KubeMQQueueReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KubeMQQueueReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.queueName = "";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                return object;
            };

            /**
             * Converts this KubeMQQueueReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.KubeMQQueueReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KubeMQQueueReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KubeMQQueueReadArgs;
        })();

        args.KubeMQQueueWriteArgs = (function() {

            /**
             * Properties of a KubeMQQueueWriteArgs.
             * @memberof protos.args
             * @interface IKubeMQQueueWriteArgs
             * @property {string|null} [queueName] KubeMQQueueWriteArgs queueName
             */

            /**
             * Constructs a new KubeMQQueueWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a KubeMQQueueWriteArgs.
             * @implements IKubeMQQueueWriteArgs
             * @constructor
             * @param {protos.args.IKubeMQQueueWriteArgs=} [properties] Properties to set
             */
            function KubeMQQueueWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KubeMQQueueWriteArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @instance
             */
            KubeMQQueueWriteArgs.prototype.queueName = "";

            /**
             * Creates a new KubeMQQueueWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {protos.args.IKubeMQQueueWriteArgs=} [properties] Properties to set
             * @returns {protos.args.KubeMQQueueWriteArgs} KubeMQQueueWriteArgs instance
             */
            KubeMQQueueWriteArgs.create = function create(properties) {
                return new KubeMQQueueWriteArgs(properties);
            };

            /**
             * Encodes the specified KubeMQQueueWriteArgs message. Does not implicitly {@link protos.args.KubeMQQueueWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {protos.args.IKubeMQQueueWriteArgs} message KubeMQQueueWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queueName);
                return writer;
            };

            /**
             * Encodes the specified KubeMQQueueWriteArgs message, length delimited. Does not implicitly {@link protos.args.KubeMQQueueWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {protos.args.IKubeMQQueueWriteArgs} message KubeMQQueueWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQQueueWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KubeMQQueueWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.KubeMQQueueWriteArgs} KubeMQQueueWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.KubeMQQueueWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queueName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KubeMQQueueWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.KubeMQQueueWriteArgs} KubeMQQueueWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQQueueWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KubeMQQueueWriteArgs message.
             * @function verify
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KubeMQQueueWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                return null;
            };

            /**
             * Creates a KubeMQQueueWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.KubeMQQueueWriteArgs} KubeMQQueueWriteArgs
             */
            KubeMQQueueWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.KubeMQQueueWriteArgs)
                    return object;
                var message = new $root.protos.args.KubeMQQueueWriteArgs();
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                return message;
            };

            /**
             * Creates a plain object from a KubeMQQueueWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @static
             * @param {protos.args.KubeMQQueueWriteArgs} message KubeMQQueueWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KubeMQQueueWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.queueName = "";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                return object;
            };

            /**
             * Converts this KubeMQQueueWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.KubeMQQueueWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KubeMQQueueWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KubeMQQueueWriteArgs;
        })();

        args.MongoConn = (function() {

            /**
             * Properties of a MongoConn.
             * @memberof protos.args
             * @interface IMongoConn
             * @property {string|null} [dsn] MongoConn dsn
             */

            /**
             * Constructs a new MongoConn.
             * @memberof protos.args
             * @classdesc Represents a MongoConn.
             * @implements IMongoConn
             * @constructor
             * @param {protos.args.IMongoConn=} [properties] Properties to set
             */
            function MongoConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MongoConn dsn.
             * @member {string} dsn
             * @memberof protos.args.MongoConn
             * @instance
             */
            MongoConn.prototype.dsn = "";

            /**
             * Creates a new MongoConn instance using the specified properties.
             * @function create
             * @memberof protos.args.MongoConn
             * @static
             * @param {protos.args.IMongoConn=} [properties] Properties to set
             * @returns {protos.args.MongoConn} MongoConn instance
             */
            MongoConn.create = function create(properties) {
                return new MongoConn(properties);
            };

            /**
             * Encodes the specified MongoConn message. Does not implicitly {@link protos.args.MongoConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MongoConn
             * @static
             * @param {protos.args.IMongoConn} message MongoConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MongoConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                return writer;
            };

            /**
             * Encodes the specified MongoConn message, length delimited. Does not implicitly {@link protos.args.MongoConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MongoConn
             * @static
             * @param {protos.args.IMongoConn} message MongoConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MongoConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MongoConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MongoConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MongoConn} MongoConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MongoConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MongoConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MongoConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MongoConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MongoConn} MongoConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MongoConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MongoConn message.
             * @function verify
             * @memberof protos.args.MongoConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MongoConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                return null;
            };

            /**
             * Creates a MongoConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MongoConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MongoConn} MongoConn
             */
            MongoConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MongoConn)
                    return object;
                var message = new $root.protos.args.MongoConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                return message;
            };

            /**
             * Creates a plain object from a MongoConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MongoConn
             * @static
             * @param {protos.args.MongoConn} message MongoConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MongoConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.dsn = "";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                return object;
            };

            /**
             * Converts this MongoConn to JSON.
             * @function toJSON
             * @memberof protos.args.MongoConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MongoConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MongoConn;
        })();

        args.MongoReadArgs = (function() {

            /**
             * Properties of a MongoReadArgs.
             * @memberof protos.args
             * @interface IMongoReadArgs
             * @property {string|null} [database] MongoReadArgs database
             * @property {string|null} [collection] MongoReadArgs collection
             * @property {boolean|null} [includeFullDocument] MongoReadArgs includeFullDocument
             */

            /**
             * Constructs a new MongoReadArgs.
             * @memberof protos.args
             * @classdesc Represents a MongoReadArgs.
             * @implements IMongoReadArgs
             * @constructor
             * @param {protos.args.IMongoReadArgs=} [properties] Properties to set
             */
            function MongoReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MongoReadArgs database.
             * @member {string} database
             * @memberof protos.args.MongoReadArgs
             * @instance
             */
            MongoReadArgs.prototype.database = "";

            /**
             * MongoReadArgs collection.
             * @member {string} collection
             * @memberof protos.args.MongoReadArgs
             * @instance
             */
            MongoReadArgs.prototype.collection = "";

            /**
             * MongoReadArgs includeFullDocument.
             * @member {boolean} includeFullDocument
             * @memberof protos.args.MongoReadArgs
             * @instance
             */
            MongoReadArgs.prototype.includeFullDocument = false;

            /**
             * Creates a new MongoReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {protos.args.IMongoReadArgs=} [properties] Properties to set
             * @returns {protos.args.MongoReadArgs} MongoReadArgs instance
             */
            MongoReadArgs.create = function create(properties) {
                return new MongoReadArgs(properties);
            };

            /**
             * Encodes the specified MongoReadArgs message. Does not implicitly {@link protos.args.MongoReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {protos.args.IMongoReadArgs} message MongoReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MongoReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.database);
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.collection);
                if (message.includeFullDocument != null && Object.hasOwnProperty.call(message, "includeFullDocument"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.includeFullDocument);
                return writer;
            };

            /**
             * Encodes the specified MongoReadArgs message, length delimited. Does not implicitly {@link protos.args.MongoReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {protos.args.IMongoReadArgs} message MongoReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MongoReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MongoReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MongoReadArgs} MongoReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MongoReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MongoReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.database = reader.string();
                        break;
                    case 2:
                        message.collection = reader.string();
                        break;
                    case 3:
                        message.includeFullDocument = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MongoReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MongoReadArgs} MongoReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MongoReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MongoReadArgs message.
             * @function verify
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MongoReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                if (message.includeFullDocument != null && message.hasOwnProperty("includeFullDocument"))
                    if (typeof message.includeFullDocument !== "boolean")
                        return "includeFullDocument: boolean expected";
                return null;
            };

            /**
             * Creates a MongoReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MongoReadArgs} MongoReadArgs
             */
            MongoReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MongoReadArgs)
                    return object;
                var message = new $root.protos.args.MongoReadArgs();
                if (object.database != null)
                    message.database = String(object.database);
                if (object.collection != null)
                    message.collection = String(object.collection);
                if (object.includeFullDocument != null)
                    message.includeFullDocument = Boolean(object.includeFullDocument);
                return message;
            };

            /**
             * Creates a plain object from a MongoReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MongoReadArgs
             * @static
             * @param {protos.args.MongoReadArgs} message MongoReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MongoReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.database = "";
                    object.collection = "";
                    object.includeFullDocument = false;
                }
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                if (message.includeFullDocument != null && message.hasOwnProperty("includeFullDocument"))
                    object.includeFullDocument = message.includeFullDocument;
                return object;
            };

            /**
             * Converts this MongoReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.MongoReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MongoReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MongoReadArgs;
        })();

        /**
         * MQTTQoSLevel enum.
         * @name protos.args.MQTTQoSLevel
         * @enum {number}
         * @property {number} MQTT_QOS_LEVEL_AT_MOST_ONCE=0 MQTT_QOS_LEVEL_AT_MOST_ONCE value
         * @property {number} MQTT_QOS_LEVEL_AT_LEAST_ONCE=1 MQTT_QOS_LEVEL_AT_LEAST_ONCE value
         * @property {number} MQTT_QOS_LEVEL_EXACTLY_ONCE=2 MQTT_QOS_LEVEL_EXACTLY_ONCE value
         */
        args.MQTTQoSLevel = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "MQTT_QOS_LEVEL_AT_MOST_ONCE"] = 0;
            values[valuesById[1] = "MQTT_QOS_LEVEL_AT_LEAST_ONCE"] = 1;
            values[valuesById[2] = "MQTT_QOS_LEVEL_EXACTLY_ONCE"] = 2;
            return values;
        })();

        args.MQTTTLSOptions = (function() {

            /**
             * Properties of a MQTTTLSOptions.
             * @memberof protos.args
             * @interface IMQTTTLSOptions
             * @property {Uint8Array|null} [tlsCaCert] MQTTTLSOptions tlsCaCert
             * @property {Uint8Array|null} [tlsClientCert] MQTTTLSOptions tlsClientCert
             * @property {Uint8Array|null} [tlsClientKey] MQTTTLSOptions tlsClientKey
             * @property {boolean|null} [tlsSkipVerify] MQTTTLSOptions tlsSkipVerify
             */

            /**
             * Constructs a new MQTTTLSOptions.
             * @memberof protos.args
             * @classdesc Represents a MQTTTLSOptions.
             * @implements IMQTTTLSOptions
             * @constructor
             * @param {protos.args.IMQTTTLSOptions=} [properties] Properties to set
             */
            function MQTTTLSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MQTTTLSOptions tlsCaCert.
             * @member {Uint8Array} tlsCaCert
             * @memberof protos.args.MQTTTLSOptions
             * @instance
             */
            MQTTTLSOptions.prototype.tlsCaCert = $util.newBuffer([]);

            /**
             * MQTTTLSOptions tlsClientCert.
             * @member {Uint8Array} tlsClientCert
             * @memberof protos.args.MQTTTLSOptions
             * @instance
             */
            MQTTTLSOptions.prototype.tlsClientCert = $util.newBuffer([]);

            /**
             * MQTTTLSOptions tlsClientKey.
             * @member {Uint8Array} tlsClientKey
             * @memberof protos.args.MQTTTLSOptions
             * @instance
             */
            MQTTTLSOptions.prototype.tlsClientKey = $util.newBuffer([]);

            /**
             * MQTTTLSOptions tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.args.MQTTTLSOptions
             * @instance
             */
            MQTTTLSOptions.prototype.tlsSkipVerify = false;

            /**
             * Creates a new MQTTTLSOptions instance using the specified properties.
             * @function create
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {protos.args.IMQTTTLSOptions=} [properties] Properties to set
             * @returns {protos.args.MQTTTLSOptions} MQTTTLSOptions instance
             */
            MQTTTLSOptions.create = function create(properties) {
                return new MQTTTLSOptions(properties);
            };

            /**
             * Encodes the specified MQTTTLSOptions message. Does not implicitly {@link protos.args.MQTTTLSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {protos.args.IMQTTTLSOptions} message MQTTTLSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTTLSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tlsCaCert != null && Object.hasOwnProperty.call(message, "tlsCaCert"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.tlsCaCert);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.tlsClientCert);
                if (message.tlsClientKey != null && Object.hasOwnProperty.call(message, "tlsClientKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.tlsClientKey);
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.tlsSkipVerify);
                return writer;
            };

            /**
             * Encodes the specified MQTTTLSOptions message, length delimited. Does not implicitly {@link protos.args.MQTTTLSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {protos.args.IMQTTTLSOptions} message MQTTTLSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTTLSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MQTTTLSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MQTTTLSOptions} MQTTTLSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTTLSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MQTTTLSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tlsCaCert = reader.bytes();
                        break;
                    case 2:
                        message.tlsClientCert = reader.bytes();
                        break;
                    case 3:
                        message.tlsClientKey = reader.bytes();
                        break;
                    case 4:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MQTTTLSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MQTTTLSOptions} MQTTTLSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTTLSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MQTTTLSOptions message.
             * @function verify
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MQTTTLSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    if (!(message.tlsCaCert && typeof message.tlsCaCert.length === "number" || $util.isString(message.tlsCaCert)))
                        return "tlsCaCert: buffer expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!(message.tlsClientCert && typeof message.tlsClientCert.length === "number" || $util.isString(message.tlsClientCert)))
                        return "tlsClientCert: buffer expected";
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    if (!(message.tlsClientKey && typeof message.tlsClientKey.length === "number" || $util.isString(message.tlsClientKey)))
                        return "tlsClientKey: buffer expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                return null;
            };

            /**
             * Creates a MQTTTLSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MQTTTLSOptions} MQTTTLSOptions
             */
            MQTTTLSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MQTTTLSOptions)
                    return object;
                var message = new $root.protos.args.MQTTTLSOptions();
                if (object.tlsCaCert != null)
                    if (typeof object.tlsCaCert === "string")
                        $util.base64.decode(object.tlsCaCert, message.tlsCaCert = $util.newBuffer($util.base64.length(object.tlsCaCert)), 0);
                    else if (object.tlsCaCert.length)
                        message.tlsCaCert = object.tlsCaCert;
                if (object.tlsClientCert != null)
                    if (typeof object.tlsClientCert === "string")
                        $util.base64.decode(object.tlsClientCert, message.tlsClientCert = $util.newBuffer($util.base64.length(object.tlsClientCert)), 0);
                    else if (object.tlsClientCert.length)
                        message.tlsClientCert = object.tlsClientCert;
                if (object.tlsClientKey != null)
                    if (typeof object.tlsClientKey === "string")
                        $util.base64.decode(object.tlsClientKey, message.tlsClientKey = $util.newBuffer($util.base64.length(object.tlsClientKey)), 0);
                    else if (object.tlsClientKey.length)
                        message.tlsClientKey = object.tlsClientKey;
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                return message;
            };

            /**
             * Creates a plain object from a MQTTTLSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MQTTTLSOptions
             * @static
             * @param {protos.args.MQTTTLSOptions} message MQTTTLSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MQTTTLSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.tlsCaCert = "";
                    else {
                        object.tlsCaCert = [];
                        if (options.bytes !== Array)
                            object.tlsCaCert = $util.newBuffer(object.tlsCaCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientCert = "";
                    else {
                        object.tlsClientCert = [];
                        if (options.bytes !== Array)
                            object.tlsClientCert = $util.newBuffer(object.tlsClientCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientKey = "";
                    else {
                        object.tlsClientKey = [];
                        if (options.bytes !== Array)
                            object.tlsClientKey = $util.newBuffer(object.tlsClientKey);
                    }
                    object.tlsSkipVerify = false;
                }
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    object.tlsCaCert = options.bytes === String ? $util.base64.encode(message.tlsCaCert, 0, message.tlsCaCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsCaCert) : message.tlsCaCert;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = options.bytes === String ? $util.base64.encode(message.tlsClientCert, 0, message.tlsClientCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientCert) : message.tlsClientCert;
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    object.tlsClientKey = options.bytes === String ? $util.base64.encode(message.tlsClientKey, 0, message.tlsClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientKey) : message.tlsClientKey;
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                return object;
            };

            /**
             * Converts this MQTTTLSOptions to JSON.
             * @function toJSON
             * @memberof protos.args.MQTTTLSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MQTTTLSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MQTTTLSOptions;
        })();

        args.MQTTConn = (function() {

            /**
             * Properties of a MQTTConn.
             * @memberof protos.args
             * @interface IMQTTConn
             * @property {string|null} [address] MQTTConn address
             * @property {number|null} [connTimeoutSeconds] MQTTConn connTimeoutSeconds
             * @property {string|null} [clientId] MQTTConn clientId
             * @property {protos.args.MQTTQoSLevel|null} [qosLevel] MQTTConn qosLevel
             * @property {protos.args.IMQTTTLSOptions|null} [tlsOptions] MQTTConn tlsOptions
             */

            /**
             * Constructs a new MQTTConn.
             * @memberof protos.args
             * @classdesc Represents a MQTTConn.
             * @implements IMQTTConn
             * @constructor
             * @param {protos.args.IMQTTConn=} [properties] Properties to set
             */
            function MQTTConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MQTTConn address.
             * @member {string} address
             * @memberof protos.args.MQTTConn
             * @instance
             */
            MQTTConn.prototype.address = "";

            /**
             * MQTTConn connTimeoutSeconds.
             * @member {number} connTimeoutSeconds
             * @memberof protos.args.MQTTConn
             * @instance
             */
            MQTTConn.prototype.connTimeoutSeconds = 0;

            /**
             * MQTTConn clientId.
             * @member {string} clientId
             * @memberof protos.args.MQTTConn
             * @instance
             */
            MQTTConn.prototype.clientId = "";

            /**
             * MQTTConn qosLevel.
             * @member {protos.args.MQTTQoSLevel} qosLevel
             * @memberof protos.args.MQTTConn
             * @instance
             */
            MQTTConn.prototype.qosLevel = 0;

            /**
             * MQTTConn tlsOptions.
             * @member {protos.args.IMQTTTLSOptions|null|undefined} tlsOptions
             * @memberof protos.args.MQTTConn
             * @instance
             */
            MQTTConn.prototype.tlsOptions = null;

            /**
             * Creates a new MQTTConn instance using the specified properties.
             * @function create
             * @memberof protos.args.MQTTConn
             * @static
             * @param {protos.args.IMQTTConn=} [properties] Properties to set
             * @returns {protos.args.MQTTConn} MQTTConn instance
             */
            MQTTConn.create = function create(properties) {
                return new MQTTConn(properties);
            };

            /**
             * Encodes the specified MQTTConn message. Does not implicitly {@link protos.args.MQTTConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MQTTConn
             * @static
             * @param {protos.args.IMQTTConn} message MQTTConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.connTimeoutSeconds != null && Object.hasOwnProperty.call(message, "connTimeoutSeconds"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.connTimeoutSeconds);
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.clientId);
                if (message.qosLevel != null && Object.hasOwnProperty.call(message, "qosLevel"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.qosLevel);
                if (message.tlsOptions != null && Object.hasOwnProperty.call(message, "tlsOptions"))
                    $root.protos.args.MQTTTLSOptions.encode(message.tlsOptions, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MQTTConn message, length delimited. Does not implicitly {@link protos.args.MQTTConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MQTTConn
             * @static
             * @param {protos.args.IMQTTConn} message MQTTConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MQTTConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MQTTConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MQTTConn} MQTTConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MQTTConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 3:
                        message.connTimeoutSeconds = reader.uint32();
                        break;
                    case 4:
                        message.clientId = reader.string();
                        break;
                    case 5:
                        message.qosLevel = reader.int32();
                        break;
                    case 6:
                        message.tlsOptions = $root.protos.args.MQTTTLSOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MQTTConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MQTTConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MQTTConn} MQTTConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MQTTConn message.
             * @function verify
             * @memberof protos.args.MQTTConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MQTTConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.connTimeoutSeconds != null && message.hasOwnProperty("connTimeoutSeconds"))
                    if (!$util.isInteger(message.connTimeoutSeconds))
                        return "connTimeoutSeconds: integer expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                if (message.qosLevel != null && message.hasOwnProperty("qosLevel"))
                    switch (message.qosLevel) {
                    default:
                        return "qosLevel: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.tlsOptions != null && message.hasOwnProperty("tlsOptions")) {
                    var error = $root.protos.args.MQTTTLSOptions.verify(message.tlsOptions);
                    if (error)
                        return "tlsOptions." + error;
                }
                return null;
            };

            /**
             * Creates a MQTTConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MQTTConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MQTTConn} MQTTConn
             */
            MQTTConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MQTTConn)
                    return object;
                var message = new $root.protos.args.MQTTConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.connTimeoutSeconds != null)
                    message.connTimeoutSeconds = object.connTimeoutSeconds >>> 0;
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                switch (object.qosLevel) {
                case "MQTT_QOS_LEVEL_AT_MOST_ONCE":
                case 0:
                    message.qosLevel = 0;
                    break;
                case "MQTT_QOS_LEVEL_AT_LEAST_ONCE":
                case 1:
                    message.qosLevel = 1;
                    break;
                case "MQTT_QOS_LEVEL_EXACTLY_ONCE":
                case 2:
                    message.qosLevel = 2;
                    break;
                }
                if (object.tlsOptions != null) {
                    if (typeof object.tlsOptions !== "object")
                        throw TypeError(".protos.args.MQTTConn.tlsOptions: object expected");
                    message.tlsOptions = $root.protos.args.MQTTTLSOptions.fromObject(object.tlsOptions);
                }
                return message;
            };

            /**
             * Creates a plain object from a MQTTConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MQTTConn
             * @static
             * @param {protos.args.MQTTConn} message MQTTConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MQTTConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = "";
                    object.connTimeoutSeconds = 0;
                    object.clientId = "";
                    object.qosLevel = options.enums === String ? "MQTT_QOS_LEVEL_AT_MOST_ONCE" : 0;
                    object.tlsOptions = null;
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.connTimeoutSeconds != null && message.hasOwnProperty("connTimeoutSeconds"))
                    object.connTimeoutSeconds = message.connTimeoutSeconds;
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                if (message.qosLevel != null && message.hasOwnProperty("qosLevel"))
                    object.qosLevel = options.enums === String ? $root.protos.args.MQTTQoSLevel[message.qosLevel] : message.qosLevel;
                if (message.tlsOptions != null && message.hasOwnProperty("tlsOptions"))
                    object.tlsOptions = $root.protos.args.MQTTTLSOptions.toObject(message.tlsOptions, options);
                return object;
            };

            /**
             * Converts this MQTTConn to JSON.
             * @function toJSON
             * @memberof protos.args.MQTTConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MQTTConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MQTTConn;
        })();

        args.MQTTReadArgs = (function() {

            /**
             * Properties of a MQTTReadArgs.
             * @memberof protos.args
             * @interface IMQTTReadArgs
             * @property {string|null} [topic] MQTTReadArgs topic
             * @property {number|null} [readTimeoutSeconds] MQTTReadArgs readTimeoutSeconds
             */

            /**
             * Constructs a new MQTTReadArgs.
             * @memberof protos.args
             * @classdesc Represents a MQTTReadArgs.
             * @implements IMQTTReadArgs
             * @constructor
             * @param {protos.args.IMQTTReadArgs=} [properties] Properties to set
             */
            function MQTTReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MQTTReadArgs topic.
             * @member {string} topic
             * @memberof protos.args.MQTTReadArgs
             * @instance
             */
            MQTTReadArgs.prototype.topic = "";

            /**
             * MQTTReadArgs readTimeoutSeconds.
             * @member {number} readTimeoutSeconds
             * @memberof protos.args.MQTTReadArgs
             * @instance
             */
            MQTTReadArgs.prototype.readTimeoutSeconds = 0;

            /**
             * Creates a new MQTTReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {protos.args.IMQTTReadArgs=} [properties] Properties to set
             * @returns {protos.args.MQTTReadArgs} MQTTReadArgs instance
             */
            MQTTReadArgs.create = function create(properties) {
                return new MQTTReadArgs(properties);
            };

            /**
             * Encodes the specified MQTTReadArgs message. Does not implicitly {@link protos.args.MQTTReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {protos.args.IMQTTReadArgs} message MQTTReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.readTimeoutSeconds != null && Object.hasOwnProperty.call(message, "readTimeoutSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.readTimeoutSeconds);
                return writer;
            };

            /**
             * Encodes the specified MQTTReadArgs message, length delimited. Does not implicitly {@link protos.args.MQTTReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {protos.args.IMQTTReadArgs} message MQTTReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MQTTReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MQTTReadArgs} MQTTReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MQTTReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.readTimeoutSeconds = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MQTTReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MQTTReadArgs} MQTTReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MQTTReadArgs message.
             * @function verify
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MQTTReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.readTimeoutSeconds != null && message.hasOwnProperty("readTimeoutSeconds"))
                    if (!$util.isInteger(message.readTimeoutSeconds))
                        return "readTimeoutSeconds: integer expected";
                return null;
            };

            /**
             * Creates a MQTTReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MQTTReadArgs} MQTTReadArgs
             */
            MQTTReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MQTTReadArgs)
                    return object;
                var message = new $root.protos.args.MQTTReadArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.readTimeoutSeconds != null)
                    message.readTimeoutSeconds = object.readTimeoutSeconds >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a MQTTReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MQTTReadArgs
             * @static
             * @param {protos.args.MQTTReadArgs} message MQTTReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MQTTReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.readTimeoutSeconds = 0;
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.readTimeoutSeconds != null && message.hasOwnProperty("readTimeoutSeconds"))
                    object.readTimeoutSeconds = message.readTimeoutSeconds;
                return object;
            };

            /**
             * Converts this MQTTReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.MQTTReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MQTTReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MQTTReadArgs;
        })();

        args.MQTTWriteArgs = (function() {

            /**
             * Properties of a MQTTWriteArgs.
             * @memberof protos.args
             * @interface IMQTTWriteArgs
             * @property {string|null} [topic] MQTTWriteArgs topic
             * @property {number|null} [writeTimeoutSeconds] MQTTWriteArgs writeTimeoutSeconds
             */

            /**
             * Constructs a new MQTTWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a MQTTWriteArgs.
             * @implements IMQTTWriteArgs
             * @constructor
             * @param {protos.args.IMQTTWriteArgs=} [properties] Properties to set
             */
            function MQTTWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MQTTWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.MQTTWriteArgs
             * @instance
             */
            MQTTWriteArgs.prototype.topic = "";

            /**
             * MQTTWriteArgs writeTimeoutSeconds.
             * @member {number} writeTimeoutSeconds
             * @memberof protos.args.MQTTWriteArgs
             * @instance
             */
            MQTTWriteArgs.prototype.writeTimeoutSeconds = 0;

            /**
             * Creates a new MQTTWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {protos.args.IMQTTWriteArgs=} [properties] Properties to set
             * @returns {protos.args.MQTTWriteArgs} MQTTWriteArgs instance
             */
            MQTTWriteArgs.create = function create(properties) {
                return new MQTTWriteArgs(properties);
            };

            /**
             * Encodes the specified MQTTWriteArgs message. Does not implicitly {@link protos.args.MQTTWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {protos.args.IMQTTWriteArgs} message MQTTWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.writeTimeoutSeconds != null && Object.hasOwnProperty.call(message, "writeTimeoutSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.writeTimeoutSeconds);
                return writer;
            };

            /**
             * Encodes the specified MQTTWriteArgs message, length delimited. Does not implicitly {@link protos.args.MQTTWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {protos.args.IMQTTWriteArgs} message MQTTWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MQTTWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.MQTTWriteArgs} MQTTWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.MQTTWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.writeTimeoutSeconds = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MQTTWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.MQTTWriteArgs} MQTTWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MQTTWriteArgs message.
             * @function verify
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MQTTWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.writeTimeoutSeconds != null && message.hasOwnProperty("writeTimeoutSeconds"))
                    if (!$util.isInteger(message.writeTimeoutSeconds))
                        return "writeTimeoutSeconds: integer expected";
                return null;
            };

            /**
             * Creates a MQTTWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.MQTTWriteArgs} MQTTWriteArgs
             */
            MQTTWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.MQTTWriteArgs)
                    return object;
                var message = new $root.protos.args.MQTTWriteArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.writeTimeoutSeconds != null)
                    message.writeTimeoutSeconds = object.writeTimeoutSeconds >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a MQTTWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.MQTTWriteArgs
             * @static
             * @param {protos.args.MQTTWriteArgs} message MQTTWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MQTTWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.writeTimeoutSeconds = 0;
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.writeTimeoutSeconds != null && message.hasOwnProperty("writeTimeoutSeconds"))
                    object.writeTimeoutSeconds = message.writeTimeoutSeconds;
                return object;
            };

            /**
             * Converts this MQTTWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.MQTTWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MQTTWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MQTTWriteArgs;
        })();

        args.NatsConn = (function() {

            /**
             * Properties of a NatsConn.
             * @memberof protos.args
             * @interface INatsConn
             * @property {string|null} [dsn] NatsConn dsn
             * @property {Uint8Array|null} [userCredentials] NatsConn userCredentials
             * @property {protos.args.INatsTLSOptions|null} [tlsOptions] NatsConn tlsOptions
             */

            /**
             * Constructs a new NatsConn.
             * @memberof protos.args
             * @classdesc Represents a NatsConn.
             * @implements INatsConn
             * @constructor
             * @param {protos.args.INatsConn=} [properties] Properties to set
             */
            function NatsConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsConn dsn.
             * @member {string} dsn
             * @memberof protos.args.NatsConn
             * @instance
             */
            NatsConn.prototype.dsn = "";

            /**
             * NatsConn userCredentials.
             * @member {Uint8Array} userCredentials
             * @memberof protos.args.NatsConn
             * @instance
             */
            NatsConn.prototype.userCredentials = $util.newBuffer([]);

            /**
             * NatsConn tlsOptions.
             * @member {protos.args.INatsTLSOptions|null|undefined} tlsOptions
             * @memberof protos.args.NatsConn
             * @instance
             */
            NatsConn.prototype.tlsOptions = null;

            /**
             * Creates a new NatsConn instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsConn
             * @static
             * @param {protos.args.INatsConn=} [properties] Properties to set
             * @returns {protos.args.NatsConn} NatsConn instance
             */
            NatsConn.create = function create(properties) {
                return new NatsConn(properties);
            };

            /**
             * Encodes the specified NatsConn message. Does not implicitly {@link protos.args.NatsConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsConn
             * @static
             * @param {protos.args.INatsConn} message NatsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                if (message.userCredentials != null && Object.hasOwnProperty.call(message, "userCredentials"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.userCredentials);
                if (message.tlsOptions != null && Object.hasOwnProperty.call(message, "tlsOptions"))
                    $root.protos.args.NatsTLSOptions.encode(message.tlsOptions, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NatsConn message, length delimited. Does not implicitly {@link protos.args.NatsConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsConn
             * @static
             * @param {protos.args.INatsConn} message NatsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsConn} NatsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    case 2:
                        message.userCredentials = reader.bytes();
                        break;
                    case 3:
                        message.tlsOptions = $root.protos.args.NatsTLSOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsConn} NatsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsConn message.
             * @function verify
             * @memberof protos.args.NatsConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                if (message.userCredentials != null && message.hasOwnProperty("userCredentials"))
                    if (!(message.userCredentials && typeof message.userCredentials.length === "number" || $util.isString(message.userCredentials)))
                        return "userCredentials: buffer expected";
                if (message.tlsOptions != null && message.hasOwnProperty("tlsOptions")) {
                    var error = $root.protos.args.NatsTLSOptions.verify(message.tlsOptions);
                    if (error)
                        return "tlsOptions." + error;
                }
                return null;
            };

            /**
             * Creates a NatsConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsConn} NatsConn
             */
            NatsConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsConn)
                    return object;
                var message = new $root.protos.args.NatsConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                if (object.userCredentials != null)
                    if (typeof object.userCredentials === "string")
                        $util.base64.decode(object.userCredentials, message.userCredentials = $util.newBuffer($util.base64.length(object.userCredentials)), 0);
                    else if (object.userCredentials.length)
                        message.userCredentials = object.userCredentials;
                if (object.tlsOptions != null) {
                    if (typeof object.tlsOptions !== "object")
                        throw TypeError(".protos.args.NatsConn.tlsOptions: object expected");
                    message.tlsOptions = $root.protos.args.NatsTLSOptions.fromObject(object.tlsOptions);
                }
                return message;
            };

            /**
             * Creates a plain object from a NatsConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsConn
             * @static
             * @param {protos.args.NatsConn} message NatsConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.dsn = "";
                    if (options.bytes === String)
                        object.userCredentials = "";
                    else {
                        object.userCredentials = [];
                        if (options.bytes !== Array)
                            object.userCredentials = $util.newBuffer(object.userCredentials);
                    }
                    object.tlsOptions = null;
                }
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                if (message.userCredentials != null && message.hasOwnProperty("userCredentials"))
                    object.userCredentials = options.bytes === String ? $util.base64.encode(message.userCredentials, 0, message.userCredentials.length) : options.bytes === Array ? Array.prototype.slice.call(message.userCredentials) : message.userCredentials;
                if (message.tlsOptions != null && message.hasOwnProperty("tlsOptions"))
                    object.tlsOptions = $root.protos.args.NatsTLSOptions.toObject(message.tlsOptions, options);
                return object;
            };

            /**
             * Converts this NatsConn to JSON.
             * @function toJSON
             * @memberof protos.args.NatsConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsConn;
        })();

        args.NatsTLSOptions = (function() {

            /**
             * Properties of a NatsTLSOptions.
             * @memberof protos.args
             * @interface INatsTLSOptions
             * @property {boolean|null} [tlsSkipVerify] NatsTLSOptions tlsSkipVerify
             * @property {Uint8Array|null} [tlsCaCert] NatsTLSOptions tlsCaCert
             * @property {Uint8Array|null} [tlsClientCert] NatsTLSOptions tlsClientCert
             * @property {Uint8Array|null} [tlsClientKey] NatsTLSOptions tlsClientKey
             */

            /**
             * Constructs a new NatsTLSOptions.
             * @memberof protos.args
             * @classdesc Represents a NatsTLSOptions.
             * @implements INatsTLSOptions
             * @constructor
             * @param {protos.args.INatsTLSOptions=} [properties] Properties to set
             */
            function NatsTLSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsTLSOptions tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.args.NatsTLSOptions
             * @instance
             */
            NatsTLSOptions.prototype.tlsSkipVerify = false;

            /**
             * NatsTLSOptions tlsCaCert.
             * @member {Uint8Array} tlsCaCert
             * @memberof protos.args.NatsTLSOptions
             * @instance
             */
            NatsTLSOptions.prototype.tlsCaCert = $util.newBuffer([]);

            /**
             * NatsTLSOptions tlsClientCert.
             * @member {Uint8Array} tlsClientCert
             * @memberof protos.args.NatsTLSOptions
             * @instance
             */
            NatsTLSOptions.prototype.tlsClientCert = $util.newBuffer([]);

            /**
             * NatsTLSOptions tlsClientKey.
             * @member {Uint8Array} tlsClientKey
             * @memberof protos.args.NatsTLSOptions
             * @instance
             */
            NatsTLSOptions.prototype.tlsClientKey = $util.newBuffer([]);

            /**
             * Creates a new NatsTLSOptions instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsTLSOptions
             * @static
             * @param {protos.args.INatsTLSOptions=} [properties] Properties to set
             * @returns {protos.args.NatsTLSOptions} NatsTLSOptions instance
             */
            NatsTLSOptions.create = function create(properties) {
                return new NatsTLSOptions(properties);
            };

            /**
             * Encodes the specified NatsTLSOptions message. Does not implicitly {@link protos.args.NatsTLSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsTLSOptions
             * @static
             * @param {protos.args.INatsTLSOptions} message NatsTLSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsTLSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.tlsSkipVerify);
                if (message.tlsCaCert != null && Object.hasOwnProperty.call(message, "tlsCaCert"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.tlsCaCert);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.tlsClientCert);
                if (message.tlsClientKey != null && Object.hasOwnProperty.call(message, "tlsClientKey"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.tlsClientKey);
                return writer;
            };

            /**
             * Encodes the specified NatsTLSOptions message, length delimited. Does not implicitly {@link protos.args.NatsTLSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsTLSOptions
             * @static
             * @param {protos.args.INatsTLSOptions} message NatsTLSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsTLSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsTLSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsTLSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsTLSOptions} NatsTLSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsTLSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsTLSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    case 2:
                        message.tlsCaCert = reader.bytes();
                        break;
                    case 3:
                        message.tlsClientCert = reader.bytes();
                        break;
                    case 4:
                        message.tlsClientKey = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsTLSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsTLSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsTLSOptions} NatsTLSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsTLSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsTLSOptions message.
             * @function verify
             * @memberof protos.args.NatsTLSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsTLSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    if (!(message.tlsCaCert && typeof message.tlsCaCert.length === "number" || $util.isString(message.tlsCaCert)))
                        return "tlsCaCert: buffer expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!(message.tlsClientCert && typeof message.tlsClientCert.length === "number" || $util.isString(message.tlsClientCert)))
                        return "tlsClientCert: buffer expected";
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    if (!(message.tlsClientKey && typeof message.tlsClientKey.length === "number" || $util.isString(message.tlsClientKey)))
                        return "tlsClientKey: buffer expected";
                return null;
            };

            /**
             * Creates a NatsTLSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsTLSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsTLSOptions} NatsTLSOptions
             */
            NatsTLSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsTLSOptions)
                    return object;
                var message = new $root.protos.args.NatsTLSOptions();
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                if (object.tlsCaCert != null)
                    if (typeof object.tlsCaCert === "string")
                        $util.base64.decode(object.tlsCaCert, message.tlsCaCert = $util.newBuffer($util.base64.length(object.tlsCaCert)), 0);
                    else if (object.tlsCaCert.length)
                        message.tlsCaCert = object.tlsCaCert;
                if (object.tlsClientCert != null)
                    if (typeof object.tlsClientCert === "string")
                        $util.base64.decode(object.tlsClientCert, message.tlsClientCert = $util.newBuffer($util.base64.length(object.tlsClientCert)), 0);
                    else if (object.tlsClientCert.length)
                        message.tlsClientCert = object.tlsClientCert;
                if (object.tlsClientKey != null)
                    if (typeof object.tlsClientKey === "string")
                        $util.base64.decode(object.tlsClientKey, message.tlsClientKey = $util.newBuffer($util.base64.length(object.tlsClientKey)), 0);
                    else if (object.tlsClientKey.length)
                        message.tlsClientKey = object.tlsClientKey;
                return message;
            };

            /**
             * Creates a plain object from a NatsTLSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsTLSOptions
             * @static
             * @param {protos.args.NatsTLSOptions} message NatsTLSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsTLSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tlsSkipVerify = false;
                    if (options.bytes === String)
                        object.tlsCaCert = "";
                    else {
                        object.tlsCaCert = [];
                        if (options.bytes !== Array)
                            object.tlsCaCert = $util.newBuffer(object.tlsCaCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientCert = "";
                    else {
                        object.tlsClientCert = [];
                        if (options.bytes !== Array)
                            object.tlsClientCert = $util.newBuffer(object.tlsClientCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientKey = "";
                    else {
                        object.tlsClientKey = [];
                        if (options.bytes !== Array)
                            object.tlsClientKey = $util.newBuffer(object.tlsClientKey);
                    }
                }
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    object.tlsCaCert = options.bytes === String ? $util.base64.encode(message.tlsCaCert, 0, message.tlsCaCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsCaCert) : message.tlsCaCert;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = options.bytes === String ? $util.base64.encode(message.tlsClientCert, 0, message.tlsClientCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientCert) : message.tlsClientCert;
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    object.tlsClientKey = options.bytes === String ? $util.base64.encode(message.tlsClientKey, 0, message.tlsClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientKey) : message.tlsClientKey;
                return object;
            };

            /**
             * Converts this NatsTLSOptions to JSON.
             * @function toJSON
             * @memberof protos.args.NatsTLSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsTLSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsTLSOptions;
        })();

        args.NatsReadArgs = (function() {

            /**
             * Properties of a NatsReadArgs.
             * @memberof protos.args
             * @interface INatsReadArgs
             * @property {string|null} [subject] NatsReadArgs subject
             */

            /**
             * Constructs a new NatsReadArgs.
             * @memberof protos.args
             * @classdesc Represents a NatsReadArgs.
             * @implements INatsReadArgs
             * @constructor
             * @param {protos.args.INatsReadArgs=} [properties] Properties to set
             */
            function NatsReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsReadArgs subject.
             * @member {string} subject
             * @memberof protos.args.NatsReadArgs
             * @instance
             */
            NatsReadArgs.prototype.subject = "";

            /**
             * Creates a new NatsReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {protos.args.INatsReadArgs=} [properties] Properties to set
             * @returns {protos.args.NatsReadArgs} NatsReadArgs instance
             */
            NatsReadArgs.create = function create(properties) {
                return new NatsReadArgs(properties);
            };

            /**
             * Encodes the specified NatsReadArgs message. Does not implicitly {@link protos.args.NatsReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {protos.args.INatsReadArgs} message NatsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.subject);
                return writer;
            };

            /**
             * Encodes the specified NatsReadArgs message, length delimited. Does not implicitly {@link protos.args.NatsReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {protos.args.INatsReadArgs} message NatsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsReadArgs} NatsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subject = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsReadArgs} NatsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsReadArgs message.
             * @function verify
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    if (!$util.isString(message.subject))
                        return "subject: string expected";
                return null;
            };

            /**
             * Creates a NatsReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsReadArgs} NatsReadArgs
             */
            NatsReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsReadArgs)
                    return object;
                var message = new $root.protos.args.NatsReadArgs();
                if (object.subject != null)
                    message.subject = String(object.subject);
                return message;
            };

            /**
             * Creates a plain object from a NatsReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsReadArgs
             * @static
             * @param {protos.args.NatsReadArgs} message NatsReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.subject = "";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    object.subject = message.subject;
                return object;
            };

            /**
             * Converts this NatsReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NatsReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsReadArgs;
        })();

        args.NatsWriteArgs = (function() {

            /**
             * Properties of a NatsWriteArgs.
             * @memberof protos.args
             * @interface INatsWriteArgs
             * @property {string|null} [subject] NatsWriteArgs subject
             */

            /**
             * Constructs a new NatsWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a NatsWriteArgs.
             * @implements INatsWriteArgs
             * @constructor
             * @param {protos.args.INatsWriteArgs=} [properties] Properties to set
             */
            function NatsWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsWriteArgs subject.
             * @member {string} subject
             * @memberof protos.args.NatsWriteArgs
             * @instance
             */
            NatsWriteArgs.prototype.subject = "";

            /**
             * Creates a new NatsWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {protos.args.INatsWriteArgs=} [properties] Properties to set
             * @returns {protos.args.NatsWriteArgs} NatsWriteArgs instance
             */
            NatsWriteArgs.create = function create(properties) {
                return new NatsWriteArgs(properties);
            };

            /**
             * Encodes the specified NatsWriteArgs message. Does not implicitly {@link protos.args.NatsWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {protos.args.INatsWriteArgs} message NatsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.subject);
                return writer;
            };

            /**
             * Encodes the specified NatsWriteArgs message, length delimited. Does not implicitly {@link protos.args.NatsWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {protos.args.INatsWriteArgs} message NatsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsWriteArgs} NatsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subject = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsWriteArgs} NatsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsWriteArgs message.
             * @function verify
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    if (!$util.isString(message.subject))
                        return "subject: string expected";
                return null;
            };

            /**
             * Creates a NatsWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsWriteArgs} NatsWriteArgs
             */
            NatsWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsWriteArgs)
                    return object;
                var message = new $root.protos.args.NatsWriteArgs();
                if (object.subject != null)
                    message.subject = String(object.subject);
                return message;
            };

            /**
             * Creates a plain object from a NatsWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsWriteArgs
             * @static
             * @param {protos.args.NatsWriteArgs} message NatsWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.subject = "";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    object.subject = message.subject;
                return object;
            };

            /**
             * Converts this NatsWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NatsWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsWriteArgs;
        })();

        args.NatsJetstreamTLSOptions = (function() {

            /**
             * Properties of a NatsJetstreamTLSOptions.
             * @memberof protos.args
             * @interface INatsJetstreamTLSOptions
             * @property {Uint8Array|null} [tlsCaCert] NatsJetstreamTLSOptions tlsCaCert
             * @property {Uint8Array|null} [tlsClientCert] NatsJetstreamTLSOptions tlsClientCert
             * @property {Uint8Array|null} [tlsClientKey] NatsJetstreamTLSOptions tlsClientKey
             * @property {boolean|null} [tlsSkipVerify] NatsJetstreamTLSOptions tlsSkipVerify
             */

            /**
             * Constructs a new NatsJetstreamTLSOptions.
             * @memberof protos.args
             * @classdesc Represents a NatsJetstreamTLSOptions.
             * @implements INatsJetstreamTLSOptions
             * @constructor
             * @param {protos.args.INatsJetstreamTLSOptions=} [properties] Properties to set
             */
            function NatsJetstreamTLSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsJetstreamTLSOptions tlsCaCert.
             * @member {Uint8Array} tlsCaCert
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @instance
             */
            NatsJetstreamTLSOptions.prototype.tlsCaCert = $util.newBuffer([]);

            /**
             * NatsJetstreamTLSOptions tlsClientCert.
             * @member {Uint8Array} tlsClientCert
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @instance
             */
            NatsJetstreamTLSOptions.prototype.tlsClientCert = $util.newBuffer([]);

            /**
             * NatsJetstreamTLSOptions tlsClientKey.
             * @member {Uint8Array} tlsClientKey
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @instance
             */
            NatsJetstreamTLSOptions.prototype.tlsClientKey = $util.newBuffer([]);

            /**
             * NatsJetstreamTLSOptions tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @instance
             */
            NatsJetstreamTLSOptions.prototype.tlsSkipVerify = false;

            /**
             * Creates a new NatsJetstreamTLSOptions instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @static
             * @param {protos.args.INatsJetstreamTLSOptions=} [properties] Properties to set
             * @returns {protos.args.NatsJetstreamTLSOptions} NatsJetstreamTLSOptions instance
             */
            NatsJetstreamTLSOptions.create = function create(properties) {
                return new NatsJetstreamTLSOptions(properties);
            };

            /**
             * Encodes the specified NatsJetstreamTLSOptions message. Does not implicitly {@link protos.args.NatsJetstreamTLSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @static
             * @param {protos.args.INatsJetstreamTLSOptions} message NatsJetstreamTLSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsJetstreamTLSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tlsCaCert != null && Object.hasOwnProperty.call(message, "tlsCaCert"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.tlsCaCert);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.tlsClientCert);
                if (message.tlsClientKey != null && Object.hasOwnProperty.call(message, "tlsClientKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.tlsClientKey);
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.tlsSkipVerify);
                return writer;
            };

            /**
             * Encodes the specified NatsJetstreamTLSOptions message, length delimited. Does not implicitly {@link protos.args.NatsJetstreamTLSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @static
             * @param {protos.args.INatsJetstreamTLSOptions} message NatsJetstreamTLSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsJetstreamTLSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsJetstreamTLSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsJetstreamTLSOptions} NatsJetstreamTLSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsJetstreamTLSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsJetstreamTLSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tlsCaCert = reader.bytes();
                        break;
                    case 2:
                        message.tlsClientCert = reader.bytes();
                        break;
                    case 3:
                        message.tlsClientKey = reader.bytes();
                        break;
                    case 4:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsJetstreamTLSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsJetstreamTLSOptions} NatsJetstreamTLSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsJetstreamTLSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsJetstreamTLSOptions message.
             * @function verify
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsJetstreamTLSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    if (!(message.tlsCaCert && typeof message.tlsCaCert.length === "number" || $util.isString(message.tlsCaCert)))
                        return "tlsCaCert: buffer expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!(message.tlsClientCert && typeof message.tlsClientCert.length === "number" || $util.isString(message.tlsClientCert)))
                        return "tlsClientCert: buffer expected";
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    if (!(message.tlsClientKey && typeof message.tlsClientKey.length === "number" || $util.isString(message.tlsClientKey)))
                        return "tlsClientKey: buffer expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                return null;
            };

            /**
             * Creates a NatsJetstreamTLSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsJetstreamTLSOptions} NatsJetstreamTLSOptions
             */
            NatsJetstreamTLSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsJetstreamTLSOptions)
                    return object;
                var message = new $root.protos.args.NatsJetstreamTLSOptions();
                if (object.tlsCaCert != null)
                    if (typeof object.tlsCaCert === "string")
                        $util.base64.decode(object.tlsCaCert, message.tlsCaCert = $util.newBuffer($util.base64.length(object.tlsCaCert)), 0);
                    else if (object.tlsCaCert.length)
                        message.tlsCaCert = object.tlsCaCert;
                if (object.tlsClientCert != null)
                    if (typeof object.tlsClientCert === "string")
                        $util.base64.decode(object.tlsClientCert, message.tlsClientCert = $util.newBuffer($util.base64.length(object.tlsClientCert)), 0);
                    else if (object.tlsClientCert.length)
                        message.tlsClientCert = object.tlsClientCert;
                if (object.tlsClientKey != null)
                    if (typeof object.tlsClientKey === "string")
                        $util.base64.decode(object.tlsClientKey, message.tlsClientKey = $util.newBuffer($util.base64.length(object.tlsClientKey)), 0);
                    else if (object.tlsClientKey.length)
                        message.tlsClientKey = object.tlsClientKey;
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                return message;
            };

            /**
             * Creates a plain object from a NatsJetstreamTLSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @static
             * @param {protos.args.NatsJetstreamTLSOptions} message NatsJetstreamTLSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsJetstreamTLSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.tlsCaCert = "";
                    else {
                        object.tlsCaCert = [];
                        if (options.bytes !== Array)
                            object.tlsCaCert = $util.newBuffer(object.tlsCaCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientCert = "";
                    else {
                        object.tlsClientCert = [];
                        if (options.bytes !== Array)
                            object.tlsClientCert = $util.newBuffer(object.tlsClientCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientKey = "";
                    else {
                        object.tlsClientKey = [];
                        if (options.bytes !== Array)
                            object.tlsClientKey = $util.newBuffer(object.tlsClientKey);
                    }
                    object.tlsSkipVerify = false;
                }
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    object.tlsCaCert = options.bytes === String ? $util.base64.encode(message.tlsCaCert, 0, message.tlsCaCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsCaCert) : message.tlsCaCert;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = options.bytes === String ? $util.base64.encode(message.tlsClientCert, 0, message.tlsClientCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientCert) : message.tlsClientCert;
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    object.tlsClientKey = options.bytes === String ? $util.base64.encode(message.tlsClientKey, 0, message.tlsClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientKey) : message.tlsClientKey;
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                return object;
            };

            /**
             * Converts this NatsJetstreamTLSOptions to JSON.
             * @function toJSON
             * @memberof protos.args.NatsJetstreamTLSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsJetstreamTLSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsJetstreamTLSOptions;
        })();

        args.NatsJetstreamConn = (function() {

            /**
             * Properties of a NatsJetstreamConn.
             * @memberof protos.args
             * @interface INatsJetstreamConn
             * @property {string|null} [dsn] NatsJetstreamConn dsn
             * @property {Uint8Array|null} [userCredentials] NatsJetstreamConn userCredentials
             * @property {string|null} [clientId] NatsJetstreamConn clientId
             * @property {protos.args.INatsJetstreamTLSOptions|null} [tlsOptions] NatsJetstreamConn tlsOptions
             */

            /**
             * Constructs a new NatsJetstreamConn.
             * @memberof protos.args
             * @classdesc Represents a NatsJetstreamConn.
             * @implements INatsJetstreamConn
             * @constructor
             * @param {protos.args.INatsJetstreamConn=} [properties] Properties to set
             */
            function NatsJetstreamConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsJetstreamConn dsn.
             * @member {string} dsn
             * @memberof protos.args.NatsJetstreamConn
             * @instance
             */
            NatsJetstreamConn.prototype.dsn = "";

            /**
             * NatsJetstreamConn userCredentials.
             * @member {Uint8Array} userCredentials
             * @memberof protos.args.NatsJetstreamConn
             * @instance
             */
            NatsJetstreamConn.prototype.userCredentials = $util.newBuffer([]);

            /**
             * NatsJetstreamConn clientId.
             * @member {string} clientId
             * @memberof protos.args.NatsJetstreamConn
             * @instance
             */
            NatsJetstreamConn.prototype.clientId = "";

            /**
             * NatsJetstreamConn tlsOptions.
             * @member {protos.args.INatsJetstreamTLSOptions|null|undefined} tlsOptions
             * @memberof protos.args.NatsJetstreamConn
             * @instance
             */
            NatsJetstreamConn.prototype.tlsOptions = null;

            /**
             * Creates a new NatsJetstreamConn instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsJetstreamConn
             * @static
             * @param {protos.args.INatsJetstreamConn=} [properties] Properties to set
             * @returns {protos.args.NatsJetstreamConn} NatsJetstreamConn instance
             */
            NatsJetstreamConn.create = function create(properties) {
                return new NatsJetstreamConn(properties);
            };

            /**
             * Encodes the specified NatsJetstreamConn message. Does not implicitly {@link protos.args.NatsJetstreamConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsJetstreamConn
             * @static
             * @param {protos.args.INatsJetstreamConn} message NatsJetstreamConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsJetstreamConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                if (message.userCredentials != null && Object.hasOwnProperty.call(message, "userCredentials"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.userCredentials);
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.clientId);
                if (message.tlsOptions != null && Object.hasOwnProperty.call(message, "tlsOptions"))
                    $root.protos.args.NatsJetstreamTLSOptions.encode(message.tlsOptions, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NatsJetstreamConn message, length delimited. Does not implicitly {@link protos.args.NatsJetstreamConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsJetstreamConn
             * @static
             * @param {protos.args.INatsJetstreamConn} message NatsJetstreamConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsJetstreamConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsJetstreamConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsJetstreamConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsJetstreamConn} NatsJetstreamConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsJetstreamConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsJetstreamConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    case 2:
                        message.userCredentials = reader.bytes();
                        break;
                    case 3:
                        message.clientId = reader.string();
                        break;
                    case 4:
                        message.tlsOptions = $root.protos.args.NatsJetstreamTLSOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsJetstreamConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsJetstreamConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsJetstreamConn} NatsJetstreamConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsJetstreamConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsJetstreamConn message.
             * @function verify
             * @memberof protos.args.NatsJetstreamConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsJetstreamConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                if (message.userCredentials != null && message.hasOwnProperty("userCredentials"))
                    if (!(message.userCredentials && typeof message.userCredentials.length === "number" || $util.isString(message.userCredentials)))
                        return "userCredentials: buffer expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                if (message.tlsOptions != null && message.hasOwnProperty("tlsOptions")) {
                    var error = $root.protos.args.NatsJetstreamTLSOptions.verify(message.tlsOptions);
                    if (error)
                        return "tlsOptions." + error;
                }
                return null;
            };

            /**
             * Creates a NatsJetstreamConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsJetstreamConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsJetstreamConn} NatsJetstreamConn
             */
            NatsJetstreamConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsJetstreamConn)
                    return object;
                var message = new $root.protos.args.NatsJetstreamConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                if (object.userCredentials != null)
                    if (typeof object.userCredentials === "string")
                        $util.base64.decode(object.userCredentials, message.userCredentials = $util.newBuffer($util.base64.length(object.userCredentials)), 0);
                    else if (object.userCredentials.length)
                        message.userCredentials = object.userCredentials;
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                if (object.tlsOptions != null) {
                    if (typeof object.tlsOptions !== "object")
                        throw TypeError(".protos.args.NatsJetstreamConn.tlsOptions: object expected");
                    message.tlsOptions = $root.protos.args.NatsJetstreamTLSOptions.fromObject(object.tlsOptions);
                }
                return message;
            };

            /**
             * Creates a plain object from a NatsJetstreamConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsJetstreamConn
             * @static
             * @param {protos.args.NatsJetstreamConn} message NatsJetstreamConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsJetstreamConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.dsn = "";
                    if (options.bytes === String)
                        object.userCredentials = "";
                    else {
                        object.userCredentials = [];
                        if (options.bytes !== Array)
                            object.userCredentials = $util.newBuffer(object.userCredentials);
                    }
                    object.clientId = "";
                    object.tlsOptions = null;
                }
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                if (message.userCredentials != null && message.hasOwnProperty("userCredentials"))
                    object.userCredentials = options.bytes === String ? $util.base64.encode(message.userCredentials, 0, message.userCredentials.length) : options.bytes === Array ? Array.prototype.slice.call(message.userCredentials) : message.userCredentials;
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                if (message.tlsOptions != null && message.hasOwnProperty("tlsOptions"))
                    object.tlsOptions = $root.protos.args.NatsJetstreamTLSOptions.toObject(message.tlsOptions, options);
                return object;
            };

            /**
             * Converts this NatsJetstreamConn to JSON.
             * @function toJSON
             * @memberof protos.args.NatsJetstreamConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsJetstreamConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsJetstreamConn;
        })();

        args.NatsJetstreamReadArgs = (function() {

            /**
             * Properties of a NatsJetstreamReadArgs.
             * @memberof protos.args
             * @interface INatsJetstreamReadArgs
             * @property {string|null} [stream] NatsJetstreamReadArgs stream
             */

            /**
             * Constructs a new NatsJetstreamReadArgs.
             * @memberof protos.args
             * @classdesc Represents a NatsJetstreamReadArgs.
             * @implements INatsJetstreamReadArgs
             * @constructor
             * @param {protos.args.INatsJetstreamReadArgs=} [properties] Properties to set
             */
            function NatsJetstreamReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsJetstreamReadArgs stream.
             * @member {string} stream
             * @memberof protos.args.NatsJetstreamReadArgs
             * @instance
             */
            NatsJetstreamReadArgs.prototype.stream = "";

            /**
             * Creates a new NatsJetstreamReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsJetstreamReadArgs
             * @static
             * @param {protos.args.INatsJetstreamReadArgs=} [properties] Properties to set
             * @returns {protos.args.NatsJetstreamReadArgs} NatsJetstreamReadArgs instance
             */
            NatsJetstreamReadArgs.create = function create(properties) {
                return new NatsJetstreamReadArgs(properties);
            };

            /**
             * Encodes the specified NatsJetstreamReadArgs message. Does not implicitly {@link protos.args.NatsJetstreamReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsJetstreamReadArgs
             * @static
             * @param {protos.args.INatsJetstreamReadArgs} message NatsJetstreamReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsJetstreamReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stream);
                return writer;
            };

            /**
             * Encodes the specified NatsJetstreamReadArgs message, length delimited. Does not implicitly {@link protos.args.NatsJetstreamReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsJetstreamReadArgs
             * @static
             * @param {protos.args.INatsJetstreamReadArgs} message NatsJetstreamReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsJetstreamReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsJetstreamReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsJetstreamReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsJetstreamReadArgs} NatsJetstreamReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsJetstreamReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsJetstreamReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stream = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsJetstreamReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsJetstreamReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsJetstreamReadArgs} NatsJetstreamReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsJetstreamReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsJetstreamReadArgs message.
             * @function verify
             * @memberof protos.args.NatsJetstreamReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsJetstreamReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isString(message.stream))
                        return "stream: string expected";
                return null;
            };

            /**
             * Creates a NatsJetstreamReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsJetstreamReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsJetstreamReadArgs} NatsJetstreamReadArgs
             */
            NatsJetstreamReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsJetstreamReadArgs)
                    return object;
                var message = new $root.protos.args.NatsJetstreamReadArgs();
                if (object.stream != null)
                    message.stream = String(object.stream);
                return message;
            };

            /**
             * Creates a plain object from a NatsJetstreamReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsJetstreamReadArgs
             * @static
             * @param {protos.args.NatsJetstreamReadArgs} message NatsJetstreamReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsJetstreamReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.stream = "";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                return object;
            };

            /**
             * Converts this NatsJetstreamReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NatsJetstreamReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsJetstreamReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsJetstreamReadArgs;
        })();

        args.NatsJetstreamWriteArgs = (function() {

            /**
             * Properties of a NatsJetstreamWriteArgs.
             * @memberof protos.args
             * @interface INatsJetstreamWriteArgs
             * @property {string|null} [stream] NatsJetstreamWriteArgs stream
             */

            /**
             * Constructs a new NatsJetstreamWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a NatsJetstreamWriteArgs.
             * @implements INatsJetstreamWriteArgs
             * @constructor
             * @param {protos.args.INatsJetstreamWriteArgs=} [properties] Properties to set
             */
            function NatsJetstreamWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsJetstreamWriteArgs stream.
             * @member {string} stream
             * @memberof protos.args.NatsJetstreamWriteArgs
             * @instance
             */
            NatsJetstreamWriteArgs.prototype.stream = "";

            /**
             * Creates a new NatsJetstreamWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsJetstreamWriteArgs
             * @static
             * @param {protos.args.INatsJetstreamWriteArgs=} [properties] Properties to set
             * @returns {protos.args.NatsJetstreamWriteArgs} NatsJetstreamWriteArgs instance
             */
            NatsJetstreamWriteArgs.create = function create(properties) {
                return new NatsJetstreamWriteArgs(properties);
            };

            /**
             * Encodes the specified NatsJetstreamWriteArgs message. Does not implicitly {@link protos.args.NatsJetstreamWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsJetstreamWriteArgs
             * @static
             * @param {protos.args.INatsJetstreamWriteArgs} message NatsJetstreamWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsJetstreamWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stream);
                return writer;
            };

            /**
             * Encodes the specified NatsJetstreamWriteArgs message, length delimited. Does not implicitly {@link protos.args.NatsJetstreamWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsJetstreamWriteArgs
             * @static
             * @param {protos.args.INatsJetstreamWriteArgs} message NatsJetstreamWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsJetstreamWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsJetstreamWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsJetstreamWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsJetstreamWriteArgs} NatsJetstreamWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsJetstreamWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsJetstreamWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stream = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsJetstreamWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsJetstreamWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsJetstreamWriteArgs} NatsJetstreamWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsJetstreamWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsJetstreamWriteArgs message.
             * @function verify
             * @memberof protos.args.NatsJetstreamWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsJetstreamWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isString(message.stream))
                        return "stream: string expected";
                return null;
            };

            /**
             * Creates a NatsJetstreamWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsJetstreamWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsJetstreamWriteArgs} NatsJetstreamWriteArgs
             */
            NatsJetstreamWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsJetstreamWriteArgs)
                    return object;
                var message = new $root.protos.args.NatsJetstreamWriteArgs();
                if (object.stream != null)
                    message.stream = String(object.stream);
                return message;
            };

            /**
             * Creates a plain object from a NatsJetstreamWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsJetstreamWriteArgs
             * @static
             * @param {protos.args.NatsJetstreamWriteArgs} message NatsJetstreamWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsJetstreamWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.stream = "";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                return object;
            };

            /**
             * Converts this NatsJetstreamWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NatsJetstreamWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsJetstreamWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsJetstreamWriteArgs;
        })();

        args.NatsStreamingTLSOptions = (function() {

            /**
             * Properties of a NatsStreamingTLSOptions.
             * @memberof protos.args
             * @interface INatsStreamingTLSOptions
             * @property {Uint8Array|null} [tlsCaCert] NatsStreamingTLSOptions tlsCaCert
             * @property {Uint8Array|null} [tlsClientCert] NatsStreamingTLSOptions tlsClientCert
             * @property {Uint8Array|null} [tlsClientKey] NatsStreamingTLSOptions tlsClientKey
             * @property {boolean|null} [tlsSkipVerify] NatsStreamingTLSOptions tlsSkipVerify
             */

            /**
             * Constructs a new NatsStreamingTLSOptions.
             * @memberof protos.args
             * @classdesc Represents a NatsStreamingTLSOptions.
             * @implements INatsStreamingTLSOptions
             * @constructor
             * @param {protos.args.INatsStreamingTLSOptions=} [properties] Properties to set
             */
            function NatsStreamingTLSOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsStreamingTLSOptions tlsCaCert.
             * @member {Uint8Array} tlsCaCert
             * @memberof protos.args.NatsStreamingTLSOptions
             * @instance
             */
            NatsStreamingTLSOptions.prototype.tlsCaCert = $util.newBuffer([]);

            /**
             * NatsStreamingTLSOptions tlsClientCert.
             * @member {Uint8Array} tlsClientCert
             * @memberof protos.args.NatsStreamingTLSOptions
             * @instance
             */
            NatsStreamingTLSOptions.prototype.tlsClientCert = $util.newBuffer([]);

            /**
             * NatsStreamingTLSOptions tlsClientKey.
             * @member {Uint8Array} tlsClientKey
             * @memberof protos.args.NatsStreamingTLSOptions
             * @instance
             */
            NatsStreamingTLSOptions.prototype.tlsClientKey = $util.newBuffer([]);

            /**
             * NatsStreamingTLSOptions tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.args.NatsStreamingTLSOptions
             * @instance
             */
            NatsStreamingTLSOptions.prototype.tlsSkipVerify = false;

            /**
             * Creates a new NatsStreamingTLSOptions instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsStreamingTLSOptions
             * @static
             * @param {protos.args.INatsStreamingTLSOptions=} [properties] Properties to set
             * @returns {protos.args.NatsStreamingTLSOptions} NatsStreamingTLSOptions instance
             */
            NatsStreamingTLSOptions.create = function create(properties) {
                return new NatsStreamingTLSOptions(properties);
            };

            /**
             * Encodes the specified NatsStreamingTLSOptions message. Does not implicitly {@link protos.args.NatsStreamingTLSOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsStreamingTLSOptions
             * @static
             * @param {protos.args.INatsStreamingTLSOptions} message NatsStreamingTLSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingTLSOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tlsCaCert != null && Object.hasOwnProperty.call(message, "tlsCaCert"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.tlsCaCert);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.tlsClientCert);
                if (message.tlsClientKey != null && Object.hasOwnProperty.call(message, "tlsClientKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.tlsClientKey);
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.tlsSkipVerify);
                return writer;
            };

            /**
             * Encodes the specified NatsStreamingTLSOptions message, length delimited. Does not implicitly {@link protos.args.NatsStreamingTLSOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsStreamingTLSOptions
             * @static
             * @param {protos.args.INatsStreamingTLSOptions} message NatsStreamingTLSOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingTLSOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsStreamingTLSOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsStreamingTLSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsStreamingTLSOptions} NatsStreamingTLSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingTLSOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsStreamingTLSOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tlsCaCert = reader.bytes();
                        break;
                    case 2:
                        message.tlsClientCert = reader.bytes();
                        break;
                    case 3:
                        message.tlsClientKey = reader.bytes();
                        break;
                    case 4:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsStreamingTLSOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsStreamingTLSOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsStreamingTLSOptions} NatsStreamingTLSOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingTLSOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsStreamingTLSOptions message.
             * @function verify
             * @memberof protos.args.NatsStreamingTLSOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsStreamingTLSOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    if (!(message.tlsCaCert && typeof message.tlsCaCert.length === "number" || $util.isString(message.tlsCaCert)))
                        return "tlsCaCert: buffer expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!(message.tlsClientCert && typeof message.tlsClientCert.length === "number" || $util.isString(message.tlsClientCert)))
                        return "tlsClientCert: buffer expected";
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    if (!(message.tlsClientKey && typeof message.tlsClientKey.length === "number" || $util.isString(message.tlsClientKey)))
                        return "tlsClientKey: buffer expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                return null;
            };

            /**
             * Creates a NatsStreamingTLSOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsStreamingTLSOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsStreamingTLSOptions} NatsStreamingTLSOptions
             */
            NatsStreamingTLSOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsStreamingTLSOptions)
                    return object;
                var message = new $root.protos.args.NatsStreamingTLSOptions();
                if (object.tlsCaCert != null)
                    if (typeof object.tlsCaCert === "string")
                        $util.base64.decode(object.tlsCaCert, message.tlsCaCert = $util.newBuffer($util.base64.length(object.tlsCaCert)), 0);
                    else if (object.tlsCaCert.length)
                        message.tlsCaCert = object.tlsCaCert;
                if (object.tlsClientCert != null)
                    if (typeof object.tlsClientCert === "string")
                        $util.base64.decode(object.tlsClientCert, message.tlsClientCert = $util.newBuffer($util.base64.length(object.tlsClientCert)), 0);
                    else if (object.tlsClientCert.length)
                        message.tlsClientCert = object.tlsClientCert;
                if (object.tlsClientKey != null)
                    if (typeof object.tlsClientKey === "string")
                        $util.base64.decode(object.tlsClientKey, message.tlsClientKey = $util.newBuffer($util.base64.length(object.tlsClientKey)), 0);
                    else if (object.tlsClientKey.length)
                        message.tlsClientKey = object.tlsClientKey;
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                return message;
            };

            /**
             * Creates a plain object from a NatsStreamingTLSOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsStreamingTLSOptions
             * @static
             * @param {protos.args.NatsStreamingTLSOptions} message NatsStreamingTLSOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsStreamingTLSOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.tlsCaCert = "";
                    else {
                        object.tlsCaCert = [];
                        if (options.bytes !== Array)
                            object.tlsCaCert = $util.newBuffer(object.tlsCaCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientCert = "";
                    else {
                        object.tlsClientCert = [];
                        if (options.bytes !== Array)
                            object.tlsClientCert = $util.newBuffer(object.tlsClientCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientKey = "";
                    else {
                        object.tlsClientKey = [];
                        if (options.bytes !== Array)
                            object.tlsClientKey = $util.newBuffer(object.tlsClientKey);
                    }
                    object.tlsSkipVerify = false;
                }
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    object.tlsCaCert = options.bytes === String ? $util.base64.encode(message.tlsCaCert, 0, message.tlsCaCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsCaCert) : message.tlsCaCert;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = options.bytes === String ? $util.base64.encode(message.tlsClientCert, 0, message.tlsClientCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientCert) : message.tlsClientCert;
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    object.tlsClientKey = options.bytes === String ? $util.base64.encode(message.tlsClientKey, 0, message.tlsClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientKey) : message.tlsClientKey;
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                return object;
            };

            /**
             * Converts this NatsStreamingTLSOptions to JSON.
             * @function toJSON
             * @memberof protos.args.NatsStreamingTLSOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsStreamingTLSOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsStreamingTLSOptions;
        })();

        args.NatsStreamingConn = (function() {

            /**
             * Properties of a NatsStreamingConn.
             * @memberof protos.args
             * @interface INatsStreamingConn
             * @property {string|null} [dsn] NatsStreamingConn dsn
             * @property {Uint8Array|null} [userCredentials] NatsStreamingConn userCredentials
             * @property {string|null} [clusterId] NatsStreamingConn clusterId
             * @property {string|null} [clientId] NatsStreamingConn clientId
             * @property {protos.args.INatsStreamingTLSOptions|null} [tlsOptions] NatsStreamingConn tlsOptions
             */

            /**
             * Constructs a new NatsStreamingConn.
             * @memberof protos.args
             * @classdesc Represents a NatsStreamingConn.
             * @implements INatsStreamingConn
             * @constructor
             * @param {protos.args.INatsStreamingConn=} [properties] Properties to set
             */
            function NatsStreamingConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsStreamingConn dsn.
             * @member {string} dsn
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.dsn = "";

            /**
             * NatsStreamingConn userCredentials.
             * @member {Uint8Array} userCredentials
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.userCredentials = $util.newBuffer([]);

            /**
             * NatsStreamingConn clusterId.
             * @member {string} clusterId
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.clusterId = "";

            /**
             * NatsStreamingConn clientId.
             * @member {string} clientId
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.clientId = "";

            /**
             * NatsStreamingConn tlsOptions.
             * @member {protos.args.INatsStreamingTLSOptions|null|undefined} tlsOptions
             * @memberof protos.args.NatsStreamingConn
             * @instance
             */
            NatsStreamingConn.prototype.tlsOptions = null;

            /**
             * Creates a new NatsStreamingConn instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {protos.args.INatsStreamingConn=} [properties] Properties to set
             * @returns {protos.args.NatsStreamingConn} NatsStreamingConn instance
             */
            NatsStreamingConn.create = function create(properties) {
                return new NatsStreamingConn(properties);
            };

            /**
             * Encodes the specified NatsStreamingConn message. Does not implicitly {@link protos.args.NatsStreamingConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {protos.args.INatsStreamingConn} message NatsStreamingConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                if (message.userCredentials != null && Object.hasOwnProperty.call(message, "userCredentials"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.userCredentials);
                if (message.clusterId != null && Object.hasOwnProperty.call(message, "clusterId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.clusterId);
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.clientId);
                if (message.tlsOptions != null && Object.hasOwnProperty.call(message, "tlsOptions"))
                    $root.protos.args.NatsStreamingTLSOptions.encode(message.tlsOptions, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NatsStreamingConn message, length delimited. Does not implicitly {@link protos.args.NatsStreamingConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {protos.args.INatsStreamingConn} message NatsStreamingConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsStreamingConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsStreamingConn} NatsStreamingConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsStreamingConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    case 2:
                        message.userCredentials = reader.bytes();
                        break;
                    case 3:
                        message.clusterId = reader.string();
                        break;
                    case 4:
                        message.clientId = reader.string();
                        break;
                    case 5:
                        message.tlsOptions = $root.protos.args.NatsStreamingTLSOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsStreamingConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsStreamingConn} NatsStreamingConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsStreamingConn message.
             * @function verify
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsStreamingConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                if (message.userCredentials != null && message.hasOwnProperty("userCredentials"))
                    if (!(message.userCredentials && typeof message.userCredentials.length === "number" || $util.isString(message.userCredentials)))
                        return "userCredentials: buffer expected";
                if (message.clusterId != null && message.hasOwnProperty("clusterId"))
                    if (!$util.isString(message.clusterId))
                        return "clusterId: string expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                if (message.tlsOptions != null && message.hasOwnProperty("tlsOptions")) {
                    var error = $root.protos.args.NatsStreamingTLSOptions.verify(message.tlsOptions);
                    if (error)
                        return "tlsOptions." + error;
                }
                return null;
            };

            /**
             * Creates a NatsStreamingConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsStreamingConn} NatsStreamingConn
             */
            NatsStreamingConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsStreamingConn)
                    return object;
                var message = new $root.protos.args.NatsStreamingConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                if (object.userCredentials != null)
                    if (typeof object.userCredentials === "string")
                        $util.base64.decode(object.userCredentials, message.userCredentials = $util.newBuffer($util.base64.length(object.userCredentials)), 0);
                    else if (object.userCredentials.length)
                        message.userCredentials = object.userCredentials;
                if (object.clusterId != null)
                    message.clusterId = String(object.clusterId);
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                if (object.tlsOptions != null) {
                    if (typeof object.tlsOptions !== "object")
                        throw TypeError(".protos.args.NatsStreamingConn.tlsOptions: object expected");
                    message.tlsOptions = $root.protos.args.NatsStreamingTLSOptions.fromObject(object.tlsOptions);
                }
                return message;
            };

            /**
             * Creates a plain object from a NatsStreamingConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsStreamingConn
             * @static
             * @param {protos.args.NatsStreamingConn} message NatsStreamingConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsStreamingConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.dsn = "";
                    if (options.bytes === String)
                        object.userCredentials = "";
                    else {
                        object.userCredentials = [];
                        if (options.bytes !== Array)
                            object.userCredentials = $util.newBuffer(object.userCredentials);
                    }
                    object.clusterId = "";
                    object.clientId = "";
                    object.tlsOptions = null;
                }
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                if (message.userCredentials != null && message.hasOwnProperty("userCredentials"))
                    object.userCredentials = options.bytes === String ? $util.base64.encode(message.userCredentials, 0, message.userCredentials.length) : options.bytes === Array ? Array.prototype.slice.call(message.userCredentials) : message.userCredentials;
                if (message.clusterId != null && message.hasOwnProperty("clusterId"))
                    object.clusterId = message.clusterId;
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                if (message.tlsOptions != null && message.hasOwnProperty("tlsOptions"))
                    object.tlsOptions = $root.protos.args.NatsStreamingTLSOptions.toObject(message.tlsOptions, options);
                return object;
            };

            /**
             * Converts this NatsStreamingConn to JSON.
             * @function toJSON
             * @memberof protos.args.NatsStreamingConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsStreamingConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsStreamingConn;
        })();

        args.NatsStreamingReadArgs = (function() {

            /**
             * Properties of a NatsStreamingReadArgs.
             * @memberof protos.args
             * @interface INatsStreamingReadArgs
             * @property {string|null} [channel] NatsStreamingReadArgs channel
             * @property {string|null} [durableName] NatsStreamingReadArgs durableName
             * @property {boolean|null} [readLastAvailable] NatsStreamingReadArgs readLastAvailable
             * @property {number|null} [readSequenceNumber] NatsStreamingReadArgs readSequenceNumber
             * @property {string|null} [readSince] NatsStreamingReadArgs readSince
             * @property {boolean|null} [readAll] NatsStreamingReadArgs readAll
             */

            /**
             * Constructs a new NatsStreamingReadArgs.
             * @memberof protos.args
             * @classdesc Represents a NatsStreamingReadArgs.
             * @implements INatsStreamingReadArgs
             * @constructor
             * @param {protos.args.INatsStreamingReadArgs=} [properties] Properties to set
             */
            function NatsStreamingReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsStreamingReadArgs channel.
             * @member {string} channel
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.channel = "";

            /**
             * NatsStreamingReadArgs durableName.
             * @member {string} durableName
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.durableName = "";

            /**
             * NatsStreamingReadArgs readLastAvailable.
             * @member {boolean} readLastAvailable
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.readLastAvailable = false;

            /**
             * NatsStreamingReadArgs readSequenceNumber.
             * @member {number} readSequenceNumber
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.readSequenceNumber = 0;

            /**
             * NatsStreamingReadArgs readSince.
             * @member {string} readSince
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.readSince = "";

            /**
             * NatsStreamingReadArgs readAll.
             * @member {boolean} readAll
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             */
            NatsStreamingReadArgs.prototype.readAll = false;

            /**
             * Creates a new NatsStreamingReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {protos.args.INatsStreamingReadArgs=} [properties] Properties to set
             * @returns {protos.args.NatsStreamingReadArgs} NatsStreamingReadArgs instance
             */
            NatsStreamingReadArgs.create = function create(properties) {
                return new NatsStreamingReadArgs(properties);
            };

            /**
             * Encodes the specified NatsStreamingReadArgs message. Does not implicitly {@link protos.args.NatsStreamingReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {protos.args.INatsStreamingReadArgs} message NatsStreamingReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);
                if (message.durableName != null && Object.hasOwnProperty.call(message, "durableName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.durableName);
                if (message.readLastAvailable != null && Object.hasOwnProperty.call(message, "readLastAvailable"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.readLastAvailable);
                if (message.readSequenceNumber != null && Object.hasOwnProperty.call(message, "readSequenceNumber"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.readSequenceNumber);
                if (message.readSince != null && Object.hasOwnProperty.call(message, "readSince"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.readSince);
                if (message.readAll != null && Object.hasOwnProperty.call(message, "readAll"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.readAll);
                return writer;
            };

            /**
             * Encodes the specified NatsStreamingReadArgs message, length delimited. Does not implicitly {@link protos.args.NatsStreamingReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {protos.args.INatsStreamingReadArgs} message NatsStreamingReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsStreamingReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsStreamingReadArgs} NatsStreamingReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsStreamingReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = reader.string();
                        break;
                    case 2:
                        message.durableName = reader.string();
                        break;
                    case 3:
                        message.readLastAvailable = reader.bool();
                        break;
                    case 4:
                        message.readSequenceNumber = reader.uint32();
                        break;
                    case 5:
                        message.readSince = reader.string();
                        break;
                    case 6:
                        message.readAll = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsStreamingReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsStreamingReadArgs} NatsStreamingReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsStreamingReadArgs message.
             * @function verify
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsStreamingReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                if (message.durableName != null && message.hasOwnProperty("durableName"))
                    if (!$util.isString(message.durableName))
                        return "durableName: string expected";
                if (message.readLastAvailable != null && message.hasOwnProperty("readLastAvailable"))
                    if (typeof message.readLastAvailable !== "boolean")
                        return "readLastAvailable: boolean expected";
                if (message.readSequenceNumber != null && message.hasOwnProperty("readSequenceNumber"))
                    if (!$util.isInteger(message.readSequenceNumber))
                        return "readSequenceNumber: integer expected";
                if (message.readSince != null && message.hasOwnProperty("readSince"))
                    if (!$util.isString(message.readSince))
                        return "readSince: string expected";
                if (message.readAll != null && message.hasOwnProperty("readAll"))
                    if (typeof message.readAll !== "boolean")
                        return "readAll: boolean expected";
                return null;
            };

            /**
             * Creates a NatsStreamingReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsStreamingReadArgs} NatsStreamingReadArgs
             */
            NatsStreamingReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsStreamingReadArgs)
                    return object;
                var message = new $root.protos.args.NatsStreamingReadArgs();
                if (object.channel != null)
                    message.channel = String(object.channel);
                if (object.durableName != null)
                    message.durableName = String(object.durableName);
                if (object.readLastAvailable != null)
                    message.readLastAvailable = Boolean(object.readLastAvailable);
                if (object.readSequenceNumber != null)
                    message.readSequenceNumber = object.readSequenceNumber >>> 0;
                if (object.readSince != null)
                    message.readSince = String(object.readSince);
                if (object.readAll != null)
                    message.readAll = Boolean(object.readAll);
                return message;
            };

            /**
             * Creates a plain object from a NatsStreamingReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsStreamingReadArgs
             * @static
             * @param {protos.args.NatsStreamingReadArgs} message NatsStreamingReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsStreamingReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.channel = "";
                    object.durableName = "";
                    object.readLastAvailable = false;
                    object.readSequenceNumber = 0;
                    object.readSince = "";
                    object.readAll = false;
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.durableName != null && message.hasOwnProperty("durableName"))
                    object.durableName = message.durableName;
                if (message.readLastAvailable != null && message.hasOwnProperty("readLastAvailable"))
                    object.readLastAvailable = message.readLastAvailable;
                if (message.readSequenceNumber != null && message.hasOwnProperty("readSequenceNumber"))
                    object.readSequenceNumber = message.readSequenceNumber;
                if (message.readSince != null && message.hasOwnProperty("readSince"))
                    object.readSince = message.readSince;
                if (message.readAll != null && message.hasOwnProperty("readAll"))
                    object.readAll = message.readAll;
                return object;
            };

            /**
             * Converts this NatsStreamingReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NatsStreamingReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsStreamingReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsStreamingReadArgs;
        })();

        args.NatsStreamingWriteArgs = (function() {

            /**
             * Properties of a NatsStreamingWriteArgs.
             * @memberof protos.args
             * @interface INatsStreamingWriteArgs
             * @property {string|null} [channel] NatsStreamingWriteArgs channel
             */

            /**
             * Constructs a new NatsStreamingWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a NatsStreamingWriteArgs.
             * @implements INatsStreamingWriteArgs
             * @constructor
             * @param {protos.args.INatsStreamingWriteArgs=} [properties] Properties to set
             */
            function NatsStreamingWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsStreamingWriteArgs channel.
             * @member {string} channel
             * @memberof protos.args.NatsStreamingWriteArgs
             * @instance
             */
            NatsStreamingWriteArgs.prototype.channel = "";

            /**
             * Creates a new NatsStreamingWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {protos.args.INatsStreamingWriteArgs=} [properties] Properties to set
             * @returns {protos.args.NatsStreamingWriteArgs} NatsStreamingWriteArgs instance
             */
            NatsStreamingWriteArgs.create = function create(properties) {
                return new NatsStreamingWriteArgs(properties);
            };

            /**
             * Encodes the specified NatsStreamingWriteArgs message. Does not implicitly {@link protos.args.NatsStreamingWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {protos.args.INatsStreamingWriteArgs} message NatsStreamingWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);
                return writer;
            };

            /**
             * Encodes the specified NatsStreamingWriteArgs message, length delimited. Does not implicitly {@link protos.args.NatsStreamingWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {protos.args.INatsStreamingWriteArgs} message NatsStreamingWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreamingWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsStreamingWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NatsStreamingWriteArgs} NatsStreamingWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NatsStreamingWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsStreamingWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NatsStreamingWriteArgs} NatsStreamingWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreamingWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsStreamingWriteArgs message.
             * @function verify
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsStreamingWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                return null;
            };

            /**
             * Creates a NatsStreamingWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NatsStreamingWriteArgs} NatsStreamingWriteArgs
             */
            NatsStreamingWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NatsStreamingWriteArgs)
                    return object;
                var message = new $root.protos.args.NatsStreamingWriteArgs();
                if (object.channel != null)
                    message.channel = String(object.channel);
                return message;
            };

            /**
             * Creates a plain object from a NatsStreamingWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NatsStreamingWriteArgs
             * @static
             * @param {protos.args.NatsStreamingWriteArgs} message NatsStreamingWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsStreamingWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.channel = "";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                return object;
            };

            /**
             * Converts this NatsStreamingWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NatsStreamingWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsStreamingWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsStreamingWriteArgs;
        })();

        args.NSQConn = (function() {

            /**
             * Properties of a NSQConn.
             * @memberof protos.args
             * @interface INSQConn
             * @property {string|null} [nsqdAddress] NSQConn nsqdAddress
             * @property {string|null} [lookupdAddress] NSQConn lookupdAddress
             * @property {boolean|null} [useTls] NSQConn useTls
             * @property {boolean|null} [tlsSkipVerify] NSQConn tlsSkipVerify
             * @property {Uint8Array|null} [tlsCaCert] NSQConn tlsCaCert
             * @property {Uint8Array|null} [tlsClientCert] NSQConn tlsClientCert
             * @property {Uint8Array|null} [tlsClientKey] NSQConn tlsClientKey
             * @property {string|null} [authSecret] NSQConn authSecret
             * @property {string|null} [clientId] NSQConn clientId
             */

            /**
             * Constructs a new NSQConn.
             * @memberof protos.args
             * @classdesc Represents a NSQConn.
             * @implements INSQConn
             * @constructor
             * @param {protos.args.INSQConn=} [properties] Properties to set
             */
            function NSQConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NSQConn nsqdAddress.
             * @member {string} nsqdAddress
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.nsqdAddress = "";

            /**
             * NSQConn lookupdAddress.
             * @member {string} lookupdAddress
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.lookupdAddress = "";

            /**
             * NSQConn useTls.
             * @member {boolean} useTls
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.useTls = false;

            /**
             * NSQConn tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.tlsSkipVerify = false;

            /**
             * NSQConn tlsCaCert.
             * @member {Uint8Array} tlsCaCert
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.tlsCaCert = $util.newBuffer([]);

            /**
             * NSQConn tlsClientCert.
             * @member {Uint8Array} tlsClientCert
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.tlsClientCert = $util.newBuffer([]);

            /**
             * NSQConn tlsClientKey.
             * @member {Uint8Array} tlsClientKey
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.tlsClientKey = $util.newBuffer([]);

            /**
             * NSQConn authSecret.
             * @member {string} authSecret
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.authSecret = "";

            /**
             * NSQConn clientId.
             * @member {string} clientId
             * @memberof protos.args.NSQConn
             * @instance
             */
            NSQConn.prototype.clientId = "";

            /**
             * Creates a new NSQConn instance using the specified properties.
             * @function create
             * @memberof protos.args.NSQConn
             * @static
             * @param {protos.args.INSQConn=} [properties] Properties to set
             * @returns {protos.args.NSQConn} NSQConn instance
             */
            NSQConn.create = function create(properties) {
                return new NSQConn(properties);
            };

            /**
             * Encodes the specified NSQConn message. Does not implicitly {@link protos.args.NSQConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NSQConn
             * @static
             * @param {protos.args.INSQConn} message NSQConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nsqdAddress != null && Object.hasOwnProperty.call(message, "nsqdAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nsqdAddress);
                if (message.lookupdAddress != null && Object.hasOwnProperty.call(message, "lookupdAddress"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.lookupdAddress);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.useTls);
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.tlsSkipVerify);
                if (message.tlsCaCert != null && Object.hasOwnProperty.call(message, "tlsCaCert"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.tlsCaCert);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.tlsClientCert);
                if (message.tlsClientKey != null && Object.hasOwnProperty.call(message, "tlsClientKey"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.tlsClientKey);
                if (message.authSecret != null && Object.hasOwnProperty.call(message, "authSecret"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.authSecret);
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.clientId);
                return writer;
            };

            /**
             * Encodes the specified NSQConn message, length delimited. Does not implicitly {@link protos.args.NSQConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NSQConn
             * @static
             * @param {protos.args.INSQConn} message NSQConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NSQConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NSQConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NSQConn} NSQConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NSQConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nsqdAddress = reader.string();
                        break;
                    case 2:
                        message.lookupdAddress = reader.string();
                        break;
                    case 3:
                        message.useTls = reader.bool();
                        break;
                    case 4:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    case 5:
                        message.tlsCaCert = reader.bytes();
                        break;
                    case 6:
                        message.tlsClientCert = reader.bytes();
                        break;
                    case 7:
                        message.tlsClientKey = reader.bytes();
                        break;
                    case 8:
                        message.authSecret = reader.string();
                        break;
                    case 9:
                        message.clientId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NSQConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NSQConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NSQConn} NSQConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NSQConn message.
             * @function verify
             * @memberof protos.args.NSQConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NSQConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nsqdAddress != null && message.hasOwnProperty("nsqdAddress"))
                    if (!$util.isString(message.nsqdAddress))
                        return "nsqdAddress: string expected";
                if (message.lookupdAddress != null && message.hasOwnProperty("lookupdAddress"))
                    if (!$util.isString(message.lookupdAddress))
                        return "lookupdAddress: string expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    if (!(message.tlsCaCert && typeof message.tlsCaCert.length === "number" || $util.isString(message.tlsCaCert)))
                        return "tlsCaCert: buffer expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!(message.tlsClientCert && typeof message.tlsClientCert.length === "number" || $util.isString(message.tlsClientCert)))
                        return "tlsClientCert: buffer expected";
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    if (!(message.tlsClientKey && typeof message.tlsClientKey.length === "number" || $util.isString(message.tlsClientKey)))
                        return "tlsClientKey: buffer expected";
                if (message.authSecret != null && message.hasOwnProperty("authSecret"))
                    if (!$util.isString(message.authSecret))
                        return "authSecret: string expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                return null;
            };

            /**
             * Creates a NSQConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NSQConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NSQConn} NSQConn
             */
            NSQConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NSQConn)
                    return object;
                var message = new $root.protos.args.NSQConn();
                if (object.nsqdAddress != null)
                    message.nsqdAddress = String(object.nsqdAddress);
                if (object.lookupdAddress != null)
                    message.lookupdAddress = String(object.lookupdAddress);
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                if (object.tlsCaCert != null)
                    if (typeof object.tlsCaCert === "string")
                        $util.base64.decode(object.tlsCaCert, message.tlsCaCert = $util.newBuffer($util.base64.length(object.tlsCaCert)), 0);
                    else if (object.tlsCaCert.length)
                        message.tlsCaCert = object.tlsCaCert;
                if (object.tlsClientCert != null)
                    if (typeof object.tlsClientCert === "string")
                        $util.base64.decode(object.tlsClientCert, message.tlsClientCert = $util.newBuffer($util.base64.length(object.tlsClientCert)), 0);
                    else if (object.tlsClientCert.length)
                        message.tlsClientCert = object.tlsClientCert;
                if (object.tlsClientKey != null)
                    if (typeof object.tlsClientKey === "string")
                        $util.base64.decode(object.tlsClientKey, message.tlsClientKey = $util.newBuffer($util.base64.length(object.tlsClientKey)), 0);
                    else if (object.tlsClientKey.length)
                        message.tlsClientKey = object.tlsClientKey;
                if (object.authSecret != null)
                    message.authSecret = String(object.authSecret);
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                return message;
            };

            /**
             * Creates a plain object from a NSQConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NSQConn
             * @static
             * @param {protos.args.NSQConn} message NSQConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NSQConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.nsqdAddress = "";
                    object.lookupdAddress = "";
                    object.useTls = false;
                    object.tlsSkipVerify = false;
                    if (options.bytes === String)
                        object.tlsCaCert = "";
                    else {
                        object.tlsCaCert = [];
                        if (options.bytes !== Array)
                            object.tlsCaCert = $util.newBuffer(object.tlsCaCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientCert = "";
                    else {
                        object.tlsClientCert = [];
                        if (options.bytes !== Array)
                            object.tlsClientCert = $util.newBuffer(object.tlsClientCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientKey = "";
                    else {
                        object.tlsClientKey = [];
                        if (options.bytes !== Array)
                            object.tlsClientKey = $util.newBuffer(object.tlsClientKey);
                    }
                    object.authSecret = "";
                    object.clientId = "";
                }
                if (message.nsqdAddress != null && message.hasOwnProperty("nsqdAddress"))
                    object.nsqdAddress = message.nsqdAddress;
                if (message.lookupdAddress != null && message.hasOwnProperty("lookupdAddress"))
                    object.lookupdAddress = message.lookupdAddress;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                if (message.tlsCaCert != null && message.hasOwnProperty("tlsCaCert"))
                    object.tlsCaCert = options.bytes === String ? $util.base64.encode(message.tlsCaCert, 0, message.tlsCaCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsCaCert) : message.tlsCaCert;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = options.bytes === String ? $util.base64.encode(message.tlsClientCert, 0, message.tlsClientCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientCert) : message.tlsClientCert;
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    object.tlsClientKey = options.bytes === String ? $util.base64.encode(message.tlsClientKey, 0, message.tlsClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientKey) : message.tlsClientKey;
                if (message.authSecret != null && message.hasOwnProperty("authSecret"))
                    object.authSecret = message.authSecret;
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                return object;
            };

            /**
             * Converts this NSQConn to JSON.
             * @function toJSON
             * @memberof protos.args.NSQConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NSQConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NSQConn;
        })();

        args.NSQReadArgs = (function() {

            /**
             * Properties of a NSQReadArgs.
             * @memberof protos.args
             * @interface INSQReadArgs
             * @property {string|null} [topic] NSQReadArgs topic
             * @property {string|null} [channel] NSQReadArgs channel
             */

            /**
             * Constructs a new NSQReadArgs.
             * @memberof protos.args
             * @classdesc Represents a NSQReadArgs.
             * @implements INSQReadArgs
             * @constructor
             * @param {protos.args.INSQReadArgs=} [properties] Properties to set
             */
            function NSQReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NSQReadArgs topic.
             * @member {string} topic
             * @memberof protos.args.NSQReadArgs
             * @instance
             */
            NSQReadArgs.prototype.topic = "";

            /**
             * NSQReadArgs channel.
             * @member {string} channel
             * @memberof protos.args.NSQReadArgs
             * @instance
             */
            NSQReadArgs.prototype.channel = "";

            /**
             * Creates a new NSQReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {protos.args.INSQReadArgs=} [properties] Properties to set
             * @returns {protos.args.NSQReadArgs} NSQReadArgs instance
             */
            NSQReadArgs.create = function create(properties) {
                return new NSQReadArgs(properties);
            };

            /**
             * Encodes the specified NSQReadArgs message. Does not implicitly {@link protos.args.NSQReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {protos.args.INSQReadArgs} message NSQReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.channel);
                return writer;
            };

            /**
             * Encodes the specified NSQReadArgs message, length delimited. Does not implicitly {@link protos.args.NSQReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {protos.args.INSQReadArgs} message NSQReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NSQReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NSQReadArgs} NSQReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NSQReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.channel = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NSQReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NSQReadArgs} NSQReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NSQReadArgs message.
             * @function verify
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NSQReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                return null;
            };

            /**
             * Creates a NSQReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NSQReadArgs} NSQReadArgs
             */
            NSQReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NSQReadArgs)
                    return object;
                var message = new $root.protos.args.NSQReadArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.channel != null)
                    message.channel = String(object.channel);
                return message;
            };

            /**
             * Creates a plain object from a NSQReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NSQReadArgs
             * @static
             * @param {protos.args.NSQReadArgs} message NSQReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NSQReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.channel = "";
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                return object;
            };

            /**
             * Converts this NSQReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NSQReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NSQReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NSQReadArgs;
        })();

        args.NSQWriteArgs = (function() {

            /**
             * Properties of a NSQWriteArgs.
             * @memberof protos.args
             * @interface INSQWriteArgs
             * @property {string|null} [topic] NSQWriteArgs topic
             */

            /**
             * Constructs a new NSQWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a NSQWriteArgs.
             * @implements INSQWriteArgs
             * @constructor
             * @param {protos.args.INSQWriteArgs=} [properties] Properties to set
             */
            function NSQWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NSQWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.NSQWriteArgs
             * @instance
             */
            NSQWriteArgs.prototype.topic = "";

            /**
             * Creates a new NSQWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {protos.args.INSQWriteArgs=} [properties] Properties to set
             * @returns {protos.args.NSQWriteArgs} NSQWriteArgs instance
             */
            NSQWriteArgs.create = function create(properties) {
                return new NSQWriteArgs(properties);
            };

            /**
             * Encodes the specified NSQWriteArgs message. Does not implicitly {@link protos.args.NSQWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {protos.args.INSQWriteArgs} message NSQWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                return writer;
            };

            /**
             * Encodes the specified NSQWriteArgs message, length delimited. Does not implicitly {@link protos.args.NSQWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {protos.args.INSQWriteArgs} message NSQWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NSQWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.NSQWriteArgs} NSQWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.NSQWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NSQWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.NSQWriteArgs} NSQWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NSQWriteArgs message.
             * @function verify
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NSQWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                return null;
            };

            /**
             * Creates a NSQWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.NSQWriteArgs} NSQWriteArgs
             */
            NSQWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.NSQWriteArgs)
                    return object;
                var message = new $root.protos.args.NSQWriteArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                return message;
            };

            /**
             * Creates a plain object from a NSQWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.NSQWriteArgs
             * @static
             * @param {protos.args.NSQWriteArgs} message NSQWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NSQWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.topic = "";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                return object;
            };

            /**
             * Converts this NSQWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.NSQWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NSQWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NSQWriteArgs;
        })();

        args.PostgresConn = (function() {

            /**
             * Properties of a PostgresConn.
             * @memberof protos.args
             * @interface IPostgresConn
             * @property {string|null} [address] PostgresConn address
             * @property {number|null} [port] PostgresConn port
             * @property {string|null} [username] PostgresConn username
             * @property {string|null} [password] PostgresConn password
             * @property {string|null} [database] PostgresConn database
             * @property {boolean|null} [useTls] PostgresConn useTls
             * @property {boolean|null} [tlsSkipVerify] PostgresConn tlsSkipVerify
             */

            /**
             * Constructs a new PostgresConn.
             * @memberof protos.args
             * @classdesc Represents a PostgresConn.
             * @implements IPostgresConn
             * @constructor
             * @param {protos.args.IPostgresConn=} [properties] Properties to set
             */
            function PostgresConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PostgresConn address.
             * @member {string} address
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.address = "";

            /**
             * PostgresConn port.
             * @member {number} port
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.port = 0;

            /**
             * PostgresConn username.
             * @member {string} username
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.username = "";

            /**
             * PostgresConn password.
             * @member {string} password
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.password = "";

            /**
             * PostgresConn database.
             * @member {string} database
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.database = "";

            /**
             * PostgresConn useTls.
             * @member {boolean} useTls
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.useTls = false;

            /**
             * PostgresConn tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.args.PostgresConn
             * @instance
             */
            PostgresConn.prototype.tlsSkipVerify = false;

            /**
             * Creates a new PostgresConn instance using the specified properties.
             * @function create
             * @memberof protos.args.PostgresConn
             * @static
             * @param {protos.args.IPostgresConn=} [properties] Properties to set
             * @returns {protos.args.PostgresConn} PostgresConn instance
             */
            PostgresConn.create = function create(properties) {
                return new PostgresConn(properties);
            };

            /**
             * Encodes the specified PostgresConn message. Does not implicitly {@link protos.args.PostgresConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.PostgresConn
             * @static
             * @param {protos.args.IPostgresConn} message PostgresConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PostgresConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.username);
                if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.password);
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.database);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.useTls);
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.tlsSkipVerify);
                return writer;
            };

            /**
             * Encodes the specified PostgresConn message, length delimited. Does not implicitly {@link protos.args.PostgresConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.PostgresConn
             * @static
             * @param {protos.args.IPostgresConn} message PostgresConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PostgresConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PostgresConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.PostgresConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.PostgresConn} PostgresConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PostgresConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.PostgresConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.port = reader.uint32();
                        break;
                    case 3:
                        message.username = reader.string();
                        break;
                    case 4:
                        message.password = reader.string();
                        break;
                    case 5:
                        message.database = reader.string();
                        break;
                    case 6:
                        message.useTls = reader.bool();
                        break;
                    case 7:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PostgresConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.PostgresConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.PostgresConn} PostgresConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PostgresConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PostgresConn message.
             * @function verify
             * @memberof protos.args.PostgresConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PostgresConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!$util.isString(message.password))
                        return "password: string expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                return null;
            };

            /**
             * Creates a PostgresConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.PostgresConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.PostgresConn} PostgresConn
             */
            PostgresConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.PostgresConn)
                    return object;
                var message = new $root.protos.args.PostgresConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.port != null)
                    message.port = object.port >>> 0;
                if (object.username != null)
                    message.username = String(object.username);
                if (object.password != null)
                    message.password = String(object.password);
                if (object.database != null)
                    message.database = String(object.database);
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                return message;
            };

            /**
             * Creates a plain object from a PostgresConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.PostgresConn
             * @static
             * @param {protos.args.PostgresConn} message PostgresConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PostgresConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = "";
                    object.port = 0;
                    object.username = "";
                    object.password = "";
                    object.database = "";
                    object.useTls = false;
                    object.tlsSkipVerify = false;
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = message.password;
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                return object;
            };

            /**
             * Converts this PostgresConn to JSON.
             * @function toJSON
             * @memberof protos.args.PostgresConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PostgresConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PostgresConn;
        })();

        args.PostgresReadArgs = (function() {

            /**
             * Properties of a PostgresReadArgs.
             * @memberof protos.args
             * @interface IPostgresReadArgs
             * @property {string|null} [replicationSlotName] PostgresReadArgs replicationSlotName
             * @property {string|null} [publisherName] PostgresReadArgs publisherName
             */

            /**
             * Constructs a new PostgresReadArgs.
             * @memberof protos.args
             * @classdesc Represents a PostgresReadArgs.
             * @implements IPostgresReadArgs
             * @constructor
             * @param {protos.args.IPostgresReadArgs=} [properties] Properties to set
             */
            function PostgresReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PostgresReadArgs replicationSlotName.
             * @member {string} replicationSlotName
             * @memberof protos.args.PostgresReadArgs
             * @instance
             */
            PostgresReadArgs.prototype.replicationSlotName = "";

            /**
             * PostgresReadArgs publisherName.
             * @member {string} publisherName
             * @memberof protos.args.PostgresReadArgs
             * @instance
             */
            PostgresReadArgs.prototype.publisherName = "";

            /**
             * Creates a new PostgresReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {protos.args.IPostgresReadArgs=} [properties] Properties to set
             * @returns {protos.args.PostgresReadArgs} PostgresReadArgs instance
             */
            PostgresReadArgs.create = function create(properties) {
                return new PostgresReadArgs(properties);
            };

            /**
             * Encodes the specified PostgresReadArgs message. Does not implicitly {@link protos.args.PostgresReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {protos.args.IPostgresReadArgs} message PostgresReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PostgresReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.replicationSlotName != null && Object.hasOwnProperty.call(message, "replicationSlotName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.replicationSlotName);
                if (message.publisherName != null && Object.hasOwnProperty.call(message, "publisherName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.publisherName);
                return writer;
            };

            /**
             * Encodes the specified PostgresReadArgs message, length delimited. Does not implicitly {@link protos.args.PostgresReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {protos.args.IPostgresReadArgs} message PostgresReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PostgresReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PostgresReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.PostgresReadArgs} PostgresReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PostgresReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.PostgresReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.replicationSlotName = reader.string();
                        break;
                    case 3:
                        message.publisherName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PostgresReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.PostgresReadArgs} PostgresReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PostgresReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PostgresReadArgs message.
             * @function verify
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PostgresReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.replicationSlotName != null && message.hasOwnProperty("replicationSlotName"))
                    if (!$util.isString(message.replicationSlotName))
                        return "replicationSlotName: string expected";
                if (message.publisherName != null && message.hasOwnProperty("publisherName"))
                    if (!$util.isString(message.publisherName))
                        return "publisherName: string expected";
                return null;
            };

            /**
             * Creates a PostgresReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.PostgresReadArgs} PostgresReadArgs
             */
            PostgresReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.PostgresReadArgs)
                    return object;
                var message = new $root.protos.args.PostgresReadArgs();
                if (object.replicationSlotName != null)
                    message.replicationSlotName = String(object.replicationSlotName);
                if (object.publisherName != null)
                    message.publisherName = String(object.publisherName);
                return message;
            };

            /**
             * Creates a plain object from a PostgresReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.PostgresReadArgs
             * @static
             * @param {protos.args.PostgresReadArgs} message PostgresReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PostgresReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.replicationSlotName = "";
                    object.publisherName = "";
                }
                if (message.replicationSlotName != null && message.hasOwnProperty("replicationSlotName"))
                    object.replicationSlotName = message.replicationSlotName;
                if (message.publisherName != null && message.hasOwnProperty("publisherName"))
                    object.publisherName = message.publisherName;
                return object;
            };

            /**
             * Converts this PostgresReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.PostgresReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PostgresReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PostgresReadArgs;
        })();

        /**
         * SubscriptionType enum.
         * @name protos.args.SubscriptionType
         * @enum {number}
         * @property {number} SHARED=0 SHARED value
         * @property {number} EXCLUSIVE=1 EXCLUSIVE value
         * @property {number} FAILOVER=2 FAILOVER value
         * @property {number} KEYSHARED=3 KEYSHARED value
         */
        args.SubscriptionType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SHARED"] = 0;
            values[valuesById[1] = "EXCLUSIVE"] = 1;
            values[valuesById[2] = "FAILOVER"] = 2;
            values[valuesById[3] = "KEYSHARED"] = 3;
            return values;
        })();

        args.PulsarConn = (function() {

            /**
             * Properties of a PulsarConn.
             * @memberof protos.args
             * @interface IPulsarConn
             * @property {string|null} [dsn] PulsarConn dsn
             * @property {number|null} [connectTimeoutSeconds] PulsarConn connectTimeoutSeconds
             * @property {boolean|null} [tlsSkipVerify] PulsarConn tlsSkipVerify
             * @property {Uint8Array|null} [tlsClientCert] PulsarConn tlsClientCert
             * @property {Uint8Array|null} [tlsClientKey] PulsarConn tlsClientKey
             */

            /**
             * Constructs a new PulsarConn.
             * @memberof protos.args
             * @classdesc Represents a PulsarConn.
             * @implements IPulsarConn
             * @constructor
             * @param {protos.args.IPulsarConn=} [properties] Properties to set
             */
            function PulsarConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PulsarConn dsn.
             * @member {string} dsn
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.dsn = "";

            /**
             * PulsarConn connectTimeoutSeconds.
             * @member {number} connectTimeoutSeconds
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.connectTimeoutSeconds = 0;

            /**
             * PulsarConn tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.tlsSkipVerify = false;

            /**
             * PulsarConn tlsClientCert.
             * @member {Uint8Array} tlsClientCert
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.tlsClientCert = $util.newBuffer([]);

            /**
             * PulsarConn tlsClientKey.
             * @member {Uint8Array} tlsClientKey
             * @memberof protos.args.PulsarConn
             * @instance
             */
            PulsarConn.prototype.tlsClientKey = $util.newBuffer([]);

            /**
             * Creates a new PulsarConn instance using the specified properties.
             * @function create
             * @memberof protos.args.PulsarConn
             * @static
             * @param {protos.args.IPulsarConn=} [properties] Properties to set
             * @returns {protos.args.PulsarConn} PulsarConn instance
             */
            PulsarConn.create = function create(properties) {
                return new PulsarConn(properties);
            };

            /**
             * Encodes the specified PulsarConn message. Does not implicitly {@link protos.args.PulsarConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.PulsarConn
             * @static
             * @param {protos.args.IPulsarConn} message PulsarConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                if (message.connectTimeoutSeconds != null && Object.hasOwnProperty.call(message, "connectTimeoutSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.connectTimeoutSeconds);
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.tlsSkipVerify);
                if (message.tlsClientCert != null && Object.hasOwnProperty.call(message, "tlsClientCert"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.tlsClientCert);
                if (message.tlsClientKey != null && Object.hasOwnProperty.call(message, "tlsClientKey"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.tlsClientKey);
                return writer;
            };

            /**
             * Encodes the specified PulsarConn message, length delimited. Does not implicitly {@link protos.args.PulsarConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.PulsarConn
             * @static
             * @param {protos.args.IPulsarConn} message PulsarConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PulsarConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.PulsarConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.PulsarConn} PulsarConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.PulsarConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    case 2:
                        message.connectTimeoutSeconds = reader.uint32();
                        break;
                    case 3:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    case 4:
                        message.tlsClientCert = reader.bytes();
                        break;
                    case 5:
                        message.tlsClientKey = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PulsarConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.PulsarConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.PulsarConn} PulsarConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PulsarConn message.
             * @function verify
             * @memberof protos.args.PulsarConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PulsarConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                if (message.connectTimeoutSeconds != null && message.hasOwnProperty("connectTimeoutSeconds"))
                    if (!$util.isInteger(message.connectTimeoutSeconds))
                        return "connectTimeoutSeconds: integer expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    if (!(message.tlsClientCert && typeof message.tlsClientCert.length === "number" || $util.isString(message.tlsClientCert)))
                        return "tlsClientCert: buffer expected";
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    if (!(message.tlsClientKey && typeof message.tlsClientKey.length === "number" || $util.isString(message.tlsClientKey)))
                        return "tlsClientKey: buffer expected";
                return null;
            };

            /**
             * Creates a PulsarConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.PulsarConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.PulsarConn} PulsarConn
             */
            PulsarConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.PulsarConn)
                    return object;
                var message = new $root.protos.args.PulsarConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                if (object.connectTimeoutSeconds != null)
                    message.connectTimeoutSeconds = object.connectTimeoutSeconds >>> 0;
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                if (object.tlsClientCert != null)
                    if (typeof object.tlsClientCert === "string")
                        $util.base64.decode(object.tlsClientCert, message.tlsClientCert = $util.newBuffer($util.base64.length(object.tlsClientCert)), 0);
                    else if (object.tlsClientCert.length)
                        message.tlsClientCert = object.tlsClientCert;
                if (object.tlsClientKey != null)
                    if (typeof object.tlsClientKey === "string")
                        $util.base64.decode(object.tlsClientKey, message.tlsClientKey = $util.newBuffer($util.base64.length(object.tlsClientKey)), 0);
                    else if (object.tlsClientKey.length)
                        message.tlsClientKey = object.tlsClientKey;
                return message;
            };

            /**
             * Creates a plain object from a PulsarConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.PulsarConn
             * @static
             * @param {protos.args.PulsarConn} message PulsarConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PulsarConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.dsn = "";
                    object.connectTimeoutSeconds = 0;
                    object.tlsSkipVerify = false;
                    if (options.bytes === String)
                        object.tlsClientCert = "";
                    else {
                        object.tlsClientCert = [];
                        if (options.bytes !== Array)
                            object.tlsClientCert = $util.newBuffer(object.tlsClientCert);
                    }
                    if (options.bytes === String)
                        object.tlsClientKey = "";
                    else {
                        object.tlsClientKey = [];
                        if (options.bytes !== Array)
                            object.tlsClientKey = $util.newBuffer(object.tlsClientKey);
                    }
                }
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                if (message.connectTimeoutSeconds != null && message.hasOwnProperty("connectTimeoutSeconds"))
                    object.connectTimeoutSeconds = message.connectTimeoutSeconds;
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                if (message.tlsClientCert != null && message.hasOwnProperty("tlsClientCert"))
                    object.tlsClientCert = options.bytes === String ? $util.base64.encode(message.tlsClientCert, 0, message.tlsClientCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientCert) : message.tlsClientCert;
                if (message.tlsClientKey != null && message.hasOwnProperty("tlsClientKey"))
                    object.tlsClientKey = options.bytes === String ? $util.base64.encode(message.tlsClientKey, 0, message.tlsClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsClientKey) : message.tlsClientKey;
                return object;
            };

            /**
             * Converts this PulsarConn to JSON.
             * @function toJSON
             * @memberof protos.args.PulsarConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PulsarConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PulsarConn;
        })();

        args.PulsarReadArgs = (function() {

            /**
             * Properties of a PulsarReadArgs.
             * @memberof protos.args
             * @interface IPulsarReadArgs
             * @property {string|null} [topic] PulsarReadArgs topic
             * @property {string|null} [subscriptionName] PulsarReadArgs subscriptionName
             * @property {protos.args.SubscriptionType|null} [subscriptionType] PulsarReadArgs subscriptionType
             */

            /**
             * Constructs a new PulsarReadArgs.
             * @memberof protos.args
             * @classdesc Represents a PulsarReadArgs.
             * @implements IPulsarReadArgs
             * @constructor
             * @param {protos.args.IPulsarReadArgs=} [properties] Properties to set
             */
            function PulsarReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PulsarReadArgs topic.
             * @member {string} topic
             * @memberof protos.args.PulsarReadArgs
             * @instance
             */
            PulsarReadArgs.prototype.topic = "";

            /**
             * PulsarReadArgs subscriptionName.
             * @member {string} subscriptionName
             * @memberof protos.args.PulsarReadArgs
             * @instance
             */
            PulsarReadArgs.prototype.subscriptionName = "";

            /**
             * PulsarReadArgs subscriptionType.
             * @member {protos.args.SubscriptionType} subscriptionType
             * @memberof protos.args.PulsarReadArgs
             * @instance
             */
            PulsarReadArgs.prototype.subscriptionType = 0;

            /**
             * Creates a new PulsarReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {protos.args.IPulsarReadArgs=} [properties] Properties to set
             * @returns {protos.args.PulsarReadArgs} PulsarReadArgs instance
             */
            PulsarReadArgs.create = function create(properties) {
                return new PulsarReadArgs(properties);
            };

            /**
             * Encodes the specified PulsarReadArgs message. Does not implicitly {@link protos.args.PulsarReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {protos.args.IPulsarReadArgs} message PulsarReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.subscriptionName != null && Object.hasOwnProperty.call(message, "subscriptionName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.subscriptionName);
                if (message.subscriptionType != null && Object.hasOwnProperty.call(message, "subscriptionType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.subscriptionType);
                return writer;
            };

            /**
             * Encodes the specified PulsarReadArgs message, length delimited. Does not implicitly {@link protos.args.PulsarReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {protos.args.IPulsarReadArgs} message PulsarReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PulsarReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.PulsarReadArgs} PulsarReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.PulsarReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.subscriptionName = reader.string();
                        break;
                    case 3:
                        message.subscriptionType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PulsarReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.PulsarReadArgs} PulsarReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PulsarReadArgs message.
             * @function verify
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PulsarReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.subscriptionName != null && message.hasOwnProperty("subscriptionName"))
                    if (!$util.isString(message.subscriptionName))
                        return "subscriptionName: string expected";
                if (message.subscriptionType != null && message.hasOwnProperty("subscriptionType"))
                    switch (message.subscriptionType) {
                    default:
                        return "subscriptionType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            /**
             * Creates a PulsarReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.PulsarReadArgs} PulsarReadArgs
             */
            PulsarReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.PulsarReadArgs)
                    return object;
                var message = new $root.protos.args.PulsarReadArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.subscriptionName != null)
                    message.subscriptionName = String(object.subscriptionName);
                switch (object.subscriptionType) {
                case "SHARED":
                case 0:
                    message.subscriptionType = 0;
                    break;
                case "EXCLUSIVE":
                case 1:
                    message.subscriptionType = 1;
                    break;
                case "FAILOVER":
                case 2:
                    message.subscriptionType = 2;
                    break;
                case "KEYSHARED":
                case 3:
                    message.subscriptionType = 3;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a PulsarReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.PulsarReadArgs
             * @static
             * @param {protos.args.PulsarReadArgs} message PulsarReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PulsarReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.topic = "";
                    object.subscriptionName = "";
                    object.subscriptionType = options.enums === String ? "SHARED" : 0;
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.subscriptionName != null && message.hasOwnProperty("subscriptionName"))
                    object.subscriptionName = message.subscriptionName;
                if (message.subscriptionType != null && message.hasOwnProperty("subscriptionType"))
                    object.subscriptionType = options.enums === String ? $root.protos.args.SubscriptionType[message.subscriptionType] : message.subscriptionType;
                return object;
            };

            /**
             * Converts this PulsarReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.PulsarReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PulsarReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PulsarReadArgs;
        })();

        args.PulsarWriteArgs = (function() {

            /**
             * Properties of a PulsarWriteArgs.
             * @memberof protos.args
             * @interface IPulsarWriteArgs
             * @property {string|null} [topic] PulsarWriteArgs topic
             */

            /**
             * Constructs a new PulsarWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a PulsarWriteArgs.
             * @implements IPulsarWriteArgs
             * @constructor
             * @param {protos.args.IPulsarWriteArgs=} [properties] Properties to set
             */
            function PulsarWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PulsarWriteArgs topic.
             * @member {string} topic
             * @memberof protos.args.PulsarWriteArgs
             * @instance
             */
            PulsarWriteArgs.prototype.topic = "";

            /**
             * Creates a new PulsarWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {protos.args.IPulsarWriteArgs=} [properties] Properties to set
             * @returns {protos.args.PulsarWriteArgs} PulsarWriteArgs instance
             */
            PulsarWriteArgs.create = function create(properties) {
                return new PulsarWriteArgs(properties);
            };

            /**
             * Encodes the specified PulsarWriteArgs message. Does not implicitly {@link protos.args.PulsarWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {protos.args.IPulsarWriteArgs} message PulsarWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                return writer;
            };

            /**
             * Encodes the specified PulsarWriteArgs message, length delimited. Does not implicitly {@link protos.args.PulsarWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {protos.args.IPulsarWriteArgs} message PulsarWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PulsarWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PulsarWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.PulsarWriteArgs} PulsarWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.PulsarWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PulsarWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.PulsarWriteArgs} PulsarWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PulsarWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PulsarWriteArgs message.
             * @function verify
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PulsarWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                return null;
            };

            /**
             * Creates a PulsarWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.PulsarWriteArgs} PulsarWriteArgs
             */
            PulsarWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.PulsarWriteArgs)
                    return object;
                var message = new $root.protos.args.PulsarWriteArgs();
                if (object.topic != null)
                    message.topic = String(object.topic);
                return message;
            };

            /**
             * Creates a plain object from a PulsarWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.PulsarWriteArgs
             * @static
             * @param {protos.args.PulsarWriteArgs} message PulsarWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PulsarWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.topic = "";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                return object;
            };

            /**
             * Converts this PulsarWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.PulsarWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PulsarWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PulsarWriteArgs;
        })();

        args.RabbitConn = (function() {

            /**
             * Properties of a RabbitConn.
             * @memberof protos.args
             * @interface IRabbitConn
             * @property {string|null} [address] RabbitConn address
             * @property {boolean|null} [useTls] RabbitConn useTls
             * @property {boolean|null} [tlsSkipVerify] RabbitConn tlsSkipVerify
             */

            /**
             * Constructs a new RabbitConn.
             * @memberof protos.args
             * @classdesc Represents a RabbitConn.
             * @implements IRabbitConn
             * @constructor
             * @param {protos.args.IRabbitConn=} [properties] Properties to set
             */
            function RabbitConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitConn address.
             * @member {string} address
             * @memberof protos.args.RabbitConn
             * @instance
             */
            RabbitConn.prototype.address = "";

            /**
             * RabbitConn useTls.
             * @member {boolean} useTls
             * @memberof protos.args.RabbitConn
             * @instance
             */
            RabbitConn.prototype.useTls = false;

            /**
             * RabbitConn tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.args.RabbitConn
             * @instance
             */
            RabbitConn.prototype.tlsSkipVerify = false;

            /**
             * Creates a new RabbitConn instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitConn
             * @static
             * @param {protos.args.IRabbitConn=} [properties] Properties to set
             * @returns {protos.args.RabbitConn} RabbitConn instance
             */
            RabbitConn.create = function create(properties) {
                return new RabbitConn(properties);
            };

            /**
             * Encodes the specified RabbitConn message. Does not implicitly {@link protos.args.RabbitConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitConn
             * @static
             * @param {protos.args.IRabbitConn} message RabbitConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.useTls);
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.tlsSkipVerify);
                return writer;
            };

            /**
             * Encodes the specified RabbitConn message, length delimited. Does not implicitly {@link protos.args.RabbitConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitConn
             * @static
             * @param {protos.args.IRabbitConn} message RabbitConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitConn} RabbitConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.useTls = reader.bool();
                        break;
                    case 3:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitConn} RabbitConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitConn message.
             * @function verify
             * @memberof protos.args.RabbitConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                return null;
            };

            /**
             * Creates a RabbitConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitConn} RabbitConn
             */
            RabbitConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitConn)
                    return object;
                var message = new $root.protos.args.RabbitConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                return message;
            };

            /**
             * Creates a plain object from a RabbitConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitConn
             * @static
             * @param {protos.args.RabbitConn} message RabbitConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = "";
                    object.useTls = false;
                    object.tlsSkipVerify = false;
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                return object;
            };

            /**
             * Converts this RabbitConn to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitConn;
        })();

        args.RabbitReadArgs = (function() {

            /**
             * Properties of a RabbitReadArgs.
             * @memberof protos.args
             * @interface IRabbitReadArgs
             * @property {string|null} [exchangeName] RabbitReadArgs exchangeName
             * @property {string|null} [queueName] RabbitReadArgs queueName
             * @property {string|null} [bindingKey] RabbitReadArgs bindingKey
             * @property {boolean|null} [queueExclusive] RabbitReadArgs queueExclusive
             * @property {boolean|null} [queueDeclare] RabbitReadArgs queueDeclare
             * @property {boolean|null} [queueDurable] RabbitReadArgs queueDurable
             * @property {boolean|null} [autoAck] RabbitReadArgs autoAck
             * @property {string|null} [consumerTag] RabbitReadArgs consumerTag
             * @property {boolean|null} [queueDelete] RabbitReadArgs queueDelete
             * @property {Object.<string,string>|null} [queueArg] RabbitReadArgs queueArg
             */

            /**
             * Constructs a new RabbitReadArgs.
             * @memberof protos.args
             * @classdesc Represents a RabbitReadArgs.
             * @implements IRabbitReadArgs
             * @constructor
             * @param {protos.args.IRabbitReadArgs=} [properties] Properties to set
             */
            function RabbitReadArgs(properties) {
                this.queueArg = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitReadArgs exchangeName.
             * @member {string} exchangeName
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.exchangeName = "";

            /**
             * RabbitReadArgs queueName.
             * @member {string} queueName
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueName = "";

            /**
             * RabbitReadArgs bindingKey.
             * @member {string} bindingKey
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.bindingKey = "";

            /**
             * RabbitReadArgs queueExclusive.
             * @member {boolean} queueExclusive
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueExclusive = false;

            /**
             * RabbitReadArgs queueDeclare.
             * @member {boolean} queueDeclare
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueDeclare = false;

            /**
             * RabbitReadArgs queueDurable.
             * @member {boolean} queueDurable
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueDurable = false;

            /**
             * RabbitReadArgs autoAck.
             * @member {boolean} autoAck
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.autoAck = false;

            /**
             * RabbitReadArgs consumerTag.
             * @member {string} consumerTag
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.consumerTag = "";

            /**
             * RabbitReadArgs queueDelete.
             * @member {boolean} queueDelete
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueDelete = false;

            /**
             * RabbitReadArgs queueArg.
             * @member {Object.<string,string>} queueArg
             * @memberof protos.args.RabbitReadArgs
             * @instance
             */
            RabbitReadArgs.prototype.queueArg = $util.emptyObject;

            /**
             * Creates a new RabbitReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {protos.args.IRabbitReadArgs=} [properties] Properties to set
             * @returns {protos.args.RabbitReadArgs} RabbitReadArgs instance
             */
            RabbitReadArgs.create = function create(properties) {
                return new RabbitReadArgs(properties);
            };

            /**
             * Encodes the specified RabbitReadArgs message. Does not implicitly {@link protos.args.RabbitReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {protos.args.IRabbitReadArgs} message RabbitReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.exchangeName != null && Object.hasOwnProperty.call(message, "exchangeName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.exchangeName);
                if (message.queueName != null && Object.hasOwnProperty.call(message, "queueName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.queueName);
                if (message.bindingKey != null && Object.hasOwnProperty.call(message, "bindingKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.bindingKey);
                if (message.queueExclusive != null && Object.hasOwnProperty.call(message, "queueExclusive"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.queueExclusive);
                if (message.queueDeclare != null && Object.hasOwnProperty.call(message, "queueDeclare"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.queueDeclare);
                if (message.queueDurable != null && Object.hasOwnProperty.call(message, "queueDurable"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.queueDurable);
                if (message.autoAck != null && Object.hasOwnProperty.call(message, "autoAck"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.autoAck);
                if (message.consumerTag != null && Object.hasOwnProperty.call(message, "consumerTag"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.consumerTag);
                if (message.queueDelete != null && Object.hasOwnProperty.call(message, "queueDelete"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.queueDelete);
                if (message.queueArg != null && Object.hasOwnProperty.call(message, "queueArg"))
                    for (var keys = Object.keys(message.queueArg), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.queueArg[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RabbitReadArgs message, length delimited. Does not implicitly {@link protos.args.RabbitReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {protos.args.IRabbitReadArgs} message RabbitReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitReadArgs} RabbitReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitReadArgs(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.exchangeName = reader.string();
                        break;
                    case 2:
                        message.queueName = reader.string();
                        break;
                    case 3:
                        message.bindingKey = reader.string();
                        break;
                    case 4:
                        message.queueExclusive = reader.bool();
                        break;
                    case 5:
                        message.queueDeclare = reader.bool();
                        break;
                    case 6:
                        message.queueDurable = reader.bool();
                        break;
                    case 7:
                        message.autoAck = reader.bool();
                        break;
                    case 8:
                        message.consumerTag = reader.string();
                        break;
                    case 9:
                        message.queueDelete = reader.bool();
                        break;
                    case 10:
                        if (message.queueArg === $util.emptyObject)
                            message.queueArg = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.queueArg[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitReadArgs} RabbitReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitReadArgs message.
             * @function verify
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.exchangeName != null && message.hasOwnProperty("exchangeName"))
                    if (!$util.isString(message.exchangeName))
                        return "exchangeName: string expected";
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    if (!$util.isString(message.queueName))
                        return "queueName: string expected";
                if (message.bindingKey != null && message.hasOwnProperty("bindingKey"))
                    if (!$util.isString(message.bindingKey))
                        return "bindingKey: string expected";
                if (message.queueExclusive != null && message.hasOwnProperty("queueExclusive"))
                    if (typeof message.queueExclusive !== "boolean")
                        return "queueExclusive: boolean expected";
                if (message.queueDeclare != null && message.hasOwnProperty("queueDeclare"))
                    if (typeof message.queueDeclare !== "boolean")
                        return "queueDeclare: boolean expected";
                if (message.queueDurable != null && message.hasOwnProperty("queueDurable"))
                    if (typeof message.queueDurable !== "boolean")
                        return "queueDurable: boolean expected";
                if (message.autoAck != null && message.hasOwnProperty("autoAck"))
                    if (typeof message.autoAck !== "boolean")
                        return "autoAck: boolean expected";
                if (message.consumerTag != null && message.hasOwnProperty("consumerTag"))
                    if (!$util.isString(message.consumerTag))
                        return "consumerTag: string expected";
                if (message.queueDelete != null && message.hasOwnProperty("queueDelete"))
                    if (typeof message.queueDelete !== "boolean")
                        return "queueDelete: boolean expected";
                if (message.queueArg != null && message.hasOwnProperty("queueArg")) {
                    if (!$util.isObject(message.queueArg))
                        return "queueArg: object expected";
                    var key = Object.keys(message.queueArg);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.queueArg[key[i]]))
                            return "queueArg: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a RabbitReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitReadArgs} RabbitReadArgs
             */
            RabbitReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitReadArgs)
                    return object;
                var message = new $root.protos.args.RabbitReadArgs();
                if (object.exchangeName != null)
                    message.exchangeName = String(object.exchangeName);
                if (object.queueName != null)
                    message.queueName = String(object.queueName);
                if (object.bindingKey != null)
                    message.bindingKey = String(object.bindingKey);
                if (object.queueExclusive != null)
                    message.queueExclusive = Boolean(object.queueExclusive);
                if (object.queueDeclare != null)
                    message.queueDeclare = Boolean(object.queueDeclare);
                if (object.queueDurable != null)
                    message.queueDurable = Boolean(object.queueDurable);
                if (object.autoAck != null)
                    message.autoAck = Boolean(object.autoAck);
                if (object.consumerTag != null)
                    message.consumerTag = String(object.consumerTag);
                if (object.queueDelete != null)
                    message.queueDelete = Boolean(object.queueDelete);
                if (object.queueArg) {
                    if (typeof object.queueArg !== "object")
                        throw TypeError(".protos.args.RabbitReadArgs.queueArg: object expected");
                    message.queueArg = {};
                    for (var keys = Object.keys(object.queueArg), i = 0; i < keys.length; ++i)
                        message.queueArg[keys[i]] = String(object.queueArg[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a RabbitReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitReadArgs
             * @static
             * @param {protos.args.RabbitReadArgs} message RabbitReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.queueArg = {};
                if (options.defaults) {
                    object.exchangeName = "";
                    object.queueName = "";
                    object.bindingKey = "";
                    object.queueExclusive = false;
                    object.queueDeclare = false;
                    object.queueDurable = false;
                    object.autoAck = false;
                    object.consumerTag = "";
                    object.queueDelete = false;
                }
                if (message.exchangeName != null && message.hasOwnProperty("exchangeName"))
                    object.exchangeName = message.exchangeName;
                if (message.queueName != null && message.hasOwnProperty("queueName"))
                    object.queueName = message.queueName;
                if (message.bindingKey != null && message.hasOwnProperty("bindingKey"))
                    object.bindingKey = message.bindingKey;
                if (message.queueExclusive != null && message.hasOwnProperty("queueExclusive"))
                    object.queueExclusive = message.queueExclusive;
                if (message.queueDeclare != null && message.hasOwnProperty("queueDeclare"))
                    object.queueDeclare = message.queueDeclare;
                if (message.queueDurable != null && message.hasOwnProperty("queueDurable"))
                    object.queueDurable = message.queueDurable;
                if (message.autoAck != null && message.hasOwnProperty("autoAck"))
                    object.autoAck = message.autoAck;
                if (message.consumerTag != null && message.hasOwnProperty("consumerTag"))
                    object.consumerTag = message.consumerTag;
                if (message.queueDelete != null && message.hasOwnProperty("queueDelete"))
                    object.queueDelete = message.queueDelete;
                var keys2;
                if (message.queueArg && (keys2 = Object.keys(message.queueArg)).length) {
                    object.queueArg = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.queueArg[keys2[j]] = message.queueArg[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this RabbitReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitReadArgs;
        })();

        args.RabbitWriteArgs = (function() {

            /**
             * Properties of a RabbitWriteArgs.
             * @memberof protos.args
             * @interface IRabbitWriteArgs
             * @property {string|null} [exchangeName] RabbitWriteArgs exchangeName
             * @property {string|null} [routingKey] RabbitWriteArgs routingKey
             * @property {string|null} [appId] RabbitWriteArgs appId
             * @property {string|null} [exchangeType] RabbitWriteArgs exchangeType
             * @property {boolean|null} [exchangeDeclare] RabbitWriteArgs exchangeDeclare
             * @property {boolean|null} [exchangeDurable] RabbitWriteArgs exchangeDurable
             * @property {boolean|null} [exchangeAutoDelete] RabbitWriteArgs exchangeAutoDelete
             */

            /**
             * Constructs a new RabbitWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a RabbitWriteArgs.
             * @implements IRabbitWriteArgs
             * @constructor
             * @param {protos.args.IRabbitWriteArgs=} [properties] Properties to set
             */
            function RabbitWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitWriteArgs exchangeName.
             * @member {string} exchangeName
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.exchangeName = "";

            /**
             * RabbitWriteArgs routingKey.
             * @member {string} routingKey
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.routingKey = "";

            /**
             * RabbitWriteArgs appId.
             * @member {string} appId
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.appId = "";

            /**
             * RabbitWriteArgs exchangeType.
             * @member {string} exchangeType
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.exchangeType = "";

            /**
             * RabbitWriteArgs exchangeDeclare.
             * @member {boolean} exchangeDeclare
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.exchangeDeclare = false;

            /**
             * RabbitWriteArgs exchangeDurable.
             * @member {boolean} exchangeDurable
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.exchangeDurable = false;

            /**
             * RabbitWriteArgs exchangeAutoDelete.
             * @member {boolean} exchangeAutoDelete
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             */
            RabbitWriteArgs.prototype.exchangeAutoDelete = false;

            /**
             * Creates a new RabbitWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {protos.args.IRabbitWriteArgs=} [properties] Properties to set
             * @returns {protos.args.RabbitWriteArgs} RabbitWriteArgs instance
             */
            RabbitWriteArgs.create = function create(properties) {
                return new RabbitWriteArgs(properties);
            };

            /**
             * Encodes the specified RabbitWriteArgs message. Does not implicitly {@link protos.args.RabbitWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {protos.args.IRabbitWriteArgs} message RabbitWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.exchangeName != null && Object.hasOwnProperty.call(message, "exchangeName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.exchangeName);
                if (message.routingKey != null && Object.hasOwnProperty.call(message, "routingKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.routingKey);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.appId);
                if (message.exchangeType != null && Object.hasOwnProperty.call(message, "exchangeType"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.exchangeType);
                if (message.exchangeDeclare != null && Object.hasOwnProperty.call(message, "exchangeDeclare"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.exchangeDeclare);
                if (message.exchangeDurable != null && Object.hasOwnProperty.call(message, "exchangeDurable"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.exchangeDurable);
                if (message.exchangeAutoDelete != null && Object.hasOwnProperty.call(message, "exchangeAutoDelete"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.exchangeAutoDelete);
                return writer;
            };

            /**
             * Encodes the specified RabbitWriteArgs message, length delimited. Does not implicitly {@link protos.args.RabbitWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {protos.args.IRabbitWriteArgs} message RabbitWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitWriteArgs} RabbitWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.exchangeName = reader.string();
                        break;
                    case 2:
                        message.routingKey = reader.string();
                        break;
                    case 3:
                        message.appId = reader.string();
                        break;
                    case 4:
                        message.exchangeType = reader.string();
                        break;
                    case 5:
                        message.exchangeDeclare = reader.bool();
                        break;
                    case 6:
                        message.exchangeDurable = reader.bool();
                        break;
                    case 7:
                        message.exchangeAutoDelete = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitWriteArgs} RabbitWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitWriteArgs message.
             * @function verify
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.exchangeName != null && message.hasOwnProperty("exchangeName"))
                    if (!$util.isString(message.exchangeName))
                        return "exchangeName: string expected";
                if (message.routingKey != null && message.hasOwnProperty("routingKey"))
                    if (!$util.isString(message.routingKey))
                        return "routingKey: string expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!$util.isString(message.appId))
                        return "appId: string expected";
                if (message.exchangeType != null && message.hasOwnProperty("exchangeType"))
                    if (!$util.isString(message.exchangeType))
                        return "exchangeType: string expected";
                if (message.exchangeDeclare != null && message.hasOwnProperty("exchangeDeclare"))
                    if (typeof message.exchangeDeclare !== "boolean")
                        return "exchangeDeclare: boolean expected";
                if (message.exchangeDurable != null && message.hasOwnProperty("exchangeDurable"))
                    if (typeof message.exchangeDurable !== "boolean")
                        return "exchangeDurable: boolean expected";
                if (message.exchangeAutoDelete != null && message.hasOwnProperty("exchangeAutoDelete"))
                    if (typeof message.exchangeAutoDelete !== "boolean")
                        return "exchangeAutoDelete: boolean expected";
                return null;
            };

            /**
             * Creates a RabbitWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitWriteArgs} RabbitWriteArgs
             */
            RabbitWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitWriteArgs)
                    return object;
                var message = new $root.protos.args.RabbitWriteArgs();
                if (object.exchangeName != null)
                    message.exchangeName = String(object.exchangeName);
                if (object.routingKey != null)
                    message.routingKey = String(object.routingKey);
                if (object.appId != null)
                    message.appId = String(object.appId);
                if (object.exchangeType != null)
                    message.exchangeType = String(object.exchangeType);
                if (object.exchangeDeclare != null)
                    message.exchangeDeclare = Boolean(object.exchangeDeclare);
                if (object.exchangeDurable != null)
                    message.exchangeDurable = Boolean(object.exchangeDurable);
                if (object.exchangeAutoDelete != null)
                    message.exchangeAutoDelete = Boolean(object.exchangeAutoDelete);
                return message;
            };

            /**
             * Creates a plain object from a RabbitWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitWriteArgs
             * @static
             * @param {protos.args.RabbitWriteArgs} message RabbitWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.exchangeName = "";
                    object.routingKey = "";
                    object.appId = "";
                    object.exchangeType = "";
                    object.exchangeDeclare = false;
                    object.exchangeDurable = false;
                    object.exchangeAutoDelete = false;
                }
                if (message.exchangeName != null && message.hasOwnProperty("exchangeName"))
                    object.exchangeName = message.exchangeName;
                if (message.routingKey != null && message.hasOwnProperty("routingKey"))
                    object.routingKey = message.routingKey;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = message.appId;
                if (message.exchangeType != null && message.hasOwnProperty("exchangeType"))
                    object.exchangeType = message.exchangeType;
                if (message.exchangeDeclare != null && message.hasOwnProperty("exchangeDeclare"))
                    object.exchangeDeclare = message.exchangeDeclare;
                if (message.exchangeDurable != null && message.hasOwnProperty("exchangeDurable"))
                    object.exchangeDurable = message.exchangeDurable;
                if (message.exchangeAutoDelete != null && message.hasOwnProperty("exchangeAutoDelete"))
                    object.exchangeAutoDelete = message.exchangeAutoDelete;
                return object;
            };

            /**
             * Converts this RabbitWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitWriteArgs;
        })();

        args.RabbitStreamsConn = (function() {

            /**
             * Properties of a RabbitStreamsConn.
             * @memberof protos.args
             * @interface IRabbitStreamsConn
             * @property {string|null} [dsn] RabbitStreamsConn dsn
             * @property {boolean|null} [useTls] RabbitStreamsConn useTls
             * @property {boolean|null} [tlsSkipVerify] RabbitStreamsConn tlsSkipVerify
             * @property {string|null} [username] RabbitStreamsConn username
             * @property {string|null} [password] RabbitStreamsConn password
             * @property {string|null} [clientName] RabbitStreamsConn clientName
             */

            /**
             * Constructs a new RabbitStreamsConn.
             * @memberof protos.args
             * @classdesc Represents a RabbitStreamsConn.
             * @implements IRabbitStreamsConn
             * @constructor
             * @param {protos.args.IRabbitStreamsConn=} [properties] Properties to set
             */
            function RabbitStreamsConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreamsConn dsn.
             * @member {string} dsn
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.dsn = "";

            /**
             * RabbitStreamsConn useTls.
             * @member {boolean} useTls
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.useTls = false;

            /**
             * RabbitStreamsConn tlsSkipVerify.
             * @member {boolean} tlsSkipVerify
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.tlsSkipVerify = false;

            /**
             * RabbitStreamsConn username.
             * @member {string} username
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.username = "";

            /**
             * RabbitStreamsConn password.
             * @member {string} password
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.password = "";

            /**
             * RabbitStreamsConn clientName.
             * @member {string} clientName
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             */
            RabbitStreamsConn.prototype.clientName = "";

            /**
             * Creates a new RabbitStreamsConn instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {protos.args.IRabbitStreamsConn=} [properties] Properties to set
             * @returns {protos.args.RabbitStreamsConn} RabbitStreamsConn instance
             */
            RabbitStreamsConn.create = function create(properties) {
                return new RabbitStreamsConn(properties);
            };

            /**
             * Encodes the specified RabbitStreamsConn message. Does not implicitly {@link protos.args.RabbitStreamsConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {protos.args.IRabbitStreamsConn} message RabbitStreamsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dsn != null && Object.hasOwnProperty.call(message, "dsn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dsn);
                if (message.useTls != null && Object.hasOwnProperty.call(message, "useTls"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.useTls);
                if (message.tlsSkipVerify != null && Object.hasOwnProperty.call(message, "tlsSkipVerify"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.tlsSkipVerify);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.username);
                if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.password);
                if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.clientName);
                return writer;
            };

            /**
             * Encodes the specified RabbitStreamsConn message, length delimited. Does not implicitly {@link protos.args.RabbitStreamsConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {protos.args.IRabbitStreamsConn} message RabbitStreamsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreamsConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitStreamsConn} RabbitStreamsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitStreamsConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dsn = reader.string();
                        break;
                    case 2:
                        message.useTls = reader.bool();
                        break;
                    case 3:
                        message.tlsSkipVerify = reader.bool();
                        break;
                    case 4:
                        message.username = reader.string();
                        break;
                    case 5:
                        message.password = reader.string();
                        break;
                    case 6:
                        message.clientName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreamsConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitStreamsConn} RabbitStreamsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreamsConn message.
             * @function verify
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreamsConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    if (!$util.isString(message.dsn))
                        return "dsn: string expected";
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    if (typeof message.useTls !== "boolean")
                        return "useTls: boolean expected";
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    if (typeof message.tlsSkipVerify !== "boolean")
                        return "tlsSkipVerify: boolean expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!$util.isString(message.password))
                        return "password: string expected";
                if (message.clientName != null && message.hasOwnProperty("clientName"))
                    if (!$util.isString(message.clientName))
                        return "clientName: string expected";
                return null;
            };

            /**
             * Creates a RabbitStreamsConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitStreamsConn} RabbitStreamsConn
             */
            RabbitStreamsConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitStreamsConn)
                    return object;
                var message = new $root.protos.args.RabbitStreamsConn();
                if (object.dsn != null)
                    message.dsn = String(object.dsn);
                if (object.useTls != null)
                    message.useTls = Boolean(object.useTls);
                if (object.tlsSkipVerify != null)
                    message.tlsSkipVerify = Boolean(object.tlsSkipVerify);
                if (object.username != null)
                    message.username = String(object.username);
                if (object.password != null)
                    message.password = String(object.password);
                if (object.clientName != null)
                    message.clientName = String(object.clientName);
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreamsConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitStreamsConn
             * @static
             * @param {protos.args.RabbitStreamsConn} message RabbitStreamsConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreamsConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.dsn = "";
                    object.useTls = false;
                    object.tlsSkipVerify = false;
                    object.username = "";
                    object.password = "";
                    object.clientName = "";
                }
                if (message.dsn != null && message.hasOwnProperty("dsn"))
                    object.dsn = message.dsn;
                if (message.useTls != null && message.hasOwnProperty("useTls"))
                    object.useTls = message.useTls;
                if (message.tlsSkipVerify != null && message.hasOwnProperty("tlsSkipVerify"))
                    object.tlsSkipVerify = message.tlsSkipVerify;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = message.password;
                if (message.clientName != null && message.hasOwnProperty("clientName"))
                    object.clientName = message.clientName;
                return object;
            };

            /**
             * Converts this RabbitStreamsConn to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitStreamsConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreamsConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreamsConn;
        })();

        args.RabbitStreamsOffsetOptions = (function() {

            /**
             * Properties of a RabbitStreamsOffsetOptions.
             * @memberof protos.args
             * @interface IRabbitStreamsOffsetOptions
             * @property {number|Long|null} [specificOffset] RabbitStreamsOffsetOptions specificOffset
             * @property {boolean|null} [lastOffset] RabbitStreamsOffsetOptions lastOffset
             * @property {boolean|null} [lastConsumed] RabbitStreamsOffsetOptions lastConsumed
             * @property {boolean|null} [firstOffset] RabbitStreamsOffsetOptions firstOffset
             * @property {boolean|null} [nextOffset] RabbitStreamsOffsetOptions nextOffset
             */

            /**
             * Constructs a new RabbitStreamsOffsetOptions.
             * @memberof protos.args
             * @classdesc Represents a RabbitStreamsOffsetOptions.
             * @implements IRabbitStreamsOffsetOptions
             * @constructor
             * @param {protos.args.IRabbitStreamsOffsetOptions=} [properties] Properties to set
             */
            function RabbitStreamsOffsetOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreamsOffsetOptions specificOffset.
             * @member {number|Long} specificOffset
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             */
            RabbitStreamsOffsetOptions.prototype.specificOffset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * RabbitStreamsOffsetOptions lastOffset.
             * @member {boolean} lastOffset
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             */
            RabbitStreamsOffsetOptions.prototype.lastOffset = false;

            /**
             * RabbitStreamsOffsetOptions lastConsumed.
             * @member {boolean} lastConsumed
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             */
            RabbitStreamsOffsetOptions.prototype.lastConsumed = false;

            /**
             * RabbitStreamsOffsetOptions firstOffset.
             * @member {boolean} firstOffset
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             */
            RabbitStreamsOffsetOptions.prototype.firstOffset = false;

            /**
             * RabbitStreamsOffsetOptions nextOffset.
             * @member {boolean} nextOffset
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             */
            RabbitStreamsOffsetOptions.prototype.nextOffset = false;

            /**
             * Creates a new RabbitStreamsOffsetOptions instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {protos.args.IRabbitStreamsOffsetOptions=} [properties] Properties to set
             * @returns {protos.args.RabbitStreamsOffsetOptions} RabbitStreamsOffsetOptions instance
             */
            RabbitStreamsOffsetOptions.create = function create(properties) {
                return new RabbitStreamsOffsetOptions(properties);
            };

            /**
             * Encodes the specified RabbitStreamsOffsetOptions message. Does not implicitly {@link protos.args.RabbitStreamsOffsetOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {protos.args.IRabbitStreamsOffsetOptions} message RabbitStreamsOffsetOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsOffsetOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.specificOffset != null && Object.hasOwnProperty.call(message, "specificOffset"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.specificOffset);
                if (message.lastOffset != null && Object.hasOwnProperty.call(message, "lastOffset"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.lastOffset);
                if (message.lastConsumed != null && Object.hasOwnProperty.call(message, "lastConsumed"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.lastConsumed);
                if (message.firstOffset != null && Object.hasOwnProperty.call(message, "firstOffset"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.firstOffset);
                if (message.nextOffset != null && Object.hasOwnProperty.call(message, "nextOffset"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.nextOffset);
                return writer;
            };

            /**
             * Encodes the specified RabbitStreamsOffsetOptions message, length delimited. Does not implicitly {@link protos.args.RabbitStreamsOffsetOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {protos.args.IRabbitStreamsOffsetOptions} message RabbitStreamsOffsetOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsOffsetOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreamsOffsetOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitStreamsOffsetOptions} RabbitStreamsOffsetOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsOffsetOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitStreamsOffsetOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.specificOffset = reader.int64();
                        break;
                    case 2:
                        message.lastOffset = reader.bool();
                        break;
                    case 3:
                        message.lastConsumed = reader.bool();
                        break;
                    case 4:
                        message.firstOffset = reader.bool();
                        break;
                    case 5:
                        message.nextOffset = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreamsOffsetOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitStreamsOffsetOptions} RabbitStreamsOffsetOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsOffsetOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreamsOffsetOptions message.
             * @function verify
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreamsOffsetOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.specificOffset != null && message.hasOwnProperty("specificOffset"))
                    if (!$util.isInteger(message.specificOffset) && !(message.specificOffset && $util.isInteger(message.specificOffset.low) && $util.isInteger(message.specificOffset.high)))
                        return "specificOffset: integer|Long expected";
                if (message.lastOffset != null && message.hasOwnProperty("lastOffset"))
                    if (typeof message.lastOffset !== "boolean")
                        return "lastOffset: boolean expected";
                if (message.lastConsumed != null && message.hasOwnProperty("lastConsumed"))
                    if (typeof message.lastConsumed !== "boolean")
                        return "lastConsumed: boolean expected";
                if (message.firstOffset != null && message.hasOwnProperty("firstOffset"))
                    if (typeof message.firstOffset !== "boolean")
                        return "firstOffset: boolean expected";
                if (message.nextOffset != null && message.hasOwnProperty("nextOffset"))
                    if (typeof message.nextOffset !== "boolean")
                        return "nextOffset: boolean expected";
                return null;
            };

            /**
             * Creates a RabbitStreamsOffsetOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitStreamsOffsetOptions} RabbitStreamsOffsetOptions
             */
            RabbitStreamsOffsetOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitStreamsOffsetOptions)
                    return object;
                var message = new $root.protos.args.RabbitStreamsOffsetOptions();
                if (object.specificOffset != null)
                    if ($util.Long)
                        (message.specificOffset = $util.Long.fromValue(object.specificOffset)).unsigned = false;
                    else if (typeof object.specificOffset === "string")
                        message.specificOffset = parseInt(object.specificOffset, 10);
                    else if (typeof object.specificOffset === "number")
                        message.specificOffset = object.specificOffset;
                    else if (typeof object.specificOffset === "object")
                        message.specificOffset = new $util.LongBits(object.specificOffset.low >>> 0, object.specificOffset.high >>> 0).toNumber();
                if (object.lastOffset != null)
                    message.lastOffset = Boolean(object.lastOffset);
                if (object.lastConsumed != null)
                    message.lastConsumed = Boolean(object.lastConsumed);
                if (object.firstOffset != null)
                    message.firstOffset = Boolean(object.firstOffset);
                if (object.nextOffset != null)
                    message.nextOffset = Boolean(object.nextOffset);
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreamsOffsetOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @static
             * @param {protos.args.RabbitStreamsOffsetOptions} message RabbitStreamsOffsetOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreamsOffsetOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.specificOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.specificOffset = options.longs === String ? "0" : 0;
                    object.lastOffset = false;
                    object.lastConsumed = false;
                    object.firstOffset = false;
                    object.nextOffset = false;
                }
                if (message.specificOffset != null && message.hasOwnProperty("specificOffset"))
                    if (typeof message.specificOffset === "number")
                        object.specificOffset = options.longs === String ? String(message.specificOffset) : message.specificOffset;
                    else
                        object.specificOffset = options.longs === String ? $util.Long.prototype.toString.call(message.specificOffset) : options.longs === Number ? new $util.LongBits(message.specificOffset.low >>> 0, message.specificOffset.high >>> 0).toNumber() : message.specificOffset;
                if (message.lastOffset != null && message.hasOwnProperty("lastOffset"))
                    object.lastOffset = message.lastOffset;
                if (message.lastConsumed != null && message.hasOwnProperty("lastConsumed"))
                    object.lastConsumed = message.lastConsumed;
                if (message.firstOffset != null && message.hasOwnProperty("firstOffset"))
                    object.firstOffset = message.firstOffset;
                if (message.nextOffset != null && message.hasOwnProperty("nextOffset"))
                    object.nextOffset = message.nextOffset;
                return object;
            };

            /**
             * Converts this RabbitStreamsOffsetOptions to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitStreamsOffsetOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreamsOffsetOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreamsOffsetOptions;
        })();

        args.RabbitStreamsReadArgs = (function() {

            /**
             * Properties of a RabbitStreamsReadArgs.
             * @memberof protos.args
             * @interface IRabbitStreamsReadArgs
             * @property {string|null} [stream] RabbitStreamsReadArgs stream
             * @property {boolean|null} [declareStream] RabbitStreamsReadArgs declareStream
             * @property {string|null} [declareStreamSize] RabbitStreamsReadArgs declareStreamSize
             * @property {protos.args.IRabbitStreamsOffsetOptions|null} [offsetOptions] RabbitStreamsReadArgs offsetOptions
             */

            /**
             * Constructs a new RabbitStreamsReadArgs.
             * @memberof protos.args
             * @classdesc Represents a RabbitStreamsReadArgs.
             * @implements IRabbitStreamsReadArgs
             * @constructor
             * @param {protos.args.IRabbitStreamsReadArgs=} [properties] Properties to set
             */
            function RabbitStreamsReadArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreamsReadArgs stream.
             * @member {string} stream
             * @memberof protos.args.RabbitStreamsReadArgs
             * @instance
             */
            RabbitStreamsReadArgs.prototype.stream = "";

            /**
             * RabbitStreamsReadArgs declareStream.
             * @member {boolean} declareStream
             * @memberof protos.args.RabbitStreamsReadArgs
             * @instance
             */
            RabbitStreamsReadArgs.prototype.declareStream = false;

            /**
             * RabbitStreamsReadArgs declareStreamSize.
             * @member {string} declareStreamSize
             * @memberof protos.args.RabbitStreamsReadArgs
             * @instance
             */
            RabbitStreamsReadArgs.prototype.declareStreamSize = "";

            /**
             * RabbitStreamsReadArgs offsetOptions.
             * @member {protos.args.IRabbitStreamsOffsetOptions|null|undefined} offsetOptions
             * @memberof protos.args.RabbitStreamsReadArgs
             * @instance
             */
            RabbitStreamsReadArgs.prototype.offsetOptions = null;

            /**
             * Creates a new RabbitStreamsReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {protos.args.IRabbitStreamsReadArgs=} [properties] Properties to set
             * @returns {protos.args.RabbitStreamsReadArgs} RabbitStreamsReadArgs instance
             */
            RabbitStreamsReadArgs.create = function create(properties) {
                return new RabbitStreamsReadArgs(properties);
            };

            /**
             * Encodes the specified RabbitStreamsReadArgs message. Does not implicitly {@link protos.args.RabbitStreamsReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {protos.args.IRabbitStreamsReadArgs} message RabbitStreamsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stream);
                if (message.declareStream != null && Object.hasOwnProperty.call(message, "declareStream"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.declareStream);
                if (message.declareStreamSize != null && Object.hasOwnProperty.call(message, "declareStreamSize"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.declareStreamSize);
                if (message.offsetOptions != null && Object.hasOwnProperty.call(message, "offsetOptions"))
                    $root.protos.args.RabbitStreamsOffsetOptions.encode(message.offsetOptions, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RabbitStreamsReadArgs message, length delimited. Does not implicitly {@link protos.args.RabbitStreamsReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {protos.args.IRabbitStreamsReadArgs} message RabbitStreamsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreamsReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitStreamsReadArgs} RabbitStreamsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitStreamsReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stream = reader.string();
                        break;
                    case 2:
                        message.declareStream = reader.bool();
                        break;
                    case 3:
                        message.declareStreamSize = reader.string();
                        break;
                    case 4:
                        message.offsetOptions = $root.protos.args.RabbitStreamsOffsetOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreamsReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitStreamsReadArgs} RabbitStreamsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreamsReadArgs message.
             * @function verify
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreamsReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isString(message.stream))
                        return "stream: string expected";
                if (message.declareStream != null && message.hasOwnProperty("declareStream"))
                    if (typeof message.declareStream !== "boolean")
                        return "declareStream: boolean expected";
                if (message.declareStreamSize != null && message.hasOwnProperty("declareStreamSize"))
                    if (!$util.isString(message.declareStreamSize))
                        return "declareStreamSize: string expected";
                if (message.offsetOptions != null && message.hasOwnProperty("offsetOptions")) {
                    var error = $root.protos.args.RabbitStreamsOffsetOptions.verify(message.offsetOptions);
                    if (error)
                        return "offsetOptions." + error;
                }
                return null;
            };

            /**
             * Creates a RabbitStreamsReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitStreamsReadArgs} RabbitStreamsReadArgs
             */
            RabbitStreamsReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitStreamsReadArgs)
                    return object;
                var message = new $root.protos.args.RabbitStreamsReadArgs();
                if (object.stream != null)
                    message.stream = String(object.stream);
                if (object.declareStream != null)
                    message.declareStream = Boolean(object.declareStream);
                if (object.declareStreamSize != null)
                    message.declareStreamSize = String(object.declareStreamSize);
                if (object.offsetOptions != null) {
                    if (typeof object.offsetOptions !== "object")
                        throw TypeError(".protos.args.RabbitStreamsReadArgs.offsetOptions: object expected");
                    message.offsetOptions = $root.protos.args.RabbitStreamsOffsetOptions.fromObject(object.offsetOptions);
                }
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreamsReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitStreamsReadArgs
             * @static
             * @param {protos.args.RabbitStreamsReadArgs} message RabbitStreamsReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreamsReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.stream = "";
                    object.declareStream = false;
                    object.declareStreamSize = "";
                    object.offsetOptions = null;
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                if (message.declareStream != null && message.hasOwnProperty("declareStream"))
                    object.declareStream = message.declareStream;
                if (message.declareStreamSize != null && message.hasOwnProperty("declareStreamSize"))
                    object.declareStreamSize = message.declareStreamSize;
                if (message.offsetOptions != null && message.hasOwnProperty("offsetOptions"))
                    object.offsetOptions = $root.protos.args.RabbitStreamsOffsetOptions.toObject(message.offsetOptions, options);
                return object;
            };

            /**
             * Converts this RabbitStreamsReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitStreamsReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreamsReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreamsReadArgs;
        })();

        args.RabbitStreamsWriteArgs = (function() {

            /**
             * Properties of a RabbitStreamsWriteArgs.
             * @memberof protos.args
             * @interface IRabbitStreamsWriteArgs
             * @property {string|null} [stream] RabbitStreamsWriteArgs stream
             * @property {boolean|null} [declareStream] RabbitStreamsWriteArgs declareStream
             * @property {string|null} [declareStreamSize] RabbitStreamsWriteArgs declareStreamSize
             */

            /**
             * Constructs a new RabbitStreamsWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a RabbitStreamsWriteArgs.
             * @implements IRabbitStreamsWriteArgs
             * @constructor
             * @param {protos.args.IRabbitStreamsWriteArgs=} [properties] Properties to set
             */
            function RabbitStreamsWriteArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreamsWriteArgs stream.
             * @member {string} stream
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @instance
             */
            RabbitStreamsWriteArgs.prototype.stream = "";

            /**
             * RabbitStreamsWriteArgs declareStream.
             * @member {boolean} declareStream
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @instance
             */
            RabbitStreamsWriteArgs.prototype.declareStream = false;

            /**
             * RabbitStreamsWriteArgs declareStreamSize.
             * @member {string} declareStreamSize
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @instance
             */
            RabbitStreamsWriteArgs.prototype.declareStreamSize = "";

            /**
             * Creates a new RabbitStreamsWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {protos.args.IRabbitStreamsWriteArgs=} [properties] Properties to set
             * @returns {protos.args.RabbitStreamsWriteArgs} RabbitStreamsWriteArgs instance
             */
            RabbitStreamsWriteArgs.create = function create(properties) {
                return new RabbitStreamsWriteArgs(properties);
            };

            /**
             * Encodes the specified RabbitStreamsWriteArgs message. Does not implicitly {@link protos.args.RabbitStreamsWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {protos.args.IRabbitStreamsWriteArgs} message RabbitStreamsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stream);
                if (message.declareStream != null && Object.hasOwnProperty.call(message, "declareStream"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.declareStream);
                if (message.declareStreamSize != null && Object.hasOwnProperty.call(message, "declareStreamSize"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.declareStreamSize);
                return writer;
            };

            /**
             * Encodes the specified RabbitStreamsWriteArgs message, length delimited. Does not implicitly {@link protos.args.RabbitStreamsWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {protos.args.IRabbitStreamsWriteArgs} message RabbitStreamsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreamsWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RabbitStreamsWriteArgs} RabbitStreamsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RabbitStreamsWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stream = reader.string();
                        break;
                    case 2:
                        message.declareStream = reader.bool();
                        break;
                    case 3:
                        message.declareStreamSize = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreamsWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RabbitStreamsWriteArgs} RabbitStreamsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreamsWriteArgs message.
             * @function verify
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreamsWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isString(message.stream))
                        return "stream: string expected";
                if (message.declareStream != null && message.hasOwnProperty("declareStream"))
                    if (typeof message.declareStream !== "boolean")
                        return "declareStream: boolean expected";
                if (message.declareStreamSize != null && message.hasOwnProperty("declareStreamSize"))
                    if (!$util.isString(message.declareStreamSize))
                        return "declareStreamSize: string expected";
                return null;
            };

            /**
             * Creates a RabbitStreamsWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RabbitStreamsWriteArgs} RabbitStreamsWriteArgs
             */
            RabbitStreamsWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RabbitStreamsWriteArgs)
                    return object;
                var message = new $root.protos.args.RabbitStreamsWriteArgs();
                if (object.stream != null)
                    message.stream = String(object.stream);
                if (object.declareStream != null)
                    message.declareStream = Boolean(object.declareStream);
                if (object.declareStreamSize != null)
                    message.declareStreamSize = String(object.declareStreamSize);
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreamsWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @static
             * @param {protos.args.RabbitStreamsWriteArgs} message RabbitStreamsWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreamsWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.stream = "";
                    object.declareStream = false;
                    object.declareStreamSize = "";
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                if (message.declareStream != null && message.hasOwnProperty("declareStream"))
                    object.declareStream = message.declareStream;
                if (message.declareStreamSize != null && message.hasOwnProperty("declareStreamSize"))
                    object.declareStreamSize = message.declareStreamSize;
                return object;
            };

            /**
             * Converts this RabbitStreamsWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RabbitStreamsWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreamsWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreamsWriteArgs;
        })();

        args.RedisPubSubConn = (function() {

            /**
             * Properties of a RedisPubSubConn.
             * @memberof protos.args
             * @interface IRedisPubSubConn
             * @property {string|null} [address] RedisPubSubConn address
             * @property {string|null} [username] RedisPubSubConn username
             * @property {string|null} [password] RedisPubSubConn password
             * @property {number|null} [database] RedisPubSubConn database
             */

            /**
             * Constructs a new RedisPubSubConn.
             * @memberof protos.args
             * @classdesc Represents a RedisPubSubConn.
             * @implements IRedisPubSubConn
             * @constructor
             * @param {protos.args.IRedisPubSubConn=} [properties] Properties to set
             */
            function RedisPubSubConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisPubSubConn address.
             * @member {string} address
             * @memberof protos.args.RedisPubSubConn
             * @instance
             */
            RedisPubSubConn.prototype.address = "";

            /**
             * RedisPubSubConn username.
             * @member {string} username
             * @memberof protos.args.RedisPubSubConn
             * @instance
             */
            RedisPubSubConn.prototype.username = "";

            /**
             * RedisPubSubConn password.
             * @member {string} password
             * @memberof protos.args.RedisPubSubConn
             * @instance
             */
            RedisPubSubConn.prototype.password = "";

            /**
             * RedisPubSubConn database.
             * @member {number} database
             * @memberof protos.args.RedisPubSubConn
             * @instance
             */
            RedisPubSubConn.prototype.database = 0;

            /**
             * Creates a new RedisPubSubConn instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {protos.args.IRedisPubSubConn=} [properties] Properties to set
             * @returns {protos.args.RedisPubSubConn} RedisPubSubConn instance
             */
            RedisPubSubConn.create = function create(properties) {
                return new RedisPubSubConn(properties);
            };

            /**
             * Encodes the specified RedisPubSubConn message. Does not implicitly {@link protos.args.RedisPubSubConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {protos.args.IRedisPubSubConn} message RedisPubSubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
                if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.password);
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.database);
                return writer;
            };

            /**
             * Encodes the specified RedisPubSubConn message, length delimited. Does not implicitly {@link protos.args.RedisPubSubConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {protos.args.IRedisPubSubConn} message RedisPubSubConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisPubSubConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisPubSubConn} RedisPubSubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisPubSubConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.username = reader.string();
                        break;
                    case 3:
                        message.password = reader.string();
                        break;
                    case 4:
                        message.database = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisPubSubConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisPubSubConn} RedisPubSubConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisPubSubConn message.
             * @function verify
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisPubSubConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!$util.isString(message.password))
                        return "password: string expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isInteger(message.database))
                        return "database: integer expected";
                return null;
            };

            /**
             * Creates a RedisPubSubConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisPubSubConn} RedisPubSubConn
             */
            RedisPubSubConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisPubSubConn)
                    return object;
                var message = new $root.protos.args.RedisPubSubConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.username != null)
                    message.username = String(object.username);
                if (object.password != null)
                    message.password = String(object.password);
                if (object.database != null)
                    message.database = object.database >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a RedisPubSubConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisPubSubConn
             * @static
             * @param {protos.args.RedisPubSubConn} message RedisPubSubConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisPubSubConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = "";
                    object.username = "";
                    object.password = "";
                    object.database = 0;
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = message.password;
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                return object;
            };

            /**
             * Converts this RedisPubSubConn to JSON.
             * @function toJSON
             * @memberof protos.args.RedisPubSubConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisPubSubConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisPubSubConn;
        })();

        args.RedisPubSubReadArgs = (function() {

            /**
             * Properties of a RedisPubSubReadArgs.
             * @memberof protos.args
             * @interface IRedisPubSubReadArgs
             * @property {Array.<string>|null} [channels] RedisPubSubReadArgs channels
             */

            /**
             * Constructs a new RedisPubSubReadArgs.
             * @memberof protos.args
             * @classdesc Represents a RedisPubSubReadArgs.
             * @implements IRedisPubSubReadArgs
             * @constructor
             * @param {protos.args.IRedisPubSubReadArgs=} [properties] Properties to set
             */
            function RedisPubSubReadArgs(properties) {
                this.channels = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisPubSubReadArgs channels.
             * @member {Array.<string>} channels
             * @memberof protos.args.RedisPubSubReadArgs
             * @instance
             */
            RedisPubSubReadArgs.prototype.channels = $util.emptyArray;

            /**
             * Creates a new RedisPubSubReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {protos.args.IRedisPubSubReadArgs=} [properties] Properties to set
             * @returns {protos.args.RedisPubSubReadArgs} RedisPubSubReadArgs instance
             */
            RedisPubSubReadArgs.create = function create(properties) {
                return new RedisPubSubReadArgs(properties);
            };

            /**
             * Encodes the specified RedisPubSubReadArgs message. Does not implicitly {@link protos.args.RedisPubSubReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {protos.args.IRedisPubSubReadArgs} message RedisPubSubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channels != null && message.channels.length)
                    for (var i = 0; i < message.channels.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.channels[i]);
                return writer;
            };

            /**
             * Encodes the specified RedisPubSubReadArgs message, length delimited. Does not implicitly {@link protos.args.RedisPubSubReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {protos.args.IRedisPubSubReadArgs} message RedisPubSubReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisPubSubReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisPubSubReadArgs} RedisPubSubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisPubSubReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.channels && message.channels.length))
                            message.channels = [];
                        message.channels.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisPubSubReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisPubSubReadArgs} RedisPubSubReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisPubSubReadArgs message.
             * @function verify
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisPubSubReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channels != null && message.hasOwnProperty("channels")) {
                    if (!Array.isArray(message.channels))
                        return "channels: array expected";
                    for (var i = 0; i < message.channels.length; ++i)
                        if (!$util.isString(message.channels[i]))
                            return "channels: string[] expected";
                }
                return null;
            };

            /**
             * Creates a RedisPubSubReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisPubSubReadArgs} RedisPubSubReadArgs
             */
            RedisPubSubReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisPubSubReadArgs)
                    return object;
                var message = new $root.protos.args.RedisPubSubReadArgs();
                if (object.channels) {
                    if (!Array.isArray(object.channels))
                        throw TypeError(".protos.args.RedisPubSubReadArgs.channels: array expected");
                    message.channels = [];
                    for (var i = 0; i < object.channels.length; ++i)
                        message.channels[i] = String(object.channels[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a RedisPubSubReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisPubSubReadArgs
             * @static
             * @param {protos.args.RedisPubSubReadArgs} message RedisPubSubReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisPubSubReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.channels = [];
                if (message.channels && message.channels.length) {
                    object.channels = [];
                    for (var j = 0; j < message.channels.length; ++j)
                        object.channels[j] = message.channels[j];
                }
                return object;
            };

            /**
             * Converts this RedisPubSubReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RedisPubSubReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisPubSubReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisPubSubReadArgs;
        })();

        args.RedisPubSubWriteArgs = (function() {

            /**
             * Properties of a RedisPubSubWriteArgs.
             * @memberof protos.args
             * @interface IRedisPubSubWriteArgs
             * @property {Array.<string>|null} [channels] RedisPubSubWriteArgs channels
             */

            /**
             * Constructs a new RedisPubSubWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a RedisPubSubWriteArgs.
             * @implements IRedisPubSubWriteArgs
             * @constructor
             * @param {protos.args.IRedisPubSubWriteArgs=} [properties] Properties to set
             */
            function RedisPubSubWriteArgs(properties) {
                this.channels = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisPubSubWriteArgs channels.
             * @member {Array.<string>} channels
             * @memberof protos.args.RedisPubSubWriteArgs
             * @instance
             */
            RedisPubSubWriteArgs.prototype.channels = $util.emptyArray;

            /**
             * Creates a new RedisPubSubWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {protos.args.IRedisPubSubWriteArgs=} [properties] Properties to set
             * @returns {protos.args.RedisPubSubWriteArgs} RedisPubSubWriteArgs instance
             */
            RedisPubSubWriteArgs.create = function create(properties) {
                return new RedisPubSubWriteArgs(properties);
            };

            /**
             * Encodes the specified RedisPubSubWriteArgs message. Does not implicitly {@link protos.args.RedisPubSubWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {protos.args.IRedisPubSubWriteArgs} message RedisPubSubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channels != null && message.channels.length)
                    for (var i = 0; i < message.channels.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.channels[i]);
                return writer;
            };

            /**
             * Encodes the specified RedisPubSubWriteArgs message, length delimited. Does not implicitly {@link protos.args.RedisPubSubWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {protos.args.IRedisPubSubWriteArgs} message RedisPubSubWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubSubWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisPubSubWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisPubSubWriteArgs} RedisPubSubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisPubSubWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.channels && message.channels.length))
                            message.channels = [];
                        message.channels.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisPubSubWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisPubSubWriteArgs} RedisPubSubWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubSubWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisPubSubWriteArgs message.
             * @function verify
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisPubSubWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channels != null && message.hasOwnProperty("channels")) {
                    if (!Array.isArray(message.channels))
                        return "channels: array expected";
                    for (var i = 0; i < message.channels.length; ++i)
                        if (!$util.isString(message.channels[i]))
                            return "channels: string[] expected";
                }
                return null;
            };

            /**
             * Creates a RedisPubSubWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisPubSubWriteArgs} RedisPubSubWriteArgs
             */
            RedisPubSubWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisPubSubWriteArgs)
                    return object;
                var message = new $root.protos.args.RedisPubSubWriteArgs();
                if (object.channels) {
                    if (!Array.isArray(object.channels))
                        throw TypeError(".protos.args.RedisPubSubWriteArgs.channels: array expected");
                    message.channels = [];
                    for (var i = 0; i < object.channels.length; ++i)
                        message.channels[i] = String(object.channels[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a RedisPubSubWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisPubSubWriteArgs
             * @static
             * @param {protos.args.RedisPubSubWriteArgs} message RedisPubSubWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisPubSubWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.channels = [];
                if (message.channels && message.channels.length) {
                    object.channels = [];
                    for (var j = 0; j < message.channels.length; ++j)
                        object.channels[j] = message.channels[j];
                }
                return object;
            };

            /**
             * Converts this RedisPubSubWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RedisPubSubWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisPubSubWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisPubSubWriteArgs;
        })();

        /**
         * OffsetStart enum.
         * @name protos.args.OffsetStart
         * @enum {number}
         * @property {number} LATEST=0 LATEST value
         * @property {number} OLDEST=1 OLDEST value
         */
        args.OffsetStart = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "LATEST"] = 0;
            values[valuesById[1] = "OLDEST"] = 1;
            return values;
        })();

        args.RedisStreamsConn = (function() {

            /**
             * Properties of a RedisStreamsConn.
             * @memberof protos.args
             * @interface IRedisStreamsConn
             * @property {string|null} [address] RedisStreamsConn address
             * @property {string|null} [username] RedisStreamsConn username
             * @property {string|null} [password] RedisStreamsConn password
             * @property {number|null} [database] RedisStreamsConn database
             */

            /**
             * Constructs a new RedisStreamsConn.
             * @memberof protos.args
             * @classdesc Represents a RedisStreamsConn.
             * @implements IRedisStreamsConn
             * @constructor
             * @param {protos.args.IRedisStreamsConn=} [properties] Properties to set
             */
            function RedisStreamsConn(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisStreamsConn address.
             * @member {string} address
             * @memberof protos.args.RedisStreamsConn
             * @instance
             */
            RedisStreamsConn.prototype.address = "";

            /**
             * RedisStreamsConn username.
             * @member {string} username
             * @memberof protos.args.RedisStreamsConn
             * @instance
             */
            RedisStreamsConn.prototype.username = "";

            /**
             * RedisStreamsConn password.
             * @member {string} password
             * @memberof protos.args.RedisStreamsConn
             * @instance
             */
            RedisStreamsConn.prototype.password = "";

            /**
             * RedisStreamsConn database.
             * @member {number} database
             * @memberof protos.args.RedisStreamsConn
             * @instance
             */
            RedisStreamsConn.prototype.database = 0;

            /**
             * Creates a new RedisStreamsConn instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {protos.args.IRedisStreamsConn=} [properties] Properties to set
             * @returns {protos.args.RedisStreamsConn} RedisStreamsConn instance
             */
            RedisStreamsConn.create = function create(properties) {
                return new RedisStreamsConn(properties);
            };

            /**
             * Encodes the specified RedisStreamsConn message. Does not implicitly {@link protos.args.RedisStreamsConn.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {protos.args.IRedisStreamsConn} message RedisStreamsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsConn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
                if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.password);
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.database);
                return writer;
            };

            /**
             * Encodes the specified RedisStreamsConn message, length delimited. Does not implicitly {@link protos.args.RedisStreamsConn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {protos.args.IRedisStreamsConn} message RedisStreamsConn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsConn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisStreamsConn message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisStreamsConn} RedisStreamsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsConn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisStreamsConn();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.username = reader.string();
                        break;
                    case 3:
                        message.password = reader.string();
                        break;
                    case 4:
                        message.database = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisStreamsConn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisStreamsConn} RedisStreamsConn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsConn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisStreamsConn message.
             * @function verify
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisStreamsConn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!$util.isString(message.password))
                        return "password: string expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isInteger(message.database))
                        return "database: integer expected";
                return null;
            };

            /**
             * Creates a RedisStreamsConn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisStreamsConn} RedisStreamsConn
             */
            RedisStreamsConn.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisStreamsConn)
                    return object;
                var message = new $root.protos.args.RedisStreamsConn();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.username != null)
                    message.username = String(object.username);
                if (object.password != null)
                    message.password = String(object.password);
                if (object.database != null)
                    message.database = object.database >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a RedisStreamsConn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisStreamsConn
             * @static
             * @param {protos.args.RedisStreamsConn} message RedisStreamsConn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisStreamsConn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = "";
                    object.username = "";
                    object.password = "";
                    object.database = 0;
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = message.password;
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                return object;
            };

            /**
             * Converts this RedisStreamsConn to JSON.
             * @function toJSON
             * @memberof protos.args.RedisStreamsConn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisStreamsConn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisStreamsConn;
        })();

        args.CreateConsumerConfig = (function() {

            /**
             * Properties of a CreateConsumerConfig.
             * @memberof protos.args
             * @interface ICreateConsumerConfig
             * @property {boolean|null} [createStreams] CreateConsumerConfig createStreams
             * @property {boolean|null} [recreateConsumerGroup] CreateConsumerConfig recreateConsumerGroup
             * @property {protos.args.OffsetStart|null} [offsetStart] CreateConsumerConfig offsetStart
             */

            /**
             * Constructs a new CreateConsumerConfig.
             * @memberof protos.args
             * @classdesc Represents a CreateConsumerConfig.
             * @implements ICreateConsumerConfig
             * @constructor
             * @param {protos.args.ICreateConsumerConfig=} [properties] Properties to set
             */
            function CreateConsumerConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateConsumerConfig createStreams.
             * @member {boolean} createStreams
             * @memberof protos.args.CreateConsumerConfig
             * @instance
             */
            CreateConsumerConfig.prototype.createStreams = false;

            /**
             * CreateConsumerConfig recreateConsumerGroup.
             * @member {boolean} recreateConsumerGroup
             * @memberof protos.args.CreateConsumerConfig
             * @instance
             */
            CreateConsumerConfig.prototype.recreateConsumerGroup = false;

            /**
             * CreateConsumerConfig offsetStart.
             * @member {protos.args.OffsetStart} offsetStart
             * @memberof protos.args.CreateConsumerConfig
             * @instance
             */
            CreateConsumerConfig.prototype.offsetStart = 0;

            /**
             * Creates a new CreateConsumerConfig instance using the specified properties.
             * @function create
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {protos.args.ICreateConsumerConfig=} [properties] Properties to set
             * @returns {protos.args.CreateConsumerConfig} CreateConsumerConfig instance
             */
            CreateConsumerConfig.create = function create(properties) {
                return new CreateConsumerConfig(properties);
            };

            /**
             * Encodes the specified CreateConsumerConfig message. Does not implicitly {@link protos.args.CreateConsumerConfig.verify|verify} messages.
             * @function encode
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {protos.args.ICreateConsumerConfig} message CreateConsumerConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateConsumerConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.createStreams != null && Object.hasOwnProperty.call(message, "createStreams"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.createStreams);
                if (message.recreateConsumerGroup != null && Object.hasOwnProperty.call(message, "recreateConsumerGroup"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.recreateConsumerGroup);
                if (message.offsetStart != null && Object.hasOwnProperty.call(message, "offsetStart"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.offsetStart);
                return writer;
            };

            /**
             * Encodes the specified CreateConsumerConfig message, length delimited. Does not implicitly {@link protos.args.CreateConsumerConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {protos.args.ICreateConsumerConfig} message CreateConsumerConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateConsumerConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateConsumerConfig message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.CreateConsumerConfig} CreateConsumerConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateConsumerConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.CreateConsumerConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.createStreams = reader.bool();
                        break;
                    case 2:
                        message.recreateConsumerGroup = reader.bool();
                        break;
                    case 3:
                        message.offsetStart = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateConsumerConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.CreateConsumerConfig} CreateConsumerConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateConsumerConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateConsumerConfig message.
             * @function verify
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateConsumerConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.createStreams != null && message.hasOwnProperty("createStreams"))
                    if (typeof message.createStreams !== "boolean")
                        return "createStreams: boolean expected";
                if (message.recreateConsumerGroup != null && message.hasOwnProperty("recreateConsumerGroup"))
                    if (typeof message.recreateConsumerGroup !== "boolean")
                        return "recreateConsumerGroup: boolean expected";
                if (message.offsetStart != null && message.hasOwnProperty("offsetStart"))
                    switch (message.offsetStart) {
                    default:
                        return "offsetStart: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a CreateConsumerConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.CreateConsumerConfig} CreateConsumerConfig
             */
            CreateConsumerConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.CreateConsumerConfig)
                    return object;
                var message = new $root.protos.args.CreateConsumerConfig();
                if (object.createStreams != null)
                    message.createStreams = Boolean(object.createStreams);
                if (object.recreateConsumerGroup != null)
                    message.recreateConsumerGroup = Boolean(object.recreateConsumerGroup);
                switch (object.offsetStart) {
                case "LATEST":
                case 0:
                    message.offsetStart = 0;
                    break;
                case "OLDEST":
                case 1:
                    message.offsetStart = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateConsumerConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.CreateConsumerConfig
             * @static
             * @param {protos.args.CreateConsumerConfig} message CreateConsumerConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateConsumerConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.createStreams = false;
                    object.recreateConsumerGroup = false;
                    object.offsetStart = options.enums === String ? "LATEST" : 0;
                }
                if (message.createStreams != null && message.hasOwnProperty("createStreams"))
                    object.createStreams = message.createStreams;
                if (message.recreateConsumerGroup != null && message.hasOwnProperty("recreateConsumerGroup"))
                    object.recreateConsumerGroup = message.recreateConsumerGroup;
                if (message.offsetStart != null && message.hasOwnProperty("offsetStart"))
                    object.offsetStart = options.enums === String ? $root.protos.args.OffsetStart[message.offsetStart] : message.offsetStart;
                return object;
            };

            /**
             * Converts this CreateConsumerConfig to JSON.
             * @function toJSON
             * @memberof protos.args.CreateConsumerConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateConsumerConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateConsumerConfig;
        })();

        args.RedisStreamsReadArgs = (function() {

            /**
             * Properties of a RedisStreamsReadArgs.
             * @memberof protos.args
             * @interface IRedisStreamsReadArgs
             * @property {Array.<string>|null} [streams] RedisStreamsReadArgs streams
             * @property {string|null} [consumerGroup] RedisStreamsReadArgs consumerGroup
             * @property {string|null} [consumerName] RedisStreamsReadArgs consumerName
             * @property {number|null} [count] RedisStreamsReadArgs count
             * @property {protos.args.ICreateConsumerConfig|null} [createConsumerConfig] RedisStreamsReadArgs createConsumerConfig
             */

            /**
             * Constructs a new RedisStreamsReadArgs.
             * @memberof protos.args
             * @classdesc Represents a RedisStreamsReadArgs.
             * @implements IRedisStreamsReadArgs
             * @constructor
             * @param {protos.args.IRedisStreamsReadArgs=} [properties] Properties to set
             */
            function RedisStreamsReadArgs(properties) {
                this.streams = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisStreamsReadArgs streams.
             * @member {Array.<string>} streams
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.streams = $util.emptyArray;

            /**
             * RedisStreamsReadArgs consumerGroup.
             * @member {string} consumerGroup
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.consumerGroup = "";

            /**
             * RedisStreamsReadArgs consumerName.
             * @member {string} consumerName
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.consumerName = "";

            /**
             * RedisStreamsReadArgs count.
             * @member {number} count
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.count = 0;

            /**
             * RedisStreamsReadArgs createConsumerConfig.
             * @member {protos.args.ICreateConsumerConfig|null|undefined} createConsumerConfig
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             */
            RedisStreamsReadArgs.prototype.createConsumerConfig = null;

            /**
             * Creates a new RedisStreamsReadArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {protos.args.IRedisStreamsReadArgs=} [properties] Properties to set
             * @returns {protos.args.RedisStreamsReadArgs} RedisStreamsReadArgs instance
             */
            RedisStreamsReadArgs.create = function create(properties) {
                return new RedisStreamsReadArgs(properties);
            };

            /**
             * Encodes the specified RedisStreamsReadArgs message. Does not implicitly {@link protos.args.RedisStreamsReadArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {protos.args.IRedisStreamsReadArgs} message RedisStreamsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsReadArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.streams != null && message.streams.length)
                    for (var i = 0; i < message.streams.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.streams[i]);
                if (message.consumerGroup != null && Object.hasOwnProperty.call(message, "consumerGroup"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.consumerGroup);
                if (message.consumerName != null && Object.hasOwnProperty.call(message, "consumerName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.consumerName);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.count);
                if (message.createConsumerConfig != null && Object.hasOwnProperty.call(message, "createConsumerConfig"))
                    $root.protos.args.CreateConsumerConfig.encode(message.createConsumerConfig, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RedisStreamsReadArgs message, length delimited. Does not implicitly {@link protos.args.RedisStreamsReadArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {protos.args.IRedisStreamsReadArgs} message RedisStreamsReadArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsReadArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisStreamsReadArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisStreamsReadArgs} RedisStreamsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsReadArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisStreamsReadArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.streams && message.streams.length))
                            message.streams = [];
                        message.streams.push(reader.string());
                        break;
                    case 2:
                        message.consumerGroup = reader.string();
                        break;
                    case 3:
                        message.consumerName = reader.string();
                        break;
                    case 4:
                        message.count = reader.uint32();
                        break;
                    case 5:
                        message.createConsumerConfig = $root.protos.args.CreateConsumerConfig.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisStreamsReadArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisStreamsReadArgs} RedisStreamsReadArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsReadArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisStreamsReadArgs message.
             * @function verify
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisStreamsReadArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.streams != null && message.hasOwnProperty("streams")) {
                    if (!Array.isArray(message.streams))
                        return "streams: array expected";
                    for (var i = 0; i < message.streams.length; ++i)
                        if (!$util.isString(message.streams[i]))
                            return "streams: string[] expected";
                }
                if (message.consumerGroup != null && message.hasOwnProperty("consumerGroup"))
                    if (!$util.isString(message.consumerGroup))
                        return "consumerGroup: string expected";
                if (message.consumerName != null && message.hasOwnProperty("consumerName"))
                    if (!$util.isString(message.consumerName))
                        return "consumerName: string expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                if (message.createConsumerConfig != null && message.hasOwnProperty("createConsumerConfig")) {
                    var error = $root.protos.args.CreateConsumerConfig.verify(message.createConsumerConfig);
                    if (error)
                        return "createConsumerConfig." + error;
                }
                return null;
            };

            /**
             * Creates a RedisStreamsReadArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisStreamsReadArgs} RedisStreamsReadArgs
             */
            RedisStreamsReadArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisStreamsReadArgs)
                    return object;
                var message = new $root.protos.args.RedisStreamsReadArgs();
                if (object.streams) {
                    if (!Array.isArray(object.streams))
                        throw TypeError(".protos.args.RedisStreamsReadArgs.streams: array expected");
                    message.streams = [];
                    for (var i = 0; i < object.streams.length; ++i)
                        message.streams[i] = String(object.streams[i]);
                }
                if (object.consumerGroup != null)
                    message.consumerGroup = String(object.consumerGroup);
                if (object.consumerName != null)
                    message.consumerName = String(object.consumerName);
                if (object.count != null)
                    message.count = object.count >>> 0;
                if (object.createConsumerConfig != null) {
                    if (typeof object.createConsumerConfig !== "object")
                        throw TypeError(".protos.args.RedisStreamsReadArgs.createConsumerConfig: object expected");
                    message.createConsumerConfig = $root.protos.args.CreateConsumerConfig.fromObject(object.createConsumerConfig);
                }
                return message;
            };

            /**
             * Creates a plain object from a RedisStreamsReadArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisStreamsReadArgs
             * @static
             * @param {protos.args.RedisStreamsReadArgs} message RedisStreamsReadArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisStreamsReadArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.streams = [];
                if (options.defaults) {
                    object.consumerGroup = "";
                    object.consumerName = "";
                    object.count = 0;
                    object.createConsumerConfig = null;
                }
                if (message.streams && message.streams.length) {
                    object.streams = [];
                    for (var j = 0; j < message.streams.length; ++j)
                        object.streams[j] = message.streams[j];
                }
                if (message.consumerGroup != null && message.hasOwnProperty("consumerGroup"))
                    object.consumerGroup = message.consumerGroup;
                if (message.consumerName != null && message.hasOwnProperty("consumerName"))
                    object.consumerName = message.consumerName;
                if (message.count != null && message.hasOwnProperty("count"))
                    object.count = message.count;
                if (message.createConsumerConfig != null && message.hasOwnProperty("createConsumerConfig"))
                    object.createConsumerConfig = $root.protos.args.CreateConsumerConfig.toObject(message.createConsumerConfig, options);
                return object;
            };

            /**
             * Converts this RedisStreamsReadArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RedisStreamsReadArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisStreamsReadArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisStreamsReadArgs;
        })();

        args.RedisStreamsWriteArgs = (function() {

            /**
             * Properties of a RedisStreamsWriteArgs.
             * @memberof protos.args
             * @interface IRedisStreamsWriteArgs
             * @property {string|null} [writeId] RedisStreamsWriteArgs writeId
             * @property {Array.<string>|null} [streams] RedisStreamsWriteArgs streams
             * @property {string|null} [key] RedisStreamsWriteArgs key
             */

            /**
             * Constructs a new RedisStreamsWriteArgs.
             * @memberof protos.args
             * @classdesc Represents a RedisStreamsWriteArgs.
             * @implements IRedisStreamsWriteArgs
             * @constructor
             * @param {protos.args.IRedisStreamsWriteArgs=} [properties] Properties to set
             */
            function RedisStreamsWriteArgs(properties) {
                this.streams = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisStreamsWriteArgs writeId.
             * @member {string} writeId
             * @memberof protos.args.RedisStreamsWriteArgs
             * @instance
             */
            RedisStreamsWriteArgs.prototype.writeId = "";

            /**
             * RedisStreamsWriteArgs streams.
             * @member {Array.<string>} streams
             * @memberof protos.args.RedisStreamsWriteArgs
             * @instance
             */
            RedisStreamsWriteArgs.prototype.streams = $util.emptyArray;

            /**
             * RedisStreamsWriteArgs key.
             * @member {string} key
             * @memberof protos.args.RedisStreamsWriteArgs
             * @instance
             */
            RedisStreamsWriteArgs.prototype.key = "";

            /**
             * Creates a new RedisStreamsWriteArgs instance using the specified properties.
             * @function create
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {protos.args.IRedisStreamsWriteArgs=} [properties] Properties to set
             * @returns {protos.args.RedisStreamsWriteArgs} RedisStreamsWriteArgs instance
             */
            RedisStreamsWriteArgs.create = function create(properties) {
                return new RedisStreamsWriteArgs(properties);
            };

            /**
             * Encodes the specified RedisStreamsWriteArgs message. Does not implicitly {@link protos.args.RedisStreamsWriteArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {protos.args.IRedisStreamsWriteArgs} message RedisStreamsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsWriteArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.writeId != null && Object.hasOwnProperty.call(message, "writeId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.writeId);
                if (message.streams != null && message.streams.length)
                    for (var i = 0; i < message.streams.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.streams[i]);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.key);
                return writer;
            };

            /**
             * Encodes the specified RedisStreamsWriteArgs message, length delimited. Does not implicitly {@link protos.args.RedisStreamsWriteArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {protos.args.IRedisStreamsWriteArgs} message RedisStreamsWriteArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreamsWriteArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisStreamsWriteArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.args.RedisStreamsWriteArgs} RedisStreamsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsWriteArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.args.RedisStreamsWriteArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.writeId = reader.string();
                        break;
                    case 2:
                        if (!(message.streams && message.streams.length))
                            message.streams = [];
                        message.streams.push(reader.string());
                        break;
                    case 3:
                        message.key = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisStreamsWriteArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.args.RedisStreamsWriteArgs} RedisStreamsWriteArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreamsWriteArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisStreamsWriteArgs message.
             * @function verify
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisStreamsWriteArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.writeId != null && message.hasOwnProperty("writeId"))
                    if (!$util.isString(message.writeId))
                        return "writeId: string expected";
                if (message.streams != null && message.hasOwnProperty("streams")) {
                    if (!Array.isArray(message.streams))
                        return "streams: array expected";
                    for (var i = 0; i < message.streams.length; ++i)
                        if (!$util.isString(message.streams[i]))
                            return "streams: string[] expected";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                return null;
            };

            /**
             * Creates a RedisStreamsWriteArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.args.RedisStreamsWriteArgs} RedisStreamsWriteArgs
             */
            RedisStreamsWriteArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.args.RedisStreamsWriteArgs)
                    return object;
                var message = new $root.protos.args.RedisStreamsWriteArgs();
                if (object.writeId != null)
                    message.writeId = String(object.writeId);
                if (object.streams) {
                    if (!Array.isArray(object.streams))
                        throw TypeError(".protos.args.RedisStreamsWriteArgs.streams: array expected");
                    message.streams = [];
                    for (var i = 0; i < object.streams.length; ++i)
                        message.streams[i] = String(object.streams[i]);
                }
                if (object.key != null)
                    message.key = String(object.key);
                return message;
            };

            /**
             * Creates a plain object from a RedisStreamsWriteArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.args.RedisStreamsWriteArgs
             * @static
             * @param {protos.args.RedisStreamsWriteArgs} message RedisStreamsWriteArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisStreamsWriteArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.streams = [];
                if (options.defaults) {
                    object.writeId = "";
                    object.key = "";
                }
                if (message.writeId != null && message.hasOwnProperty("writeId"))
                    object.writeId = message.writeId;
                if (message.streams && message.streams.length) {
                    object.streams = [];
                    for (var j = 0; j < message.streams.length; ++j)
                        object.streams[j] = message.streams[j];
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                return object;
            };

            /**
             * Converts this RedisStreamsWriteArgs to JSON.
             * @function toJSON
             * @memberof protos.args.RedisStreamsWriteArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisStreamsWriteArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisStreamsWriteArgs;
        })();

        return args;
    })();

    protos.GetAllDynamicRequest = (function() {

        /**
         * Properties of a GetAllDynamicRequest.
         * @memberof protos
         * @interface IGetAllDynamicRequest
         * @property {protos.common.IAuth|null} [auth] GetAllDynamicRequest auth
         */

        /**
         * Constructs a new GetAllDynamicRequest.
         * @memberof protos
         * @classdesc Represents a GetAllDynamicRequest.
         * @implements IGetAllDynamicRequest
         * @constructor
         * @param {protos.IGetAllDynamicRequest=} [properties] Properties to set
         */
        function GetAllDynamicRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllDynamicRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetAllDynamicRequest
         * @instance
         */
        GetAllDynamicRequest.prototype.auth = null;

        /**
         * Creates a new GetAllDynamicRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetAllDynamicRequest
         * @static
         * @param {protos.IGetAllDynamicRequest=} [properties] Properties to set
         * @returns {protos.GetAllDynamicRequest} GetAllDynamicRequest instance
         */
        GetAllDynamicRequest.create = function create(properties) {
            return new GetAllDynamicRequest(properties);
        };

        /**
         * Encodes the specified GetAllDynamicRequest message. Does not implicitly {@link protos.GetAllDynamicRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllDynamicRequest
         * @static
         * @param {protos.IGetAllDynamicRequest} message GetAllDynamicRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllDynamicRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllDynamicRequest message, length delimited. Does not implicitly {@link protos.GetAllDynamicRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllDynamicRequest
         * @static
         * @param {protos.IGetAllDynamicRequest} message GetAllDynamicRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllDynamicRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllDynamicRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllDynamicRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllDynamicRequest} GetAllDynamicRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllDynamicRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllDynamicRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllDynamicRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllDynamicRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllDynamicRequest} GetAllDynamicRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllDynamicRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllDynamicRequest message.
         * @function verify
         * @memberof protos.GetAllDynamicRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllDynamicRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };

        /**
         * Creates a GetAllDynamicRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllDynamicRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllDynamicRequest} GetAllDynamicRequest
         */
        GetAllDynamicRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllDynamicRequest)
                return object;
            var message = new $root.protos.GetAllDynamicRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetAllDynamicRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllDynamicRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllDynamicRequest
         * @static
         * @param {protos.GetAllDynamicRequest} message GetAllDynamicRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllDynamicRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.auth = null;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetAllDynamicRequest to JSON.
         * @function toJSON
         * @memberof protos.GetAllDynamicRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllDynamicRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllDynamicRequest;
    })();

    protos.GetAllDynamicResponse = (function() {

        /**
         * Properties of a GetAllDynamicResponse.
         * @memberof protos
         * @interface IGetAllDynamicResponse
         * @property {protos.common.IStatus|null} [status] GetAllDynamicResponse status
         * @property {Array.<protos.opts.IDynamicOptions>|null} [opts] GetAllDynamicResponse opts
         */

        /**
         * Constructs a new GetAllDynamicResponse.
         * @memberof protos
         * @classdesc Represents a GetAllDynamicResponse.
         * @implements IGetAllDynamicResponse
         * @constructor
         * @param {protos.IGetAllDynamicResponse=} [properties] Properties to set
         */
        function GetAllDynamicResponse(properties) {
            this.opts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllDynamicResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.GetAllDynamicResponse
         * @instance
         */
        GetAllDynamicResponse.prototype.status = null;

        /**
         * GetAllDynamicResponse opts.
         * @member {Array.<protos.opts.IDynamicOptions>} opts
         * @memberof protos.GetAllDynamicResponse
         * @instance
         */
        GetAllDynamicResponse.prototype.opts = $util.emptyArray;

        /**
         * Creates a new GetAllDynamicResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetAllDynamicResponse
         * @static
         * @param {protos.IGetAllDynamicResponse=} [properties] Properties to set
         * @returns {protos.GetAllDynamicResponse} GetAllDynamicResponse instance
         */
        GetAllDynamicResponse.create = function create(properties) {
            return new GetAllDynamicResponse(properties);
        };

        /**
         * Encodes the specified GetAllDynamicResponse message. Does not implicitly {@link protos.GetAllDynamicResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllDynamicResponse
         * @static
         * @param {protos.IGetAllDynamicResponse} message GetAllDynamicResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllDynamicResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.opts != null && message.opts.length)
                for (var i = 0; i < message.opts.length; ++i)
                    $root.protos.opts.DynamicOptions.encode(message.opts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllDynamicResponse message, length delimited. Does not implicitly {@link protos.GetAllDynamicResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllDynamicResponse
         * @static
         * @param {protos.IGetAllDynamicResponse} message GetAllDynamicResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllDynamicResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllDynamicResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllDynamicResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllDynamicResponse} GetAllDynamicResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllDynamicResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllDynamicResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    if (!(message.opts && message.opts.length))
                        message.opts = [];
                    message.opts.push($root.protos.opts.DynamicOptions.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllDynamicResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllDynamicResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllDynamicResponse} GetAllDynamicResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllDynamicResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllDynamicResponse message.
         * @function verify
         * @memberof protos.GetAllDynamicResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllDynamicResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.opts != null && message.hasOwnProperty("opts")) {
                if (!Array.isArray(message.opts))
                    return "opts: array expected";
                for (var i = 0; i < message.opts.length; ++i) {
                    var error = $root.protos.opts.DynamicOptions.verify(message.opts[i]);
                    if (error)
                        return "opts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetAllDynamicResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllDynamicResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllDynamicResponse} GetAllDynamicResponse
         */
        GetAllDynamicResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllDynamicResponse)
                return object;
            var message = new $root.protos.GetAllDynamicResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.GetAllDynamicResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.opts) {
                if (!Array.isArray(object.opts))
                    throw TypeError(".protos.GetAllDynamicResponse.opts: array expected");
                message.opts = [];
                for (var i = 0; i < object.opts.length; ++i) {
                    if (typeof object.opts[i] !== "object")
                        throw TypeError(".protos.GetAllDynamicResponse.opts: object expected");
                    message.opts[i] = $root.protos.opts.DynamicOptions.fromObject(object.opts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllDynamicResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllDynamicResponse
         * @static
         * @param {protos.GetAllDynamicResponse} message GetAllDynamicResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllDynamicResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.opts = [];
            if (options.defaults)
                object.status = null;
            if (message.opts && message.opts.length) {
                object.opts = [];
                for (var j = 0; j < message.opts.length; ++j)
                    object.opts[j] = $root.protos.opts.DynamicOptions.toObject(message.opts[j], options);
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this GetAllDynamicResponse to JSON.
         * @function toJSON
         * @memberof protos.GetAllDynamicResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllDynamicResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllDynamicResponse;
    })();

    protos.GetDynamicRequest = (function() {

        /**
         * Properties of a GetDynamicRequest.
         * @memberof protos
         * @interface IGetDynamicRequest
         * @property {protos.common.IAuth|null} [auth] GetDynamicRequest auth
         * @property {string|null} [dynamicId] GetDynamicRequest dynamicId
         */

        /**
         * Constructs a new GetDynamicRequest.
         * @memberof protos
         * @classdesc Represents a GetDynamicRequest.
         * @implements IGetDynamicRequest
         * @constructor
         * @param {protos.IGetDynamicRequest=} [properties] Properties to set
         */
        function GetDynamicRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetDynamicRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetDynamicRequest
         * @instance
         */
        GetDynamicRequest.prototype.auth = null;

        /**
         * GetDynamicRequest dynamicId.
         * @member {string} dynamicId
         * @memberof protos.GetDynamicRequest
         * @instance
         */
        GetDynamicRequest.prototype.dynamicId = "";

        /**
         * Creates a new GetDynamicRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetDynamicRequest
         * @static
         * @param {protos.IGetDynamicRequest=} [properties] Properties to set
         * @returns {protos.GetDynamicRequest} GetDynamicRequest instance
         */
        GetDynamicRequest.create = function create(properties) {
            return new GetDynamicRequest(properties);
        };

        /**
         * Encodes the specified GetDynamicRequest message. Does not implicitly {@link protos.GetDynamicRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetDynamicRequest
         * @static
         * @param {protos.IGetDynamicRequest} message GetDynamicRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetDynamicRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dynamicId != null && Object.hasOwnProperty.call(message, "dynamicId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.dynamicId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetDynamicRequest message, length delimited. Does not implicitly {@link protos.GetDynamicRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetDynamicRequest
         * @static
         * @param {protos.IGetDynamicRequest} message GetDynamicRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetDynamicRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetDynamicRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetDynamicRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetDynamicRequest} GetDynamicRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetDynamicRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetDynamicRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.dynamicId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetDynamicRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetDynamicRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetDynamicRequest} GetDynamicRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetDynamicRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetDynamicRequest message.
         * @function verify
         * @memberof protos.GetDynamicRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetDynamicRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.dynamicId != null && message.hasOwnProperty("dynamicId"))
                if (!$util.isString(message.dynamicId))
                    return "dynamicId: string expected";
            return null;
        };

        /**
         * Creates a GetDynamicRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetDynamicRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetDynamicRequest} GetDynamicRequest
         */
        GetDynamicRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetDynamicRequest)
                return object;
            var message = new $root.protos.GetDynamicRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetDynamicRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.dynamicId != null)
                message.dynamicId = String(object.dynamicId);
            return message;
        };

        /**
         * Creates a plain object from a GetDynamicRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetDynamicRequest
         * @static
         * @param {protos.GetDynamicRequest} message GetDynamicRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetDynamicRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.dynamicId = "";
                object.auth = null;
            }
            if (message.dynamicId != null && message.hasOwnProperty("dynamicId"))
                object.dynamicId = message.dynamicId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetDynamicRequest to JSON.
         * @function toJSON
         * @memberof protos.GetDynamicRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetDynamicRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetDynamicRequest;
    })();

    protos.GetDynamicResponse = (function() {

        /**
         * Properties of a GetDynamicResponse.
         * @memberof protos
         * @interface IGetDynamicResponse
         * @property {protos.common.IStatus|null} [status] GetDynamicResponse status
         * @property {protos.opts.IDynamicOptions|null} [opts] GetDynamicResponse opts
         */

        /**
         * Constructs a new GetDynamicResponse.
         * @memberof protos
         * @classdesc Represents a GetDynamicResponse.
         * @implements IGetDynamicResponse
         * @constructor
         * @param {protos.IGetDynamicResponse=} [properties] Properties to set
         */
        function GetDynamicResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetDynamicResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.GetDynamicResponse
         * @instance
         */
        GetDynamicResponse.prototype.status = null;

        /**
         * GetDynamicResponse opts.
         * @member {protos.opts.IDynamicOptions|null|undefined} opts
         * @memberof protos.GetDynamicResponse
         * @instance
         */
        GetDynamicResponse.prototype.opts = null;

        /**
         * Creates a new GetDynamicResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetDynamicResponse
         * @static
         * @param {protos.IGetDynamicResponse=} [properties] Properties to set
         * @returns {protos.GetDynamicResponse} GetDynamicResponse instance
         */
        GetDynamicResponse.create = function create(properties) {
            return new GetDynamicResponse(properties);
        };

        /**
         * Encodes the specified GetDynamicResponse message. Does not implicitly {@link protos.GetDynamicResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetDynamicResponse
         * @static
         * @param {protos.IGetDynamicResponse} message GetDynamicResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetDynamicResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.opts != null && Object.hasOwnProperty.call(message, "opts"))
                $root.protos.opts.DynamicOptions.encode(message.opts, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetDynamicResponse message, length delimited. Does not implicitly {@link protos.GetDynamicResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetDynamicResponse
         * @static
         * @param {protos.IGetDynamicResponse} message GetDynamicResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetDynamicResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetDynamicResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetDynamicResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetDynamicResponse} GetDynamicResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetDynamicResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetDynamicResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.opts = $root.protos.opts.DynamicOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetDynamicResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetDynamicResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetDynamicResponse} GetDynamicResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetDynamicResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetDynamicResponse message.
         * @function verify
         * @memberof protos.GetDynamicResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetDynamicResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.opts != null && message.hasOwnProperty("opts")) {
                var error = $root.protos.opts.DynamicOptions.verify(message.opts);
                if (error)
                    return "opts." + error;
            }
            return null;
        };

        /**
         * Creates a GetDynamicResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetDynamicResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetDynamicResponse} GetDynamicResponse
         */
        GetDynamicResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetDynamicResponse)
                return object;
            var message = new $root.protos.GetDynamicResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.GetDynamicResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.opts != null) {
                if (typeof object.opts !== "object")
                    throw TypeError(".protos.GetDynamicResponse.opts: object expected");
                message.opts = $root.protos.opts.DynamicOptions.fromObject(object.opts);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetDynamicResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetDynamicResponse
         * @static
         * @param {protos.GetDynamicResponse} message GetDynamicResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetDynamicResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.opts = null;
                object.status = null;
            }
            if (message.opts != null && message.hasOwnProperty("opts"))
                object.opts = $root.protos.opts.DynamicOptions.toObject(message.opts, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this GetDynamicResponse to JSON.
         * @function toJSON
         * @memberof protos.GetDynamicResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetDynamicResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetDynamicResponse;
    })();

    protos.CreateDynamicRequest = (function() {

        /**
         * Properties of a CreateDynamicRequest.
         * @memberof protos
         * @interface ICreateDynamicRequest
         * @property {protos.common.IAuth|null} [auth] CreateDynamicRequest auth
         * @property {protos.opts.IDynamicOptions|null} [opts] CreateDynamicRequest opts
         */

        /**
         * Constructs a new CreateDynamicRequest.
         * @memberof protos
         * @classdesc Represents a CreateDynamicRequest.
         * @implements ICreateDynamicRequest
         * @constructor
         * @param {protos.ICreateDynamicRequest=} [properties] Properties to set
         */
        function CreateDynamicRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateDynamicRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.CreateDynamicRequest
         * @instance
         */
        CreateDynamicRequest.prototype.auth = null;

        /**
         * CreateDynamicRequest opts.
         * @member {protos.opts.IDynamicOptions|null|undefined} opts
         * @memberof protos.CreateDynamicRequest
         * @instance
         */
        CreateDynamicRequest.prototype.opts = null;

        /**
         * Creates a new CreateDynamicRequest instance using the specified properties.
         * @function create
         * @memberof protos.CreateDynamicRequest
         * @static
         * @param {protos.ICreateDynamicRequest=} [properties] Properties to set
         * @returns {protos.CreateDynamicRequest} CreateDynamicRequest instance
         */
        CreateDynamicRequest.create = function create(properties) {
            return new CreateDynamicRequest(properties);
        };

        /**
         * Encodes the specified CreateDynamicRequest message. Does not implicitly {@link protos.CreateDynamicRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateDynamicRequest
         * @static
         * @param {protos.ICreateDynamicRequest} message CreateDynamicRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateDynamicRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.opts != null && Object.hasOwnProperty.call(message, "opts"))
                $root.protos.opts.DynamicOptions.encode(message.opts, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateDynamicRequest message, length delimited. Does not implicitly {@link protos.CreateDynamicRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateDynamicRequest
         * @static
         * @param {protos.ICreateDynamicRequest} message CreateDynamicRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateDynamicRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateDynamicRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateDynamicRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateDynamicRequest} CreateDynamicRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateDynamicRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateDynamicRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.opts = $root.protos.opts.DynamicOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateDynamicRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateDynamicRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateDynamicRequest} CreateDynamicRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateDynamicRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateDynamicRequest message.
         * @function verify
         * @memberof protos.CreateDynamicRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateDynamicRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.opts != null && message.hasOwnProperty("opts")) {
                var error = $root.protos.opts.DynamicOptions.verify(message.opts);
                if (error)
                    return "opts." + error;
            }
            return null;
        };

        /**
         * Creates a CreateDynamicRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateDynamicRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateDynamicRequest} CreateDynamicRequest
         */
        CreateDynamicRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateDynamicRequest)
                return object;
            var message = new $root.protos.CreateDynamicRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.CreateDynamicRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.opts != null) {
                if (typeof object.opts !== "object")
                    throw TypeError(".protos.CreateDynamicRequest.opts: object expected");
                message.opts = $root.protos.opts.DynamicOptions.fromObject(object.opts);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateDynamicRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateDynamicRequest
         * @static
         * @param {protos.CreateDynamicRequest} message CreateDynamicRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateDynamicRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.opts = null;
                object.auth = null;
            }
            if (message.opts != null && message.hasOwnProperty("opts"))
                object.opts = $root.protos.opts.DynamicOptions.toObject(message.opts, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this CreateDynamicRequest to JSON.
         * @function toJSON
         * @memberof protos.CreateDynamicRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateDynamicRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateDynamicRequest;
    })();

    protos.CreateDynamicResponse = (function() {

        /**
         * Properties of a CreateDynamicResponse.
         * @memberof protos
         * @interface ICreateDynamicResponse
         * @property {protos.common.IStatus|null} [status] CreateDynamicResponse status
         * @property {string|null} [dynamicId] CreateDynamicResponse dynamicId
         */

        /**
         * Constructs a new CreateDynamicResponse.
         * @memberof protos
         * @classdesc Represents a CreateDynamicResponse.
         * @implements ICreateDynamicResponse
         * @constructor
         * @param {protos.ICreateDynamicResponse=} [properties] Properties to set
         */
        function CreateDynamicResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateDynamicResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.CreateDynamicResponse
         * @instance
         */
        CreateDynamicResponse.prototype.status = null;

        /**
         * CreateDynamicResponse dynamicId.
         * @member {string} dynamicId
         * @memberof protos.CreateDynamicResponse
         * @instance
         */
        CreateDynamicResponse.prototype.dynamicId = "";

        /**
         * Creates a new CreateDynamicResponse instance using the specified properties.
         * @function create
         * @memberof protos.CreateDynamicResponse
         * @static
         * @param {protos.ICreateDynamicResponse=} [properties] Properties to set
         * @returns {protos.CreateDynamicResponse} CreateDynamicResponse instance
         */
        CreateDynamicResponse.create = function create(properties) {
            return new CreateDynamicResponse(properties);
        };

        /**
         * Encodes the specified CreateDynamicResponse message. Does not implicitly {@link protos.CreateDynamicResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateDynamicResponse
         * @static
         * @param {protos.ICreateDynamicResponse} message CreateDynamicResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateDynamicResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dynamicId != null && Object.hasOwnProperty.call(message, "dynamicId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.dynamicId);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateDynamicResponse message, length delimited. Does not implicitly {@link protos.CreateDynamicResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateDynamicResponse
         * @static
         * @param {protos.ICreateDynamicResponse} message CreateDynamicResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateDynamicResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateDynamicResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateDynamicResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateDynamicResponse} CreateDynamicResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateDynamicResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateDynamicResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.dynamicId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateDynamicResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateDynamicResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateDynamicResponse} CreateDynamicResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateDynamicResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateDynamicResponse message.
         * @function verify
         * @memberof protos.CreateDynamicResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateDynamicResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.dynamicId != null && message.hasOwnProperty("dynamicId"))
                if (!$util.isString(message.dynamicId))
                    return "dynamicId: string expected";
            return null;
        };

        /**
         * Creates a CreateDynamicResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateDynamicResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateDynamicResponse} CreateDynamicResponse
         */
        CreateDynamicResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateDynamicResponse)
                return object;
            var message = new $root.protos.CreateDynamicResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.CreateDynamicResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.dynamicId != null)
                message.dynamicId = String(object.dynamicId);
            return message;
        };

        /**
         * Creates a plain object from a CreateDynamicResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateDynamicResponse
         * @static
         * @param {protos.CreateDynamicResponse} message CreateDynamicResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateDynamicResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.dynamicId = "";
                object.status = null;
            }
            if (message.dynamicId != null && message.hasOwnProperty("dynamicId"))
                object.dynamicId = message.dynamicId;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this CreateDynamicResponse to JSON.
         * @function toJSON
         * @memberof protos.CreateDynamicResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateDynamicResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateDynamicResponse;
    })();

    protos.UpdateDynamicRequest = (function() {

        /**
         * Properties of an UpdateDynamicRequest.
         * @memberof protos
         * @interface IUpdateDynamicRequest
         * @property {protos.common.IAuth|null} [auth] UpdateDynamicRequest auth
         * @property {string|null} [dynamicId] UpdateDynamicRequest dynamicId
         * @property {protos.opts.IDynamicOptions|null} [opts] UpdateDynamicRequest opts
         */

        /**
         * Constructs a new UpdateDynamicRequest.
         * @memberof protos
         * @classdesc Represents an UpdateDynamicRequest.
         * @implements IUpdateDynamicRequest
         * @constructor
         * @param {protos.IUpdateDynamicRequest=} [properties] Properties to set
         */
        function UpdateDynamicRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateDynamicRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.UpdateDynamicRequest
         * @instance
         */
        UpdateDynamicRequest.prototype.auth = null;

        /**
         * UpdateDynamicRequest dynamicId.
         * @member {string} dynamicId
         * @memberof protos.UpdateDynamicRequest
         * @instance
         */
        UpdateDynamicRequest.prototype.dynamicId = "";

        /**
         * UpdateDynamicRequest opts.
         * @member {protos.opts.IDynamicOptions|null|undefined} opts
         * @memberof protos.UpdateDynamicRequest
         * @instance
         */
        UpdateDynamicRequest.prototype.opts = null;

        /**
         * Creates a new UpdateDynamicRequest instance using the specified properties.
         * @function create
         * @memberof protos.UpdateDynamicRequest
         * @static
         * @param {protos.IUpdateDynamicRequest=} [properties] Properties to set
         * @returns {protos.UpdateDynamicRequest} UpdateDynamicRequest instance
         */
        UpdateDynamicRequest.create = function create(properties) {
            return new UpdateDynamicRequest(properties);
        };

        /**
         * Encodes the specified UpdateDynamicRequest message. Does not implicitly {@link protos.UpdateDynamicRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateDynamicRequest
         * @static
         * @param {protos.IUpdateDynamicRequest} message UpdateDynamicRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateDynamicRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dynamicId != null && Object.hasOwnProperty.call(message, "dynamicId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.dynamicId);
            if (message.opts != null && Object.hasOwnProperty.call(message, "opts"))
                $root.protos.opts.DynamicOptions.encode(message.opts, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateDynamicRequest message, length delimited. Does not implicitly {@link protos.UpdateDynamicRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateDynamicRequest
         * @static
         * @param {protos.IUpdateDynamicRequest} message UpdateDynamicRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateDynamicRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateDynamicRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateDynamicRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateDynamicRequest} UpdateDynamicRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateDynamicRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateDynamicRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.dynamicId = reader.string();
                    break;
                case 2:
                    message.opts = $root.protos.opts.DynamicOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateDynamicRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateDynamicRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateDynamicRequest} UpdateDynamicRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateDynamicRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateDynamicRequest message.
         * @function verify
         * @memberof protos.UpdateDynamicRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateDynamicRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.dynamicId != null && message.hasOwnProperty("dynamicId"))
                if (!$util.isString(message.dynamicId))
                    return "dynamicId: string expected";
            if (message.opts != null && message.hasOwnProperty("opts")) {
                var error = $root.protos.opts.DynamicOptions.verify(message.opts);
                if (error)
                    return "opts." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateDynamicRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateDynamicRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateDynamicRequest} UpdateDynamicRequest
         */
        UpdateDynamicRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateDynamicRequest)
                return object;
            var message = new $root.protos.UpdateDynamicRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.UpdateDynamicRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.dynamicId != null)
                message.dynamicId = String(object.dynamicId);
            if (object.opts != null) {
                if (typeof object.opts !== "object")
                    throw TypeError(".protos.UpdateDynamicRequest.opts: object expected");
                message.opts = $root.protos.opts.DynamicOptions.fromObject(object.opts);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateDynamicRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateDynamicRequest
         * @static
         * @param {protos.UpdateDynamicRequest} message UpdateDynamicRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateDynamicRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.dynamicId = "";
                object.opts = null;
                object.auth = null;
            }
            if (message.dynamicId != null && message.hasOwnProperty("dynamicId"))
                object.dynamicId = message.dynamicId;
            if (message.opts != null && message.hasOwnProperty("opts"))
                object.opts = $root.protos.opts.DynamicOptions.toObject(message.opts, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this UpdateDynamicRequest to JSON.
         * @function toJSON
         * @memberof protos.UpdateDynamicRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateDynamicRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateDynamicRequest;
    })();

    protos.UpdateDynamicResponse = (function() {

        /**
         * Properties of an UpdateDynamicResponse.
         * @memberof protos
         * @interface IUpdateDynamicResponse
         * @property {protos.common.IStatus|null} [status] UpdateDynamicResponse status
         */

        /**
         * Constructs a new UpdateDynamicResponse.
         * @memberof protos
         * @classdesc Represents an UpdateDynamicResponse.
         * @implements IUpdateDynamicResponse
         * @constructor
         * @param {protos.IUpdateDynamicResponse=} [properties] Properties to set
         */
        function UpdateDynamicResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateDynamicResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.UpdateDynamicResponse
         * @instance
         */
        UpdateDynamicResponse.prototype.status = null;

        /**
         * Creates a new UpdateDynamicResponse instance using the specified properties.
         * @function create
         * @memberof protos.UpdateDynamicResponse
         * @static
         * @param {protos.IUpdateDynamicResponse=} [properties] Properties to set
         * @returns {protos.UpdateDynamicResponse} UpdateDynamicResponse instance
         */
        UpdateDynamicResponse.create = function create(properties) {
            return new UpdateDynamicResponse(properties);
        };

        /**
         * Encodes the specified UpdateDynamicResponse message. Does not implicitly {@link protos.UpdateDynamicResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateDynamicResponse
         * @static
         * @param {protos.IUpdateDynamicResponse} message UpdateDynamicResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateDynamicResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateDynamicResponse message, length delimited. Does not implicitly {@link protos.UpdateDynamicResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateDynamicResponse
         * @static
         * @param {protos.IUpdateDynamicResponse} message UpdateDynamicResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateDynamicResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateDynamicResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateDynamicResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateDynamicResponse} UpdateDynamicResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateDynamicResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateDynamicResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateDynamicResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateDynamicResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateDynamicResponse} UpdateDynamicResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateDynamicResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateDynamicResponse message.
         * @function verify
         * @memberof protos.UpdateDynamicResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateDynamicResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateDynamicResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateDynamicResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateDynamicResponse} UpdateDynamicResponse
         */
        UpdateDynamicResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateDynamicResponse)
                return object;
            var message = new $root.protos.UpdateDynamicResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.UpdateDynamicResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateDynamicResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateDynamicResponse
         * @static
         * @param {protos.UpdateDynamicResponse} message UpdateDynamicResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateDynamicResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this UpdateDynamicResponse to JSON.
         * @function toJSON
         * @memberof protos.UpdateDynamicResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateDynamicResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateDynamicResponse;
    })();

    protos.ResumeDynamicRequest = (function() {

        /**
         * Properties of a ResumeDynamicRequest.
         * @memberof protos
         * @interface IResumeDynamicRequest
         * @property {protos.common.IAuth|null} [auth] ResumeDynamicRequest auth
         * @property {string|null} [dynamicId] ResumeDynamicRequest dynamicId
         */

        /**
         * Constructs a new ResumeDynamicRequest.
         * @memberof protos
         * @classdesc Represents a ResumeDynamicRequest.
         * @implements IResumeDynamicRequest
         * @constructor
         * @param {protos.IResumeDynamicRequest=} [properties] Properties to set
         */
        function ResumeDynamicRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResumeDynamicRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.ResumeDynamicRequest
         * @instance
         */
        ResumeDynamicRequest.prototype.auth = null;

        /**
         * ResumeDynamicRequest dynamicId.
         * @member {string} dynamicId
         * @memberof protos.ResumeDynamicRequest
         * @instance
         */
        ResumeDynamicRequest.prototype.dynamicId = "";

        /**
         * Creates a new ResumeDynamicRequest instance using the specified properties.
         * @function create
         * @memberof protos.ResumeDynamicRequest
         * @static
         * @param {protos.IResumeDynamicRequest=} [properties] Properties to set
         * @returns {protos.ResumeDynamicRequest} ResumeDynamicRequest instance
         */
        ResumeDynamicRequest.create = function create(properties) {
            return new ResumeDynamicRequest(properties);
        };

        /**
         * Encodes the specified ResumeDynamicRequest message. Does not implicitly {@link protos.ResumeDynamicRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.ResumeDynamicRequest
         * @static
         * @param {protos.IResumeDynamicRequest} message ResumeDynamicRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeDynamicRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dynamicId != null && Object.hasOwnProperty.call(message, "dynamicId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.dynamicId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResumeDynamicRequest message, length delimited. Does not implicitly {@link protos.ResumeDynamicRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ResumeDynamicRequest
         * @static
         * @param {protos.IResumeDynamicRequest} message ResumeDynamicRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeDynamicRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResumeDynamicRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ResumeDynamicRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ResumeDynamicRequest} ResumeDynamicRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeDynamicRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ResumeDynamicRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.dynamicId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResumeDynamicRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ResumeDynamicRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ResumeDynamicRequest} ResumeDynamicRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeDynamicRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResumeDynamicRequest message.
         * @function verify
         * @memberof protos.ResumeDynamicRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResumeDynamicRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.dynamicId != null && message.hasOwnProperty("dynamicId"))
                if (!$util.isString(message.dynamicId))
                    return "dynamicId: string expected";
            return null;
        };

        /**
         * Creates a ResumeDynamicRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ResumeDynamicRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ResumeDynamicRequest} ResumeDynamicRequest
         */
        ResumeDynamicRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ResumeDynamicRequest)
                return object;
            var message = new $root.protos.ResumeDynamicRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.ResumeDynamicRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.dynamicId != null)
                message.dynamicId = String(object.dynamicId);
            return message;
        };

        /**
         * Creates a plain object from a ResumeDynamicRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ResumeDynamicRequest
         * @static
         * @param {protos.ResumeDynamicRequest} message ResumeDynamicRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResumeDynamicRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.dynamicId = "";
                object.auth = null;
            }
            if (message.dynamicId != null && message.hasOwnProperty("dynamicId"))
                object.dynamicId = message.dynamicId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this ResumeDynamicRequest to JSON.
         * @function toJSON
         * @memberof protos.ResumeDynamicRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResumeDynamicRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResumeDynamicRequest;
    })();

    protos.ResumeDynamicResponse = (function() {

        /**
         * Properties of a ResumeDynamicResponse.
         * @memberof protos
         * @interface IResumeDynamicResponse
         * @property {protos.common.IStatus|null} [status] ResumeDynamicResponse status
         */

        /**
         * Constructs a new ResumeDynamicResponse.
         * @memberof protos
         * @classdesc Represents a ResumeDynamicResponse.
         * @implements IResumeDynamicResponse
         * @constructor
         * @param {protos.IResumeDynamicResponse=} [properties] Properties to set
         */
        function ResumeDynamicResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResumeDynamicResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.ResumeDynamicResponse
         * @instance
         */
        ResumeDynamicResponse.prototype.status = null;

        /**
         * Creates a new ResumeDynamicResponse instance using the specified properties.
         * @function create
         * @memberof protos.ResumeDynamicResponse
         * @static
         * @param {protos.IResumeDynamicResponse=} [properties] Properties to set
         * @returns {protos.ResumeDynamicResponse} ResumeDynamicResponse instance
         */
        ResumeDynamicResponse.create = function create(properties) {
            return new ResumeDynamicResponse(properties);
        };

        /**
         * Encodes the specified ResumeDynamicResponse message. Does not implicitly {@link protos.ResumeDynamicResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.ResumeDynamicResponse
         * @static
         * @param {protos.IResumeDynamicResponse} message ResumeDynamicResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeDynamicResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResumeDynamicResponse message, length delimited. Does not implicitly {@link protos.ResumeDynamicResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ResumeDynamicResponse
         * @static
         * @param {protos.IResumeDynamicResponse} message ResumeDynamicResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeDynamicResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResumeDynamicResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ResumeDynamicResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ResumeDynamicResponse} ResumeDynamicResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeDynamicResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ResumeDynamicResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResumeDynamicResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ResumeDynamicResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ResumeDynamicResponse} ResumeDynamicResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeDynamicResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResumeDynamicResponse message.
         * @function verify
         * @memberof protos.ResumeDynamicResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResumeDynamicResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a ResumeDynamicResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ResumeDynamicResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ResumeDynamicResponse} ResumeDynamicResponse
         */
        ResumeDynamicResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ResumeDynamicResponse)
                return object;
            var message = new $root.protos.ResumeDynamicResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.ResumeDynamicResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a ResumeDynamicResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ResumeDynamicResponse
         * @static
         * @param {protos.ResumeDynamicResponse} message ResumeDynamicResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResumeDynamicResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this ResumeDynamicResponse to JSON.
         * @function toJSON
         * @memberof protos.ResumeDynamicResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResumeDynamicResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResumeDynamicResponse;
    })();

    protos.StopDynamicRequest = (function() {

        /**
         * Properties of a StopDynamicRequest.
         * @memberof protos
         * @interface IStopDynamicRequest
         * @property {protos.common.IAuth|null} [auth] StopDynamicRequest auth
         * @property {string|null} [dynamicId] StopDynamicRequest dynamicId
         */

        /**
         * Constructs a new StopDynamicRequest.
         * @memberof protos
         * @classdesc Represents a StopDynamicRequest.
         * @implements IStopDynamicRequest
         * @constructor
         * @param {protos.IStopDynamicRequest=} [properties] Properties to set
         */
        function StopDynamicRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StopDynamicRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.StopDynamicRequest
         * @instance
         */
        StopDynamicRequest.prototype.auth = null;

        /**
         * StopDynamicRequest dynamicId.
         * @member {string} dynamicId
         * @memberof protos.StopDynamicRequest
         * @instance
         */
        StopDynamicRequest.prototype.dynamicId = "";

        /**
         * Creates a new StopDynamicRequest instance using the specified properties.
         * @function create
         * @memberof protos.StopDynamicRequest
         * @static
         * @param {protos.IStopDynamicRequest=} [properties] Properties to set
         * @returns {protos.StopDynamicRequest} StopDynamicRequest instance
         */
        StopDynamicRequest.create = function create(properties) {
            return new StopDynamicRequest(properties);
        };

        /**
         * Encodes the specified StopDynamicRequest message. Does not implicitly {@link protos.StopDynamicRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.StopDynamicRequest
         * @static
         * @param {protos.IStopDynamicRequest} message StopDynamicRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopDynamicRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dynamicId != null && Object.hasOwnProperty.call(message, "dynamicId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.dynamicId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StopDynamicRequest message, length delimited. Does not implicitly {@link protos.StopDynamicRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.StopDynamicRequest
         * @static
         * @param {protos.IStopDynamicRequest} message StopDynamicRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopDynamicRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopDynamicRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.StopDynamicRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.StopDynamicRequest} StopDynamicRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopDynamicRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.StopDynamicRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.dynamicId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopDynamicRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.StopDynamicRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.StopDynamicRequest} StopDynamicRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopDynamicRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopDynamicRequest message.
         * @function verify
         * @memberof protos.StopDynamicRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopDynamicRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.dynamicId != null && message.hasOwnProperty("dynamicId"))
                if (!$util.isString(message.dynamicId))
                    return "dynamicId: string expected";
            return null;
        };

        /**
         * Creates a StopDynamicRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.StopDynamicRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.StopDynamicRequest} StopDynamicRequest
         */
        StopDynamicRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.StopDynamicRequest)
                return object;
            var message = new $root.protos.StopDynamicRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.StopDynamicRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.dynamicId != null)
                message.dynamicId = String(object.dynamicId);
            return message;
        };

        /**
         * Creates a plain object from a StopDynamicRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.StopDynamicRequest
         * @static
         * @param {protos.StopDynamicRequest} message StopDynamicRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopDynamicRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.dynamicId = "";
                object.auth = null;
            }
            if (message.dynamicId != null && message.hasOwnProperty("dynamicId"))
                object.dynamicId = message.dynamicId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this StopDynamicRequest to JSON.
         * @function toJSON
         * @memberof protos.StopDynamicRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopDynamicRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopDynamicRequest;
    })();

    protos.StopDynamicResponse = (function() {

        /**
         * Properties of a StopDynamicResponse.
         * @memberof protos
         * @interface IStopDynamicResponse
         * @property {protos.common.IStatus|null} [status] StopDynamicResponse status
         */

        /**
         * Constructs a new StopDynamicResponse.
         * @memberof protos
         * @classdesc Represents a StopDynamicResponse.
         * @implements IStopDynamicResponse
         * @constructor
         * @param {protos.IStopDynamicResponse=} [properties] Properties to set
         */
        function StopDynamicResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StopDynamicResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.StopDynamicResponse
         * @instance
         */
        StopDynamicResponse.prototype.status = null;

        /**
         * Creates a new StopDynamicResponse instance using the specified properties.
         * @function create
         * @memberof protos.StopDynamicResponse
         * @static
         * @param {protos.IStopDynamicResponse=} [properties] Properties to set
         * @returns {protos.StopDynamicResponse} StopDynamicResponse instance
         */
        StopDynamicResponse.create = function create(properties) {
            return new StopDynamicResponse(properties);
        };

        /**
         * Encodes the specified StopDynamicResponse message. Does not implicitly {@link protos.StopDynamicResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.StopDynamicResponse
         * @static
         * @param {protos.IStopDynamicResponse} message StopDynamicResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopDynamicResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StopDynamicResponse message, length delimited. Does not implicitly {@link protos.StopDynamicResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.StopDynamicResponse
         * @static
         * @param {protos.IStopDynamicResponse} message StopDynamicResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopDynamicResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopDynamicResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.StopDynamicResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.StopDynamicResponse} StopDynamicResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopDynamicResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.StopDynamicResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopDynamicResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.StopDynamicResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.StopDynamicResponse} StopDynamicResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopDynamicResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopDynamicResponse message.
         * @function verify
         * @memberof protos.StopDynamicResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopDynamicResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a StopDynamicResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.StopDynamicResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.StopDynamicResponse} StopDynamicResponse
         */
        StopDynamicResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.StopDynamicResponse)
                return object;
            var message = new $root.protos.StopDynamicResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.StopDynamicResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a StopDynamicResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.StopDynamicResponse
         * @static
         * @param {protos.StopDynamicResponse} message StopDynamicResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopDynamicResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this StopDynamicResponse to JSON.
         * @function toJSON
         * @memberof protos.StopDynamicResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopDynamicResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopDynamicResponse;
    })();

    protos.DeleteDynamicRequest = (function() {

        /**
         * Properties of a DeleteDynamicRequest.
         * @memberof protos
         * @interface IDeleteDynamicRequest
         * @property {protos.common.IAuth|null} [auth] DeleteDynamicRequest auth
         * @property {string|null} [dynamicId] DeleteDynamicRequest dynamicId
         */

        /**
         * Constructs a new DeleteDynamicRequest.
         * @memberof protos
         * @classdesc Represents a DeleteDynamicRequest.
         * @implements IDeleteDynamicRequest
         * @constructor
         * @param {protos.IDeleteDynamicRequest=} [properties] Properties to set
         */
        function DeleteDynamicRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteDynamicRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.DeleteDynamicRequest
         * @instance
         */
        DeleteDynamicRequest.prototype.auth = null;

        /**
         * DeleteDynamicRequest dynamicId.
         * @member {string} dynamicId
         * @memberof protos.DeleteDynamicRequest
         * @instance
         */
        DeleteDynamicRequest.prototype.dynamicId = "";

        /**
         * Creates a new DeleteDynamicRequest instance using the specified properties.
         * @function create
         * @memberof protos.DeleteDynamicRequest
         * @static
         * @param {protos.IDeleteDynamicRequest=} [properties] Properties to set
         * @returns {protos.DeleteDynamicRequest} DeleteDynamicRequest instance
         */
        DeleteDynamicRequest.create = function create(properties) {
            return new DeleteDynamicRequest(properties);
        };

        /**
         * Encodes the specified DeleteDynamicRequest message. Does not implicitly {@link protos.DeleteDynamicRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteDynamicRequest
         * @static
         * @param {protos.IDeleteDynamicRequest} message DeleteDynamicRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteDynamicRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dynamicId != null && Object.hasOwnProperty.call(message, "dynamicId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.dynamicId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteDynamicRequest message, length delimited. Does not implicitly {@link protos.DeleteDynamicRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteDynamicRequest
         * @static
         * @param {protos.IDeleteDynamicRequest} message DeleteDynamicRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteDynamicRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteDynamicRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteDynamicRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteDynamicRequest} DeleteDynamicRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteDynamicRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteDynamicRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.dynamicId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteDynamicRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteDynamicRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteDynamicRequest} DeleteDynamicRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteDynamicRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteDynamicRequest message.
         * @function verify
         * @memberof protos.DeleteDynamicRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteDynamicRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.dynamicId != null && message.hasOwnProperty("dynamicId"))
                if (!$util.isString(message.dynamicId))
                    return "dynamicId: string expected";
            return null;
        };

        /**
         * Creates a DeleteDynamicRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteDynamicRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteDynamicRequest} DeleteDynamicRequest
         */
        DeleteDynamicRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteDynamicRequest)
                return object;
            var message = new $root.protos.DeleteDynamicRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.DeleteDynamicRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.dynamicId != null)
                message.dynamicId = String(object.dynamicId);
            return message;
        };

        /**
         * Creates a plain object from a DeleteDynamicRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteDynamicRequest
         * @static
         * @param {protos.DeleteDynamicRequest} message DeleteDynamicRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteDynamicRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.dynamicId = "";
                object.auth = null;
            }
            if (message.dynamicId != null && message.hasOwnProperty("dynamicId"))
                object.dynamicId = message.dynamicId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this DeleteDynamicRequest to JSON.
         * @function toJSON
         * @memberof protos.DeleteDynamicRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteDynamicRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteDynamicRequest;
    })();

    protos.DeleteDynamicResponse = (function() {

        /**
         * Properties of a DeleteDynamicResponse.
         * @memberof protos
         * @interface IDeleteDynamicResponse
         * @property {protos.common.IStatus|null} [status] DeleteDynamicResponse status
         */

        /**
         * Constructs a new DeleteDynamicResponse.
         * @memberof protos
         * @classdesc Represents a DeleteDynamicResponse.
         * @implements IDeleteDynamicResponse
         * @constructor
         * @param {protos.IDeleteDynamicResponse=} [properties] Properties to set
         */
        function DeleteDynamicResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteDynamicResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.DeleteDynamicResponse
         * @instance
         */
        DeleteDynamicResponse.prototype.status = null;

        /**
         * Creates a new DeleteDynamicResponse instance using the specified properties.
         * @function create
         * @memberof protos.DeleteDynamicResponse
         * @static
         * @param {protos.IDeleteDynamicResponse=} [properties] Properties to set
         * @returns {protos.DeleteDynamicResponse} DeleteDynamicResponse instance
         */
        DeleteDynamicResponse.create = function create(properties) {
            return new DeleteDynamicResponse(properties);
        };

        /**
         * Encodes the specified DeleteDynamicResponse message. Does not implicitly {@link protos.DeleteDynamicResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteDynamicResponse
         * @static
         * @param {protos.IDeleteDynamicResponse} message DeleteDynamicResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteDynamicResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteDynamicResponse message, length delimited. Does not implicitly {@link protos.DeleteDynamicResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteDynamicResponse
         * @static
         * @param {protos.IDeleteDynamicResponse} message DeleteDynamicResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteDynamicResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteDynamicResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteDynamicResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteDynamicResponse} DeleteDynamicResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteDynamicResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteDynamicResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteDynamicResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteDynamicResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteDynamicResponse} DeleteDynamicResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteDynamicResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteDynamicResponse message.
         * @function verify
         * @memberof protos.DeleteDynamicResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteDynamicResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a DeleteDynamicResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteDynamicResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteDynamicResponse} DeleteDynamicResponse
         */
        DeleteDynamicResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteDynamicResponse)
                return object;
            var message = new $root.protos.DeleteDynamicResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.DeleteDynamicResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a DeleteDynamicResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteDynamicResponse
         * @static
         * @param {protos.DeleteDynamicResponse} message DeleteDynamicResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteDynamicResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this DeleteDynamicResponse to JSON.
         * @function toJSON
         * @memberof protos.DeleteDynamicResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteDynamicResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteDynamicResponse;
    })();

    protos.GetAllRelaysRequest = (function() {

        /**
         * Properties of a GetAllRelaysRequest.
         * @memberof protos
         * @interface IGetAllRelaysRequest
         * @property {protos.common.IAuth|null} [auth] GetAllRelaysRequest auth
         */

        /**
         * Constructs a new GetAllRelaysRequest.
         * @memberof protos
         * @classdesc Represents a GetAllRelaysRequest.
         * @implements IGetAllRelaysRequest
         * @constructor
         * @param {protos.IGetAllRelaysRequest=} [properties] Properties to set
         */
        function GetAllRelaysRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllRelaysRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetAllRelaysRequest
         * @instance
         */
        GetAllRelaysRequest.prototype.auth = null;

        /**
         * Creates a new GetAllRelaysRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {protos.IGetAllRelaysRequest=} [properties] Properties to set
         * @returns {protos.GetAllRelaysRequest} GetAllRelaysRequest instance
         */
        GetAllRelaysRequest.create = function create(properties) {
            return new GetAllRelaysRequest(properties);
        };

        /**
         * Encodes the specified GetAllRelaysRequest message. Does not implicitly {@link protos.GetAllRelaysRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {protos.IGetAllRelaysRequest} message GetAllRelaysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllRelaysRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllRelaysRequest message, length delimited. Does not implicitly {@link protos.GetAllRelaysRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {protos.IGetAllRelaysRequest} message GetAllRelaysRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllRelaysRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllRelaysRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllRelaysRequest} GetAllRelaysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllRelaysRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllRelaysRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllRelaysRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllRelaysRequest} GetAllRelaysRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllRelaysRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllRelaysRequest message.
         * @function verify
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllRelaysRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };

        /**
         * Creates a GetAllRelaysRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllRelaysRequest} GetAllRelaysRequest
         */
        GetAllRelaysRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllRelaysRequest)
                return object;
            var message = new $root.protos.GetAllRelaysRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetAllRelaysRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllRelaysRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllRelaysRequest
         * @static
         * @param {protos.GetAllRelaysRequest} message GetAllRelaysRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllRelaysRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.auth = null;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetAllRelaysRequest to JSON.
         * @function toJSON
         * @memberof protos.GetAllRelaysRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllRelaysRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllRelaysRequest;
    })();

    protos.GetAllRelaysResponse = (function() {

        /**
         * Properties of a GetAllRelaysResponse.
         * @memberof protos
         * @interface IGetAllRelaysResponse
         * @property {protos.common.IStatus|null} [status] GetAllRelaysResponse status
         * @property {Array.<protos.opts.IRelayOptions>|null} [opts] GetAllRelaysResponse opts
         */

        /**
         * Constructs a new GetAllRelaysResponse.
         * @memberof protos
         * @classdesc Represents a GetAllRelaysResponse.
         * @implements IGetAllRelaysResponse
         * @constructor
         * @param {protos.IGetAllRelaysResponse=} [properties] Properties to set
         */
        function GetAllRelaysResponse(properties) {
            this.opts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetAllRelaysResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.GetAllRelaysResponse
         * @instance
         */
        GetAllRelaysResponse.prototype.status = null;

        /**
         * GetAllRelaysResponse opts.
         * @member {Array.<protos.opts.IRelayOptions>} opts
         * @memberof protos.GetAllRelaysResponse
         * @instance
         */
        GetAllRelaysResponse.prototype.opts = $util.emptyArray;

        /**
         * Creates a new GetAllRelaysResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {protos.IGetAllRelaysResponse=} [properties] Properties to set
         * @returns {protos.GetAllRelaysResponse} GetAllRelaysResponse instance
         */
        GetAllRelaysResponse.create = function create(properties) {
            return new GetAllRelaysResponse(properties);
        };

        /**
         * Encodes the specified GetAllRelaysResponse message. Does not implicitly {@link protos.GetAllRelaysResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {protos.IGetAllRelaysResponse} message GetAllRelaysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllRelaysResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.opts != null && message.opts.length)
                for (var i = 0; i < message.opts.length; ++i)
                    $root.protos.opts.RelayOptions.encode(message.opts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetAllRelaysResponse message, length delimited. Does not implicitly {@link protos.GetAllRelaysResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {protos.IGetAllRelaysResponse} message GetAllRelaysResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetAllRelaysResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetAllRelaysResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetAllRelaysResponse} GetAllRelaysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllRelaysResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetAllRelaysResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    if (!(message.opts && message.opts.length))
                        message.opts = [];
                    message.opts.push($root.protos.opts.RelayOptions.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetAllRelaysResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetAllRelaysResponse} GetAllRelaysResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetAllRelaysResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetAllRelaysResponse message.
         * @function verify
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetAllRelaysResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.opts != null && message.hasOwnProperty("opts")) {
                if (!Array.isArray(message.opts))
                    return "opts: array expected";
                for (var i = 0; i < message.opts.length; ++i) {
                    var error = $root.protos.opts.RelayOptions.verify(message.opts[i]);
                    if (error)
                        return "opts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetAllRelaysResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetAllRelaysResponse} GetAllRelaysResponse
         */
        GetAllRelaysResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetAllRelaysResponse)
                return object;
            var message = new $root.protos.GetAllRelaysResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.GetAllRelaysResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.opts) {
                if (!Array.isArray(object.opts))
                    throw TypeError(".protos.GetAllRelaysResponse.opts: array expected");
                message.opts = [];
                for (var i = 0; i < object.opts.length; ++i) {
                    if (typeof object.opts[i] !== "object")
                        throw TypeError(".protos.GetAllRelaysResponse.opts: object expected");
                    message.opts[i] = $root.protos.opts.RelayOptions.fromObject(object.opts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetAllRelaysResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetAllRelaysResponse
         * @static
         * @param {protos.GetAllRelaysResponse} message GetAllRelaysResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetAllRelaysResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.opts = [];
            if (options.defaults)
                object.status = null;
            if (message.opts && message.opts.length) {
                object.opts = [];
                for (var j = 0; j < message.opts.length; ++j)
                    object.opts[j] = $root.protos.opts.RelayOptions.toObject(message.opts[j], options);
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this GetAllRelaysResponse to JSON.
         * @function toJSON
         * @memberof protos.GetAllRelaysResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetAllRelaysResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetAllRelaysResponse;
    })();

    protos.GetRelayRequest = (function() {

        /**
         * Properties of a GetRelayRequest.
         * @memberof protos
         * @interface IGetRelayRequest
         * @property {protos.common.IAuth|null} [auth] GetRelayRequest auth
         * @property {string|null} [relayId] GetRelayRequest relayId
         */

        /**
         * Constructs a new GetRelayRequest.
         * @memberof protos
         * @classdesc Represents a GetRelayRequest.
         * @implements IGetRelayRequest
         * @constructor
         * @param {protos.IGetRelayRequest=} [properties] Properties to set
         */
        function GetRelayRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRelayRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetRelayRequest
         * @instance
         */
        GetRelayRequest.prototype.auth = null;

        /**
         * GetRelayRequest relayId.
         * @member {string} relayId
         * @memberof protos.GetRelayRequest
         * @instance
         */
        GetRelayRequest.prototype.relayId = "";

        /**
         * Creates a new GetRelayRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetRelayRequest
         * @static
         * @param {protos.IGetRelayRequest=} [properties] Properties to set
         * @returns {protos.GetRelayRequest} GetRelayRequest instance
         */
        GetRelayRequest.create = function create(properties) {
            return new GetRelayRequest(properties);
        };

        /**
         * Encodes the specified GetRelayRequest message. Does not implicitly {@link protos.GetRelayRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetRelayRequest
         * @static
         * @param {protos.IGetRelayRequest} message GetRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRelayRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relayId != null && Object.hasOwnProperty.call(message, "relayId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.relayId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetRelayRequest message, length delimited. Does not implicitly {@link protos.GetRelayRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetRelayRequest
         * @static
         * @param {protos.IGetRelayRequest} message GetRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRelayRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRelayRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetRelayRequest} GetRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRelayRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetRelayRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.relayId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRelayRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetRelayRequest} GetRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRelayRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRelayRequest message.
         * @function verify
         * @memberof protos.GetRelayRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRelayRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                if (!$util.isString(message.relayId))
                    return "relayId: string expected";
            return null;
        };

        /**
         * Creates a GetRelayRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetRelayRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetRelayRequest} GetRelayRequest
         */
        GetRelayRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetRelayRequest)
                return object;
            var message = new $root.protos.GetRelayRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetRelayRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.relayId != null)
                message.relayId = String(object.relayId);
            return message;
        };

        /**
         * Creates a plain object from a GetRelayRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetRelayRequest
         * @static
         * @param {protos.GetRelayRequest} message GetRelayRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetRelayRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relayId = "";
                object.auth = null;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                object.relayId = message.relayId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetRelayRequest to JSON.
         * @function toJSON
         * @memberof protos.GetRelayRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetRelayRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetRelayRequest;
    })();

    protos.GetRelayResponse = (function() {

        /**
         * Properties of a GetRelayResponse.
         * @memberof protos
         * @interface IGetRelayResponse
         * @property {protos.common.IStatus|null} [status] GetRelayResponse status
         * @property {protos.opts.IRelayOptions|null} [opts] GetRelayResponse opts
         */

        /**
         * Constructs a new GetRelayResponse.
         * @memberof protos
         * @classdesc Represents a GetRelayResponse.
         * @implements IGetRelayResponse
         * @constructor
         * @param {protos.IGetRelayResponse=} [properties] Properties to set
         */
        function GetRelayResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRelayResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.GetRelayResponse
         * @instance
         */
        GetRelayResponse.prototype.status = null;

        /**
         * GetRelayResponse opts.
         * @member {protos.opts.IRelayOptions|null|undefined} opts
         * @memberof protos.GetRelayResponse
         * @instance
         */
        GetRelayResponse.prototype.opts = null;

        /**
         * Creates a new GetRelayResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetRelayResponse
         * @static
         * @param {protos.IGetRelayResponse=} [properties] Properties to set
         * @returns {protos.GetRelayResponse} GetRelayResponse instance
         */
        GetRelayResponse.create = function create(properties) {
            return new GetRelayResponse(properties);
        };

        /**
         * Encodes the specified GetRelayResponse message. Does not implicitly {@link protos.GetRelayResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetRelayResponse
         * @static
         * @param {protos.IGetRelayResponse} message GetRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRelayResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.opts != null && Object.hasOwnProperty.call(message, "opts"))
                $root.protos.opts.RelayOptions.encode(message.opts, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetRelayResponse message, length delimited. Does not implicitly {@link protos.GetRelayResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetRelayResponse
         * @static
         * @param {protos.IGetRelayResponse} message GetRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRelayResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRelayResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetRelayResponse} GetRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRelayResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetRelayResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.opts = $root.protos.opts.RelayOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRelayResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetRelayResponse} GetRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRelayResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRelayResponse message.
         * @function verify
         * @memberof protos.GetRelayResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRelayResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.opts != null && message.hasOwnProperty("opts")) {
                var error = $root.protos.opts.RelayOptions.verify(message.opts);
                if (error)
                    return "opts." + error;
            }
            return null;
        };

        /**
         * Creates a GetRelayResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetRelayResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetRelayResponse} GetRelayResponse
         */
        GetRelayResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetRelayResponse)
                return object;
            var message = new $root.protos.GetRelayResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.GetRelayResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.opts != null) {
                if (typeof object.opts !== "object")
                    throw TypeError(".protos.GetRelayResponse.opts: object expected");
                message.opts = $root.protos.opts.RelayOptions.fromObject(object.opts);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetRelayResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetRelayResponse
         * @static
         * @param {protos.GetRelayResponse} message GetRelayResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetRelayResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.opts = null;
                object.status = null;
            }
            if (message.opts != null && message.hasOwnProperty("opts"))
                object.opts = $root.protos.opts.RelayOptions.toObject(message.opts, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this GetRelayResponse to JSON.
         * @function toJSON
         * @memberof protos.GetRelayResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetRelayResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetRelayResponse;
    })();

    protos.CreateRelayRequest = (function() {

        /**
         * Properties of a CreateRelayRequest.
         * @memberof protos
         * @interface ICreateRelayRequest
         * @property {protos.common.IAuth|null} [auth] CreateRelayRequest auth
         * @property {protos.opts.IRelayOptions|null} [opts] CreateRelayRequest opts
         */

        /**
         * Constructs a new CreateRelayRequest.
         * @memberof protos
         * @classdesc Represents a CreateRelayRequest.
         * @implements ICreateRelayRequest
         * @constructor
         * @param {protos.ICreateRelayRequest=} [properties] Properties to set
         */
        function CreateRelayRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateRelayRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.CreateRelayRequest
         * @instance
         */
        CreateRelayRequest.prototype.auth = null;

        /**
         * CreateRelayRequest opts.
         * @member {protos.opts.IRelayOptions|null|undefined} opts
         * @memberof protos.CreateRelayRequest
         * @instance
         */
        CreateRelayRequest.prototype.opts = null;

        /**
         * Creates a new CreateRelayRequest instance using the specified properties.
         * @function create
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {protos.ICreateRelayRequest=} [properties] Properties to set
         * @returns {protos.CreateRelayRequest} CreateRelayRequest instance
         */
        CreateRelayRequest.create = function create(properties) {
            return new CreateRelayRequest(properties);
        };

        /**
         * Encodes the specified CreateRelayRequest message. Does not implicitly {@link protos.CreateRelayRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {protos.ICreateRelayRequest} message CreateRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateRelayRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.opts != null && Object.hasOwnProperty.call(message, "opts"))
                $root.protos.opts.RelayOptions.encode(message.opts, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateRelayRequest message, length delimited. Does not implicitly {@link protos.CreateRelayRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {protos.ICreateRelayRequest} message CreateRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateRelayRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateRelayRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateRelayRequest} CreateRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateRelayRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateRelayRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.opts = $root.protos.opts.RelayOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateRelayRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateRelayRequest} CreateRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateRelayRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateRelayRequest message.
         * @function verify
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateRelayRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.opts != null && message.hasOwnProperty("opts")) {
                var error = $root.protos.opts.RelayOptions.verify(message.opts);
                if (error)
                    return "opts." + error;
            }
            return null;
        };

        /**
         * Creates a CreateRelayRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateRelayRequest} CreateRelayRequest
         */
        CreateRelayRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateRelayRequest)
                return object;
            var message = new $root.protos.CreateRelayRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.CreateRelayRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.opts != null) {
                if (typeof object.opts !== "object")
                    throw TypeError(".protos.CreateRelayRequest.opts: object expected");
                message.opts = $root.protos.opts.RelayOptions.fromObject(object.opts);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateRelayRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateRelayRequest
         * @static
         * @param {protos.CreateRelayRequest} message CreateRelayRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateRelayRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.opts = null;
                object.auth = null;
            }
            if (message.opts != null && message.hasOwnProperty("opts"))
                object.opts = $root.protos.opts.RelayOptions.toObject(message.opts, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this CreateRelayRequest to JSON.
         * @function toJSON
         * @memberof protos.CreateRelayRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateRelayRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateRelayRequest;
    })();

    protos.CreateRelayResponse = (function() {

        /**
         * Properties of a CreateRelayResponse.
         * @memberof protos
         * @interface ICreateRelayResponse
         * @property {protos.common.IStatus|null} [status] CreateRelayResponse status
         * @property {string|null} [relayId] CreateRelayResponse relayId
         */

        /**
         * Constructs a new CreateRelayResponse.
         * @memberof protos
         * @classdesc Represents a CreateRelayResponse.
         * @implements ICreateRelayResponse
         * @constructor
         * @param {protos.ICreateRelayResponse=} [properties] Properties to set
         */
        function CreateRelayResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateRelayResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.CreateRelayResponse
         * @instance
         */
        CreateRelayResponse.prototype.status = null;

        /**
         * CreateRelayResponse relayId.
         * @member {string} relayId
         * @memberof protos.CreateRelayResponse
         * @instance
         */
        CreateRelayResponse.prototype.relayId = "";

        /**
         * Creates a new CreateRelayResponse instance using the specified properties.
         * @function create
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {protos.ICreateRelayResponse=} [properties] Properties to set
         * @returns {protos.CreateRelayResponse} CreateRelayResponse instance
         */
        CreateRelayResponse.create = function create(properties) {
            return new CreateRelayResponse(properties);
        };

        /**
         * Encodes the specified CreateRelayResponse message. Does not implicitly {@link protos.CreateRelayResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {protos.ICreateRelayResponse} message CreateRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateRelayResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relayId != null && Object.hasOwnProperty.call(message, "relayId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.relayId);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateRelayResponse message, length delimited. Does not implicitly {@link protos.CreateRelayResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {protos.ICreateRelayResponse} message CreateRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateRelayResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateRelayResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.CreateRelayResponse} CreateRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateRelayResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CreateRelayResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.relayId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateRelayResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.CreateRelayResponse} CreateRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateRelayResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateRelayResponse message.
         * @function verify
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateRelayResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                if (!$util.isString(message.relayId))
                    return "relayId: string expected";
            return null;
        };

        /**
         * Creates a CreateRelayResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.CreateRelayResponse} CreateRelayResponse
         */
        CreateRelayResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.CreateRelayResponse)
                return object;
            var message = new $root.protos.CreateRelayResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.CreateRelayResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            if (object.relayId != null)
                message.relayId = String(object.relayId);
            return message;
        };

        /**
         * Creates a plain object from a CreateRelayResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.CreateRelayResponse
         * @static
         * @param {protos.CreateRelayResponse} message CreateRelayResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateRelayResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relayId = "";
                object.status = null;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                object.relayId = message.relayId;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this CreateRelayResponse to JSON.
         * @function toJSON
         * @memberof protos.CreateRelayResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateRelayResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateRelayResponse;
    })();

    protos.UpdateRelayRequest = (function() {

        /**
         * Properties of an UpdateRelayRequest.
         * @memberof protos
         * @interface IUpdateRelayRequest
         * @property {protos.common.IAuth|null} [auth] UpdateRelayRequest auth
         * @property {string|null} [relayId] UpdateRelayRequest relayId
         * @property {protos.opts.IRelayOptions|null} [opts] UpdateRelayRequest opts
         */

        /**
         * Constructs a new UpdateRelayRequest.
         * @memberof protos
         * @classdesc Represents an UpdateRelayRequest.
         * @implements IUpdateRelayRequest
         * @constructor
         * @param {protos.IUpdateRelayRequest=} [properties] Properties to set
         */
        function UpdateRelayRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateRelayRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.UpdateRelayRequest
         * @instance
         */
        UpdateRelayRequest.prototype.auth = null;

        /**
         * UpdateRelayRequest relayId.
         * @member {string} relayId
         * @memberof protos.UpdateRelayRequest
         * @instance
         */
        UpdateRelayRequest.prototype.relayId = "";

        /**
         * UpdateRelayRequest opts.
         * @member {protos.opts.IRelayOptions|null|undefined} opts
         * @memberof protos.UpdateRelayRequest
         * @instance
         */
        UpdateRelayRequest.prototype.opts = null;

        /**
         * Creates a new UpdateRelayRequest instance using the specified properties.
         * @function create
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {protos.IUpdateRelayRequest=} [properties] Properties to set
         * @returns {protos.UpdateRelayRequest} UpdateRelayRequest instance
         */
        UpdateRelayRequest.create = function create(properties) {
            return new UpdateRelayRequest(properties);
        };

        /**
         * Encodes the specified UpdateRelayRequest message. Does not implicitly {@link protos.UpdateRelayRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {protos.IUpdateRelayRequest} message UpdateRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateRelayRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relayId != null && Object.hasOwnProperty.call(message, "relayId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.relayId);
            if (message.opts != null && Object.hasOwnProperty.call(message, "opts"))
                $root.protos.opts.RelayOptions.encode(message.opts, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateRelayRequest message, length delimited. Does not implicitly {@link protos.UpdateRelayRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {protos.IUpdateRelayRequest} message UpdateRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateRelayRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateRelayRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateRelayRequest} UpdateRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateRelayRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateRelayRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.relayId = reader.string();
                    break;
                case 2:
                    message.opts = $root.protos.opts.RelayOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateRelayRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateRelayRequest} UpdateRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateRelayRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateRelayRequest message.
         * @function verify
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateRelayRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                if (!$util.isString(message.relayId))
                    return "relayId: string expected";
            if (message.opts != null && message.hasOwnProperty("opts")) {
                var error = $root.protos.opts.RelayOptions.verify(message.opts);
                if (error)
                    return "opts." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateRelayRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateRelayRequest} UpdateRelayRequest
         */
        UpdateRelayRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateRelayRequest)
                return object;
            var message = new $root.protos.UpdateRelayRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.UpdateRelayRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.relayId != null)
                message.relayId = String(object.relayId);
            if (object.opts != null) {
                if (typeof object.opts !== "object")
                    throw TypeError(".protos.UpdateRelayRequest.opts: object expected");
                message.opts = $root.protos.opts.RelayOptions.fromObject(object.opts);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateRelayRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateRelayRequest
         * @static
         * @param {protos.UpdateRelayRequest} message UpdateRelayRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateRelayRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relayId = "";
                object.opts = null;
                object.auth = null;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                object.relayId = message.relayId;
            if (message.opts != null && message.hasOwnProperty("opts"))
                object.opts = $root.protos.opts.RelayOptions.toObject(message.opts, options);
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this UpdateRelayRequest to JSON.
         * @function toJSON
         * @memberof protos.UpdateRelayRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateRelayRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateRelayRequest;
    })();

    protos.UpdateRelayResponse = (function() {

        /**
         * Properties of an UpdateRelayResponse.
         * @memberof protos
         * @interface IUpdateRelayResponse
         * @property {protos.common.IStatus|null} [status] UpdateRelayResponse status
         */

        /**
         * Constructs a new UpdateRelayResponse.
         * @memberof protos
         * @classdesc Represents an UpdateRelayResponse.
         * @implements IUpdateRelayResponse
         * @constructor
         * @param {protos.IUpdateRelayResponse=} [properties] Properties to set
         */
        function UpdateRelayResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateRelayResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.UpdateRelayResponse
         * @instance
         */
        UpdateRelayResponse.prototype.status = null;

        /**
         * Creates a new UpdateRelayResponse instance using the specified properties.
         * @function create
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {protos.IUpdateRelayResponse=} [properties] Properties to set
         * @returns {protos.UpdateRelayResponse} UpdateRelayResponse instance
         */
        UpdateRelayResponse.create = function create(properties) {
            return new UpdateRelayResponse(properties);
        };

        /**
         * Encodes the specified UpdateRelayResponse message. Does not implicitly {@link protos.UpdateRelayResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {protos.IUpdateRelayResponse} message UpdateRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateRelayResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateRelayResponse message, length delimited. Does not implicitly {@link protos.UpdateRelayResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {protos.IUpdateRelayResponse} message UpdateRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateRelayResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateRelayResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.UpdateRelayResponse} UpdateRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateRelayResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.UpdateRelayResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateRelayResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.UpdateRelayResponse} UpdateRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateRelayResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateRelayResponse message.
         * @function verify
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateRelayResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateRelayResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.UpdateRelayResponse} UpdateRelayResponse
         */
        UpdateRelayResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.UpdateRelayResponse)
                return object;
            var message = new $root.protos.UpdateRelayResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.UpdateRelayResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateRelayResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.UpdateRelayResponse
         * @static
         * @param {protos.UpdateRelayResponse} message UpdateRelayResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateRelayResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this UpdateRelayResponse to JSON.
         * @function toJSON
         * @memberof protos.UpdateRelayResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateRelayResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateRelayResponse;
    })();

    protos.ResumeRelayRequest = (function() {

        /**
         * Properties of a ResumeRelayRequest.
         * @memberof protos
         * @interface IResumeRelayRequest
         * @property {protos.common.IAuth|null} [auth] ResumeRelayRequest auth
         * @property {string|null} [relayId] ResumeRelayRequest relayId
         */

        /**
         * Constructs a new ResumeRelayRequest.
         * @memberof protos
         * @classdesc Represents a ResumeRelayRequest.
         * @implements IResumeRelayRequest
         * @constructor
         * @param {protos.IResumeRelayRequest=} [properties] Properties to set
         */
        function ResumeRelayRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResumeRelayRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.ResumeRelayRequest
         * @instance
         */
        ResumeRelayRequest.prototype.auth = null;

        /**
         * ResumeRelayRequest relayId.
         * @member {string} relayId
         * @memberof protos.ResumeRelayRequest
         * @instance
         */
        ResumeRelayRequest.prototype.relayId = "";

        /**
         * Creates a new ResumeRelayRequest instance using the specified properties.
         * @function create
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {protos.IResumeRelayRequest=} [properties] Properties to set
         * @returns {protos.ResumeRelayRequest} ResumeRelayRequest instance
         */
        ResumeRelayRequest.create = function create(properties) {
            return new ResumeRelayRequest(properties);
        };

        /**
         * Encodes the specified ResumeRelayRequest message. Does not implicitly {@link protos.ResumeRelayRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {protos.IResumeRelayRequest} message ResumeRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeRelayRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relayId != null && Object.hasOwnProperty.call(message, "relayId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.relayId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResumeRelayRequest message, length delimited. Does not implicitly {@link protos.ResumeRelayRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {protos.IResumeRelayRequest} message ResumeRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeRelayRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResumeRelayRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ResumeRelayRequest} ResumeRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeRelayRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ResumeRelayRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.relayId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResumeRelayRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ResumeRelayRequest} ResumeRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeRelayRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResumeRelayRequest message.
         * @function verify
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResumeRelayRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                if (!$util.isString(message.relayId))
                    return "relayId: string expected";
            return null;
        };

        /**
         * Creates a ResumeRelayRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ResumeRelayRequest} ResumeRelayRequest
         */
        ResumeRelayRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ResumeRelayRequest)
                return object;
            var message = new $root.protos.ResumeRelayRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.ResumeRelayRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.relayId != null)
                message.relayId = String(object.relayId);
            return message;
        };

        /**
         * Creates a plain object from a ResumeRelayRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ResumeRelayRequest
         * @static
         * @param {protos.ResumeRelayRequest} message ResumeRelayRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResumeRelayRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relayId = "";
                object.auth = null;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                object.relayId = message.relayId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this ResumeRelayRequest to JSON.
         * @function toJSON
         * @memberof protos.ResumeRelayRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResumeRelayRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResumeRelayRequest;
    })();

    protos.ResumeRelayResponse = (function() {

        /**
         * Properties of a ResumeRelayResponse.
         * @memberof protos
         * @interface IResumeRelayResponse
         * @property {protos.common.IStatus|null} [status] ResumeRelayResponse status
         */

        /**
         * Constructs a new ResumeRelayResponse.
         * @memberof protos
         * @classdesc Represents a ResumeRelayResponse.
         * @implements IResumeRelayResponse
         * @constructor
         * @param {protos.IResumeRelayResponse=} [properties] Properties to set
         */
        function ResumeRelayResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResumeRelayResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.ResumeRelayResponse
         * @instance
         */
        ResumeRelayResponse.prototype.status = null;

        /**
         * Creates a new ResumeRelayResponse instance using the specified properties.
         * @function create
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {protos.IResumeRelayResponse=} [properties] Properties to set
         * @returns {protos.ResumeRelayResponse} ResumeRelayResponse instance
         */
        ResumeRelayResponse.create = function create(properties) {
            return new ResumeRelayResponse(properties);
        };

        /**
         * Encodes the specified ResumeRelayResponse message. Does not implicitly {@link protos.ResumeRelayResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {protos.IResumeRelayResponse} message ResumeRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeRelayResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResumeRelayResponse message, length delimited. Does not implicitly {@link protos.ResumeRelayResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {protos.IResumeRelayResponse} message ResumeRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResumeRelayResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResumeRelayResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.ResumeRelayResponse} ResumeRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeRelayResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ResumeRelayResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResumeRelayResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.ResumeRelayResponse} ResumeRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResumeRelayResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResumeRelayResponse message.
         * @function verify
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResumeRelayResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a ResumeRelayResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.ResumeRelayResponse} ResumeRelayResponse
         */
        ResumeRelayResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.ResumeRelayResponse)
                return object;
            var message = new $root.protos.ResumeRelayResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.ResumeRelayResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a ResumeRelayResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.ResumeRelayResponse
         * @static
         * @param {protos.ResumeRelayResponse} message ResumeRelayResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResumeRelayResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this ResumeRelayResponse to JSON.
         * @function toJSON
         * @memberof protos.ResumeRelayResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResumeRelayResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResumeRelayResponse;
    })();

    protos.StopRelayRequest = (function() {

        /**
         * Properties of a StopRelayRequest.
         * @memberof protos
         * @interface IStopRelayRequest
         * @property {protos.common.IAuth|null} [auth] StopRelayRequest auth
         * @property {string|null} [relayId] StopRelayRequest relayId
         */

        /**
         * Constructs a new StopRelayRequest.
         * @memberof protos
         * @classdesc Represents a StopRelayRequest.
         * @implements IStopRelayRequest
         * @constructor
         * @param {protos.IStopRelayRequest=} [properties] Properties to set
         */
        function StopRelayRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StopRelayRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.StopRelayRequest
         * @instance
         */
        StopRelayRequest.prototype.auth = null;

        /**
         * StopRelayRequest relayId.
         * @member {string} relayId
         * @memberof protos.StopRelayRequest
         * @instance
         */
        StopRelayRequest.prototype.relayId = "";

        /**
         * Creates a new StopRelayRequest instance using the specified properties.
         * @function create
         * @memberof protos.StopRelayRequest
         * @static
         * @param {protos.IStopRelayRequest=} [properties] Properties to set
         * @returns {protos.StopRelayRequest} StopRelayRequest instance
         */
        StopRelayRequest.create = function create(properties) {
            return new StopRelayRequest(properties);
        };

        /**
         * Encodes the specified StopRelayRequest message. Does not implicitly {@link protos.StopRelayRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.StopRelayRequest
         * @static
         * @param {protos.IStopRelayRequest} message StopRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopRelayRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relayId != null && Object.hasOwnProperty.call(message, "relayId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.relayId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StopRelayRequest message, length delimited. Does not implicitly {@link protos.StopRelayRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.StopRelayRequest
         * @static
         * @param {protos.IStopRelayRequest} message StopRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopRelayRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopRelayRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.StopRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.StopRelayRequest} StopRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopRelayRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.StopRelayRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.relayId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopRelayRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.StopRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.StopRelayRequest} StopRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopRelayRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopRelayRequest message.
         * @function verify
         * @memberof protos.StopRelayRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopRelayRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                if (!$util.isString(message.relayId))
                    return "relayId: string expected";
            return null;
        };

        /**
         * Creates a StopRelayRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.StopRelayRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.StopRelayRequest} StopRelayRequest
         */
        StopRelayRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.StopRelayRequest)
                return object;
            var message = new $root.protos.StopRelayRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.StopRelayRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.relayId != null)
                message.relayId = String(object.relayId);
            return message;
        };

        /**
         * Creates a plain object from a StopRelayRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.StopRelayRequest
         * @static
         * @param {protos.StopRelayRequest} message StopRelayRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopRelayRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relayId = "";
                object.auth = null;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                object.relayId = message.relayId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this StopRelayRequest to JSON.
         * @function toJSON
         * @memberof protos.StopRelayRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopRelayRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopRelayRequest;
    })();

    protos.StopRelayResponse = (function() {

        /**
         * Properties of a StopRelayResponse.
         * @memberof protos
         * @interface IStopRelayResponse
         * @property {protos.common.IStatus|null} [status] StopRelayResponse status
         */

        /**
         * Constructs a new StopRelayResponse.
         * @memberof protos
         * @classdesc Represents a StopRelayResponse.
         * @implements IStopRelayResponse
         * @constructor
         * @param {protos.IStopRelayResponse=} [properties] Properties to set
         */
        function StopRelayResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StopRelayResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.StopRelayResponse
         * @instance
         */
        StopRelayResponse.prototype.status = null;

        /**
         * Creates a new StopRelayResponse instance using the specified properties.
         * @function create
         * @memberof protos.StopRelayResponse
         * @static
         * @param {protos.IStopRelayResponse=} [properties] Properties to set
         * @returns {protos.StopRelayResponse} StopRelayResponse instance
         */
        StopRelayResponse.create = function create(properties) {
            return new StopRelayResponse(properties);
        };

        /**
         * Encodes the specified StopRelayResponse message. Does not implicitly {@link protos.StopRelayResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.StopRelayResponse
         * @static
         * @param {protos.IStopRelayResponse} message StopRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopRelayResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StopRelayResponse message, length delimited. Does not implicitly {@link protos.StopRelayResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.StopRelayResponse
         * @static
         * @param {protos.IStopRelayResponse} message StopRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopRelayResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopRelayResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.StopRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.StopRelayResponse} StopRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopRelayResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.StopRelayResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopRelayResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.StopRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.StopRelayResponse} StopRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopRelayResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopRelayResponse message.
         * @function verify
         * @memberof protos.StopRelayResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopRelayResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a StopRelayResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.StopRelayResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.StopRelayResponse} StopRelayResponse
         */
        StopRelayResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.StopRelayResponse)
                return object;
            var message = new $root.protos.StopRelayResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.StopRelayResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a StopRelayResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.StopRelayResponse
         * @static
         * @param {protos.StopRelayResponse} message StopRelayResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopRelayResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this StopRelayResponse to JSON.
         * @function toJSON
         * @memberof protos.StopRelayResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopRelayResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopRelayResponse;
    })();

    protos.DeleteRelayRequest = (function() {

        /**
         * Properties of a DeleteRelayRequest.
         * @memberof protos
         * @interface IDeleteRelayRequest
         * @property {protos.common.IAuth|null} [auth] DeleteRelayRequest auth
         * @property {string|null} [relayId] DeleteRelayRequest relayId
         */

        /**
         * Constructs a new DeleteRelayRequest.
         * @memberof protos
         * @classdesc Represents a DeleteRelayRequest.
         * @implements IDeleteRelayRequest
         * @constructor
         * @param {protos.IDeleteRelayRequest=} [properties] Properties to set
         */
        function DeleteRelayRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteRelayRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.DeleteRelayRequest
         * @instance
         */
        DeleteRelayRequest.prototype.auth = null;

        /**
         * DeleteRelayRequest relayId.
         * @member {string} relayId
         * @memberof protos.DeleteRelayRequest
         * @instance
         */
        DeleteRelayRequest.prototype.relayId = "";

        /**
         * Creates a new DeleteRelayRequest instance using the specified properties.
         * @function create
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {protos.IDeleteRelayRequest=} [properties] Properties to set
         * @returns {protos.DeleteRelayRequest} DeleteRelayRequest instance
         */
        DeleteRelayRequest.create = function create(properties) {
            return new DeleteRelayRequest(properties);
        };

        /**
         * Encodes the specified DeleteRelayRequest message. Does not implicitly {@link protos.DeleteRelayRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {protos.IDeleteRelayRequest} message DeleteRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteRelayRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relayId != null && Object.hasOwnProperty.call(message, "relayId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.relayId);
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteRelayRequest message, length delimited. Does not implicitly {@link protos.DeleteRelayRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {protos.IDeleteRelayRequest} message DeleteRelayRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteRelayRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteRelayRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteRelayRequest} DeleteRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteRelayRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteRelayRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.relayId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteRelayRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteRelayRequest} DeleteRelayRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteRelayRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteRelayRequest message.
         * @function verify
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteRelayRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                if (!$util.isString(message.relayId))
                    return "relayId: string expected";
            return null;
        };

        /**
         * Creates a DeleteRelayRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteRelayRequest} DeleteRelayRequest
         */
        DeleteRelayRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteRelayRequest)
                return object;
            var message = new $root.protos.DeleteRelayRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.DeleteRelayRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            if (object.relayId != null)
                message.relayId = String(object.relayId);
            return message;
        };

        /**
         * Creates a plain object from a DeleteRelayRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteRelayRequest
         * @static
         * @param {protos.DeleteRelayRequest} message DeleteRelayRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteRelayRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relayId = "";
                object.auth = null;
            }
            if (message.relayId != null && message.hasOwnProperty("relayId"))
                object.relayId = message.relayId;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this DeleteRelayRequest to JSON.
         * @function toJSON
         * @memberof protos.DeleteRelayRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteRelayRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteRelayRequest;
    })();

    protos.DeleteRelayResponse = (function() {

        /**
         * Properties of a DeleteRelayResponse.
         * @memberof protos
         * @interface IDeleteRelayResponse
         * @property {protos.common.IStatus|null} [status] DeleteRelayResponse status
         */

        /**
         * Constructs a new DeleteRelayResponse.
         * @memberof protos
         * @classdesc Represents a DeleteRelayResponse.
         * @implements IDeleteRelayResponse
         * @constructor
         * @param {protos.IDeleteRelayResponse=} [properties] Properties to set
         */
        function DeleteRelayResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteRelayResponse status.
         * @member {protos.common.IStatus|null|undefined} status
         * @memberof protos.DeleteRelayResponse
         * @instance
         */
        DeleteRelayResponse.prototype.status = null;

        /**
         * Creates a new DeleteRelayResponse instance using the specified properties.
         * @function create
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {protos.IDeleteRelayResponse=} [properties] Properties to set
         * @returns {protos.DeleteRelayResponse} DeleteRelayResponse instance
         */
        DeleteRelayResponse.create = function create(properties) {
            return new DeleteRelayResponse(properties);
        };

        /**
         * Encodes the specified DeleteRelayResponse message. Does not implicitly {@link protos.DeleteRelayResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {protos.IDeleteRelayResponse} message DeleteRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteRelayResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.protos.common.Status.encode(message.status, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeleteRelayResponse message, length delimited. Does not implicitly {@link protos.DeleteRelayResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {protos.IDeleteRelayResponse} message DeleteRelayResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteRelayResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteRelayResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.DeleteRelayResponse} DeleteRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteRelayResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeleteRelayResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.status = $root.protos.common.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteRelayResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.DeleteRelayResponse} DeleteRelayResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteRelayResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteRelayResponse message.
         * @function verify
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteRelayResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.protos.common.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a DeleteRelayResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.DeleteRelayResponse} DeleteRelayResponse
         */
        DeleteRelayResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.DeleteRelayResponse)
                return object;
            var message = new $root.protos.DeleteRelayResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".protos.DeleteRelayResponse.status: object expected");
                message.status = $root.protos.common.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a DeleteRelayResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.DeleteRelayResponse
         * @static
         * @param {protos.DeleteRelayResponse} message DeleteRelayResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteRelayResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.protos.common.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this DeleteRelayResponse to JSON.
         * @function toJSON
         * @memberof protos.DeleteRelayResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteRelayResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteRelayResponse;
    })();

    protos.GetServerOptionsRequest = (function() {

        /**
         * Properties of a GetServerOptionsRequest.
         * @memberof protos
         * @interface IGetServerOptionsRequest
         * @property {protos.common.IAuth|null} [auth] GetServerOptionsRequest auth
         */

        /**
         * Constructs a new GetServerOptionsRequest.
         * @memberof protos
         * @classdesc Represents a GetServerOptionsRequest.
         * @implements IGetServerOptionsRequest
         * @constructor
         * @param {protos.IGetServerOptionsRequest=} [properties] Properties to set
         */
        function GetServerOptionsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetServerOptionsRequest auth.
         * @member {protos.common.IAuth|null|undefined} auth
         * @memberof protos.GetServerOptionsRequest
         * @instance
         */
        GetServerOptionsRequest.prototype.auth = null;

        /**
         * Creates a new GetServerOptionsRequest instance using the specified properties.
         * @function create
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {protos.IGetServerOptionsRequest=} [properties] Properties to set
         * @returns {protos.GetServerOptionsRequest} GetServerOptionsRequest instance
         */
        GetServerOptionsRequest.create = function create(properties) {
            return new GetServerOptionsRequest(properties);
        };

        /**
         * Encodes the specified GetServerOptionsRequest message. Does not implicitly {@link protos.GetServerOptionsRequest.verify|verify} messages.
         * @function encode
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {protos.IGetServerOptionsRequest} message GetServerOptionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetServerOptionsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                $root.protos.common.Auth.encode(message.auth, writer.uint32(/* id 9999, wireType 2 =*/79994).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetServerOptionsRequest message, length delimited. Does not implicitly {@link protos.GetServerOptionsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {protos.IGetServerOptionsRequest} message GetServerOptionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetServerOptionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetServerOptionsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetServerOptionsRequest} GetServerOptionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetServerOptionsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetServerOptionsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 9999:
                    message.auth = $root.protos.common.Auth.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetServerOptionsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetServerOptionsRequest} GetServerOptionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetServerOptionsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetServerOptionsRequest message.
         * @function verify
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetServerOptionsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.auth != null && message.hasOwnProperty("auth")) {
                var error = $root.protos.common.Auth.verify(message.auth);
                if (error)
                    return "auth." + error;
            }
            return null;
        };

        /**
         * Creates a GetServerOptionsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetServerOptionsRequest} GetServerOptionsRequest
         */
        GetServerOptionsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetServerOptionsRequest)
                return object;
            var message = new $root.protos.GetServerOptionsRequest();
            if (object.auth != null) {
                if (typeof object.auth !== "object")
                    throw TypeError(".protos.GetServerOptionsRequest.auth: object expected");
                message.auth = $root.protos.common.Auth.fromObject(object.auth);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetServerOptionsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetServerOptionsRequest
         * @static
         * @param {protos.GetServerOptionsRequest} message GetServerOptionsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetServerOptionsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.auth = null;
            if (message.auth != null && message.hasOwnProperty("auth"))
                object.auth = $root.protos.common.Auth.toObject(message.auth, options);
            return object;
        };

        /**
         * Converts this GetServerOptionsRequest to JSON.
         * @function toJSON
         * @memberof protos.GetServerOptionsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetServerOptionsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetServerOptionsRequest;
    })();

    protos.GetServerOptionsResponse = (function() {

        /**
         * Properties of a GetServerOptionsResponse.
         * @memberof protos
         * @interface IGetServerOptionsResponse
         * @property {protos.opts.IServerOptions|null} [serverOptions] GetServerOptionsResponse serverOptions
         */

        /**
         * Constructs a new GetServerOptionsResponse.
         * @memberof protos
         * @classdesc Represents a GetServerOptionsResponse.
         * @implements IGetServerOptionsResponse
         * @constructor
         * @param {protos.IGetServerOptionsResponse=} [properties] Properties to set
         */
        function GetServerOptionsResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetServerOptionsResponse serverOptions.
         * @member {protos.opts.IServerOptions|null|undefined} serverOptions
         * @memberof protos.GetServerOptionsResponse
         * @instance
         */
        GetServerOptionsResponse.prototype.serverOptions = null;

        /**
         * Creates a new GetServerOptionsResponse instance using the specified properties.
         * @function create
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {protos.IGetServerOptionsResponse=} [properties] Properties to set
         * @returns {protos.GetServerOptionsResponse} GetServerOptionsResponse instance
         */
        GetServerOptionsResponse.create = function create(properties) {
            return new GetServerOptionsResponse(properties);
        };

        /**
         * Encodes the specified GetServerOptionsResponse message. Does not implicitly {@link protos.GetServerOptionsResponse.verify|verify} messages.
         * @function encode
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {protos.IGetServerOptionsResponse} message GetServerOptionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetServerOptionsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverOptions != null && Object.hasOwnProperty.call(message, "serverOptions"))
                $root.protos.opts.ServerOptions.encode(message.serverOptions, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetServerOptionsResponse message, length delimited. Does not implicitly {@link protos.GetServerOptionsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {protos.IGetServerOptionsResponse} message GetServerOptionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetServerOptionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetServerOptionsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protos.GetServerOptionsResponse} GetServerOptionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetServerOptionsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetServerOptionsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverOptions = $root.protos.opts.ServerOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetServerOptionsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protos.GetServerOptionsResponse} GetServerOptionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetServerOptionsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetServerOptionsResponse message.
         * @function verify
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetServerOptionsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverOptions != null && message.hasOwnProperty("serverOptions")) {
                var error = $root.protos.opts.ServerOptions.verify(message.serverOptions);
                if (error)
                    return "serverOptions." + error;
            }
            return null;
        };

        /**
         * Creates a GetServerOptionsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protos.GetServerOptionsResponse} GetServerOptionsResponse
         */
        GetServerOptionsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.protos.GetServerOptionsResponse)
                return object;
            var message = new $root.protos.GetServerOptionsResponse();
            if (object.serverOptions != null) {
                if (typeof object.serverOptions !== "object")
                    throw TypeError(".protos.GetServerOptionsResponse.serverOptions: object expected");
                message.serverOptions = $root.protos.opts.ServerOptions.fromObject(object.serverOptions);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetServerOptionsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protos.GetServerOptionsResponse
         * @static
         * @param {protos.GetServerOptionsResponse} message GetServerOptionsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetServerOptionsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.serverOptions = null;
            if (message.serverOptions != null && message.hasOwnProperty("serverOptions"))
                object.serverOptions = $root.protos.opts.ServerOptions.toObject(message.serverOptions, options);
            return object;
        };

        /**
         * Converts this GetServerOptionsResponse to JSON.
         * @function toJSON
         * @memberof protos.GetServerOptionsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetServerOptionsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetServerOptionsResponse;
    })();

    protos.encoding = (function() {

        /**
         * Namespace encoding.
         * @memberof protos
         * @namespace
         */
        var encoding = {};

        /**
         * EncodeType enum.
         * @name protos.encoding.EncodeType
         * @enum {number}
         * @property {number} ENCODE_TYPE_UNSET=0 ENCODE_TYPE_UNSET value
         * @property {number} ENCODE_TYPE_JSONPB=1 ENCODE_TYPE_JSONPB value
         * @property {number} ENCODE_TYPE_AVRO=2 ENCODE_TYPE_AVRO value
         */
        encoding.EncodeType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ENCODE_TYPE_UNSET"] = 0;
            values[valuesById[1] = "ENCODE_TYPE_JSONPB"] = 1;
            values[valuesById[2] = "ENCODE_TYPE_AVRO"] = 2;
            return values;
        })();

        /**
         * DecodeType enum.
         * @name protos.encoding.DecodeType
         * @enum {number}
         * @property {number} DECODE_TYPE_UNSET=0 DECODE_TYPE_UNSET value
         * @property {number} DECODE_TYPE_PROTOBUF=1 DECODE_TYPE_PROTOBUF value
         * @property {number} DECODE_TYPE_AVRO=2 DECODE_TYPE_AVRO value
         * @property {number} DECODE_TYPE_THRIFT=3 DECODE_TYPE_THRIFT value
         * @property {number} DECODE_TYPE_FLATBUFFER=4 DECODE_TYPE_FLATBUFFER value
         */
        encoding.DecodeType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DECODE_TYPE_UNSET"] = 0;
            values[valuesById[1] = "DECODE_TYPE_PROTOBUF"] = 1;
            values[valuesById[2] = "DECODE_TYPE_AVRO"] = 2;
            values[valuesById[3] = "DECODE_TYPE_THRIFT"] = 3;
            values[valuesById[4] = "DECODE_TYPE_FLATBUFFER"] = 4;
            return values;
        })();

        /**
         * EnvelopeType enum.
         * @name protos.encoding.EnvelopeType
         * @enum {number}
         * @property {number} ENVELOPE_TYPE_UNSET=0 ENVELOPE_TYPE_UNSET value
         * @property {number} ENVELOPE_TYPE_DEEP=1 ENVELOPE_TYPE_DEEP value
         * @property {number} ENVELOPE_TYPE_SHALLOW=2 ENVELOPE_TYPE_SHALLOW value
         */
        encoding.EnvelopeType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ENVELOPE_TYPE_UNSET"] = 0;
            values[valuesById[1] = "ENVELOPE_TYPE_DEEP"] = 1;
            values[valuesById[2] = "ENVELOPE_TYPE_SHALLOW"] = 2;
            return values;
        })();

        encoding.ProtobufSettings = (function() {

            /**
             * Properties of a ProtobufSettings.
             * @memberof protos.encoding
             * @interface IProtobufSettings
             * @property {string|null} [protobufRootMessage] ProtobufSettings protobufRootMessage
             * @property {Array.<string>|null} [protobufDirs] ProtobufSettings protobufDirs
             * @property {string|null} [_protobufRootDir] ProtobufSettings _protobufRootDir
             * @property {Uint8Array|null} [archive] ProtobufSettings archive
             * @property {Uint8Array|null} [_messageDescriptor] ProtobufSettings _messageDescriptor
             * @property {protos.encoding.EnvelopeType|null} [protobufEnvelopeType] ProtobufSettings protobufEnvelopeType
             * @property {string|null} [shallowEnvelopeMessage] ProtobufSettings shallowEnvelopeMessage
             * @property {number|null} [shallowEnvelopeFieldNumber] ProtobufSettings shallowEnvelopeFieldNumber
             * @property {Uint8Array|null} [_shallowEnvelopeMessageDescriptor] ProtobufSettings _shallowEnvelopeMessageDescriptor
             */

            /**
             * Constructs a new ProtobufSettings.
             * @memberof protos.encoding
             * @classdesc Represents a ProtobufSettings.
             * @implements IProtobufSettings
             * @constructor
             * @param {protos.encoding.IProtobufSettings=} [properties] Properties to set
             */
            function ProtobufSettings(properties) {
                this.protobufDirs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProtobufSettings protobufRootMessage.
             * @member {string} protobufRootMessage
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype.protobufRootMessage = "";

            /**
             * ProtobufSettings protobufDirs.
             * @member {Array.<string>} protobufDirs
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype.protobufDirs = $util.emptyArray;

            /**
             * ProtobufSettings _protobufRootDir.
             * @member {string} _protobufRootDir
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype._protobufRootDir = "";

            /**
             * ProtobufSettings archive.
             * @member {Uint8Array} archive
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype.archive = $util.newBuffer([]);

            /**
             * ProtobufSettings _messageDescriptor.
             * @member {Uint8Array} _messageDescriptor
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype._messageDescriptor = $util.newBuffer([]);

            /**
             * ProtobufSettings protobufEnvelopeType.
             * @member {protos.encoding.EnvelopeType} protobufEnvelopeType
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype.protobufEnvelopeType = 0;

            /**
             * ProtobufSettings shallowEnvelopeMessage.
             * @member {string} shallowEnvelopeMessage
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype.shallowEnvelopeMessage = "";

            /**
             * ProtobufSettings shallowEnvelopeFieldNumber.
             * @member {number} shallowEnvelopeFieldNumber
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype.shallowEnvelopeFieldNumber = 0;

            /**
             * ProtobufSettings _shallowEnvelopeMessageDescriptor.
             * @member {Uint8Array} _shallowEnvelopeMessageDescriptor
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             */
            ProtobufSettings.prototype._shallowEnvelopeMessageDescriptor = $util.newBuffer([]);

            /**
             * Creates a new ProtobufSettings instance using the specified properties.
             * @function create
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {protos.encoding.IProtobufSettings=} [properties] Properties to set
             * @returns {protos.encoding.ProtobufSettings} ProtobufSettings instance
             */
            ProtobufSettings.create = function create(properties) {
                return new ProtobufSettings(properties);
            };

            /**
             * Encodes the specified ProtobufSettings message. Does not implicitly {@link protos.encoding.ProtobufSettings.verify|verify} messages.
             * @function encode
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {protos.encoding.IProtobufSettings} message ProtobufSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtobufSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.protobufRootMessage != null && Object.hasOwnProperty.call(message, "protobufRootMessage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.protobufRootMessage);
                if (message.protobufDirs != null && message.protobufDirs.length)
                    for (var i = 0; i < message.protobufDirs.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.protobufDirs[i]);
                if (message._protobufRootDir != null && Object.hasOwnProperty.call(message, "_protobufRootDir"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message._protobufRootDir);
                if (message.archive != null && Object.hasOwnProperty.call(message, "archive"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.archive);
                if (message._messageDescriptor != null && Object.hasOwnProperty.call(message, "_messageDescriptor"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message._messageDescriptor);
                if (message.protobufEnvelopeType != null && Object.hasOwnProperty.call(message, "protobufEnvelopeType"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.protobufEnvelopeType);
                if (message.shallowEnvelopeMessage != null && Object.hasOwnProperty.call(message, "shallowEnvelopeMessage"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.shallowEnvelopeMessage);
                if (message.shallowEnvelopeFieldNumber != null && Object.hasOwnProperty.call(message, "shallowEnvelopeFieldNumber"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.shallowEnvelopeFieldNumber);
                if (message._shallowEnvelopeMessageDescriptor != null && Object.hasOwnProperty.call(message, "_shallowEnvelopeMessageDescriptor"))
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message._shallowEnvelopeMessageDescriptor);
                return writer;
            };

            /**
             * Encodes the specified ProtobufSettings message, length delimited. Does not implicitly {@link protos.encoding.ProtobufSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {protos.encoding.IProtobufSettings} message ProtobufSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProtobufSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProtobufSettings message from the specified reader or buffer.
             * @function decode
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.encoding.ProtobufSettings} ProtobufSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtobufSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.encoding.ProtobufSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.protobufRootMessage = reader.string();
                        break;
                    case 2:
                        if (!(message.protobufDirs && message.protobufDirs.length))
                            message.protobufDirs = [];
                        message.protobufDirs.push(reader.string());
                        break;
                    case 3:
                        message._protobufRootDir = reader.string();
                        break;
                    case 4:
                        message.archive = reader.bytes();
                        break;
                    case 5:
                        message._messageDescriptor = reader.bytes();
                        break;
                    case 6:
                        message.protobufEnvelopeType = reader.int32();
                        break;
                    case 7:
                        message.shallowEnvelopeMessage = reader.string();
                        break;
                    case 8:
                        message.shallowEnvelopeFieldNumber = reader.int32();
                        break;
                    case 9:
                        message._shallowEnvelopeMessageDescriptor = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProtobufSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.encoding.ProtobufSettings} ProtobufSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProtobufSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProtobufSettings message.
             * @function verify
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProtobufSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.protobufRootMessage != null && message.hasOwnProperty("protobufRootMessage"))
                    if (!$util.isString(message.protobufRootMessage))
                        return "protobufRootMessage: string expected";
                if (message.protobufDirs != null && message.hasOwnProperty("protobufDirs")) {
                    if (!Array.isArray(message.protobufDirs))
                        return "protobufDirs: array expected";
                    for (var i = 0; i < message.protobufDirs.length; ++i)
                        if (!$util.isString(message.protobufDirs[i]))
                            return "protobufDirs: string[] expected";
                }
                if (message._protobufRootDir != null && message.hasOwnProperty("_protobufRootDir"))
                    if (!$util.isString(message._protobufRootDir))
                        return "_protobufRootDir: string expected";
                if (message.archive != null && message.hasOwnProperty("archive"))
                    if (!(message.archive && typeof message.archive.length === "number" || $util.isString(message.archive)))
                        return "archive: buffer expected";
                if (message._messageDescriptor != null && message.hasOwnProperty("_messageDescriptor"))
                    if (!(message._messageDescriptor && typeof message._messageDescriptor.length === "number" || $util.isString(message._messageDescriptor)))
                        return "_messageDescriptor: buffer expected";
                if (message.protobufEnvelopeType != null && message.hasOwnProperty("protobufEnvelopeType"))
                    switch (message.protobufEnvelopeType) {
                    default:
                        return "protobufEnvelopeType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.shallowEnvelopeMessage != null && message.hasOwnProperty("shallowEnvelopeMessage"))
                    if (!$util.isString(message.shallowEnvelopeMessage))
                        return "shallowEnvelopeMessage: string expected";
                if (message.shallowEnvelopeFieldNumber != null && message.hasOwnProperty("shallowEnvelopeFieldNumber"))
                    if (!$util.isInteger(message.shallowEnvelopeFieldNumber))
                        return "shallowEnvelopeFieldNumber: integer expected";
                if (message._shallowEnvelopeMessageDescriptor != null && message.hasOwnProperty("_shallowEnvelopeMessageDescriptor"))
                    if (!(message._shallowEnvelopeMessageDescriptor && typeof message._shallowEnvelopeMessageDescriptor.length === "number" || $util.isString(message._shallowEnvelopeMessageDescriptor)))
                        return "_shallowEnvelopeMessageDescriptor: buffer expected";
                return null;
            };

            /**
             * Creates a ProtobufSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.encoding.ProtobufSettings} ProtobufSettings
             */
            ProtobufSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.encoding.ProtobufSettings)
                    return object;
                var message = new $root.protos.encoding.ProtobufSettings();
                if (object.protobufRootMessage != null)
                    message.protobufRootMessage = String(object.protobufRootMessage);
                if (object.protobufDirs) {
                    if (!Array.isArray(object.protobufDirs))
                        throw TypeError(".protos.encoding.ProtobufSettings.protobufDirs: array expected");
                    message.protobufDirs = [];
                    for (var i = 0; i < object.protobufDirs.length; ++i)
                        message.protobufDirs[i] = String(object.protobufDirs[i]);
                }
                if (object._protobufRootDir != null)
                    message._protobufRootDir = String(object._protobufRootDir);
                if (object.archive != null)
                    if (typeof object.archive === "string")
                        $util.base64.decode(object.archive, message.archive = $util.newBuffer($util.base64.length(object.archive)), 0);
                    else if (object.archive.length)
                        message.archive = object.archive;
                if (object._messageDescriptor != null)
                    if (typeof object._messageDescriptor === "string")
                        $util.base64.decode(object._messageDescriptor, message._messageDescriptor = $util.newBuffer($util.base64.length(object._messageDescriptor)), 0);
                    else if (object._messageDescriptor.length)
                        message._messageDescriptor = object._messageDescriptor;
                switch (object.protobufEnvelopeType) {
                case "ENVELOPE_TYPE_UNSET":
                case 0:
                    message.protobufEnvelopeType = 0;
                    break;
                case "ENVELOPE_TYPE_DEEP":
                case 1:
                    message.protobufEnvelopeType = 1;
                    break;
                case "ENVELOPE_TYPE_SHALLOW":
                case 2:
                    message.protobufEnvelopeType = 2;
                    break;
                }
                if (object.shallowEnvelopeMessage != null)
                    message.shallowEnvelopeMessage = String(object.shallowEnvelopeMessage);
                if (object.shallowEnvelopeFieldNumber != null)
                    message.shallowEnvelopeFieldNumber = object.shallowEnvelopeFieldNumber | 0;
                if (object._shallowEnvelopeMessageDescriptor != null)
                    if (typeof object._shallowEnvelopeMessageDescriptor === "string")
                        $util.base64.decode(object._shallowEnvelopeMessageDescriptor, message._shallowEnvelopeMessageDescriptor = $util.newBuffer($util.base64.length(object._shallowEnvelopeMessageDescriptor)), 0);
                    else if (object._shallowEnvelopeMessageDescriptor.length)
                        message._shallowEnvelopeMessageDescriptor = object._shallowEnvelopeMessageDescriptor;
                return message;
            };

            /**
             * Creates a plain object from a ProtobufSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.encoding.ProtobufSettings
             * @static
             * @param {protos.encoding.ProtobufSettings} message ProtobufSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProtobufSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.protobufDirs = [];
                if (options.defaults) {
                    object.protobufRootMessage = "";
                    object._protobufRootDir = "";
                    if (options.bytes === String)
                        object.archive = "";
                    else {
                        object.archive = [];
                        if (options.bytes !== Array)
                            object.archive = $util.newBuffer(object.archive);
                    }
                    if (options.bytes === String)
                        object._messageDescriptor = "";
                    else {
                        object._messageDescriptor = [];
                        if (options.bytes !== Array)
                            object._messageDescriptor = $util.newBuffer(object._messageDescriptor);
                    }
                    object.protobufEnvelopeType = options.enums === String ? "ENVELOPE_TYPE_UNSET" : 0;
                    object.shallowEnvelopeMessage = "";
                    object.shallowEnvelopeFieldNumber = 0;
                    if (options.bytes === String)
                        object._shallowEnvelopeMessageDescriptor = "";
                    else {
                        object._shallowEnvelopeMessageDescriptor = [];
                        if (options.bytes !== Array)
                            object._shallowEnvelopeMessageDescriptor = $util.newBuffer(object._shallowEnvelopeMessageDescriptor);
                    }
                }
                if (message.protobufRootMessage != null && message.hasOwnProperty("protobufRootMessage"))
                    object.protobufRootMessage = message.protobufRootMessage;
                if (message.protobufDirs && message.protobufDirs.length) {
                    object.protobufDirs = [];
                    for (var j = 0; j < message.protobufDirs.length; ++j)
                        object.protobufDirs[j] = message.protobufDirs[j];
                }
                if (message._protobufRootDir != null && message.hasOwnProperty("_protobufRootDir"))
                    object._protobufRootDir = message._protobufRootDir;
                if (message.archive != null && message.hasOwnProperty("archive"))
                    object.archive = options.bytes === String ? $util.base64.encode(message.archive, 0, message.archive.length) : options.bytes === Array ? Array.prototype.slice.call(message.archive) : message.archive;
                if (message._messageDescriptor != null && message.hasOwnProperty("_messageDescriptor"))
                    object._messageDescriptor = options.bytes === String ? $util.base64.encode(message._messageDescriptor, 0, message._messageDescriptor.length) : options.bytes === Array ? Array.prototype.slice.call(message._messageDescriptor) : message._messageDescriptor;
                if (message.protobufEnvelopeType != null && message.hasOwnProperty("protobufEnvelopeType"))
                    object.protobufEnvelopeType = options.enums === String ? $root.protos.encoding.EnvelopeType[message.protobufEnvelopeType] : message.protobufEnvelopeType;
                if (message.shallowEnvelopeMessage != null && message.hasOwnProperty("shallowEnvelopeMessage"))
                    object.shallowEnvelopeMessage = message.shallowEnvelopeMessage;
                if (message.shallowEnvelopeFieldNumber != null && message.hasOwnProperty("shallowEnvelopeFieldNumber"))
                    object.shallowEnvelopeFieldNumber = message.shallowEnvelopeFieldNumber;
                if (message._shallowEnvelopeMessageDescriptor != null && message.hasOwnProperty("_shallowEnvelopeMessageDescriptor"))
                    object._shallowEnvelopeMessageDescriptor = options.bytes === String ? $util.base64.encode(message._shallowEnvelopeMessageDescriptor, 0, message._shallowEnvelopeMessageDescriptor.length) : options.bytes === Array ? Array.prototype.slice.call(message._shallowEnvelopeMessageDescriptor) : message._shallowEnvelopeMessageDescriptor;
                return object;
            };

            /**
             * Converts this ProtobufSettings to JSON.
             * @function toJSON
             * @memberof protos.encoding.ProtobufSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProtobufSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ProtobufSettings;
        })();

        encoding.AvroSettings = (function() {

            /**
             * Properties of an AvroSettings.
             * @memberof protos.encoding
             * @interface IAvroSettings
             * @property {string|null} [avroSchemaFile] AvroSettings avroSchemaFile
             * @property {Uint8Array|null} [schema] AvroSettings schema
             */

            /**
             * Constructs a new AvroSettings.
             * @memberof protos.encoding
             * @classdesc Represents an AvroSettings.
             * @implements IAvroSettings
             * @constructor
             * @param {protos.encoding.IAvroSettings=} [properties] Properties to set
             */
            function AvroSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AvroSettings avroSchemaFile.
             * @member {string} avroSchemaFile
             * @memberof protos.encoding.AvroSettings
             * @instance
             */
            AvroSettings.prototype.avroSchemaFile = "";

            /**
             * AvroSettings schema.
             * @member {Uint8Array} schema
             * @memberof protos.encoding.AvroSettings
             * @instance
             */
            AvroSettings.prototype.schema = $util.newBuffer([]);

            /**
             * Creates a new AvroSettings instance using the specified properties.
             * @function create
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {protos.encoding.IAvroSettings=} [properties] Properties to set
             * @returns {protos.encoding.AvroSettings} AvroSettings instance
             */
            AvroSettings.create = function create(properties) {
                return new AvroSettings(properties);
            };

            /**
             * Encodes the specified AvroSettings message. Does not implicitly {@link protos.encoding.AvroSettings.verify|verify} messages.
             * @function encode
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {protos.encoding.IAvroSettings} message AvroSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AvroSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.avroSchemaFile != null && Object.hasOwnProperty.call(message, "avroSchemaFile"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.avroSchemaFile);
                if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.schema);
                return writer;
            };

            /**
             * Encodes the specified AvroSettings message, length delimited. Does not implicitly {@link protos.encoding.AvroSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {protos.encoding.IAvroSettings} message AvroSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AvroSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AvroSettings message from the specified reader or buffer.
             * @function decode
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.encoding.AvroSettings} AvroSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AvroSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.encoding.AvroSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.avroSchemaFile = reader.string();
                        break;
                    case 2:
                        message.schema = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AvroSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.encoding.AvroSettings} AvroSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AvroSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AvroSettings message.
             * @function verify
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AvroSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.avroSchemaFile != null && message.hasOwnProperty("avroSchemaFile"))
                    if (!$util.isString(message.avroSchemaFile))
                        return "avroSchemaFile: string expected";
                if (message.schema != null && message.hasOwnProperty("schema"))
                    if (!(message.schema && typeof message.schema.length === "number" || $util.isString(message.schema)))
                        return "schema: buffer expected";
                return null;
            };

            /**
             * Creates an AvroSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.encoding.AvroSettings} AvroSettings
             */
            AvroSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.encoding.AvroSettings)
                    return object;
                var message = new $root.protos.encoding.AvroSettings();
                if (object.avroSchemaFile != null)
                    message.avroSchemaFile = String(object.avroSchemaFile);
                if (object.schema != null)
                    if (typeof object.schema === "string")
                        $util.base64.decode(object.schema, message.schema = $util.newBuffer($util.base64.length(object.schema)), 0);
                    else if (object.schema.length)
                        message.schema = object.schema;
                return message;
            };

            /**
             * Creates a plain object from an AvroSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.encoding.AvroSettings
             * @static
             * @param {protos.encoding.AvroSettings} message AvroSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AvroSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.avroSchemaFile = "";
                    if (options.bytes === String)
                        object.schema = "";
                    else {
                        object.schema = [];
                        if (options.bytes !== Array)
                            object.schema = $util.newBuffer(object.schema);
                    }
                }
                if (message.avroSchemaFile != null && message.hasOwnProperty("avroSchemaFile"))
                    object.avroSchemaFile = message.avroSchemaFile;
                if (message.schema != null && message.hasOwnProperty("schema"))
                    object.schema = options.bytes === String ? $util.base64.encode(message.schema, 0, message.schema.length) : options.bytes === Array ? Array.prototype.slice.call(message.schema) : message.schema;
                return object;
            };

            /**
             * Converts this AvroSettings to JSON.
             * @function toJSON
             * @memberof protos.encoding.AvroSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AvroSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AvroSettings;
        })();

        encoding.JSONSchemaSettings = (function() {

            /**
             * Properties of a JSONSchemaSettings.
             * @memberof protos.encoding
             * @interface IJSONSchemaSettings
             * @property {Uint8Array|null} [schema] JSONSchemaSettings schema
             */

            /**
             * Constructs a new JSONSchemaSettings.
             * @memberof protos.encoding
             * @classdesc Represents a JSONSchemaSettings.
             * @implements IJSONSchemaSettings
             * @constructor
             * @param {protos.encoding.IJSONSchemaSettings=} [properties] Properties to set
             */
            function JSONSchemaSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JSONSchemaSettings schema.
             * @member {Uint8Array} schema
             * @memberof protos.encoding.JSONSchemaSettings
             * @instance
             */
            JSONSchemaSettings.prototype.schema = $util.newBuffer([]);

            /**
             * Creates a new JSONSchemaSettings instance using the specified properties.
             * @function create
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {protos.encoding.IJSONSchemaSettings=} [properties] Properties to set
             * @returns {protos.encoding.JSONSchemaSettings} JSONSchemaSettings instance
             */
            JSONSchemaSettings.create = function create(properties) {
                return new JSONSchemaSettings(properties);
            };

            /**
             * Encodes the specified JSONSchemaSettings message. Does not implicitly {@link protos.encoding.JSONSchemaSettings.verify|verify} messages.
             * @function encode
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {protos.encoding.IJSONSchemaSettings} message JSONSchemaSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JSONSchemaSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.schema);
                return writer;
            };

            /**
             * Encodes the specified JSONSchemaSettings message, length delimited. Does not implicitly {@link protos.encoding.JSONSchemaSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {protos.encoding.IJSONSchemaSettings} message JSONSchemaSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JSONSchemaSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JSONSchemaSettings message from the specified reader or buffer.
             * @function decode
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.encoding.JSONSchemaSettings} JSONSchemaSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JSONSchemaSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.encoding.JSONSchemaSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.schema = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JSONSchemaSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.encoding.JSONSchemaSettings} JSONSchemaSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JSONSchemaSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JSONSchemaSettings message.
             * @function verify
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JSONSchemaSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.schema != null && message.hasOwnProperty("schema"))
                    if (!(message.schema && typeof message.schema.length === "number" || $util.isString(message.schema)))
                        return "schema: buffer expected";
                return null;
            };

            /**
             * Creates a JSONSchemaSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.encoding.JSONSchemaSettings} JSONSchemaSettings
             */
            JSONSchemaSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.encoding.JSONSchemaSettings)
                    return object;
                var message = new $root.protos.encoding.JSONSchemaSettings();
                if (object.schema != null)
                    if (typeof object.schema === "string")
                        $util.base64.decode(object.schema, message.schema = $util.newBuffer($util.base64.length(object.schema)), 0);
                    else if (object.schema.length)
                        message.schema = object.schema;
                return message;
            };

            /**
             * Creates a plain object from a JSONSchemaSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.encoding.JSONSchemaSettings
             * @static
             * @param {protos.encoding.JSONSchemaSettings} message JSONSchemaSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            JSONSchemaSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.schema = "";
                    else {
                        object.schema = [];
                        if (options.bytes !== Array)
                            object.schema = $util.newBuffer(object.schema);
                    }
                if (message.schema != null && message.hasOwnProperty("schema"))
                    object.schema = options.bytes === String ? $util.base64.encode(message.schema, 0, message.schema.length) : options.bytes === Array ? Array.prototype.slice.call(message.schema) : message.schema;
                return object;
            };

            /**
             * Converts this JSONSchemaSettings to JSON.
             * @function toJSON
             * @memberof protos.encoding.JSONSchemaSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            JSONSchemaSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return JSONSchemaSettings;
        })();

        encoding.EncodeOptions = (function() {

            /**
             * Properties of an EncodeOptions.
             * @memberof protos.encoding
             * @interface IEncodeOptions
             * @property {string|null} [schemaId] EncodeOptions schemaId
             * @property {protos.encoding.EncodeType|null} [encodeType] EncodeOptions encodeType
             * @property {protos.encoding.IProtobufSettings|null} [protobufSettings] EncodeOptions protobufSettings
             * @property {protos.encoding.IAvroSettings|null} [avroSettings] EncodeOptions avroSettings
             */

            /**
             * Constructs a new EncodeOptions.
             * @memberof protos.encoding
             * @classdesc Represents an EncodeOptions.
             * @implements IEncodeOptions
             * @constructor
             * @param {protos.encoding.IEncodeOptions=} [properties] Properties to set
             */
            function EncodeOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EncodeOptions schemaId.
             * @member {string} schemaId
             * @memberof protos.encoding.EncodeOptions
             * @instance
             */
            EncodeOptions.prototype.schemaId = "";

            /**
             * EncodeOptions encodeType.
             * @member {protos.encoding.EncodeType} encodeType
             * @memberof protos.encoding.EncodeOptions
             * @instance
             */
            EncodeOptions.prototype.encodeType = 0;

            /**
             * EncodeOptions protobufSettings.
             * @member {protos.encoding.IProtobufSettings|null|undefined} protobufSettings
             * @memberof protos.encoding.EncodeOptions
             * @instance
             */
            EncodeOptions.prototype.protobufSettings = null;

            /**
             * EncodeOptions avroSettings.
             * @member {protos.encoding.IAvroSettings|null|undefined} avroSettings
             * @memberof protos.encoding.EncodeOptions
             * @instance
             */
            EncodeOptions.prototype.avroSettings = null;

            /**
             * Creates a new EncodeOptions instance using the specified properties.
             * @function create
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {protos.encoding.IEncodeOptions=} [properties] Properties to set
             * @returns {protos.encoding.EncodeOptions} EncodeOptions instance
             */
            EncodeOptions.create = function create(properties) {
                return new EncodeOptions(properties);
            };

            /**
             * Encodes the specified EncodeOptions message. Does not implicitly {@link protos.encoding.EncodeOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {protos.encoding.IEncodeOptions} message EncodeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EncodeOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.schemaId != null && Object.hasOwnProperty.call(message, "schemaId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.schemaId);
                if (message.encodeType != null && Object.hasOwnProperty.call(message, "encodeType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.encodeType);
                if (message.protobufSettings != null && Object.hasOwnProperty.call(message, "protobufSettings"))
                    $root.protos.encoding.ProtobufSettings.encode(message.protobufSettings, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.avroSettings != null && Object.hasOwnProperty.call(message, "avroSettings"))
                    $root.protos.encoding.AvroSettings.encode(message.avroSettings, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EncodeOptions message, length delimited. Does not implicitly {@link protos.encoding.EncodeOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {protos.encoding.IEncodeOptions} message EncodeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EncodeOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EncodeOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.encoding.EncodeOptions} EncodeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EncodeOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.encoding.EncodeOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.schemaId = reader.string();
                        break;
                    case 2:
                        message.encodeType = reader.int32();
                        break;
                    case 3:
                        message.protobufSettings = $root.protos.encoding.ProtobufSettings.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.avroSettings = $root.protos.encoding.AvroSettings.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EncodeOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.encoding.EncodeOptions} EncodeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EncodeOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EncodeOptions message.
             * @function verify
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EncodeOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    if (!$util.isString(message.schemaId))
                        return "schemaId: string expected";
                if (message.encodeType != null && message.hasOwnProperty("encodeType"))
                    switch (message.encodeType) {
                    default:
                        return "encodeType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings")) {
                    var error = $root.protos.encoding.ProtobufSettings.verify(message.protobufSettings);
                    if (error)
                        return "protobufSettings." + error;
                }
                if (message.avroSettings != null && message.hasOwnProperty("avroSettings")) {
                    var error = $root.protos.encoding.AvroSettings.verify(message.avroSettings);
                    if (error)
                        return "avroSettings." + error;
                }
                return null;
            };

            /**
             * Creates an EncodeOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.encoding.EncodeOptions} EncodeOptions
             */
            EncodeOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.encoding.EncodeOptions)
                    return object;
                var message = new $root.protos.encoding.EncodeOptions();
                if (object.schemaId != null)
                    message.schemaId = String(object.schemaId);
                switch (object.encodeType) {
                case "ENCODE_TYPE_UNSET":
                case 0:
                    message.encodeType = 0;
                    break;
                case "ENCODE_TYPE_JSONPB":
                case 1:
                    message.encodeType = 1;
                    break;
                case "ENCODE_TYPE_AVRO":
                case 2:
                    message.encodeType = 2;
                    break;
                }
                if (object.protobufSettings != null) {
                    if (typeof object.protobufSettings !== "object")
                        throw TypeError(".protos.encoding.EncodeOptions.protobufSettings: object expected");
                    message.protobufSettings = $root.protos.encoding.ProtobufSettings.fromObject(object.protobufSettings);
                }
                if (object.avroSettings != null) {
                    if (typeof object.avroSettings !== "object")
                        throw TypeError(".protos.encoding.EncodeOptions.avroSettings: object expected");
                    message.avroSettings = $root.protos.encoding.AvroSettings.fromObject(object.avroSettings);
                }
                return message;
            };

            /**
             * Creates a plain object from an EncodeOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.encoding.EncodeOptions
             * @static
             * @param {protos.encoding.EncodeOptions} message EncodeOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EncodeOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.schemaId = "";
                    object.encodeType = options.enums === String ? "ENCODE_TYPE_UNSET" : 0;
                    object.protobufSettings = null;
                    object.avroSettings = null;
                }
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    object.schemaId = message.schemaId;
                if (message.encodeType != null && message.hasOwnProperty("encodeType"))
                    object.encodeType = options.enums === String ? $root.protos.encoding.EncodeType[message.encodeType] : message.encodeType;
                if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings"))
                    object.protobufSettings = $root.protos.encoding.ProtobufSettings.toObject(message.protobufSettings, options);
                if (message.avroSettings != null && message.hasOwnProperty("avroSettings"))
                    object.avroSettings = $root.protos.encoding.AvroSettings.toObject(message.avroSettings, options);
                return object;
            };

            /**
             * Converts this EncodeOptions to JSON.
             * @function toJSON
             * @memberof protos.encoding.EncodeOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EncodeOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EncodeOptions;
        })();

        encoding.DecodeOptions = (function() {

            /**
             * Properties of a DecodeOptions.
             * @memberof protos.encoding
             * @interface IDecodeOptions
             * @property {string|null} [schemaId] DecodeOptions schemaId
             * @property {protos.encoding.DecodeType|null} [decodeType] DecodeOptions decodeType
             * @property {protos.encoding.IProtobufSettings|null} [protobufSettings] DecodeOptions protobufSettings
             * @property {protos.encoding.IAvroSettings|null} [avroSettings] DecodeOptions avroSettings
             */

            /**
             * Constructs a new DecodeOptions.
             * @memberof protos.encoding
             * @classdesc Represents a DecodeOptions.
             * @implements IDecodeOptions
             * @constructor
             * @param {protos.encoding.IDecodeOptions=} [properties] Properties to set
             */
            function DecodeOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DecodeOptions schemaId.
             * @member {string} schemaId
             * @memberof protos.encoding.DecodeOptions
             * @instance
             */
            DecodeOptions.prototype.schemaId = "";

            /**
             * DecodeOptions decodeType.
             * @member {protos.encoding.DecodeType} decodeType
             * @memberof protos.encoding.DecodeOptions
             * @instance
             */
            DecodeOptions.prototype.decodeType = 0;

            /**
             * DecodeOptions protobufSettings.
             * @member {protos.encoding.IProtobufSettings|null|undefined} protobufSettings
             * @memberof protos.encoding.DecodeOptions
             * @instance
             */
            DecodeOptions.prototype.protobufSettings = null;

            /**
             * DecodeOptions avroSettings.
             * @member {protos.encoding.IAvroSettings|null|undefined} avroSettings
             * @memberof protos.encoding.DecodeOptions
             * @instance
             */
            DecodeOptions.prototype.avroSettings = null;

            /**
             * Creates a new DecodeOptions instance using the specified properties.
             * @function create
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {protos.encoding.IDecodeOptions=} [properties] Properties to set
             * @returns {protos.encoding.DecodeOptions} DecodeOptions instance
             */
            DecodeOptions.create = function create(properties) {
                return new DecodeOptions(properties);
            };

            /**
             * Encodes the specified DecodeOptions message. Does not implicitly {@link protos.encoding.DecodeOptions.verify|verify} messages.
             * @function encode
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {protos.encoding.IDecodeOptions} message DecodeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DecodeOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.schemaId != null && Object.hasOwnProperty.call(message, "schemaId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.schemaId);
                if (message.decodeType != null && Object.hasOwnProperty.call(message, "decodeType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.decodeType);
                if (message.protobufSettings != null && Object.hasOwnProperty.call(message, "protobufSettings"))
                    $root.protos.encoding.ProtobufSettings.encode(message.protobufSettings, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.avroSettings != null && Object.hasOwnProperty.call(message, "avroSettings"))
                    $root.protos.encoding.AvroSettings.encode(message.avroSettings, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DecodeOptions message, length delimited. Does not implicitly {@link protos.encoding.DecodeOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {protos.encoding.IDecodeOptions} message DecodeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DecodeOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DecodeOptions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.encoding.DecodeOptions} DecodeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DecodeOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.encoding.DecodeOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.schemaId = reader.string();
                        break;
                    case 2:
                        message.decodeType = reader.int32();
                        break;
                    case 3:
                        message.protobufSettings = $root.protos.encoding.ProtobufSettings.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.avroSettings = $root.protos.encoding.AvroSettings.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DecodeOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.encoding.DecodeOptions} DecodeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DecodeOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DecodeOptions message.
             * @function verify
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DecodeOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    if (!$util.isString(message.schemaId))
                        return "schemaId: string expected";
                if (message.decodeType != null && message.hasOwnProperty("decodeType"))
                    switch (message.decodeType) {
                    default:
                        return "decodeType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings")) {
                    var error = $root.protos.encoding.ProtobufSettings.verify(message.protobufSettings);
                    if (error)
                        return "protobufSettings." + error;
                }
                if (message.avroSettings != null && message.hasOwnProperty("avroSettings")) {
                    var error = $root.protos.encoding.AvroSettings.verify(message.avroSettings);
                    if (error)
                        return "avroSettings." + error;
                }
                return null;
            };

            /**
             * Creates a DecodeOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.encoding.DecodeOptions} DecodeOptions
             */
            DecodeOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.encoding.DecodeOptions)
                    return object;
                var message = new $root.protos.encoding.DecodeOptions();
                if (object.schemaId != null)
                    message.schemaId = String(object.schemaId);
                switch (object.decodeType) {
                case "DECODE_TYPE_UNSET":
                case 0:
                    message.decodeType = 0;
                    break;
                case "DECODE_TYPE_PROTOBUF":
                case 1:
                    message.decodeType = 1;
                    break;
                case "DECODE_TYPE_AVRO":
                case 2:
                    message.decodeType = 2;
                    break;
                case "DECODE_TYPE_THRIFT":
                case 3:
                    message.decodeType = 3;
                    break;
                case "DECODE_TYPE_FLATBUFFER":
                case 4:
                    message.decodeType = 4;
                    break;
                }
                if (object.protobufSettings != null) {
                    if (typeof object.protobufSettings !== "object")
                        throw TypeError(".protos.encoding.DecodeOptions.protobufSettings: object expected");
                    message.protobufSettings = $root.protos.encoding.ProtobufSettings.fromObject(object.protobufSettings);
                }
                if (object.avroSettings != null) {
                    if (typeof object.avroSettings !== "object")
                        throw TypeError(".protos.encoding.DecodeOptions.avroSettings: object expected");
                    message.avroSettings = $root.protos.encoding.AvroSettings.fromObject(object.avroSettings);
                }
                return message;
            };

            /**
             * Creates a plain object from a DecodeOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.encoding.DecodeOptions
             * @static
             * @param {protos.encoding.DecodeOptions} message DecodeOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DecodeOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.schemaId = "";
                    object.decodeType = options.enums === String ? "DECODE_TYPE_UNSET" : 0;
                    object.protobufSettings = null;
                    object.avroSettings = null;
                }
                if (message.schemaId != null && message.hasOwnProperty("schemaId"))
                    object.schemaId = message.schemaId;
                if (message.decodeType != null && message.hasOwnProperty("decodeType"))
                    object.decodeType = options.enums === String ? $root.protos.encoding.DecodeType[message.decodeType] : message.decodeType;
                if (message.protobufSettings != null && message.hasOwnProperty("protobufSettings"))
                    object.protobufSettings = $root.protos.encoding.ProtobufSettings.toObject(message.protobufSettings, options);
                if (message.avroSettings != null && message.hasOwnProperty("avroSettings"))
                    object.avroSettings = $root.protos.encoding.AvroSettings.toObject(message.avroSettings, options);
                return object;
            };

            /**
             * Converts this DecodeOptions to JSON.
             * @function toJSON
             * @memberof protos.encoding.DecodeOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DecodeOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DecodeOptions;
        })();

        return encoding;
    })();

    protos.records = (function() {

        /**
         * Namespace records.
         * @memberof protos
         * @namespace
         */
        var records = {};

        records.ReadRecord = (function() {

            /**
             * Properties of a ReadRecord.
             * @memberof protos.records
             * @interface IReadRecord
             * @property {string|null} [messageId] ReadRecord messageId
             * @property {number|Long|null} [num] ReadRecord num
             * @property {Object.<string,string>|null} [metadata] ReadRecord metadata
             * @property {number|Long|null} [receivedAtUnixTsUtc] ReadRecord receivedAtUnixTsUtc
             * @property {Uint8Array|null} [payload] ReadRecord payload
             * @property {protos.records.IKafka|null} [kafka] ReadRecord kafka
             * @property {protos.records.IRabbit|null} [rabbit] ReadRecord rabbit
             * @property {protos.records.IActiveMQ|null} [activemq] ReadRecord activemq
             * @property {protos.records.IAWSSQS|null} [awsSqs] ReadRecord awsSqs
             * @property {protos.records.IAzureEventHub|null} [azureEventHub] ReadRecord azureEventHub
             * @property {protos.records.IAzureServiceBus|null} [azureServiceBus] ReadRecord azureServiceBus
             * @property {protos.records.IGCPPubSub|null} [gcpPubsub] ReadRecord gcpPubsub
             * @property {protos.records.IKubeMQ|null} [kubemq] ReadRecord kubemq
             * @property {protos.records.IMongo|null} [mongo] ReadRecord mongo
             * @property {protos.records.IMQTT|null} [mqtt] ReadRecord mqtt
             * @property {protos.records.INats|null} [nats] ReadRecord nats
             * @property {protos.records.INatsStreaming|null} [natsStreaming] ReadRecord natsStreaming
             * @property {protos.records.INSQ|null} [nsq] ReadRecord nsq
             * @property {protos.records.IPostgres|null} [postgres] ReadRecord postgres
             * @property {protos.records.IPulsar|null} [pulsar] ReadRecord pulsar
             * @property {protos.records.IRabbitStreams|null} [rabbitStreams] ReadRecord rabbitStreams
             * @property {protos.records.IRedisPubsub|null} [redisPubsub] ReadRecord redisPubsub
             * @property {protos.records.IRedisStreams|null} [redisStreams] ReadRecord redisStreams
             * @property {protos.records.INatsJetstream|null} [natsJetstream] ReadRecord natsJetstream
             * @property {protos.records.IAWSKinesis|null} [awsKinesis] ReadRecord awsKinesis
             * @property {Uint8Array|null} [_raw] ReadRecord _raw
             * @property {string|null} [_plumberId] ReadRecord _plumberId
             */

            /**
             * Constructs a new ReadRecord.
             * @memberof protos.records
             * @classdesc Represents a ReadRecord.
             * @implements IReadRecord
             * @constructor
             * @param {protos.records.IReadRecord=} [properties] Properties to set
             */
            function ReadRecord(properties) {
                this.metadata = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadRecord messageId.
             * @member {string} messageId
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.messageId = "";

            /**
             * ReadRecord num.
             * @member {number|Long} num
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.num = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ReadRecord metadata.
             * @member {Object.<string,string>} metadata
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.metadata = $util.emptyObject;

            /**
             * ReadRecord receivedAtUnixTsUtc.
             * @member {number|Long} receivedAtUnixTsUtc
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.receivedAtUnixTsUtc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ReadRecord payload.
             * @member {Uint8Array} payload
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.payload = $util.newBuffer([]);

            /**
             * ReadRecord kafka.
             * @member {protos.records.IKafka|null|undefined} kafka
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.kafka = null;

            /**
             * ReadRecord rabbit.
             * @member {protos.records.IRabbit|null|undefined} rabbit
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.rabbit = null;

            /**
             * ReadRecord activemq.
             * @member {protos.records.IActiveMQ|null|undefined} activemq
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.activemq = null;

            /**
             * ReadRecord awsSqs.
             * @member {protos.records.IAWSSQS|null|undefined} awsSqs
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.awsSqs = null;

            /**
             * ReadRecord azureEventHub.
             * @member {protos.records.IAzureEventHub|null|undefined} azureEventHub
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.azureEventHub = null;

            /**
             * ReadRecord azureServiceBus.
             * @member {protos.records.IAzureServiceBus|null|undefined} azureServiceBus
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.azureServiceBus = null;

            /**
             * ReadRecord gcpPubsub.
             * @member {protos.records.IGCPPubSub|null|undefined} gcpPubsub
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.gcpPubsub = null;

            /**
             * ReadRecord kubemq.
             * @member {protos.records.IKubeMQ|null|undefined} kubemq
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.kubemq = null;

            /**
             * ReadRecord mongo.
             * @member {protos.records.IMongo|null|undefined} mongo
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.mongo = null;

            /**
             * ReadRecord mqtt.
             * @member {protos.records.IMQTT|null|undefined} mqtt
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.mqtt = null;

            /**
             * ReadRecord nats.
             * @member {protos.records.INats|null|undefined} nats
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.nats = null;

            /**
             * ReadRecord natsStreaming.
             * @member {protos.records.INatsStreaming|null|undefined} natsStreaming
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.natsStreaming = null;

            /**
             * ReadRecord nsq.
             * @member {protos.records.INSQ|null|undefined} nsq
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.nsq = null;

            /**
             * ReadRecord postgres.
             * @member {protos.records.IPostgres|null|undefined} postgres
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.postgres = null;

            /**
             * ReadRecord pulsar.
             * @member {protos.records.IPulsar|null|undefined} pulsar
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.pulsar = null;

            /**
             * ReadRecord rabbitStreams.
             * @member {protos.records.IRabbitStreams|null|undefined} rabbitStreams
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.rabbitStreams = null;

            /**
             * ReadRecord redisPubsub.
             * @member {protos.records.IRedisPubsub|null|undefined} redisPubsub
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.redisPubsub = null;

            /**
             * ReadRecord redisStreams.
             * @member {protos.records.IRedisStreams|null|undefined} redisStreams
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.redisStreams = null;

            /**
             * ReadRecord natsJetstream.
             * @member {protos.records.INatsJetstream|null|undefined} natsJetstream
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.natsJetstream = null;

            /**
             * ReadRecord awsKinesis.
             * @member {protos.records.IAWSKinesis|null|undefined} awsKinesis
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype.awsKinesis = null;

            /**
             * ReadRecord _raw.
             * @member {Uint8Array} _raw
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype._raw = $util.newBuffer([]);

            /**
             * ReadRecord _plumberId.
             * @member {string} _plumberId
             * @memberof protos.records.ReadRecord
             * @instance
             */
            ReadRecord.prototype._plumberId = "";

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * ReadRecord Record.
             * @member {"kafka"|"rabbit"|"activemq"|"awsSqs"|"azureEventHub"|"azureServiceBus"|"gcpPubsub"|"kubemq"|"mongo"|"mqtt"|"nats"|"natsStreaming"|"nsq"|"postgres"|"pulsar"|"rabbitStreams"|"redisPubsub"|"redisStreams"|"natsJetstream"|"awsKinesis"|undefined} Record
             * @memberof protos.records.ReadRecord
             * @instance
             */
            Object.defineProperty(ReadRecord.prototype, "Record", {
                get: $util.oneOfGetter($oneOfFields = ["kafka", "rabbit", "activemq", "awsSqs", "azureEventHub", "azureServiceBus", "gcpPubsub", "kubemq", "mongo", "mqtt", "nats", "natsStreaming", "nsq", "postgres", "pulsar", "rabbitStreams", "redisPubsub", "redisStreams", "natsJetstream", "awsKinesis"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ReadRecord instance using the specified properties.
             * @function create
             * @memberof protos.records.ReadRecord
             * @static
             * @param {protos.records.IReadRecord=} [properties] Properties to set
             * @returns {protos.records.ReadRecord} ReadRecord instance
             */
            ReadRecord.create = function create(properties) {
                return new ReadRecord(properties);
            };

            /**
             * Encodes the specified ReadRecord message. Does not implicitly {@link protos.records.ReadRecord.verify|verify} messages.
             * @function encode
             * @memberof protos.records.ReadRecord
             * @static
             * @param {protos.records.IReadRecord} message ReadRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadRecord.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.messageId);
                if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.num);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    for (var keys = Object.keys(message.metadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.metadata[keys[i]]).ldelim();
                if (message.receivedAtUnixTsUtc != null && Object.hasOwnProperty.call(message, "receivedAtUnixTsUtc"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.receivedAtUnixTsUtc);
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 99, wireType 2 =*/794).bytes(message.payload);
                if (message.kafka != null && Object.hasOwnProperty.call(message, "kafka"))
                    $root.protos.records.Kafka.encode(message.kafka, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                if (message.rabbit != null && Object.hasOwnProperty.call(message, "rabbit"))
                    $root.protos.records.Rabbit.encode(message.rabbit, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                if (message.activemq != null && Object.hasOwnProperty.call(message, "activemq"))
                    $root.protos.records.ActiveMQ.encode(message.activemq, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
                if (message.awsSqs != null && Object.hasOwnProperty.call(message, "awsSqs"))
                    $root.protos.records.AWSSQS.encode(message.awsSqs, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
                if (message.azureEventHub != null && Object.hasOwnProperty.call(message, "azureEventHub"))
                    $root.protos.records.AzureEventHub.encode(message.azureEventHub, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
                if (message.azureServiceBus != null && Object.hasOwnProperty.call(message, "azureServiceBus"))
                    $root.protos.records.AzureServiceBus.encode(message.azureServiceBus, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
                if (message.gcpPubsub != null && Object.hasOwnProperty.call(message, "gcpPubsub"))
                    $root.protos.records.GCPPubSub.encode(message.gcpPubsub, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
                if (message.kubemq != null && Object.hasOwnProperty.call(message, "kubemq"))
                    $root.protos.records.KubeMQ.encode(message.kubemq, writer.uint32(/* id 107, wireType 2 =*/858).fork()).ldelim();
                if (message.mongo != null && Object.hasOwnProperty.call(message, "mongo"))
                    $root.protos.records.Mongo.encode(message.mongo, writer.uint32(/* id 108, wireType 2 =*/866).fork()).ldelim();
                if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                    $root.protos.records.MQTT.encode(message.mqtt, writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.nats != null && Object.hasOwnProperty.call(message, "nats"))
                    $root.protos.records.Nats.encode(message.nats, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
                if (message.natsStreaming != null && Object.hasOwnProperty.call(message, "natsStreaming"))
                    $root.protos.records.NatsStreaming.encode(message.natsStreaming, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
                if (message.nsq != null && Object.hasOwnProperty.call(message, "nsq"))
                    $root.protos.records.NSQ.encode(message.nsq, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
                if (message.postgres != null && Object.hasOwnProperty.call(message, "postgres"))
                    $root.protos.records.Postgres.encode(message.postgres, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
                if (message.pulsar != null && Object.hasOwnProperty.call(message, "pulsar"))
                    $root.protos.records.Pulsar.encode(message.pulsar, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
                if (message.rabbitStreams != null && Object.hasOwnProperty.call(message, "rabbitStreams"))
                    $root.protos.records.RabbitStreams.encode(message.rabbitStreams, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
                if (message.redisPubsub != null && Object.hasOwnProperty.call(message, "redisPubsub"))
                    $root.protos.records.RedisPubsub.encode(message.redisPubsub, writer.uint32(/* id 116, wireType 2 =*/930).fork()).ldelim();
                if (message.redisStreams != null && Object.hasOwnProperty.call(message, "redisStreams"))
                    $root.protos.records.RedisStreams.encode(message.redisStreams, writer.uint32(/* id 117, wireType 2 =*/938).fork()).ldelim();
                if (message.natsJetstream != null && Object.hasOwnProperty.call(message, "natsJetstream"))
                    $root.protos.records.NatsJetstream.encode(message.natsJetstream, writer.uint32(/* id 118, wireType 2 =*/946).fork()).ldelim();
                if (message.awsKinesis != null && Object.hasOwnProperty.call(message, "awsKinesis"))
                    $root.protos.records.AWSKinesis.encode(message.awsKinesis, writer.uint32(/* id 119, wireType 2 =*/954).fork()).ldelim();
                if (message._raw != null && Object.hasOwnProperty.call(message, "_raw"))
                    writer.uint32(/* id 1000, wireType 2 =*/8002).bytes(message._raw);
                if (message._plumberId != null && Object.hasOwnProperty.call(message, "_plumberId"))
                    writer.uint32(/* id 1001, wireType 2 =*/8010).string(message._plumberId);
                return writer;
            };

            /**
             * Encodes the specified ReadRecord message, length delimited. Does not implicitly {@link protos.records.ReadRecord.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.ReadRecord
             * @static
             * @param {protos.records.IReadRecord} message ReadRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadRecord.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadRecord message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.ReadRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.ReadRecord} ReadRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadRecord.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.ReadRecord(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageId = reader.string();
                        break;
                    case 3:
                        message.num = reader.int64();
                        break;
                    case 4:
                        if (message.metadata === $util.emptyObject)
                            message.metadata = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.metadata[key] = value;
                        break;
                    case 6:
                        message.receivedAtUnixTsUtc = reader.int64();
                        break;
                    case 99:
                        message.payload = reader.bytes();
                        break;
                    case 100:
                        message.kafka = $root.protos.records.Kafka.decode(reader, reader.uint32());
                        break;
                    case 101:
                        message.rabbit = $root.protos.records.Rabbit.decode(reader, reader.uint32());
                        break;
                    case 102:
                        message.activemq = $root.protos.records.ActiveMQ.decode(reader, reader.uint32());
                        break;
                    case 103:
                        message.awsSqs = $root.protos.records.AWSSQS.decode(reader, reader.uint32());
                        break;
                    case 104:
                        message.azureEventHub = $root.protos.records.AzureEventHub.decode(reader, reader.uint32());
                        break;
                    case 105:
                        message.azureServiceBus = $root.protos.records.AzureServiceBus.decode(reader, reader.uint32());
                        break;
                    case 106:
                        message.gcpPubsub = $root.protos.records.GCPPubSub.decode(reader, reader.uint32());
                        break;
                    case 107:
                        message.kubemq = $root.protos.records.KubeMQ.decode(reader, reader.uint32());
                        break;
                    case 108:
                        message.mongo = $root.protos.records.Mongo.decode(reader, reader.uint32());
                        break;
                    case 109:
                        message.mqtt = $root.protos.records.MQTT.decode(reader, reader.uint32());
                        break;
                    case 110:
                        message.nats = $root.protos.records.Nats.decode(reader, reader.uint32());
                        break;
                    case 111:
                        message.natsStreaming = $root.protos.records.NatsStreaming.decode(reader, reader.uint32());
                        break;
                    case 112:
                        message.nsq = $root.protos.records.NSQ.decode(reader, reader.uint32());
                        break;
                    case 113:
                        message.postgres = $root.protos.records.Postgres.decode(reader, reader.uint32());
                        break;
                    case 114:
                        message.pulsar = $root.protos.records.Pulsar.decode(reader, reader.uint32());
                        break;
                    case 115:
                        message.rabbitStreams = $root.protos.records.RabbitStreams.decode(reader, reader.uint32());
                        break;
                    case 116:
                        message.redisPubsub = $root.protos.records.RedisPubsub.decode(reader, reader.uint32());
                        break;
                    case 117:
                        message.redisStreams = $root.protos.records.RedisStreams.decode(reader, reader.uint32());
                        break;
                    case 118:
                        message.natsJetstream = $root.protos.records.NatsJetstream.decode(reader, reader.uint32());
                        break;
                    case 119:
                        message.awsKinesis = $root.protos.records.AWSKinesis.decode(reader, reader.uint32());
                        break;
                    case 1000:
                        message._raw = reader.bytes();
                        break;
                    case 1001:
                        message._plumberId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadRecord message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.ReadRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.ReadRecord} ReadRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadRecord.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadRecord message.
             * @function verify
             * @memberof protos.records.ReadRecord
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadRecord.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                if (message.num != null && message.hasOwnProperty("num"))
                    if (!$util.isInteger(message.num) && !(message.num && $util.isInteger(message.num.low) && $util.isInteger(message.num.high)))
                        return "num: integer|Long expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    if (!$util.isObject(message.metadata))
                        return "metadata: object expected";
                    var key = Object.keys(message.metadata);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.metadata[key[i]]))
                            return "metadata: string{k:string} expected";
                }
                if (message.receivedAtUnixTsUtc != null && message.hasOwnProperty("receivedAtUnixTsUtc"))
                    if (!$util.isInteger(message.receivedAtUnixTsUtc) && !(message.receivedAtUnixTsUtc && $util.isInteger(message.receivedAtUnixTsUtc.low) && $util.isInteger(message.receivedAtUnixTsUtc.high)))
                        return "receivedAtUnixTsUtc: integer|Long expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.Kafka.verify(message.kafka);
                        if (error)
                            return "kafka." + error;
                    }
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.Rabbit.verify(message.rabbit);
                        if (error)
                            return "rabbit." + error;
                    }
                }
                if (message.activemq != null && message.hasOwnProperty("activemq")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.ActiveMQ.verify(message.activemq);
                        if (error)
                            return "activemq." + error;
                    }
                }
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.AWSSQS.verify(message.awsSqs);
                        if (error)
                            return "awsSqs." + error;
                    }
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.AzureEventHub.verify(message.azureEventHub);
                        if (error)
                            return "azureEventHub." + error;
                    }
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.AzureServiceBus.verify(message.azureServiceBus);
                        if (error)
                            return "azureServiceBus." + error;
                    }
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.GCPPubSub.verify(message.gcpPubsub);
                        if (error)
                            return "gcpPubsub." + error;
                    }
                }
                if (message.kubemq != null && message.hasOwnProperty("kubemq")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.KubeMQ.verify(message.kubemq);
                        if (error)
                            return "kubemq." + error;
                    }
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.Mongo.verify(message.mongo);
                        if (error)
                            return "mongo." + error;
                    }
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.MQTT.verify(message.mqtt);
                        if (error)
                            return "mqtt." + error;
                    }
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.Nats.verify(message.nats);
                        if (error)
                            return "nats." + error;
                    }
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.NatsStreaming.verify(message.natsStreaming);
                        if (error)
                            return "natsStreaming." + error;
                    }
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.NSQ.verify(message.nsq);
                        if (error)
                            return "nsq." + error;
                    }
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.Postgres.verify(message.postgres);
                        if (error)
                            return "postgres." + error;
                    }
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.Pulsar.verify(message.pulsar);
                        if (error)
                            return "pulsar." + error;
                    }
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.RabbitStreams.verify(message.rabbitStreams);
                        if (error)
                            return "rabbitStreams." + error;
                    }
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.RedisPubsub.verify(message.redisPubsub);
                        if (error)
                            return "redisPubsub." + error;
                    }
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.RedisStreams.verify(message.redisStreams);
                        if (error)
                            return "redisStreams." + error;
                    }
                }
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.NatsJetstream.verify(message.natsJetstream);
                        if (error)
                            return "natsJetstream." + error;
                    }
                }
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis")) {
                    if (properties.Record === 1)
                        return "Record: multiple values";
                    properties.Record = 1;
                    {
                        var error = $root.protos.records.AWSKinesis.verify(message.awsKinesis);
                        if (error)
                            return "awsKinesis." + error;
                    }
                }
                if (message._raw != null && message.hasOwnProperty("_raw"))
                    if (!(message._raw && typeof message._raw.length === "number" || $util.isString(message._raw)))
                        return "_raw: buffer expected";
                if (message._plumberId != null && message.hasOwnProperty("_plumberId"))
                    if (!$util.isString(message._plumberId))
                        return "_plumberId: string expected";
                return null;
            };

            /**
             * Creates a ReadRecord message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.ReadRecord
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.ReadRecord} ReadRecord
             */
            ReadRecord.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.ReadRecord)
                    return object;
                var message = new $root.protos.records.ReadRecord();
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.num != null)
                    if ($util.Long)
                        (message.num = $util.Long.fromValue(object.num)).unsigned = false;
                    else if (typeof object.num === "string")
                        message.num = parseInt(object.num, 10);
                    else if (typeof object.num === "number")
                        message.num = object.num;
                    else if (typeof object.num === "object")
                        message.num = new $util.LongBits(object.num.low >>> 0, object.num.high >>> 0).toNumber();
                if (object.metadata) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".protos.records.ReadRecord.metadata: object expected");
                    message.metadata = {};
                    for (var keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i)
                        message.metadata[keys[i]] = String(object.metadata[keys[i]]);
                }
                if (object.receivedAtUnixTsUtc != null)
                    if ($util.Long)
                        (message.receivedAtUnixTsUtc = $util.Long.fromValue(object.receivedAtUnixTsUtc)).unsigned = false;
                    else if (typeof object.receivedAtUnixTsUtc === "string")
                        message.receivedAtUnixTsUtc = parseInt(object.receivedAtUnixTsUtc, 10);
                    else if (typeof object.receivedAtUnixTsUtc === "number")
                        message.receivedAtUnixTsUtc = object.receivedAtUnixTsUtc;
                    else if (typeof object.receivedAtUnixTsUtc === "object")
                        message.receivedAtUnixTsUtc = new $util.LongBits(object.receivedAtUnixTsUtc.low >>> 0, object.receivedAtUnixTsUtc.high >>> 0).toNumber();
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.kafka != null) {
                    if (typeof object.kafka !== "object")
                        throw TypeError(".protos.records.ReadRecord.kafka: object expected");
                    message.kafka = $root.protos.records.Kafka.fromObject(object.kafka);
                }
                if (object.rabbit != null) {
                    if (typeof object.rabbit !== "object")
                        throw TypeError(".protos.records.ReadRecord.rabbit: object expected");
                    message.rabbit = $root.protos.records.Rabbit.fromObject(object.rabbit);
                }
                if (object.activemq != null) {
                    if (typeof object.activemq !== "object")
                        throw TypeError(".protos.records.ReadRecord.activemq: object expected");
                    message.activemq = $root.protos.records.ActiveMQ.fromObject(object.activemq);
                }
                if (object.awsSqs != null) {
                    if (typeof object.awsSqs !== "object")
                        throw TypeError(".protos.records.ReadRecord.awsSqs: object expected");
                    message.awsSqs = $root.protos.records.AWSSQS.fromObject(object.awsSqs);
                }
                if (object.azureEventHub != null) {
                    if (typeof object.azureEventHub !== "object")
                        throw TypeError(".protos.records.ReadRecord.azureEventHub: object expected");
                    message.azureEventHub = $root.protos.records.AzureEventHub.fromObject(object.azureEventHub);
                }
                if (object.azureServiceBus != null) {
                    if (typeof object.azureServiceBus !== "object")
                        throw TypeError(".protos.records.ReadRecord.azureServiceBus: object expected");
                    message.azureServiceBus = $root.protos.records.AzureServiceBus.fromObject(object.azureServiceBus);
                }
                if (object.gcpPubsub != null) {
                    if (typeof object.gcpPubsub !== "object")
                        throw TypeError(".protos.records.ReadRecord.gcpPubsub: object expected");
                    message.gcpPubsub = $root.protos.records.GCPPubSub.fromObject(object.gcpPubsub);
                }
                if (object.kubemq != null) {
                    if (typeof object.kubemq !== "object")
                        throw TypeError(".protos.records.ReadRecord.kubemq: object expected");
                    message.kubemq = $root.protos.records.KubeMQ.fromObject(object.kubemq);
                }
                if (object.mongo != null) {
                    if (typeof object.mongo !== "object")
                        throw TypeError(".protos.records.ReadRecord.mongo: object expected");
                    message.mongo = $root.protos.records.Mongo.fromObject(object.mongo);
                }
                if (object.mqtt != null) {
                    if (typeof object.mqtt !== "object")
                        throw TypeError(".protos.records.ReadRecord.mqtt: object expected");
                    message.mqtt = $root.protos.records.MQTT.fromObject(object.mqtt);
                }
                if (object.nats != null) {
                    if (typeof object.nats !== "object")
                        throw TypeError(".protos.records.ReadRecord.nats: object expected");
                    message.nats = $root.protos.records.Nats.fromObject(object.nats);
                }
                if (object.natsStreaming != null) {
                    if (typeof object.natsStreaming !== "object")
                        throw TypeError(".protos.records.ReadRecord.natsStreaming: object expected");
                    message.natsStreaming = $root.protos.records.NatsStreaming.fromObject(object.natsStreaming);
                }
                if (object.nsq != null) {
                    if (typeof object.nsq !== "object")
                        throw TypeError(".protos.records.ReadRecord.nsq: object expected");
                    message.nsq = $root.protos.records.NSQ.fromObject(object.nsq);
                }
                if (object.postgres != null) {
                    if (typeof object.postgres !== "object")
                        throw TypeError(".protos.records.ReadRecord.postgres: object expected");
                    message.postgres = $root.protos.records.Postgres.fromObject(object.postgres);
                }
                if (object.pulsar != null) {
                    if (typeof object.pulsar !== "object")
                        throw TypeError(".protos.records.ReadRecord.pulsar: object expected");
                    message.pulsar = $root.protos.records.Pulsar.fromObject(object.pulsar);
                }
                if (object.rabbitStreams != null) {
                    if (typeof object.rabbitStreams !== "object")
                        throw TypeError(".protos.records.ReadRecord.rabbitStreams: object expected");
                    message.rabbitStreams = $root.protos.records.RabbitStreams.fromObject(object.rabbitStreams);
                }
                if (object.redisPubsub != null) {
                    if (typeof object.redisPubsub !== "object")
                        throw TypeError(".protos.records.ReadRecord.redisPubsub: object expected");
                    message.redisPubsub = $root.protos.records.RedisPubsub.fromObject(object.redisPubsub);
                }
                if (object.redisStreams != null) {
                    if (typeof object.redisStreams !== "object")
                        throw TypeError(".protos.records.ReadRecord.redisStreams: object expected");
                    message.redisStreams = $root.protos.records.RedisStreams.fromObject(object.redisStreams);
                }
                if (object.natsJetstream != null) {
                    if (typeof object.natsJetstream !== "object")
                        throw TypeError(".protos.records.ReadRecord.natsJetstream: object expected");
                    message.natsJetstream = $root.protos.records.NatsJetstream.fromObject(object.natsJetstream);
                }
                if (object.awsKinesis != null) {
                    if (typeof object.awsKinesis !== "object")
                        throw TypeError(".protos.records.ReadRecord.awsKinesis: object expected");
                    message.awsKinesis = $root.protos.records.AWSKinesis.fromObject(object.awsKinesis);
                }
                if (object._raw != null)
                    if (typeof object._raw === "string")
                        $util.base64.decode(object._raw, message._raw = $util.newBuffer($util.base64.length(object._raw)), 0);
                    else if (object._raw.length)
                        message._raw = object._raw;
                if (object._plumberId != null)
                    message._plumberId = String(object._plumberId);
                return message;
            };

            /**
             * Creates a plain object from a ReadRecord message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.ReadRecord
             * @static
             * @param {protos.records.ReadRecord} message ReadRecord
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadRecord.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.metadata = {};
                if (options.defaults) {
                    object.messageId = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.num = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.receivedAtUnixTsUtc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.receivedAtUnixTsUtc = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    if (options.bytes === String)
                        object._raw = "";
                    else {
                        object._raw = [];
                        if (options.bytes !== Array)
                            object._raw = $util.newBuffer(object._raw);
                    }
                    object._plumberId = "";
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                if (message.num != null && message.hasOwnProperty("num"))
                    if (typeof message.num === "number")
                        object.num = options.longs === String ? String(message.num) : message.num;
                    else
                        object.num = options.longs === String ? $util.Long.prototype.toString.call(message.num) : options.longs === Number ? new $util.LongBits(message.num.low >>> 0, message.num.high >>> 0).toNumber() : message.num;
                var keys2;
                if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                    object.metadata = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.metadata[keys2[j]] = message.metadata[keys2[j]];
                }
                if (message.receivedAtUnixTsUtc != null && message.hasOwnProperty("receivedAtUnixTsUtc"))
                    if (typeof message.receivedAtUnixTsUtc === "number")
                        object.receivedAtUnixTsUtc = options.longs === String ? String(message.receivedAtUnixTsUtc) : message.receivedAtUnixTsUtc;
                    else
                        object.receivedAtUnixTsUtc = options.longs === String ? $util.Long.prototype.toString.call(message.receivedAtUnixTsUtc) : options.longs === Number ? new $util.LongBits(message.receivedAtUnixTsUtc.low >>> 0, message.receivedAtUnixTsUtc.high >>> 0).toNumber() : message.receivedAtUnixTsUtc;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.kafka != null && message.hasOwnProperty("kafka")) {
                    object.kafka = $root.protos.records.Kafka.toObject(message.kafka, options);
                    if (options.oneofs)
                        object.Record = "kafka";
                }
                if (message.rabbit != null && message.hasOwnProperty("rabbit")) {
                    object.rabbit = $root.protos.records.Rabbit.toObject(message.rabbit, options);
                    if (options.oneofs)
                        object.Record = "rabbit";
                }
                if (message.activemq != null && message.hasOwnProperty("activemq")) {
                    object.activemq = $root.protos.records.ActiveMQ.toObject(message.activemq, options);
                    if (options.oneofs)
                        object.Record = "activemq";
                }
                if (message.awsSqs != null && message.hasOwnProperty("awsSqs")) {
                    object.awsSqs = $root.protos.records.AWSSQS.toObject(message.awsSqs, options);
                    if (options.oneofs)
                        object.Record = "awsSqs";
                }
                if (message.azureEventHub != null && message.hasOwnProperty("azureEventHub")) {
                    object.azureEventHub = $root.protos.records.AzureEventHub.toObject(message.azureEventHub, options);
                    if (options.oneofs)
                        object.Record = "azureEventHub";
                }
                if (message.azureServiceBus != null && message.hasOwnProperty("azureServiceBus")) {
                    object.azureServiceBus = $root.protos.records.AzureServiceBus.toObject(message.azureServiceBus, options);
                    if (options.oneofs)
                        object.Record = "azureServiceBus";
                }
                if (message.gcpPubsub != null && message.hasOwnProperty("gcpPubsub")) {
                    object.gcpPubsub = $root.protos.records.GCPPubSub.toObject(message.gcpPubsub, options);
                    if (options.oneofs)
                        object.Record = "gcpPubsub";
                }
                if (message.kubemq != null && message.hasOwnProperty("kubemq")) {
                    object.kubemq = $root.protos.records.KubeMQ.toObject(message.kubemq, options);
                    if (options.oneofs)
                        object.Record = "kubemq";
                }
                if (message.mongo != null && message.hasOwnProperty("mongo")) {
                    object.mongo = $root.protos.records.Mongo.toObject(message.mongo, options);
                    if (options.oneofs)
                        object.Record = "mongo";
                }
                if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                    object.mqtt = $root.protos.records.MQTT.toObject(message.mqtt, options);
                    if (options.oneofs)
                        object.Record = "mqtt";
                }
                if (message.nats != null && message.hasOwnProperty("nats")) {
                    object.nats = $root.protos.records.Nats.toObject(message.nats, options);
                    if (options.oneofs)
                        object.Record = "nats";
                }
                if (message.natsStreaming != null && message.hasOwnProperty("natsStreaming")) {
                    object.natsStreaming = $root.protos.records.NatsStreaming.toObject(message.natsStreaming, options);
                    if (options.oneofs)
                        object.Record = "natsStreaming";
                }
                if (message.nsq != null && message.hasOwnProperty("nsq")) {
                    object.nsq = $root.protos.records.NSQ.toObject(message.nsq, options);
                    if (options.oneofs)
                        object.Record = "nsq";
                }
                if (message.postgres != null && message.hasOwnProperty("postgres")) {
                    object.postgres = $root.protos.records.Postgres.toObject(message.postgres, options);
                    if (options.oneofs)
                        object.Record = "postgres";
                }
                if (message.pulsar != null && message.hasOwnProperty("pulsar")) {
                    object.pulsar = $root.protos.records.Pulsar.toObject(message.pulsar, options);
                    if (options.oneofs)
                        object.Record = "pulsar";
                }
                if (message.rabbitStreams != null && message.hasOwnProperty("rabbitStreams")) {
                    object.rabbitStreams = $root.protos.records.RabbitStreams.toObject(message.rabbitStreams, options);
                    if (options.oneofs)
                        object.Record = "rabbitStreams";
                }
                if (message.redisPubsub != null && message.hasOwnProperty("redisPubsub")) {
                    object.redisPubsub = $root.protos.records.RedisPubsub.toObject(message.redisPubsub, options);
                    if (options.oneofs)
                        object.Record = "redisPubsub";
                }
                if (message.redisStreams != null && message.hasOwnProperty("redisStreams")) {
                    object.redisStreams = $root.protos.records.RedisStreams.toObject(message.redisStreams, options);
                    if (options.oneofs)
                        object.Record = "redisStreams";
                }
                if (message.natsJetstream != null && message.hasOwnProperty("natsJetstream")) {
                    object.natsJetstream = $root.protos.records.NatsJetstream.toObject(message.natsJetstream, options);
                    if (options.oneofs)
                        object.Record = "natsJetstream";
                }
                if (message.awsKinesis != null && message.hasOwnProperty("awsKinesis")) {
                    object.awsKinesis = $root.protos.records.AWSKinesis.toObject(message.awsKinesis, options);
                    if (options.oneofs)
                        object.Record = "awsKinesis";
                }
                if (message._raw != null && message.hasOwnProperty("_raw"))
                    object._raw = options.bytes === String ? $util.base64.encode(message._raw, 0, message._raw.length) : options.bytes === Array ? Array.prototype.slice.call(message._raw) : message._raw;
                if (message._plumberId != null && message.hasOwnProperty("_plumberId"))
                    object._plumberId = message._plumberId;
                return object;
            };

            /**
             * Converts this ReadRecord to JSON.
             * @function toJSON
             * @memberof protos.records.ReadRecord
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadRecord.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadRecord;
        })();

        records.WriteRecord = (function() {

            /**
             * Properties of a WriteRecord.
             * @memberof protos.records
             * @interface IWriteRecord
             * @property {string|null} [input] WriteRecord input
             * @property {Object.<string,string>|null} [inputMetadata] WriteRecord inputMetadata
             */

            /**
             * Constructs a new WriteRecord.
             * @memberof protos.records
             * @classdesc Represents a WriteRecord.
             * @implements IWriteRecord
             * @constructor
             * @param {protos.records.IWriteRecord=} [properties] Properties to set
             */
            function WriteRecord(properties) {
                this.inputMetadata = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteRecord input.
             * @member {string} input
             * @memberof protos.records.WriteRecord
             * @instance
             */
            WriteRecord.prototype.input = "";

            /**
             * WriteRecord inputMetadata.
             * @member {Object.<string,string>} inputMetadata
             * @memberof protos.records.WriteRecord
             * @instance
             */
            WriteRecord.prototype.inputMetadata = $util.emptyObject;

            /**
             * Creates a new WriteRecord instance using the specified properties.
             * @function create
             * @memberof protos.records.WriteRecord
             * @static
             * @param {protos.records.IWriteRecord=} [properties] Properties to set
             * @returns {protos.records.WriteRecord} WriteRecord instance
             */
            WriteRecord.create = function create(properties) {
                return new WriteRecord(properties);
            };

            /**
             * Encodes the specified WriteRecord message. Does not implicitly {@link protos.records.WriteRecord.verify|verify} messages.
             * @function encode
             * @memberof protos.records.WriteRecord
             * @static
             * @param {protos.records.IWriteRecord} message WriteRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteRecord.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.input != null && Object.hasOwnProperty.call(message, "input"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.input);
                if (message.inputMetadata != null && Object.hasOwnProperty.call(message, "inputMetadata"))
                    for (var keys = Object.keys(message.inputMetadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.inputMetadata[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WriteRecord message, length delimited. Does not implicitly {@link protos.records.WriteRecord.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.WriteRecord
             * @static
             * @param {protos.records.IWriteRecord} message WriteRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteRecord.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteRecord message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.WriteRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.WriteRecord} WriteRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteRecord.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.WriteRecord(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.input = reader.string();
                        break;
                    case 2:
                        if (message.inputMetadata === $util.emptyObject)
                            message.inputMetadata = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.inputMetadata[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteRecord message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.WriteRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.WriteRecord} WriteRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteRecord.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteRecord message.
             * @function verify
             * @memberof protos.records.WriteRecord
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteRecord.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.input != null && message.hasOwnProperty("input"))
                    if (!$util.isString(message.input))
                        return "input: string expected";
                if (message.inputMetadata != null && message.hasOwnProperty("inputMetadata")) {
                    if (!$util.isObject(message.inputMetadata))
                        return "inputMetadata: object expected";
                    var key = Object.keys(message.inputMetadata);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.inputMetadata[key[i]]))
                            return "inputMetadata: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a WriteRecord message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.WriteRecord
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.WriteRecord} WriteRecord
             */
            WriteRecord.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.WriteRecord)
                    return object;
                var message = new $root.protos.records.WriteRecord();
                if (object.input != null)
                    message.input = String(object.input);
                if (object.inputMetadata) {
                    if (typeof object.inputMetadata !== "object")
                        throw TypeError(".protos.records.WriteRecord.inputMetadata: object expected");
                    message.inputMetadata = {};
                    for (var keys = Object.keys(object.inputMetadata), i = 0; i < keys.length; ++i)
                        message.inputMetadata[keys[i]] = String(object.inputMetadata[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteRecord message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.WriteRecord
             * @static
             * @param {protos.records.WriteRecord} message WriteRecord
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteRecord.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.inputMetadata = {};
                if (options.defaults)
                    object.input = "";
                if (message.input != null && message.hasOwnProperty("input"))
                    object.input = message.input;
                var keys2;
                if (message.inputMetadata && (keys2 = Object.keys(message.inputMetadata)).length) {
                    object.inputMetadata = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.inputMetadata[keys2[j]] = message.inputMetadata[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this WriteRecord to JSON.
             * @function toJSON
             * @memberof protos.records.WriteRecord
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteRecord.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WriteRecord;
        })();

        records.ErrorRecord = (function() {

            /**
             * Properties of an ErrorRecord.
             * @memberof protos.records
             * @interface IErrorRecord
             * @property {number|Long|null} [occurredAtUnixTsUtc] ErrorRecord occurredAtUnixTsUtc
             * @property {string|null} [error] ErrorRecord error
             * @property {Object.<string,Uint8Array>|null} [metadata] ErrorRecord metadata
             */

            /**
             * Constructs a new ErrorRecord.
             * @memberof protos.records
             * @classdesc Represents an ErrorRecord.
             * @implements IErrorRecord
             * @constructor
             * @param {protos.records.IErrorRecord=} [properties] Properties to set
             */
            function ErrorRecord(properties) {
                this.metadata = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ErrorRecord occurredAtUnixTsUtc.
             * @member {number|Long} occurredAtUnixTsUtc
             * @memberof protos.records.ErrorRecord
             * @instance
             */
            ErrorRecord.prototype.occurredAtUnixTsUtc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ErrorRecord error.
             * @member {string} error
             * @memberof protos.records.ErrorRecord
             * @instance
             */
            ErrorRecord.prototype.error = "";

            /**
             * ErrorRecord metadata.
             * @member {Object.<string,Uint8Array>} metadata
             * @memberof protos.records.ErrorRecord
             * @instance
             */
            ErrorRecord.prototype.metadata = $util.emptyObject;

            /**
             * Creates a new ErrorRecord instance using the specified properties.
             * @function create
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {protos.records.IErrorRecord=} [properties] Properties to set
             * @returns {protos.records.ErrorRecord} ErrorRecord instance
             */
            ErrorRecord.create = function create(properties) {
                return new ErrorRecord(properties);
            };

            /**
             * Encodes the specified ErrorRecord message. Does not implicitly {@link protos.records.ErrorRecord.verify|verify} messages.
             * @function encode
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {protos.records.IErrorRecord} message ErrorRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorRecord.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.occurredAtUnixTsUtc != null && Object.hasOwnProperty.call(message, "occurredAtUnixTsUtc"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.occurredAtUnixTsUtc);
                if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.error);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    for (var keys = Object.keys(message.metadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).bytes(message.metadata[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ErrorRecord message, length delimited. Does not implicitly {@link protos.records.ErrorRecord.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {protos.records.IErrorRecord} message ErrorRecord message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorRecord.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ErrorRecord message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.ErrorRecord} ErrorRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorRecord.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.ErrorRecord(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.occurredAtUnixTsUtc = reader.int64();
                        break;
                    case 2:
                        message.error = reader.string();
                        break;
                    case 3:
                        if (message.metadata === $util.emptyObject)
                            message.metadata = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = [];
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.metadata[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ErrorRecord message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.ErrorRecord} ErrorRecord
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorRecord.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ErrorRecord message.
             * @function verify
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ErrorRecord.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.occurredAtUnixTsUtc != null && message.hasOwnProperty("occurredAtUnixTsUtc"))
                    if (!$util.isInteger(message.occurredAtUnixTsUtc) && !(message.occurredAtUnixTsUtc && $util.isInteger(message.occurredAtUnixTsUtc.low) && $util.isInteger(message.occurredAtUnixTsUtc.high)))
                        return "occurredAtUnixTsUtc: integer|Long expected";
                if (message.error != null && message.hasOwnProperty("error"))
                    if (!$util.isString(message.error))
                        return "error: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    if (!$util.isObject(message.metadata))
                        return "metadata: object expected";
                    var key = Object.keys(message.metadata);
                    for (var i = 0; i < key.length; ++i)
                        if (!(message.metadata[key[i]] && typeof message.metadata[key[i]].length === "number" || $util.isString(message.metadata[key[i]])))
                            return "metadata: buffer{k:string} expected";
                }
                return null;
            };

            /**
             * Creates an ErrorRecord message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.ErrorRecord} ErrorRecord
             */
            ErrorRecord.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.ErrorRecord)
                    return object;
                var message = new $root.protos.records.ErrorRecord();
                if (object.occurredAtUnixTsUtc != null)
                    if ($util.Long)
                        (message.occurredAtUnixTsUtc = $util.Long.fromValue(object.occurredAtUnixTsUtc)).unsigned = false;
                    else if (typeof object.occurredAtUnixTsUtc === "string")
                        message.occurredAtUnixTsUtc = parseInt(object.occurredAtUnixTsUtc, 10);
                    else if (typeof object.occurredAtUnixTsUtc === "number")
                        message.occurredAtUnixTsUtc = object.occurredAtUnixTsUtc;
                    else if (typeof object.occurredAtUnixTsUtc === "object")
                        message.occurredAtUnixTsUtc = new $util.LongBits(object.occurredAtUnixTsUtc.low >>> 0, object.occurredAtUnixTsUtc.high >>> 0).toNumber();
                if (object.error != null)
                    message.error = String(object.error);
                if (object.metadata) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".protos.records.ErrorRecord.metadata: object expected");
                    message.metadata = {};
                    for (var keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i)
                        if (typeof object.metadata[keys[i]] === "string")
                            $util.base64.decode(object.metadata[keys[i]], message.metadata[keys[i]] = $util.newBuffer($util.base64.length(object.metadata[keys[i]])), 0);
                        else if (object.metadata[keys[i]].length)
                            message.metadata[keys[i]] = object.metadata[keys[i]];
                }
                return message;
            };

            /**
             * Creates a plain object from an ErrorRecord message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.ErrorRecord
             * @static
             * @param {protos.records.ErrorRecord} message ErrorRecord
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ErrorRecord.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.metadata = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.occurredAtUnixTsUtc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.occurredAtUnixTsUtc = options.longs === String ? "0" : 0;
                    object.error = "";
                }
                if (message.occurredAtUnixTsUtc != null && message.hasOwnProperty("occurredAtUnixTsUtc"))
                    if (typeof message.occurredAtUnixTsUtc === "number")
                        object.occurredAtUnixTsUtc = options.longs === String ? String(message.occurredAtUnixTsUtc) : message.occurredAtUnixTsUtc;
                    else
                        object.occurredAtUnixTsUtc = options.longs === String ? $util.Long.prototype.toString.call(message.occurredAtUnixTsUtc) : options.longs === Number ? new $util.LongBits(message.occurredAtUnixTsUtc.low >>> 0, message.occurredAtUnixTsUtc.high >>> 0).toNumber() : message.occurredAtUnixTsUtc;
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = message.error;
                var keys2;
                if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                    object.metadata = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.metadata[keys2[j]] = options.bytes === String ? $util.base64.encode(message.metadata[keys2[j]], 0, message.metadata[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata[keys2[j]]) : message.metadata[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this ErrorRecord to JSON.
             * @function toJSON
             * @memberof protos.records.ErrorRecord
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ErrorRecord.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ErrorRecord;
        })();

        records.ActiveMQ = (function() {

            /**
             * Properties of an ActiveMQ.
             * @memberof protos.records
             * @interface IActiveMQ
             * @property {string|null} [destination] ActiveMQ destination
             * @property {string|null} [contentType] ActiveMQ contentType
             * @property {string|null} [subscriptionId] ActiveMQ subscriptionId
             * @property {number|Long|null} [timestamp] ActiveMQ timestamp
             * @property {Uint8Array|null} [value] ActiveMQ value
             */

            /**
             * Constructs a new ActiveMQ.
             * @memberof protos.records
             * @classdesc Represents an ActiveMQ.
             * @implements IActiveMQ
             * @constructor
             * @param {protos.records.IActiveMQ=} [properties] Properties to set
             */
            function ActiveMQ(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ActiveMQ destination.
             * @member {string} destination
             * @memberof protos.records.ActiveMQ
             * @instance
             */
            ActiveMQ.prototype.destination = "";

            /**
             * ActiveMQ contentType.
             * @member {string} contentType
             * @memberof protos.records.ActiveMQ
             * @instance
             */
            ActiveMQ.prototype.contentType = "";

            /**
             * ActiveMQ subscriptionId.
             * @member {string} subscriptionId
             * @memberof protos.records.ActiveMQ
             * @instance
             */
            ActiveMQ.prototype.subscriptionId = "";

            /**
             * ActiveMQ timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.ActiveMQ
             * @instance
             */
            ActiveMQ.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ActiveMQ value.
             * @member {Uint8Array} value
             * @memberof protos.records.ActiveMQ
             * @instance
             */
            ActiveMQ.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new ActiveMQ instance using the specified properties.
             * @function create
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {protos.records.IActiveMQ=} [properties] Properties to set
             * @returns {protos.records.ActiveMQ} ActiveMQ instance
             */
            ActiveMQ.create = function create(properties) {
                return new ActiveMQ(properties);
            };

            /**
             * Encodes the specified ActiveMQ message. Does not implicitly {@link protos.records.ActiveMQ.verify|verify} messages.
             * @function encode
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {protos.records.IActiveMQ} message ActiveMQ message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQ.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.destination);
                if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.contentType);
                if (message.subscriptionId != null && Object.hasOwnProperty.call(message, "subscriptionId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.subscriptionId);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestamp);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified ActiveMQ message, length delimited. Does not implicitly {@link protos.records.ActiveMQ.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {protos.records.IActiveMQ} message ActiveMQ message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ActiveMQ.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ActiveMQ message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.ActiveMQ} ActiveMQ
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQ.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.ActiveMQ();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.destination = reader.string();
                        break;
                    case 2:
                        message.contentType = reader.string();
                        break;
                    case 3:
                        message.subscriptionId = reader.string();
                        break;
                    case 4:
                        message.timestamp = reader.int64();
                        break;
                    case 5:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ActiveMQ message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.ActiveMQ} ActiveMQ
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ActiveMQ.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ActiveMQ message.
             * @function verify
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ActiveMQ.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.destination != null && message.hasOwnProperty("destination"))
                    if (!$util.isString(message.destination))
                        return "destination: string expected";
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    if (!$util.isString(message.contentType))
                        return "contentType: string expected";
                if (message.subscriptionId != null && message.hasOwnProperty("subscriptionId"))
                    if (!$util.isString(message.subscriptionId))
                        return "subscriptionId: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an ActiveMQ message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.ActiveMQ} ActiveMQ
             */
            ActiveMQ.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.ActiveMQ)
                    return object;
                var message = new $root.protos.records.ActiveMQ();
                if (object.destination != null)
                    message.destination = String(object.destination);
                if (object.contentType != null)
                    message.contentType = String(object.contentType);
                if (object.subscriptionId != null)
                    message.subscriptionId = String(object.subscriptionId);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an ActiveMQ message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.ActiveMQ
             * @static
             * @param {protos.records.ActiveMQ} message ActiveMQ
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ActiveMQ.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.destination = "";
                    object.contentType = "";
                    object.subscriptionId = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.destination != null && message.hasOwnProperty("destination"))
                    object.destination = message.destination;
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    object.contentType = message.contentType;
                if (message.subscriptionId != null && message.hasOwnProperty("subscriptionId"))
                    object.subscriptionId = message.subscriptionId;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this ActiveMQ to JSON.
             * @function toJSON
             * @memberof protos.records.ActiveMQ
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ActiveMQ.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ActiveMQ;
        })();

        records.AWSKinesis = (function() {

            /**
             * Properties of a AWSKinesis.
             * @memberof protos.records
             * @interface IAWSKinesis
             * @property {string|null} [partitionKey] AWSKinesis partitionKey
             * @property {string|null} [sequenceNumber] AWSKinesis sequenceNumber
             * @property {string|null} [encryptionType] AWSKinesis encryptionType
             * @property {string|null} [shardId] AWSKinesis shardId
             * @property {Uint8Array|null} [value] AWSKinesis value
             */

            /**
             * Constructs a new AWSKinesis.
             * @memberof protos.records
             * @classdesc Represents a AWSKinesis.
             * @implements IAWSKinesis
             * @constructor
             * @param {protos.records.IAWSKinesis=} [properties] Properties to set
             */
            function AWSKinesis(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSKinesis partitionKey.
             * @member {string} partitionKey
             * @memberof protos.records.AWSKinesis
             * @instance
             */
            AWSKinesis.prototype.partitionKey = "";

            /**
             * AWSKinesis sequenceNumber.
             * @member {string} sequenceNumber
             * @memberof protos.records.AWSKinesis
             * @instance
             */
            AWSKinesis.prototype.sequenceNumber = "";

            /**
             * AWSKinesis encryptionType.
             * @member {string} encryptionType
             * @memberof protos.records.AWSKinesis
             * @instance
             */
            AWSKinesis.prototype.encryptionType = "";

            /**
             * AWSKinesis shardId.
             * @member {string} shardId
             * @memberof protos.records.AWSKinesis
             * @instance
             */
            AWSKinesis.prototype.shardId = "";

            /**
             * AWSKinesis value.
             * @member {Uint8Array} value
             * @memberof protos.records.AWSKinesis
             * @instance
             */
            AWSKinesis.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new AWSKinesis instance using the specified properties.
             * @function create
             * @memberof protos.records.AWSKinesis
             * @static
             * @param {protos.records.IAWSKinesis=} [properties] Properties to set
             * @returns {protos.records.AWSKinesis} AWSKinesis instance
             */
            AWSKinesis.create = function create(properties) {
                return new AWSKinesis(properties);
            };

            /**
             * Encodes the specified AWSKinesis message. Does not implicitly {@link protos.records.AWSKinesis.verify|verify} messages.
             * @function encode
             * @memberof protos.records.AWSKinesis
             * @static
             * @param {protos.records.IAWSKinesis} message AWSKinesis message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSKinesis.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.partitionKey != null && Object.hasOwnProperty.call(message, "partitionKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.partitionKey);
                if (message.sequenceNumber != null && Object.hasOwnProperty.call(message, "sequenceNumber"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.sequenceNumber);
                if (message.encryptionType != null && Object.hasOwnProperty.call(message, "encryptionType"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.encryptionType);
                if (message.shardId != null && Object.hasOwnProperty.call(message, "shardId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.shardId);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified AWSKinesis message, length delimited. Does not implicitly {@link protos.records.AWSKinesis.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.AWSKinesis
             * @static
             * @param {protos.records.IAWSKinesis} message AWSKinesis message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSKinesis.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSKinesis message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.AWSKinesis
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.AWSKinesis} AWSKinesis
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSKinesis.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.AWSKinesis();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.partitionKey = reader.string();
                        break;
                    case 2:
                        message.sequenceNumber = reader.string();
                        break;
                    case 3:
                        message.encryptionType = reader.string();
                        break;
                    case 4:
                        message.shardId = reader.string();
                        break;
                    case 5:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSKinesis message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.AWSKinesis
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.AWSKinesis} AWSKinesis
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSKinesis.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSKinesis message.
             * @function verify
             * @memberof protos.records.AWSKinesis
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSKinesis.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    if (!$util.isString(message.partitionKey))
                        return "partitionKey: string expected";
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    if (!$util.isString(message.sequenceNumber))
                        return "sequenceNumber: string expected";
                if (message.encryptionType != null && message.hasOwnProperty("encryptionType"))
                    if (!$util.isString(message.encryptionType))
                        return "encryptionType: string expected";
                if (message.shardId != null && message.hasOwnProperty("shardId"))
                    if (!$util.isString(message.shardId))
                        return "shardId: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a AWSKinesis message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.AWSKinesis
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.AWSKinesis} AWSKinesis
             */
            AWSKinesis.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.AWSKinesis)
                    return object;
                var message = new $root.protos.records.AWSKinesis();
                if (object.partitionKey != null)
                    message.partitionKey = String(object.partitionKey);
                if (object.sequenceNumber != null)
                    message.sequenceNumber = String(object.sequenceNumber);
                if (object.encryptionType != null)
                    message.encryptionType = String(object.encryptionType);
                if (object.shardId != null)
                    message.shardId = String(object.shardId);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a AWSKinesis message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.AWSKinesis
             * @static
             * @param {protos.records.AWSKinesis} message AWSKinesis
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSKinesis.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.partitionKey = "";
                    object.sequenceNumber = "";
                    object.encryptionType = "";
                    object.shardId = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    object.partitionKey = message.partitionKey;
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    object.sequenceNumber = message.sequenceNumber;
                if (message.encryptionType != null && message.hasOwnProperty("encryptionType"))
                    object.encryptionType = message.encryptionType;
                if (message.shardId != null && message.hasOwnProperty("shardId"))
                    object.shardId = message.shardId;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this AWSKinesis to JSON.
             * @function toJSON
             * @memberof protos.records.AWSKinesis
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSKinesis.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSKinesis;
        })();

        records.AWSSQS = (function() {

            /**
             * Properties of a AWSSQS.
             * @memberof protos.records
             * @interface IAWSSQS
             * @property {string|null} [id] AWSSQS id
             * @property {number|Long|null} [timestamp] AWSSQS timestamp
             * @property {string|null} [recipientHandle] AWSSQS recipientHandle
             * @property {Object.<string,string>|null} [attributes] AWSSQS attributes
             * @property {Uint8Array|null} [value] AWSSQS value
             */

            /**
             * Constructs a new AWSSQS.
             * @memberof protos.records
             * @classdesc Represents a AWSSQS.
             * @implements IAWSSQS
             * @constructor
             * @param {protos.records.IAWSSQS=} [properties] Properties to set
             */
            function AWSSQS(properties) {
                this.attributes = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AWSSQS id.
             * @member {string} id
             * @memberof protos.records.AWSSQS
             * @instance
             */
            AWSSQS.prototype.id = "";

            /**
             * AWSSQS timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.AWSSQS
             * @instance
             */
            AWSSQS.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AWSSQS recipientHandle.
             * @member {string} recipientHandle
             * @memberof protos.records.AWSSQS
             * @instance
             */
            AWSSQS.prototype.recipientHandle = "";

            /**
             * AWSSQS attributes.
             * @member {Object.<string,string>} attributes
             * @memberof protos.records.AWSSQS
             * @instance
             */
            AWSSQS.prototype.attributes = $util.emptyObject;

            /**
             * AWSSQS value.
             * @member {Uint8Array} value
             * @memberof protos.records.AWSSQS
             * @instance
             */
            AWSSQS.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new AWSSQS instance using the specified properties.
             * @function create
             * @memberof protos.records.AWSSQS
             * @static
             * @param {protos.records.IAWSSQS=} [properties] Properties to set
             * @returns {protos.records.AWSSQS} AWSSQS instance
             */
            AWSSQS.create = function create(properties) {
                return new AWSSQS(properties);
            };

            /**
             * Encodes the specified AWSSQS message. Does not implicitly {@link protos.records.AWSSQS.verify|verify} messages.
             * @function encode
             * @memberof protos.records.AWSSQS
             * @static
             * @param {protos.records.IAWSSQS} message AWSSQS message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQS.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                if (message.recipientHandle != null && Object.hasOwnProperty.call(message, "recipientHandle"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.recipientHandle);
                if (message.attributes != null && Object.hasOwnProperty.call(message, "attributes"))
                    for (var keys = Object.keys(message.attributes), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.attributes[keys[i]]).ldelim();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified AWSSQS message, length delimited. Does not implicitly {@link protos.records.AWSSQS.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.AWSSQS
             * @static
             * @param {protos.records.IAWSSQS} message AWSSQS message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AWSSQS.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a AWSSQS message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.AWSSQS
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.AWSSQS} AWSSQS
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQS.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.AWSSQS(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    case 3:
                        message.recipientHandle = reader.string();
                        break;
                    case 4:
                        if (message.attributes === $util.emptyObject)
                            message.attributes = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.attributes[key] = value;
                        break;
                    case 5:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a AWSSQS message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.AWSSQS
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.AWSSQS} AWSSQS
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AWSSQS.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a AWSSQS message.
             * @function verify
             * @memberof protos.records.AWSSQS
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AWSSQS.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.recipientHandle != null && message.hasOwnProperty("recipientHandle"))
                    if (!$util.isString(message.recipientHandle))
                        return "recipientHandle: string expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    if (!$util.isObject(message.attributes))
                        return "attributes: object expected";
                    var key = Object.keys(message.attributes);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.attributes[key[i]]))
                            return "attributes: string{k:string} expected";
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a AWSSQS message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.AWSSQS
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.AWSSQS} AWSSQS
             */
            AWSSQS.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.AWSSQS)
                    return object;
                var message = new $root.protos.records.AWSSQS();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.recipientHandle != null)
                    message.recipientHandle = String(object.recipientHandle);
                if (object.attributes) {
                    if (typeof object.attributes !== "object")
                        throw TypeError(".protos.records.AWSSQS.attributes: object expected");
                    message.attributes = {};
                    for (var keys = Object.keys(object.attributes), i = 0; i < keys.length; ++i)
                        message.attributes[keys[i]] = String(object.attributes[keys[i]]);
                }
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a AWSSQS message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.AWSSQS
             * @static
             * @param {protos.records.AWSSQS} message AWSSQS
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AWSSQS.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.attributes = {};
                if (options.defaults) {
                    object.id = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    object.recipientHandle = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.recipientHandle != null && message.hasOwnProperty("recipientHandle"))
                    object.recipientHandle = message.recipientHandle;
                var keys2;
                if (message.attributes && (keys2 = Object.keys(message.attributes)).length) {
                    object.attributes = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.attributes[keys2[j]] = message.attributes[keys2[j]];
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this AWSSQS to JSON.
             * @function toJSON
             * @memberof protos.records.AWSSQS
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AWSSQS.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AWSSQS;
        })();

        records.AzureEventHub = (function() {

            /**
             * Properties of an AzureEventHub.
             * @memberof protos.records
             * @interface IAzureEventHub
             * @property {string|null} [id] AzureEventHub id
             * @property {Object.<string,string>|null} [systemProperties] AzureEventHub systemProperties
             * @property {number|Long|null} [timestamp] AzureEventHub timestamp
             * @property {Uint8Array|null} [value] AzureEventHub value
             */

            /**
             * Constructs a new AzureEventHub.
             * @memberof protos.records
             * @classdesc Represents an AzureEventHub.
             * @implements IAzureEventHub
             * @constructor
             * @param {protos.records.IAzureEventHub=} [properties] Properties to set
             */
            function AzureEventHub(properties) {
                this.systemProperties = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureEventHub id.
             * @member {string} id
             * @memberof protos.records.AzureEventHub
             * @instance
             */
            AzureEventHub.prototype.id = "";

            /**
             * AzureEventHub systemProperties.
             * @member {Object.<string,string>} systemProperties
             * @memberof protos.records.AzureEventHub
             * @instance
             */
            AzureEventHub.prototype.systemProperties = $util.emptyObject;

            /**
             * AzureEventHub timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.AzureEventHub
             * @instance
             */
            AzureEventHub.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AzureEventHub value.
             * @member {Uint8Array} value
             * @memberof protos.records.AzureEventHub
             * @instance
             */
            AzureEventHub.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new AzureEventHub instance using the specified properties.
             * @function create
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {protos.records.IAzureEventHub=} [properties] Properties to set
             * @returns {protos.records.AzureEventHub} AzureEventHub instance
             */
            AzureEventHub.create = function create(properties) {
                return new AzureEventHub(properties);
            };

            /**
             * Encodes the specified AzureEventHub message. Does not implicitly {@link protos.records.AzureEventHub.verify|verify} messages.
             * @function encode
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {protos.records.IAzureEventHub} message AzureEventHub message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHub.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.systemProperties != null && Object.hasOwnProperty.call(message, "systemProperties"))
                    for (var keys = Object.keys(message.systemProperties), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.systemProperties[keys[i]]).ldelim();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified AzureEventHub message, length delimited. Does not implicitly {@link protos.records.AzureEventHub.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {protos.records.IAzureEventHub} message AzureEventHub message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureEventHub.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureEventHub message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.AzureEventHub} AzureEventHub
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHub.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.AzureEventHub(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        if (message.systemProperties === $util.emptyObject)
                            message.systemProperties = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.systemProperties[key] = value;
                        break;
                    case 3:
                        message.timestamp = reader.int64();
                        break;
                    case 4:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureEventHub message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.AzureEventHub} AzureEventHub
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureEventHub.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureEventHub message.
             * @function verify
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureEventHub.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.systemProperties != null && message.hasOwnProperty("systemProperties")) {
                    if (!$util.isObject(message.systemProperties))
                        return "systemProperties: object expected";
                    var key = Object.keys(message.systemProperties);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.systemProperties[key[i]]))
                            return "systemProperties: string{k:string} expected";
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an AzureEventHub message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.AzureEventHub} AzureEventHub
             */
            AzureEventHub.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.AzureEventHub)
                    return object;
                var message = new $root.protos.records.AzureEventHub();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.systemProperties) {
                    if (typeof object.systemProperties !== "object")
                        throw TypeError(".protos.records.AzureEventHub.systemProperties: object expected");
                    message.systemProperties = {};
                    for (var keys = Object.keys(object.systemProperties), i = 0; i < keys.length; ++i)
                        message.systemProperties[keys[i]] = String(object.systemProperties[keys[i]]);
                }
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an AzureEventHub message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.AzureEventHub
             * @static
             * @param {protos.records.AzureEventHub} message AzureEventHub
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureEventHub.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.systemProperties = {};
                if (options.defaults) {
                    object.id = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                var keys2;
                if (message.systemProperties && (keys2 = Object.keys(message.systemProperties)).length) {
                    object.systemProperties = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.systemProperties[keys2[j]] = message.systemProperties[keys2[j]];
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this AzureEventHub to JSON.
             * @function toJSON
             * @memberof protos.records.AzureEventHub
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureEventHub.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureEventHub;
        })();

        records.AzureServiceBus = (function() {

            /**
             * Properties of an AzureServiceBus.
             * @memberof protos.records
             * @interface IAzureServiceBus
             * @property {string|null} [contentType] AzureServiceBus contentType
             * @property {string|null} [correlationId] AzureServiceBus correlationId
             * @property {Uint8Array|null} [value] AzureServiceBus value
             * @property {number|null} [deliveryCount] AzureServiceBus deliveryCount
             * @property {string|null} [sessionId] AzureServiceBus sessionId
             * @property {number|null} [groupSequence] AzureServiceBus groupSequence
             * @property {string|null} [id] AzureServiceBus id
             * @property {string|null} [label] AzureServiceBus label
             * @property {string|null} [replyTo] AzureServiceBus replyTo
             * @property {string|null} [replyToGroupId] AzureServiceBus replyToGroupId
             * @property {string|null} [to] AzureServiceBus to
             * @property {number|Long|null} [ttl] AzureServiceBus ttl
             * @property {string|null} [lockToken] AzureServiceBus lockToken
             * @property {protos.records.IAzureSystemProperties|null} [systemProperties] AzureServiceBus systemProperties
             * @property {Object.<string,string>|null} [userProperties] AzureServiceBus userProperties
             * @property {number|null} [format] AzureServiceBus format
             */

            /**
             * Constructs a new AzureServiceBus.
             * @memberof protos.records
             * @classdesc Represents an AzureServiceBus.
             * @implements IAzureServiceBus
             * @constructor
             * @param {protos.records.IAzureServiceBus=} [properties] Properties to set
             */
            function AzureServiceBus(properties) {
                this.userProperties = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureServiceBus contentType.
             * @member {string} contentType
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.contentType = "";

            /**
             * AzureServiceBus correlationId.
             * @member {string} correlationId
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.correlationId = "";

            /**
             * AzureServiceBus value.
             * @member {Uint8Array} value
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.value = $util.newBuffer([]);

            /**
             * AzureServiceBus deliveryCount.
             * @member {number} deliveryCount
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.deliveryCount = 0;

            /**
             * AzureServiceBus sessionId.
             * @member {string} sessionId
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.sessionId = "";

            /**
             * AzureServiceBus groupSequence.
             * @member {number} groupSequence
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.groupSequence = 0;

            /**
             * AzureServiceBus id.
             * @member {string} id
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.id = "";

            /**
             * AzureServiceBus label.
             * @member {string} label
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.label = "";

            /**
             * AzureServiceBus replyTo.
             * @member {string} replyTo
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.replyTo = "";

            /**
             * AzureServiceBus replyToGroupId.
             * @member {string} replyToGroupId
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.replyToGroupId = "";

            /**
             * AzureServiceBus to.
             * @member {string} to
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.to = "";

            /**
             * AzureServiceBus ttl.
             * @member {number|Long} ttl
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.ttl = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AzureServiceBus lockToken.
             * @member {string} lockToken
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.lockToken = "";

            /**
             * AzureServiceBus systemProperties.
             * @member {protos.records.IAzureSystemProperties|null|undefined} systemProperties
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.systemProperties = null;

            /**
             * AzureServiceBus userProperties.
             * @member {Object.<string,string>} userProperties
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.userProperties = $util.emptyObject;

            /**
             * AzureServiceBus format.
             * @member {number} format
             * @memberof protos.records.AzureServiceBus
             * @instance
             */
            AzureServiceBus.prototype.format = 0;

            /**
             * Creates a new AzureServiceBus instance using the specified properties.
             * @function create
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {protos.records.IAzureServiceBus=} [properties] Properties to set
             * @returns {protos.records.AzureServiceBus} AzureServiceBus instance
             */
            AzureServiceBus.create = function create(properties) {
                return new AzureServiceBus(properties);
            };

            /**
             * Encodes the specified AzureServiceBus message. Does not implicitly {@link protos.records.AzureServiceBus.verify|verify} messages.
             * @function encode
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {protos.records.IAzureServiceBus} message AzureServiceBus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.contentType);
                if (message.correlationId != null && Object.hasOwnProperty.call(message, "correlationId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.correlationId);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                if (message.deliveryCount != null && Object.hasOwnProperty.call(message, "deliveryCount"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.deliveryCount);
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.sessionId);
                if (message.groupSequence != null && Object.hasOwnProperty.call(message, "groupSequence"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.groupSequence);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.id);
                if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.label);
                if (message.replyTo != null && Object.hasOwnProperty.call(message, "replyTo"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.replyTo);
                if (message.replyToGroupId != null && Object.hasOwnProperty.call(message, "replyToGroupId"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.replyToGroupId);
                if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.to);
                if (message.ttl != null && Object.hasOwnProperty.call(message, "ttl"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int64(message.ttl);
                if (message.lockToken != null && Object.hasOwnProperty.call(message, "lockToken"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.lockToken);
                if (message.systemProperties != null && Object.hasOwnProperty.call(message, "systemProperties"))
                    $root.protos.records.AzureSystemProperties.encode(message.systemProperties, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.userProperties != null && Object.hasOwnProperty.call(message, "userProperties"))
                    for (var keys = Object.keys(message.userProperties), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 15, wireType 2 =*/122).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.userProperties[keys[i]]).ldelim();
                if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                    writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.format);
                return writer;
            };

            /**
             * Encodes the specified AzureServiceBus message, length delimited. Does not implicitly {@link protos.records.AzureServiceBus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {protos.records.IAzureServiceBus} message AzureServiceBus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureServiceBus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureServiceBus message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.AzureServiceBus} AzureServiceBus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.AzureServiceBus(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.contentType = reader.string();
                        break;
                    case 2:
                        message.correlationId = reader.string();
                        break;
                    case 3:
                        message.value = reader.bytes();
                        break;
                    case 4:
                        message.deliveryCount = reader.uint32();
                        break;
                    case 5:
                        message.sessionId = reader.string();
                        break;
                    case 6:
                        message.groupSequence = reader.uint32();
                        break;
                    case 7:
                        message.id = reader.string();
                        break;
                    case 8:
                        message.label = reader.string();
                        break;
                    case 9:
                        message.replyTo = reader.string();
                        break;
                    case 10:
                        message.replyToGroupId = reader.string();
                        break;
                    case 11:
                        message.to = reader.string();
                        break;
                    case 12:
                        message.ttl = reader.int64();
                        break;
                    case 13:
                        message.lockToken = reader.string();
                        break;
                    case 14:
                        message.systemProperties = $root.protos.records.AzureSystemProperties.decode(reader, reader.uint32());
                        break;
                    case 15:
                        if (message.userProperties === $util.emptyObject)
                            message.userProperties = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.userProperties[key] = value;
                        break;
                    case 16:
                        message.format = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureServiceBus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.AzureServiceBus} AzureServiceBus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureServiceBus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureServiceBus message.
             * @function verify
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureServiceBus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    if (!$util.isString(message.contentType))
                        return "contentType: string expected";
                if (message.correlationId != null && message.hasOwnProperty("correlationId"))
                    if (!$util.isString(message.correlationId))
                        return "correlationId: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.deliveryCount != null && message.hasOwnProperty("deliveryCount"))
                    if (!$util.isInteger(message.deliveryCount))
                        return "deliveryCount: integer expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.groupSequence != null && message.hasOwnProperty("groupSequence"))
                    if (!$util.isInteger(message.groupSequence))
                        return "groupSequence: integer expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    if (!$util.isString(message.label))
                        return "label: string expected";
                if (message.replyTo != null && message.hasOwnProperty("replyTo"))
                    if (!$util.isString(message.replyTo))
                        return "replyTo: string expected";
                if (message.replyToGroupId != null && message.hasOwnProperty("replyToGroupId"))
                    if (!$util.isString(message.replyToGroupId))
                        return "replyToGroupId: string expected";
                if (message.to != null && message.hasOwnProperty("to"))
                    if (!$util.isString(message.to))
                        return "to: string expected";
                if (message.ttl != null && message.hasOwnProperty("ttl"))
                    if (!$util.isInteger(message.ttl) && !(message.ttl && $util.isInteger(message.ttl.low) && $util.isInteger(message.ttl.high)))
                        return "ttl: integer|Long expected";
                if (message.lockToken != null && message.hasOwnProperty("lockToken"))
                    if (!$util.isString(message.lockToken))
                        return "lockToken: string expected";
                if (message.systemProperties != null && message.hasOwnProperty("systemProperties")) {
                    var error = $root.protos.records.AzureSystemProperties.verify(message.systemProperties);
                    if (error)
                        return "systemProperties." + error;
                }
                if (message.userProperties != null && message.hasOwnProperty("userProperties")) {
                    if (!$util.isObject(message.userProperties))
                        return "userProperties: object expected";
                    var key = Object.keys(message.userProperties);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.userProperties[key[i]]))
                            return "userProperties: string{k:string} expected";
                }
                if (message.format != null && message.hasOwnProperty("format"))
                    if (!$util.isInteger(message.format))
                        return "format: integer expected";
                return null;
            };

            /**
             * Creates an AzureServiceBus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.AzureServiceBus} AzureServiceBus
             */
            AzureServiceBus.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.AzureServiceBus)
                    return object;
                var message = new $root.protos.records.AzureServiceBus();
                if (object.contentType != null)
                    message.contentType = String(object.contentType);
                if (object.correlationId != null)
                    message.correlationId = String(object.correlationId);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.deliveryCount != null)
                    message.deliveryCount = object.deliveryCount >>> 0;
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.groupSequence != null)
                    message.groupSequence = object.groupSequence >>> 0;
                if (object.id != null)
                    message.id = String(object.id);
                if (object.label != null)
                    message.label = String(object.label);
                if (object.replyTo != null)
                    message.replyTo = String(object.replyTo);
                if (object.replyToGroupId != null)
                    message.replyToGroupId = String(object.replyToGroupId);
                if (object.to != null)
                    message.to = String(object.to);
                if (object.ttl != null)
                    if ($util.Long)
                        (message.ttl = $util.Long.fromValue(object.ttl)).unsigned = false;
                    else if (typeof object.ttl === "string")
                        message.ttl = parseInt(object.ttl, 10);
                    else if (typeof object.ttl === "number")
                        message.ttl = object.ttl;
                    else if (typeof object.ttl === "object")
                        message.ttl = new $util.LongBits(object.ttl.low >>> 0, object.ttl.high >>> 0).toNumber();
                if (object.lockToken != null)
                    message.lockToken = String(object.lockToken);
                if (object.systemProperties != null) {
                    if (typeof object.systemProperties !== "object")
                        throw TypeError(".protos.records.AzureServiceBus.systemProperties: object expected");
                    message.systemProperties = $root.protos.records.AzureSystemProperties.fromObject(object.systemProperties);
                }
                if (object.userProperties) {
                    if (typeof object.userProperties !== "object")
                        throw TypeError(".protos.records.AzureServiceBus.userProperties: object expected");
                    message.userProperties = {};
                    for (var keys = Object.keys(object.userProperties), i = 0; i < keys.length; ++i)
                        message.userProperties[keys[i]] = String(object.userProperties[keys[i]]);
                }
                if (object.format != null)
                    message.format = object.format >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an AzureServiceBus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.AzureServiceBus
             * @static
             * @param {protos.records.AzureServiceBus} message AzureServiceBus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureServiceBus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.userProperties = {};
                if (options.defaults) {
                    object.contentType = "";
                    object.correlationId = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    object.deliveryCount = 0;
                    object.sessionId = "";
                    object.groupSequence = 0;
                    object.id = "";
                    object.label = "";
                    object.replyTo = "";
                    object.replyToGroupId = "";
                    object.to = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ttl = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ttl = options.longs === String ? "0" : 0;
                    object.lockToken = "";
                    object.systemProperties = null;
                    object.format = 0;
                }
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    object.contentType = message.contentType;
                if (message.correlationId != null && message.hasOwnProperty("correlationId"))
                    object.correlationId = message.correlationId;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.deliveryCount != null && message.hasOwnProperty("deliveryCount"))
                    object.deliveryCount = message.deliveryCount;
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.groupSequence != null && message.hasOwnProperty("groupSequence"))
                    object.groupSequence = message.groupSequence;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = message.label;
                if (message.replyTo != null && message.hasOwnProperty("replyTo"))
                    object.replyTo = message.replyTo;
                if (message.replyToGroupId != null && message.hasOwnProperty("replyToGroupId"))
                    object.replyToGroupId = message.replyToGroupId;
                if (message.to != null && message.hasOwnProperty("to"))
                    object.to = message.to;
                if (message.ttl != null && message.hasOwnProperty("ttl"))
                    if (typeof message.ttl === "number")
                        object.ttl = options.longs === String ? String(message.ttl) : message.ttl;
                    else
                        object.ttl = options.longs === String ? $util.Long.prototype.toString.call(message.ttl) : options.longs === Number ? new $util.LongBits(message.ttl.low >>> 0, message.ttl.high >>> 0).toNumber() : message.ttl;
                if (message.lockToken != null && message.hasOwnProperty("lockToken"))
                    object.lockToken = message.lockToken;
                if (message.systemProperties != null && message.hasOwnProperty("systemProperties"))
                    object.systemProperties = $root.protos.records.AzureSystemProperties.toObject(message.systemProperties, options);
                var keys2;
                if (message.userProperties && (keys2 = Object.keys(message.userProperties)).length) {
                    object.userProperties = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.userProperties[keys2[j]] = message.userProperties[keys2[j]];
                }
                if (message.format != null && message.hasOwnProperty("format"))
                    object.format = message.format;
                return object;
            };

            /**
             * Converts this AzureServiceBus to JSON.
             * @function toJSON
             * @memberof protos.records.AzureServiceBus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureServiceBus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureServiceBus;
        })();

        records.AzureSystemProperties = (function() {

            /**
             * Properties of an AzureSystemProperties.
             * @memberof protos.records
             * @interface IAzureSystemProperties
             * @property {number|Long|null} [lockedUntil] AzureSystemProperties lockedUntil
             * @property {number|Long|null} [sequenceNumber] AzureSystemProperties sequenceNumber
             * @property {number|null} [partitionId] AzureSystemProperties partitionId
             * @property {string|null} [partitionKey] AzureSystemProperties partitionKey
             * @property {number|Long|null} [enqueuedTime] AzureSystemProperties enqueuedTime
             * @property {string|null} [deadLetterSource] AzureSystemProperties deadLetterSource
             * @property {number|Long|null} [scheduledEnqueueTime] AzureSystemProperties scheduledEnqueueTime
             * @property {number|Long|null} [enqueuedSequenceNumber] AzureSystemProperties enqueuedSequenceNumber
             * @property {string|null} [viaPartitionKey] AzureSystemProperties viaPartitionKey
             * @property {Object.<string,string>|null} [annotations] AzureSystemProperties annotations
             */

            /**
             * Constructs a new AzureSystemProperties.
             * @memberof protos.records
             * @classdesc Represents an AzureSystemProperties.
             * @implements IAzureSystemProperties
             * @constructor
             * @param {protos.records.IAzureSystemProperties=} [properties] Properties to set
             */
            function AzureSystemProperties(properties) {
                this.annotations = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzureSystemProperties lockedUntil.
             * @member {number|Long} lockedUntil
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.lockedUntil = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AzureSystemProperties sequenceNumber.
             * @member {number|Long} sequenceNumber
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AzureSystemProperties partitionId.
             * @member {number} partitionId
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.partitionId = 0;

            /**
             * AzureSystemProperties partitionKey.
             * @member {string} partitionKey
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.partitionKey = "";

            /**
             * AzureSystemProperties enqueuedTime.
             * @member {number|Long} enqueuedTime
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.enqueuedTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AzureSystemProperties deadLetterSource.
             * @member {string} deadLetterSource
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.deadLetterSource = "";

            /**
             * AzureSystemProperties scheduledEnqueueTime.
             * @member {number|Long} scheduledEnqueueTime
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.scheduledEnqueueTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AzureSystemProperties enqueuedSequenceNumber.
             * @member {number|Long} enqueuedSequenceNumber
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.enqueuedSequenceNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AzureSystemProperties viaPartitionKey.
             * @member {string} viaPartitionKey
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.viaPartitionKey = "";

            /**
             * AzureSystemProperties annotations.
             * @member {Object.<string,string>} annotations
             * @memberof protos.records.AzureSystemProperties
             * @instance
             */
            AzureSystemProperties.prototype.annotations = $util.emptyObject;

            /**
             * Creates a new AzureSystemProperties instance using the specified properties.
             * @function create
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {protos.records.IAzureSystemProperties=} [properties] Properties to set
             * @returns {protos.records.AzureSystemProperties} AzureSystemProperties instance
             */
            AzureSystemProperties.create = function create(properties) {
                return new AzureSystemProperties(properties);
            };

            /**
             * Encodes the specified AzureSystemProperties message. Does not implicitly {@link protos.records.AzureSystemProperties.verify|verify} messages.
             * @function encode
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {protos.records.IAzureSystemProperties} message AzureSystemProperties message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureSystemProperties.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.lockedUntil != null && Object.hasOwnProperty.call(message, "lockedUntil"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.lockedUntil);
                if (message.sequenceNumber != null && Object.hasOwnProperty.call(message, "sequenceNumber"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.sequenceNumber);
                if (message.partitionId != null && Object.hasOwnProperty.call(message, "partitionId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.partitionId);
                if (message.partitionKey != null && Object.hasOwnProperty.call(message, "partitionKey"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.partitionKey);
                if (message.enqueuedTime != null && Object.hasOwnProperty.call(message, "enqueuedTime"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.enqueuedTime);
                if (message.deadLetterSource != null && Object.hasOwnProperty.call(message, "deadLetterSource"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.deadLetterSource);
                if (message.scheduledEnqueueTime != null && Object.hasOwnProperty.call(message, "scheduledEnqueueTime"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.scheduledEnqueueTime);
                if (message.enqueuedSequenceNumber != null && Object.hasOwnProperty.call(message, "enqueuedSequenceNumber"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int64(message.enqueuedSequenceNumber);
                if (message.viaPartitionKey != null && Object.hasOwnProperty.call(message, "viaPartitionKey"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.viaPartitionKey);
                if (message.annotations != null && Object.hasOwnProperty.call(message, "annotations"))
                    for (var keys = Object.keys(message.annotations), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.annotations[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AzureSystemProperties message, length delimited. Does not implicitly {@link protos.records.AzureSystemProperties.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {protos.records.IAzureSystemProperties} message AzureSystemProperties message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzureSystemProperties.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzureSystemProperties message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.AzureSystemProperties} AzureSystemProperties
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureSystemProperties.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.AzureSystemProperties(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.lockedUntil = reader.int64();
                        break;
                    case 2:
                        message.sequenceNumber = reader.int64();
                        break;
                    case 3:
                        message.partitionId = reader.int32();
                        break;
                    case 4:
                        message.partitionKey = reader.string();
                        break;
                    case 5:
                        message.enqueuedTime = reader.int64();
                        break;
                    case 6:
                        message.deadLetterSource = reader.string();
                        break;
                    case 7:
                        message.scheduledEnqueueTime = reader.int64();
                        break;
                    case 8:
                        message.enqueuedSequenceNumber = reader.int64();
                        break;
                    case 9:
                        message.viaPartitionKey = reader.string();
                        break;
                    case 10:
                        if (message.annotations === $util.emptyObject)
                            message.annotations = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.annotations[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzureSystemProperties message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.AzureSystemProperties} AzureSystemProperties
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzureSystemProperties.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzureSystemProperties message.
             * @function verify
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzureSystemProperties.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.lockedUntil != null && message.hasOwnProperty("lockedUntil"))
                    if (!$util.isInteger(message.lockedUntil) && !(message.lockedUntil && $util.isInteger(message.lockedUntil.low) && $util.isInteger(message.lockedUntil.high)))
                        return "lockedUntil: integer|Long expected";
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    if (!$util.isInteger(message.sequenceNumber) && !(message.sequenceNumber && $util.isInteger(message.sequenceNumber.low) && $util.isInteger(message.sequenceNumber.high)))
                        return "sequenceNumber: integer|Long expected";
                if (message.partitionId != null && message.hasOwnProperty("partitionId"))
                    if (!$util.isInteger(message.partitionId))
                        return "partitionId: integer expected";
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    if (!$util.isString(message.partitionKey))
                        return "partitionKey: string expected";
                if (message.enqueuedTime != null && message.hasOwnProperty("enqueuedTime"))
                    if (!$util.isInteger(message.enqueuedTime) && !(message.enqueuedTime && $util.isInteger(message.enqueuedTime.low) && $util.isInteger(message.enqueuedTime.high)))
                        return "enqueuedTime: integer|Long expected";
                if (message.deadLetterSource != null && message.hasOwnProperty("deadLetterSource"))
                    if (!$util.isString(message.deadLetterSource))
                        return "deadLetterSource: string expected";
                if (message.scheduledEnqueueTime != null && message.hasOwnProperty("scheduledEnqueueTime"))
                    if (!$util.isInteger(message.scheduledEnqueueTime) && !(message.scheduledEnqueueTime && $util.isInteger(message.scheduledEnqueueTime.low) && $util.isInteger(message.scheduledEnqueueTime.high)))
                        return "scheduledEnqueueTime: integer|Long expected";
                if (message.enqueuedSequenceNumber != null && message.hasOwnProperty("enqueuedSequenceNumber"))
                    if (!$util.isInteger(message.enqueuedSequenceNumber) && !(message.enqueuedSequenceNumber && $util.isInteger(message.enqueuedSequenceNumber.low) && $util.isInteger(message.enqueuedSequenceNumber.high)))
                        return "enqueuedSequenceNumber: integer|Long expected";
                if (message.viaPartitionKey != null && message.hasOwnProperty("viaPartitionKey"))
                    if (!$util.isString(message.viaPartitionKey))
                        return "viaPartitionKey: string expected";
                if (message.annotations != null && message.hasOwnProperty("annotations")) {
                    if (!$util.isObject(message.annotations))
                        return "annotations: object expected";
                    var key = Object.keys(message.annotations);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.annotations[key[i]]))
                            return "annotations: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates an AzureSystemProperties message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.AzureSystemProperties} AzureSystemProperties
             */
            AzureSystemProperties.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.AzureSystemProperties)
                    return object;
                var message = new $root.protos.records.AzureSystemProperties();
                if (object.lockedUntil != null)
                    if ($util.Long)
                        (message.lockedUntil = $util.Long.fromValue(object.lockedUntil)).unsigned = false;
                    else if (typeof object.lockedUntil === "string")
                        message.lockedUntil = parseInt(object.lockedUntil, 10);
                    else if (typeof object.lockedUntil === "number")
                        message.lockedUntil = object.lockedUntil;
                    else if (typeof object.lockedUntil === "object")
                        message.lockedUntil = new $util.LongBits(object.lockedUntil.low >>> 0, object.lockedUntil.high >>> 0).toNumber();
                if (object.sequenceNumber != null)
                    if ($util.Long)
                        (message.sequenceNumber = $util.Long.fromValue(object.sequenceNumber)).unsigned = false;
                    else if (typeof object.sequenceNumber === "string")
                        message.sequenceNumber = parseInt(object.sequenceNumber, 10);
                    else if (typeof object.sequenceNumber === "number")
                        message.sequenceNumber = object.sequenceNumber;
                    else if (typeof object.sequenceNumber === "object")
                        message.sequenceNumber = new $util.LongBits(object.sequenceNumber.low >>> 0, object.sequenceNumber.high >>> 0).toNumber();
                if (object.partitionId != null)
                    message.partitionId = object.partitionId | 0;
                if (object.partitionKey != null)
                    message.partitionKey = String(object.partitionKey);
                if (object.enqueuedTime != null)
                    if ($util.Long)
                        (message.enqueuedTime = $util.Long.fromValue(object.enqueuedTime)).unsigned = false;
                    else if (typeof object.enqueuedTime === "string")
                        message.enqueuedTime = parseInt(object.enqueuedTime, 10);
                    else if (typeof object.enqueuedTime === "number")
                        message.enqueuedTime = object.enqueuedTime;
                    else if (typeof object.enqueuedTime === "object")
                        message.enqueuedTime = new $util.LongBits(object.enqueuedTime.low >>> 0, object.enqueuedTime.high >>> 0).toNumber();
                if (object.deadLetterSource != null)
                    message.deadLetterSource = String(object.deadLetterSource);
                if (object.scheduledEnqueueTime != null)
                    if ($util.Long)
                        (message.scheduledEnqueueTime = $util.Long.fromValue(object.scheduledEnqueueTime)).unsigned = false;
                    else if (typeof object.scheduledEnqueueTime === "string")
                        message.scheduledEnqueueTime = parseInt(object.scheduledEnqueueTime, 10);
                    else if (typeof object.scheduledEnqueueTime === "number")
                        message.scheduledEnqueueTime = object.scheduledEnqueueTime;
                    else if (typeof object.scheduledEnqueueTime === "object")
                        message.scheduledEnqueueTime = new $util.LongBits(object.scheduledEnqueueTime.low >>> 0, object.scheduledEnqueueTime.high >>> 0).toNumber();
                if (object.enqueuedSequenceNumber != null)
                    if ($util.Long)
                        (message.enqueuedSequenceNumber = $util.Long.fromValue(object.enqueuedSequenceNumber)).unsigned = false;
                    else if (typeof object.enqueuedSequenceNumber === "string")
                        message.enqueuedSequenceNumber = parseInt(object.enqueuedSequenceNumber, 10);
                    else if (typeof object.enqueuedSequenceNumber === "number")
                        message.enqueuedSequenceNumber = object.enqueuedSequenceNumber;
                    else if (typeof object.enqueuedSequenceNumber === "object")
                        message.enqueuedSequenceNumber = new $util.LongBits(object.enqueuedSequenceNumber.low >>> 0, object.enqueuedSequenceNumber.high >>> 0).toNumber();
                if (object.viaPartitionKey != null)
                    message.viaPartitionKey = String(object.viaPartitionKey);
                if (object.annotations) {
                    if (typeof object.annotations !== "object")
                        throw TypeError(".protos.records.AzureSystemProperties.annotations: object expected");
                    message.annotations = {};
                    for (var keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i)
                        message.annotations[keys[i]] = String(object.annotations[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from an AzureSystemProperties message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.AzureSystemProperties
             * @static
             * @param {protos.records.AzureSystemProperties} message AzureSystemProperties
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzureSystemProperties.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.annotations = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.lockedUntil = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lockedUntil = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.sequenceNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sequenceNumber = options.longs === String ? "0" : 0;
                    object.partitionId = 0;
                    object.partitionKey = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.enqueuedTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.enqueuedTime = options.longs === String ? "0" : 0;
                    object.deadLetterSource = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.scheduledEnqueueTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.scheduledEnqueueTime = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.enqueuedSequenceNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.enqueuedSequenceNumber = options.longs === String ? "0" : 0;
                    object.viaPartitionKey = "";
                }
                if (message.lockedUntil != null && message.hasOwnProperty("lockedUntil"))
                    if (typeof message.lockedUntil === "number")
                        object.lockedUntil = options.longs === String ? String(message.lockedUntil) : message.lockedUntil;
                    else
                        object.lockedUntil = options.longs === String ? $util.Long.prototype.toString.call(message.lockedUntil) : options.longs === Number ? new $util.LongBits(message.lockedUntil.low >>> 0, message.lockedUntil.high >>> 0).toNumber() : message.lockedUntil;
                if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                    if (typeof message.sequenceNumber === "number")
                        object.sequenceNumber = options.longs === String ? String(message.sequenceNumber) : message.sequenceNumber;
                    else
                        object.sequenceNumber = options.longs === String ? $util.Long.prototype.toString.call(message.sequenceNumber) : options.longs === Number ? new $util.LongBits(message.sequenceNumber.low >>> 0, message.sequenceNumber.high >>> 0).toNumber() : message.sequenceNumber;
                if (message.partitionId != null && message.hasOwnProperty("partitionId"))
                    object.partitionId = message.partitionId;
                if (message.partitionKey != null && message.hasOwnProperty("partitionKey"))
                    object.partitionKey = message.partitionKey;
                if (message.enqueuedTime != null && message.hasOwnProperty("enqueuedTime"))
                    if (typeof message.enqueuedTime === "number")
                        object.enqueuedTime = options.longs === String ? String(message.enqueuedTime) : message.enqueuedTime;
                    else
                        object.enqueuedTime = options.longs === String ? $util.Long.prototype.toString.call(message.enqueuedTime) : options.longs === Number ? new $util.LongBits(message.enqueuedTime.low >>> 0, message.enqueuedTime.high >>> 0).toNumber() : message.enqueuedTime;
                if (message.deadLetterSource != null && message.hasOwnProperty("deadLetterSource"))
                    object.deadLetterSource = message.deadLetterSource;
                if (message.scheduledEnqueueTime != null && message.hasOwnProperty("scheduledEnqueueTime"))
                    if (typeof message.scheduledEnqueueTime === "number")
                        object.scheduledEnqueueTime = options.longs === String ? String(message.scheduledEnqueueTime) : message.scheduledEnqueueTime;
                    else
                        object.scheduledEnqueueTime = options.longs === String ? $util.Long.prototype.toString.call(message.scheduledEnqueueTime) : options.longs === Number ? new $util.LongBits(message.scheduledEnqueueTime.low >>> 0, message.scheduledEnqueueTime.high >>> 0).toNumber() : message.scheduledEnqueueTime;
                if (message.enqueuedSequenceNumber != null && message.hasOwnProperty("enqueuedSequenceNumber"))
                    if (typeof message.enqueuedSequenceNumber === "number")
                        object.enqueuedSequenceNumber = options.longs === String ? String(message.enqueuedSequenceNumber) : message.enqueuedSequenceNumber;
                    else
                        object.enqueuedSequenceNumber = options.longs === String ? $util.Long.prototype.toString.call(message.enqueuedSequenceNumber) : options.longs === Number ? new $util.LongBits(message.enqueuedSequenceNumber.low >>> 0, message.enqueuedSequenceNumber.high >>> 0).toNumber() : message.enqueuedSequenceNumber;
                if (message.viaPartitionKey != null && message.hasOwnProperty("viaPartitionKey"))
                    object.viaPartitionKey = message.viaPartitionKey;
                var keys2;
                if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                    object.annotations = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.annotations[keys2[j]] = message.annotations[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this AzureSystemProperties to JSON.
             * @function toJSON
             * @memberof protos.records.AzureSystemProperties
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzureSystemProperties.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzureSystemProperties;
        })();

        records.GCPPubSub = (function() {

            /**
             * Properties of a GCPPubSub.
             * @memberof protos.records
             * @interface IGCPPubSub
             * @property {string|null} [id] GCPPubSub id
             * @property {Uint8Array|null} [value] GCPPubSub value
             * @property {Object.<string,string>|null} [attributes] GCPPubSub attributes
             * @property {number|Long|null} [publishTime] GCPPubSub publishTime
             * @property {number|null} [deliveryAttempt] GCPPubSub deliveryAttempt
             * @property {string|null} [orderingKey] GCPPubSub orderingKey
             */

            /**
             * Constructs a new GCPPubSub.
             * @memberof protos.records
             * @classdesc Represents a GCPPubSub.
             * @implements IGCPPubSub
             * @constructor
             * @param {protos.records.IGCPPubSub=} [properties] Properties to set
             */
            function GCPPubSub(properties) {
                this.attributes = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GCPPubSub id.
             * @member {string} id
             * @memberof protos.records.GCPPubSub
             * @instance
             */
            GCPPubSub.prototype.id = "";

            /**
             * GCPPubSub value.
             * @member {Uint8Array} value
             * @memberof protos.records.GCPPubSub
             * @instance
             */
            GCPPubSub.prototype.value = $util.newBuffer([]);

            /**
             * GCPPubSub attributes.
             * @member {Object.<string,string>} attributes
             * @memberof protos.records.GCPPubSub
             * @instance
             */
            GCPPubSub.prototype.attributes = $util.emptyObject;

            /**
             * GCPPubSub publishTime.
             * @member {number|Long} publishTime
             * @memberof protos.records.GCPPubSub
             * @instance
             */
            GCPPubSub.prototype.publishTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * GCPPubSub deliveryAttempt.
             * @member {number} deliveryAttempt
             * @memberof protos.records.GCPPubSub
             * @instance
             */
            GCPPubSub.prototype.deliveryAttempt = 0;

            /**
             * GCPPubSub orderingKey.
             * @member {string} orderingKey
             * @memberof protos.records.GCPPubSub
             * @instance
             */
            GCPPubSub.prototype.orderingKey = "";

            /**
             * Creates a new GCPPubSub instance using the specified properties.
             * @function create
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {protos.records.IGCPPubSub=} [properties] Properties to set
             * @returns {protos.records.GCPPubSub} GCPPubSub instance
             */
            GCPPubSub.create = function create(properties) {
                return new GCPPubSub(properties);
            };

            /**
             * Encodes the specified GCPPubSub message. Does not implicitly {@link protos.records.GCPPubSub.verify|verify} messages.
             * @function encode
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {protos.records.IGCPPubSub} message GCPPubSub message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSub.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                if (message.attributes != null && Object.hasOwnProperty.call(message, "attributes"))
                    for (var keys = Object.keys(message.attributes), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.attributes[keys[i]]).ldelim();
                if (message.publishTime != null && Object.hasOwnProperty.call(message, "publishTime"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.publishTime);
                if (message.deliveryAttempt != null && Object.hasOwnProperty.call(message, "deliveryAttempt"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.deliveryAttempt);
                if (message.orderingKey != null && Object.hasOwnProperty.call(message, "orderingKey"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.orderingKey);
                return writer;
            };

            /**
             * Encodes the specified GCPPubSub message, length delimited. Does not implicitly {@link protos.records.GCPPubSub.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {protos.records.IGCPPubSub} message GCPPubSub message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPPubSub.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GCPPubSub message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.GCPPubSub} GCPPubSub
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSub.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.GCPPubSub(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    case 3:
                        if (message.attributes === $util.emptyObject)
                            message.attributes = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.attributes[key] = value;
                        break;
                    case 4:
                        message.publishTime = reader.int64();
                        break;
                    case 5:
                        message.deliveryAttempt = reader.int32();
                        break;
                    case 6:
                        message.orderingKey = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GCPPubSub message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.GCPPubSub} GCPPubSub
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPPubSub.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GCPPubSub message.
             * @function verify
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GCPPubSub.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    if (!$util.isObject(message.attributes))
                        return "attributes: object expected";
                    var key = Object.keys(message.attributes);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.attributes[key[i]]))
                            return "attributes: string{k:string} expected";
                }
                if (message.publishTime != null && message.hasOwnProperty("publishTime"))
                    if (!$util.isInteger(message.publishTime) && !(message.publishTime && $util.isInteger(message.publishTime.low) && $util.isInteger(message.publishTime.high)))
                        return "publishTime: integer|Long expected";
                if (message.deliveryAttempt != null && message.hasOwnProperty("deliveryAttempt"))
                    if (!$util.isInteger(message.deliveryAttempt))
                        return "deliveryAttempt: integer expected";
                if (message.orderingKey != null && message.hasOwnProperty("orderingKey"))
                    if (!$util.isString(message.orderingKey))
                        return "orderingKey: string expected";
                return null;
            };

            /**
             * Creates a GCPPubSub message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.GCPPubSub} GCPPubSub
             */
            GCPPubSub.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.GCPPubSub)
                    return object;
                var message = new $root.protos.records.GCPPubSub();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.attributes) {
                    if (typeof object.attributes !== "object")
                        throw TypeError(".protos.records.GCPPubSub.attributes: object expected");
                    message.attributes = {};
                    for (var keys = Object.keys(object.attributes), i = 0; i < keys.length; ++i)
                        message.attributes[keys[i]] = String(object.attributes[keys[i]]);
                }
                if (object.publishTime != null)
                    if ($util.Long)
                        (message.publishTime = $util.Long.fromValue(object.publishTime)).unsigned = false;
                    else if (typeof object.publishTime === "string")
                        message.publishTime = parseInt(object.publishTime, 10);
                    else if (typeof object.publishTime === "number")
                        message.publishTime = object.publishTime;
                    else if (typeof object.publishTime === "object")
                        message.publishTime = new $util.LongBits(object.publishTime.low >>> 0, object.publishTime.high >>> 0).toNumber();
                if (object.deliveryAttempt != null)
                    message.deliveryAttempt = object.deliveryAttempt | 0;
                if (object.orderingKey != null)
                    message.orderingKey = String(object.orderingKey);
                return message;
            };

            /**
             * Creates a plain object from a GCPPubSub message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.GCPPubSub
             * @static
             * @param {protos.records.GCPPubSub} message GCPPubSub
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GCPPubSub.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.attributes = {};
                if (options.defaults) {
                    object.id = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.publishTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.publishTime = options.longs === String ? "0" : 0;
                    object.deliveryAttempt = 0;
                    object.orderingKey = "";
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                var keys2;
                if (message.attributes && (keys2 = Object.keys(message.attributes)).length) {
                    object.attributes = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.attributes[keys2[j]] = message.attributes[keys2[j]];
                }
                if (message.publishTime != null && message.hasOwnProperty("publishTime"))
                    if (typeof message.publishTime === "number")
                        object.publishTime = options.longs === String ? String(message.publishTime) : message.publishTime;
                    else
                        object.publishTime = options.longs === String ? $util.Long.prototype.toString.call(message.publishTime) : options.longs === Number ? new $util.LongBits(message.publishTime.low >>> 0, message.publishTime.high >>> 0).toNumber() : message.publishTime;
                if (message.deliveryAttempt != null && message.hasOwnProperty("deliveryAttempt"))
                    object.deliveryAttempt = message.deliveryAttempt;
                if (message.orderingKey != null && message.hasOwnProperty("orderingKey"))
                    object.orderingKey = message.orderingKey;
                return object;
            };

            /**
             * Converts this GCPPubSub to JSON.
             * @function toJSON
             * @memberof protos.records.GCPPubSub
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GCPPubSub.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GCPPubSub;
        })();

        records.KafkaHeader = (function() {

            /**
             * Properties of a KafkaHeader.
             * @memberof protos.records
             * @interface IKafkaHeader
             * @property {string|null} [key] KafkaHeader key
             * @property {string|null} [value] KafkaHeader value
             */

            /**
             * Constructs a new KafkaHeader.
             * @memberof protos.records
             * @classdesc Represents a KafkaHeader.
             * @implements IKafkaHeader
             * @constructor
             * @param {protos.records.IKafkaHeader=} [properties] Properties to set
             */
            function KafkaHeader(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KafkaHeader key.
             * @member {string} key
             * @memberof protos.records.KafkaHeader
             * @instance
             */
            KafkaHeader.prototype.key = "";

            /**
             * KafkaHeader value.
             * @member {string} value
             * @memberof protos.records.KafkaHeader
             * @instance
             */
            KafkaHeader.prototype.value = "";

            /**
             * Creates a new KafkaHeader instance using the specified properties.
             * @function create
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {protos.records.IKafkaHeader=} [properties] Properties to set
             * @returns {protos.records.KafkaHeader} KafkaHeader instance
             */
            KafkaHeader.create = function create(properties) {
                return new KafkaHeader(properties);
            };

            /**
             * Encodes the specified KafkaHeader message. Does not implicitly {@link protos.records.KafkaHeader.verify|verify} messages.
             * @function encode
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {protos.records.IKafkaHeader} message KafkaHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaHeader.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };

            /**
             * Encodes the specified KafkaHeader message, length delimited. Does not implicitly {@link protos.records.KafkaHeader.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {protos.records.IKafkaHeader} message KafkaHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaHeader.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KafkaHeader message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.KafkaHeader} KafkaHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaHeader.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.KafkaHeader();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KafkaHeader message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.KafkaHeader} KafkaHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaHeader.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KafkaHeader message.
             * @function verify
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaHeader.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };

            /**
             * Creates a KafkaHeader message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.KafkaHeader} KafkaHeader
             */
            KafkaHeader.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.KafkaHeader)
                    return object;
                var message = new $root.protos.records.KafkaHeader();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };

            /**
             * Creates a plain object from a KafkaHeader message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.KafkaHeader
             * @static
             * @param {protos.records.KafkaHeader} message KafkaHeader
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaHeader.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.value = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this KafkaHeader to JSON.
             * @function toJSON
             * @memberof protos.records.KafkaHeader
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaHeader.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KafkaHeader;
        })();

        records.Kafka = (function() {

            /**
             * Properties of a Kafka.
             * @memberof protos.records
             * @interface IKafka
             * @property {string|null} [topic] Kafka topic
             * @property {Uint8Array|null} [key] Kafka key
             * @property {Uint8Array|null} [value] Kafka value
             * @property {number|Long|null} [timestamp] Kafka timestamp
             * @property {number|Long|null} [offset] Kafka offset
             * @property {number|null} [partition] Kafka partition
             * @property {Array.<protos.records.IKafkaHeader>|null} [headers] Kafka headers
             */

            /**
             * Constructs a new Kafka.
             * @memberof protos.records
             * @classdesc Represents a Kafka.
             * @implements IKafka
             * @constructor
             * @param {protos.records.IKafka=} [properties] Properties to set
             */
            function Kafka(properties) {
                this.headers = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Kafka topic.
             * @member {string} topic
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.topic = "";

            /**
             * Kafka key.
             * @member {Uint8Array} key
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.key = $util.newBuffer([]);

            /**
             * Kafka value.
             * @member {Uint8Array} value
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.value = $util.newBuffer([]);

            /**
             * Kafka timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Kafka offset.
             * @member {number|Long} offset
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.offset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Kafka partition.
             * @member {number} partition
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.partition = 0;

            /**
             * Kafka headers.
             * @member {Array.<protos.records.IKafkaHeader>} headers
             * @memberof protos.records.Kafka
             * @instance
             */
            Kafka.prototype.headers = $util.emptyArray;

            /**
             * Creates a new Kafka instance using the specified properties.
             * @function create
             * @memberof protos.records.Kafka
             * @static
             * @param {protos.records.IKafka=} [properties] Properties to set
             * @returns {protos.records.Kafka} Kafka instance
             */
            Kafka.create = function create(properties) {
                return new Kafka(properties);
            };

            /**
             * Encodes the specified Kafka message. Does not implicitly {@link protos.records.Kafka.verify|verify} messages.
             * @function encode
             * @memberof protos.records.Kafka
             * @static
             * @param {protos.records.IKafka} message Kafka message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Kafka.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestamp);
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.offset);
                if (message.partition != null && Object.hasOwnProperty.call(message, "partition"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.partition);
                if (message.headers != null && message.headers.length)
                    for (var i = 0; i < message.headers.length; ++i)
                        $root.protos.records.KafkaHeader.encode(message.headers[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Kafka message, length delimited. Does not implicitly {@link protos.records.Kafka.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.Kafka
             * @static
             * @param {protos.records.IKafka} message Kafka message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Kafka.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Kafka message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.Kafka
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.Kafka} Kafka
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Kafka.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.Kafka();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topic = reader.string();
                        break;
                    case 2:
                        message.key = reader.bytes();
                        break;
                    case 3:
                        message.value = reader.bytes();
                        break;
                    case 4:
                        message.timestamp = reader.int64();
                        break;
                    case 5:
                        message.offset = reader.int64();
                        break;
                    case 6:
                        message.partition = reader.int32();
                        break;
                    case 7:
                        if (!(message.headers && message.headers.length))
                            message.headers = [];
                        message.headers.push($root.protos.records.KafkaHeader.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Kafka message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.Kafka
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.Kafka} Kafka
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Kafka.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Kafka message.
             * @function verify
             * @memberof protos.records.Kafka
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Kafka.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high)))
                        return "offset: integer|Long expected";
                if (message.partition != null && message.hasOwnProperty("partition"))
                    if (!$util.isInteger(message.partition))
                        return "partition: integer expected";
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    if (!Array.isArray(message.headers))
                        return "headers: array expected";
                    for (var i = 0; i < message.headers.length; ++i) {
                        var error = $root.protos.records.KafkaHeader.verify(message.headers[i]);
                        if (error)
                            return "headers." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Kafka message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.Kafka
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.Kafka} Kafka
             */
            Kafka.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.Kafka)
                    return object;
                var message = new $root.protos.records.Kafka();
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length)
                        message.key = object.key;
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.offset != null)
                    if ($util.Long)
                        (message.offset = $util.Long.fromValue(object.offset)).unsigned = false;
                    else if (typeof object.offset === "string")
                        message.offset = parseInt(object.offset, 10);
                    else if (typeof object.offset === "number")
                        message.offset = object.offset;
                    else if (typeof object.offset === "object")
                        message.offset = new $util.LongBits(object.offset.low >>> 0, object.offset.high >>> 0).toNumber();
                if (object.partition != null)
                    message.partition = object.partition | 0;
                if (object.headers) {
                    if (!Array.isArray(object.headers))
                        throw TypeError(".protos.records.Kafka.headers: array expected");
                    message.headers = [];
                    for (var i = 0; i < object.headers.length; ++i) {
                        if (typeof object.headers[i] !== "object")
                            throw TypeError(".protos.records.Kafka.headers: object expected");
                        message.headers[i] = $root.protos.records.KafkaHeader.fromObject(object.headers[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Kafka message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.Kafka
             * @static
             * @param {protos.records.Kafka} message Kafka
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Kafka.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.headers = [];
                if (options.defaults) {
                    object.topic = "";
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.offset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.offset = options.longs === String ? "0" : 0;
                    object.partition = 0;
                }
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (typeof message.offset === "number")
                        object.offset = options.longs === String ? String(message.offset) : message.offset;
                    else
                        object.offset = options.longs === String ? $util.Long.prototype.toString.call(message.offset) : options.longs === Number ? new $util.LongBits(message.offset.low >>> 0, message.offset.high >>> 0).toNumber() : message.offset;
                if (message.partition != null && message.hasOwnProperty("partition"))
                    object.partition = message.partition;
                if (message.headers && message.headers.length) {
                    object.headers = [];
                    for (var j = 0; j < message.headers.length; ++j)
                        object.headers[j] = $root.protos.records.KafkaHeader.toObject(message.headers[j], options);
                }
                return object;
            };

            /**
             * Converts this Kafka to JSON.
             * @function toJSON
             * @memberof protos.records.Kafka
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Kafka.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Kafka;
        })();

        records.KubeMQ = (function() {

            /**
             * Properties of a KubeMQ.
             * @memberof protos.records
             * @interface IKubeMQ
             * @property {string|null} [id] KubeMQ id
             * @property {string|null} [clientId] KubeMQ clientId
             * @property {string|null} [channel] KubeMQ channel
             * @property {Uint8Array|null} [value] KubeMQ value
             * @property {number|Long|null} [timestamp] KubeMQ timestamp
             * @property {number|Long|null} [sequence] KubeMQ sequence
             */

            /**
             * Constructs a new KubeMQ.
             * @memberof protos.records
             * @classdesc Represents a KubeMQ.
             * @implements IKubeMQ
             * @constructor
             * @param {protos.records.IKubeMQ=} [properties] Properties to set
             */
            function KubeMQ(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KubeMQ id.
             * @member {string} id
             * @memberof protos.records.KubeMQ
             * @instance
             */
            KubeMQ.prototype.id = "";

            /**
             * KubeMQ clientId.
             * @member {string} clientId
             * @memberof protos.records.KubeMQ
             * @instance
             */
            KubeMQ.prototype.clientId = "";

            /**
             * KubeMQ channel.
             * @member {string} channel
             * @memberof protos.records.KubeMQ
             * @instance
             */
            KubeMQ.prototype.channel = "";

            /**
             * KubeMQ value.
             * @member {Uint8Array} value
             * @memberof protos.records.KubeMQ
             * @instance
             */
            KubeMQ.prototype.value = $util.newBuffer([]);

            /**
             * KubeMQ timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.KubeMQ
             * @instance
             */
            KubeMQ.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * KubeMQ sequence.
             * @member {number|Long} sequence
             * @memberof protos.records.KubeMQ
             * @instance
             */
            KubeMQ.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new KubeMQ instance using the specified properties.
             * @function create
             * @memberof protos.records.KubeMQ
             * @static
             * @param {protos.records.IKubeMQ=} [properties] Properties to set
             * @returns {protos.records.KubeMQ} KubeMQ instance
             */
            KubeMQ.create = function create(properties) {
                return new KubeMQ(properties);
            };

            /**
             * Encodes the specified KubeMQ message. Does not implicitly {@link protos.records.KubeMQ.verify|verify} messages.
             * @function encode
             * @memberof protos.records.KubeMQ
             * @static
             * @param {protos.records.IKubeMQ} message KubeMQ message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQ.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.clientId != null && Object.hasOwnProperty.call(message, "clientId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientId);
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.channel);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.value);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
                if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.sequence);
                return writer;
            };

            /**
             * Encodes the specified KubeMQ message, length delimited. Does not implicitly {@link protos.records.KubeMQ.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.KubeMQ
             * @static
             * @param {protos.records.IKubeMQ} message KubeMQ message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KubeMQ.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KubeMQ message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.KubeMQ
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.KubeMQ} KubeMQ
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQ.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.KubeMQ();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.clientId = reader.string();
                        break;
                    case 3:
                        message.channel = reader.string();
                        break;
                    case 4:
                        message.value = reader.bytes();
                        break;
                    case 5:
                        message.timestamp = reader.int64();
                        break;
                    case 6:
                        message.sequence = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KubeMQ message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.KubeMQ
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.KubeMQ} KubeMQ
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KubeMQ.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KubeMQ message.
             * @function verify
             * @memberof protos.records.KubeMQ
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KubeMQ.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    if (!$util.isString(message.clientId))
                        return "clientId: string expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                        return "sequence: integer|Long expected";
                return null;
            };

            /**
             * Creates a KubeMQ message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.KubeMQ
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.KubeMQ} KubeMQ
             */
            KubeMQ.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.KubeMQ)
                    return object;
                var message = new $root.protos.records.KubeMQ();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.clientId != null)
                    message.clientId = String(object.clientId);
                if (object.channel != null)
                    message.channel = String(object.channel);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.sequence != null)
                    if ($util.Long)
                        (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                    else if (typeof object.sequence === "string")
                        message.sequence = parseInt(object.sequence, 10);
                    else if (typeof object.sequence === "number")
                        message.sequence = object.sequence;
                    else if (typeof object.sequence === "object")
                        message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a KubeMQ message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.KubeMQ
             * @static
             * @param {protos.records.KubeMQ} message KubeMQ
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KubeMQ.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    object.clientId = "";
                    object.channel = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sequence = options.longs === String ? "0" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.clientId != null && message.hasOwnProperty("clientId"))
                    object.clientId = message.clientId;
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (typeof message.sequence === "number")
                        object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                    else
                        object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
                return object;
            };

            /**
             * Converts this KubeMQ to JSON.
             * @function toJSON
             * @memberof protos.records.KubeMQ
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KubeMQ.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KubeMQ;
        })();

        records.Mongo = (function() {

            /**
             * Properties of a Mongo.
             * @memberof protos.records
             * @interface IMongo
             * @property {Uint8Array|null} [value] Mongo value
             * @property {number|Long|null} [timestamp] Mongo timestamp
             */

            /**
             * Constructs a new Mongo.
             * @memberof protos.records
             * @classdesc Represents a Mongo.
             * @implements IMongo
             * @constructor
             * @param {protos.records.IMongo=} [properties] Properties to set
             */
            function Mongo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Mongo value.
             * @member {Uint8Array} value
             * @memberof protos.records.Mongo
             * @instance
             */
            Mongo.prototype.value = $util.newBuffer([]);

            /**
             * Mongo timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.Mongo
             * @instance
             */
            Mongo.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Mongo instance using the specified properties.
             * @function create
             * @memberof protos.records.Mongo
             * @static
             * @param {protos.records.IMongo=} [properties] Properties to set
             * @returns {protos.records.Mongo} Mongo instance
             */
            Mongo.create = function create(properties) {
                return new Mongo(properties);
            };

            /**
             * Encodes the specified Mongo message. Does not implicitly {@link protos.records.Mongo.verify|verify} messages.
             * @function encode
             * @memberof protos.records.Mongo
             * @static
             * @param {protos.records.IMongo} message Mongo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Mongo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified Mongo message, length delimited. Does not implicitly {@link protos.records.Mongo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.Mongo
             * @static
             * @param {protos.records.IMongo} message Mongo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Mongo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Mongo message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.Mongo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.Mongo} Mongo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Mongo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.Mongo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.bytes();
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Mongo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.Mongo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.Mongo} Mongo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Mongo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Mongo message.
             * @function verify
             * @memberof protos.records.Mongo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Mongo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a Mongo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.Mongo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.Mongo} Mongo
             */
            Mongo.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.Mongo)
                    return object;
                var message = new $root.protos.records.Mongo();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Mongo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.Mongo
             * @static
             * @param {protos.records.Mongo} message Mongo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Mongo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this Mongo to JSON.
             * @function toJSON
             * @memberof protos.records.Mongo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Mongo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Mongo;
        })();

        records.MQTT = (function() {

            /**
             * Properties of a MQTT.
             * @memberof protos.records
             * @interface IMQTT
             * @property {number|null} [id] MQTT id
             * @property {string|null} [topic] MQTT topic
             * @property {Uint8Array|null} [value] MQTT value
             * @property {boolean|null} [duplicate] MQTT duplicate
             * @property {boolean|null} [retained] MQTT retained
             * @property {number|null} [qos] MQTT qos
             * @property {number|Long|null} [timestamp] MQTT timestamp
             */

            /**
             * Constructs a new MQTT.
             * @memberof protos.records
             * @classdesc Represents a MQTT.
             * @implements IMQTT
             * @constructor
             * @param {protos.records.IMQTT=} [properties] Properties to set
             */
            function MQTT(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MQTT id.
             * @member {number} id
             * @memberof protos.records.MQTT
             * @instance
             */
            MQTT.prototype.id = 0;

            /**
             * MQTT topic.
             * @member {string} topic
             * @memberof protos.records.MQTT
             * @instance
             */
            MQTT.prototype.topic = "";

            /**
             * MQTT value.
             * @member {Uint8Array} value
             * @memberof protos.records.MQTT
             * @instance
             */
            MQTT.prototype.value = $util.newBuffer([]);

            /**
             * MQTT duplicate.
             * @member {boolean} duplicate
             * @memberof protos.records.MQTT
             * @instance
             */
            MQTT.prototype.duplicate = false;

            /**
             * MQTT retained.
             * @member {boolean} retained
             * @memberof protos.records.MQTT
             * @instance
             */
            MQTT.prototype.retained = false;

            /**
             * MQTT qos.
             * @member {number} qos
             * @memberof protos.records.MQTT
             * @instance
             */
            MQTT.prototype.qos = 0;

            /**
             * MQTT timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.MQTT
             * @instance
             */
            MQTT.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new MQTT instance using the specified properties.
             * @function create
             * @memberof protos.records.MQTT
             * @static
             * @param {protos.records.IMQTT=} [properties] Properties to set
             * @returns {protos.records.MQTT} MQTT instance
             */
            MQTT.create = function create(properties) {
                return new MQTT(properties);
            };

            /**
             * Encodes the specified MQTT message. Does not implicitly {@link protos.records.MQTT.verify|verify} messages.
             * @function encode
             * @memberof protos.records.MQTT
             * @static
             * @param {protos.records.IMQTT} message MQTT message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTT.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.topic);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                if (message.duplicate != null && Object.hasOwnProperty.call(message, "duplicate"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.duplicate);
                if (message.retained != null && Object.hasOwnProperty.call(message, "retained"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.retained);
                if (message.qos != null && Object.hasOwnProperty.call(message, "qos"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.qos);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified MQTT message, length delimited. Does not implicitly {@link protos.records.MQTT.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.MQTT
             * @static
             * @param {protos.records.IMQTT} message MQTT message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTT.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MQTT message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.MQTT
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.MQTT} MQTT
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTT.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.MQTT();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.uint32();
                        break;
                    case 2:
                        message.topic = reader.string();
                        break;
                    case 3:
                        message.value = reader.bytes();
                        break;
                    case 4:
                        message.duplicate = reader.bool();
                        break;
                    case 5:
                        message.retained = reader.bool();
                        break;
                    case 6:
                        message.qos = reader.uint32();
                        break;
                    case 7:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MQTT message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.MQTT
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.MQTT} MQTT
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTT.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MQTT message.
             * @function verify
             * @memberof protos.records.MQTT
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MQTT.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.duplicate != null && message.hasOwnProperty("duplicate"))
                    if (typeof message.duplicate !== "boolean")
                        return "duplicate: boolean expected";
                if (message.retained != null && message.hasOwnProperty("retained"))
                    if (typeof message.retained !== "boolean")
                        return "retained: boolean expected";
                if (message.qos != null && message.hasOwnProperty("qos"))
                    if (!$util.isInteger(message.qos))
                        return "qos: integer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a MQTT message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.MQTT
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.MQTT} MQTT
             */
            MQTT.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.MQTT)
                    return object;
                var message = new $root.protos.records.MQTT();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.duplicate != null)
                    message.duplicate = Boolean(object.duplicate);
                if (object.retained != null)
                    message.retained = Boolean(object.retained);
                if (object.qos != null)
                    message.qos = object.qos >>> 0;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a MQTT message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.MQTT
             * @static
             * @param {protos.records.MQTT} message MQTT
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MQTT.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.topic = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    object.duplicate = false;
                    object.retained = false;
                    object.qos = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.duplicate != null && message.hasOwnProperty("duplicate"))
                    object.duplicate = message.duplicate;
                if (message.retained != null && message.hasOwnProperty("retained"))
                    object.retained = message.retained;
                if (message.qos != null && message.hasOwnProperty("qos"))
                    object.qos = message.qos;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this MQTT to JSON.
             * @function toJSON
             * @memberof protos.records.MQTT
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MQTT.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MQTT;
        })();

        records.Nats = (function() {

            /**
             * Properties of a Nats.
             * @memberof protos.records
             * @interface INats
             * @property {string|null} [subject] Nats subject
             * @property {Uint8Array|null} [value] Nats value
             */

            /**
             * Constructs a new Nats.
             * @memberof protos.records
             * @classdesc Represents a Nats.
             * @implements INats
             * @constructor
             * @param {protos.records.INats=} [properties] Properties to set
             */
            function Nats(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Nats subject.
             * @member {string} subject
             * @memberof protos.records.Nats
             * @instance
             */
            Nats.prototype.subject = "";

            /**
             * Nats value.
             * @member {Uint8Array} value
             * @memberof protos.records.Nats
             * @instance
             */
            Nats.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Nats instance using the specified properties.
             * @function create
             * @memberof protos.records.Nats
             * @static
             * @param {protos.records.INats=} [properties] Properties to set
             * @returns {protos.records.Nats} Nats instance
             */
            Nats.create = function create(properties) {
                return new Nats(properties);
            };

            /**
             * Encodes the specified Nats message. Does not implicitly {@link protos.records.Nats.verify|verify} messages.
             * @function encode
             * @memberof protos.records.Nats
             * @static
             * @param {protos.records.INats} message Nats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Nats.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.subject);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Nats message, length delimited. Does not implicitly {@link protos.records.Nats.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.Nats
             * @static
             * @param {protos.records.INats} message Nats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Nats.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Nats message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.Nats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.Nats} Nats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Nats.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.Nats();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subject = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Nats message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.Nats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.Nats} Nats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Nats.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Nats message.
             * @function verify
             * @memberof protos.records.Nats
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Nats.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    if (!$util.isString(message.subject))
                        return "subject: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a Nats message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.Nats
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.Nats} Nats
             */
            Nats.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.Nats)
                    return object;
                var message = new $root.protos.records.Nats();
                if (object.subject != null)
                    message.subject = String(object.subject);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a Nats message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.Nats
             * @static
             * @param {protos.records.Nats} message Nats
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Nats.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.subject = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.subject != null && message.hasOwnProperty("subject"))
                    object.subject = message.subject;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Nats to JSON.
             * @function toJSON
             * @memberof protos.records.Nats
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Nats.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Nats;
        })();

        records.NatsJetstream = (function() {

            /**
             * Properties of a NatsJetstream.
             * @memberof protos.records
             * @interface INatsJetstream
             * @property {string|null} [stream] NatsJetstream stream
             * @property {Uint8Array|null} [value] NatsJetstream value
             */

            /**
             * Constructs a new NatsJetstream.
             * @memberof protos.records
             * @classdesc Represents a NatsJetstream.
             * @implements INatsJetstream
             * @constructor
             * @param {protos.records.INatsJetstream=} [properties] Properties to set
             */
            function NatsJetstream(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsJetstream stream.
             * @member {string} stream
             * @memberof protos.records.NatsJetstream
             * @instance
             */
            NatsJetstream.prototype.stream = "";

            /**
             * NatsJetstream value.
             * @member {Uint8Array} value
             * @memberof protos.records.NatsJetstream
             * @instance
             */
            NatsJetstream.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new NatsJetstream instance using the specified properties.
             * @function create
             * @memberof protos.records.NatsJetstream
             * @static
             * @param {protos.records.INatsJetstream=} [properties] Properties to set
             * @returns {protos.records.NatsJetstream} NatsJetstream instance
             */
            NatsJetstream.create = function create(properties) {
                return new NatsJetstream(properties);
            };

            /**
             * Encodes the specified NatsJetstream message. Does not implicitly {@link protos.records.NatsJetstream.verify|verify} messages.
             * @function encode
             * @memberof protos.records.NatsJetstream
             * @static
             * @param {protos.records.INatsJetstream} message NatsJetstream message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsJetstream.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stream);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified NatsJetstream message, length delimited. Does not implicitly {@link protos.records.NatsJetstream.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.NatsJetstream
             * @static
             * @param {protos.records.INatsJetstream} message NatsJetstream message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsJetstream.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsJetstream message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.NatsJetstream
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.NatsJetstream} NatsJetstream
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsJetstream.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.NatsJetstream();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stream = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsJetstream message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.NatsJetstream
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.NatsJetstream} NatsJetstream
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsJetstream.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsJetstream message.
             * @function verify
             * @memberof protos.records.NatsJetstream
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsJetstream.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isString(message.stream))
                        return "stream: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a NatsJetstream message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.NatsJetstream
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.NatsJetstream} NatsJetstream
             */
            NatsJetstream.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.NatsJetstream)
                    return object;
                var message = new $root.protos.records.NatsJetstream();
                if (object.stream != null)
                    message.stream = String(object.stream);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a NatsJetstream message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.NatsJetstream
             * @static
             * @param {protos.records.NatsJetstream} message NatsJetstream
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsJetstream.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.stream = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this NatsJetstream to JSON.
             * @function toJSON
             * @memberof protos.records.NatsJetstream
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsJetstream.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsJetstream;
        })();

        records.NatsStreaming = (function() {

            /**
             * Properties of a NatsStreaming.
             * @memberof protos.records
             * @interface INatsStreaming
             * @property {Object.<string,string>|null} [metadata] NatsStreaming metadata
             * @property {Uint8Array|null} [value] NatsStreaming value
             * @property {number|Long|null} [timestamp] NatsStreaming timestamp
             */

            /**
             * Constructs a new NatsStreaming.
             * @memberof protos.records
             * @classdesc Represents a NatsStreaming.
             * @implements INatsStreaming
             * @constructor
             * @param {protos.records.INatsStreaming=} [properties] Properties to set
             */
            function NatsStreaming(properties) {
                this.metadata = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NatsStreaming metadata.
             * @member {Object.<string,string>} metadata
             * @memberof protos.records.NatsStreaming
             * @instance
             */
            NatsStreaming.prototype.metadata = $util.emptyObject;

            /**
             * NatsStreaming value.
             * @member {Uint8Array} value
             * @memberof protos.records.NatsStreaming
             * @instance
             */
            NatsStreaming.prototype.value = $util.newBuffer([]);

            /**
             * NatsStreaming timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.NatsStreaming
             * @instance
             */
            NatsStreaming.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new NatsStreaming instance using the specified properties.
             * @function create
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {protos.records.INatsStreaming=} [properties] Properties to set
             * @returns {protos.records.NatsStreaming} NatsStreaming instance
             */
            NatsStreaming.create = function create(properties) {
                return new NatsStreaming(properties);
            };

            /**
             * Encodes the specified NatsStreaming message. Does not implicitly {@link protos.records.NatsStreaming.verify|verify} messages.
             * @function encode
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {protos.records.INatsStreaming} message NatsStreaming message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreaming.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    for (var keys = Object.keys(message.metadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.metadata[keys[i]]).ldelim();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified NatsStreaming message, length delimited. Does not implicitly {@link protos.records.NatsStreaming.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {protos.records.INatsStreaming} message NatsStreaming message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NatsStreaming.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NatsStreaming message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.NatsStreaming} NatsStreaming
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreaming.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.NatsStreaming(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.metadata === $util.emptyObject)
                            message.metadata = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.metadata[key] = value;
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    case 3:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NatsStreaming message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.NatsStreaming} NatsStreaming
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NatsStreaming.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NatsStreaming message.
             * @function verify
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NatsStreaming.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    if (!$util.isObject(message.metadata))
                        return "metadata: object expected";
                    var key = Object.keys(message.metadata);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.metadata[key[i]]))
                            return "metadata: string{k:string} expected";
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a NatsStreaming message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.NatsStreaming} NatsStreaming
             */
            NatsStreaming.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.NatsStreaming)
                    return object;
                var message = new $root.protos.records.NatsStreaming();
                if (object.metadata) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".protos.records.NatsStreaming.metadata: object expected");
                    message.metadata = {};
                    for (var keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i)
                        message.metadata[keys[i]] = String(object.metadata[keys[i]]);
                }
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a NatsStreaming message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.NatsStreaming
             * @static
             * @param {protos.records.NatsStreaming} message NatsStreaming
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NatsStreaming.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.metadata = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                var keys2;
                if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                    object.metadata = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.metadata[keys2[j]] = message.metadata[keys2[j]];
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this NatsStreaming to JSON.
             * @function toJSON
             * @memberof protos.records.NatsStreaming
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NatsStreaming.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NatsStreaming;
        })();

        records.NSQ = (function() {

            /**
             * Properties of a NSQ.
             * @memberof protos.records
             * @interface INSQ
             * @property {string|null} [id] NSQ id
             * @property {string|null} [topic] NSQ topic
             * @property {string|null} [channel] NSQ channel
             * @property {number|null} [attempts] NSQ attempts
             * @property {string|null} [nsqdAddress] NSQ nsqdAddress
             * @property {Uint8Array|null} [value] NSQ value
             * @property {number|Long|null} [timestamp] NSQ timestamp
             */

            /**
             * Constructs a new NSQ.
             * @memberof protos.records
             * @classdesc Represents a NSQ.
             * @implements INSQ
             * @constructor
             * @param {protos.records.INSQ=} [properties] Properties to set
             */
            function NSQ(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NSQ id.
             * @member {string} id
             * @memberof protos.records.NSQ
             * @instance
             */
            NSQ.prototype.id = "";

            /**
             * NSQ topic.
             * @member {string} topic
             * @memberof protos.records.NSQ
             * @instance
             */
            NSQ.prototype.topic = "";

            /**
             * NSQ channel.
             * @member {string} channel
             * @memberof protos.records.NSQ
             * @instance
             */
            NSQ.prototype.channel = "";

            /**
             * NSQ attempts.
             * @member {number} attempts
             * @memberof protos.records.NSQ
             * @instance
             */
            NSQ.prototype.attempts = 0;

            /**
             * NSQ nsqdAddress.
             * @member {string} nsqdAddress
             * @memberof protos.records.NSQ
             * @instance
             */
            NSQ.prototype.nsqdAddress = "";

            /**
             * NSQ value.
             * @member {Uint8Array} value
             * @memberof protos.records.NSQ
             * @instance
             */
            NSQ.prototype.value = $util.newBuffer([]);

            /**
             * NSQ timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.NSQ
             * @instance
             */
            NSQ.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new NSQ instance using the specified properties.
             * @function create
             * @memberof protos.records.NSQ
             * @static
             * @param {protos.records.INSQ=} [properties] Properties to set
             * @returns {protos.records.NSQ} NSQ instance
             */
            NSQ.create = function create(properties) {
                return new NSQ(properties);
            };

            /**
             * Encodes the specified NSQ message. Does not implicitly {@link protos.records.NSQ.verify|verify} messages.
             * @function encode
             * @memberof protos.records.NSQ
             * @static
             * @param {protos.records.INSQ} message NSQ message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQ.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.topic);
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.channel);
                if (message.attempts != null && Object.hasOwnProperty.call(message, "attempts"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.attempts);
                if (message.nsqdAddress != null && Object.hasOwnProperty.call(message, "nsqdAddress"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.nsqdAddress);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.value);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified NSQ message, length delimited. Does not implicitly {@link protos.records.NSQ.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.NSQ
             * @static
             * @param {protos.records.INSQ} message NSQ message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NSQ.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NSQ message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.NSQ
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.NSQ} NSQ
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQ.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.NSQ();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.topic = reader.string();
                        break;
                    case 3:
                        message.channel = reader.string();
                        break;
                    case 4:
                        message.attempts = reader.int32();
                        break;
                    case 5:
                        message.nsqdAddress = reader.string();
                        break;
                    case 6:
                        message.value = reader.bytes();
                        break;
                    case 7:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NSQ message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.NSQ
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.NSQ} NSQ
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NSQ.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NSQ message.
             * @function verify
             * @memberof protos.records.NSQ
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NSQ.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                if (message.attempts != null && message.hasOwnProperty("attempts"))
                    if (!$util.isInteger(message.attempts))
                        return "attempts: integer expected";
                if (message.nsqdAddress != null && message.hasOwnProperty("nsqdAddress"))
                    if (!$util.isString(message.nsqdAddress))
                        return "nsqdAddress: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a NSQ message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.NSQ
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.NSQ} NSQ
             */
            NSQ.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.NSQ)
                    return object;
                var message = new $root.protos.records.NSQ();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.channel != null)
                    message.channel = String(object.channel);
                if (object.attempts != null)
                    message.attempts = object.attempts | 0;
                if (object.nsqdAddress != null)
                    message.nsqdAddress = String(object.nsqdAddress);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a NSQ message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.NSQ
             * @static
             * @param {protos.records.NSQ} message NSQ
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NSQ.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    object.topic = "";
                    object.channel = "";
                    object.attempts = 0;
                    object.nsqdAddress = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.attempts != null && message.hasOwnProperty("attempts"))
                    object.attempts = message.attempts;
                if (message.nsqdAddress != null && message.hasOwnProperty("nsqdAddress"))
                    object.nsqdAddress = message.nsqdAddress;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this NSQ to JSON.
             * @function toJSON
             * @memberof protos.records.NSQ
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NSQ.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NSQ;
        })();

        records.Postgres = (function() {

            /**
             * Properties of a Postgres.
             * @memberof protos.records
             * @interface IPostgres
             * @property {Object.<string,string>|null} [metadata] Postgres metadata
             * @property {number|Long|null} [timestamp] Postgres timestamp
             * @property {Uint8Array|null} [value] Postgres value
             */

            /**
             * Constructs a new Postgres.
             * @memberof protos.records
             * @classdesc Represents a Postgres.
             * @implements IPostgres
             * @constructor
             * @param {protos.records.IPostgres=} [properties] Properties to set
             */
            function Postgres(properties) {
                this.metadata = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Postgres metadata.
             * @member {Object.<string,string>} metadata
             * @memberof protos.records.Postgres
             * @instance
             */
            Postgres.prototype.metadata = $util.emptyObject;

            /**
             * Postgres timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.Postgres
             * @instance
             */
            Postgres.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Postgres value.
             * @member {Uint8Array} value
             * @memberof protos.records.Postgres
             * @instance
             */
            Postgres.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Postgres instance using the specified properties.
             * @function create
             * @memberof protos.records.Postgres
             * @static
             * @param {protos.records.IPostgres=} [properties] Properties to set
             * @returns {protos.records.Postgres} Postgres instance
             */
            Postgres.create = function create(properties) {
                return new Postgres(properties);
            };

            /**
             * Encodes the specified Postgres message. Does not implicitly {@link protos.records.Postgres.verify|verify} messages.
             * @function encode
             * @memberof protos.records.Postgres
             * @static
             * @param {protos.records.IPostgres} message Postgres message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Postgres.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    for (var keys = Object.keys(message.metadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.metadata[keys[i]]).ldelim();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Postgres message, length delimited. Does not implicitly {@link protos.records.Postgres.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.Postgres
             * @static
             * @param {protos.records.IPostgres} message Postgres message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Postgres.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Postgres message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.Postgres
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.Postgres} Postgres
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Postgres.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.Postgres(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.metadata === $util.emptyObject)
                            message.metadata = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.metadata[key] = value;
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    case 3:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Postgres message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.Postgres
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.Postgres} Postgres
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Postgres.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Postgres message.
             * @function verify
             * @memberof protos.records.Postgres
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Postgres.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    if (!$util.isObject(message.metadata))
                        return "metadata: object expected";
                    var key = Object.keys(message.metadata);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.metadata[key[i]]))
                            return "metadata: string{k:string} expected";
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a Postgres message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.Postgres
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.Postgres} Postgres
             */
            Postgres.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.Postgres)
                    return object;
                var message = new $root.protos.records.Postgres();
                if (object.metadata) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".protos.records.Postgres.metadata: object expected");
                    message.metadata = {};
                    for (var keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i)
                        message.metadata[keys[i]] = String(object.metadata[keys[i]]);
                }
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a Postgres message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.Postgres
             * @static
             * @param {protos.records.Postgres} message Postgres
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Postgres.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.metadata = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                var keys2;
                if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                    object.metadata = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.metadata[keys2[j]] = message.metadata[keys2[j]];
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Postgres to JSON.
             * @function toJSON
             * @memberof protos.records.Postgres
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Postgres.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Postgres;
        })();

        records.Pulsar = (function() {

            /**
             * Properties of a Pulsar.
             * @memberof protos.records
             * @interface IPulsar
             * @property {string|null} [id] Pulsar id
             * @property {string|null} [key] Pulsar key
             * @property {string|null} [topic] Pulsar topic
             * @property {Object.<string,string>|null} [properties] Pulsar properties
             * @property {number|null} [redeliveryCount] Pulsar redeliveryCount
             * @property {string|null} [eventTime] Pulsar eventTime
             * @property {boolean|null} [isReplicated] Pulsar isReplicated
             * @property {string|null} [orderingKey] Pulsar orderingKey
             * @property {string|null} [producerName] Pulsar producerName
             * @property {string|null} [publishTime] Pulsar publishTime
             * @property {number|Long|null} [timestamp] Pulsar timestamp
             * @property {Uint8Array|null} [value] Pulsar value
             */

            /**
             * Constructs a new Pulsar.
             * @memberof protos.records
             * @classdesc Represents a Pulsar.
             * @implements IPulsar
             * @constructor
             * @param {protos.records.IPulsar=} [properties] Properties to set
             */
            function Pulsar(properties) {
                this.properties = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Pulsar id.
             * @member {string} id
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.id = "";

            /**
             * Pulsar key.
             * @member {string} key
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.key = "";

            /**
             * Pulsar topic.
             * @member {string} topic
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.topic = "";

            /**
             * Pulsar properties.
             * @member {Object.<string,string>} properties
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.properties = $util.emptyObject;

            /**
             * Pulsar redeliveryCount.
             * @member {number} redeliveryCount
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.redeliveryCount = 0;

            /**
             * Pulsar eventTime.
             * @member {string} eventTime
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.eventTime = "";

            /**
             * Pulsar isReplicated.
             * @member {boolean} isReplicated
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.isReplicated = false;

            /**
             * Pulsar orderingKey.
             * @member {string} orderingKey
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.orderingKey = "";

            /**
             * Pulsar producerName.
             * @member {string} producerName
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.producerName = "";

            /**
             * Pulsar publishTime.
             * @member {string} publishTime
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.publishTime = "";

            /**
             * Pulsar timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Pulsar value.
             * @member {Uint8Array} value
             * @memberof protos.records.Pulsar
             * @instance
             */
            Pulsar.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Pulsar instance using the specified properties.
             * @function create
             * @memberof protos.records.Pulsar
             * @static
             * @param {protos.records.IPulsar=} [properties] Properties to set
             * @returns {protos.records.Pulsar} Pulsar instance
             */
            Pulsar.create = function create(properties) {
                return new Pulsar(properties);
            };

            /**
             * Encodes the specified Pulsar message. Does not implicitly {@link protos.records.Pulsar.verify|verify} messages.
             * @function encode
             * @memberof protos.records.Pulsar
             * @static
             * @param {protos.records.IPulsar} message Pulsar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Pulsar.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.key);
                if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.topic);
                if (message.properties != null && Object.hasOwnProperty.call(message, "properties"))
                    for (var keys = Object.keys(message.properties), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.properties[keys[i]]).ldelim();
                if (message.redeliveryCount != null && Object.hasOwnProperty.call(message, "redeliveryCount"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.redeliveryCount);
                if (message.eventTime != null && Object.hasOwnProperty.call(message, "eventTime"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.eventTime);
                if (message.isReplicated != null && Object.hasOwnProperty.call(message, "isReplicated"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isReplicated);
                if (message.orderingKey != null && Object.hasOwnProperty.call(message, "orderingKey"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.orderingKey);
                if (message.producerName != null && Object.hasOwnProperty.call(message, "producerName"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.producerName);
                if (message.publishTime != null && Object.hasOwnProperty.call(message, "publishTime"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.publishTime);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int64(message.timestamp);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Pulsar message, length delimited. Does not implicitly {@link protos.records.Pulsar.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.Pulsar
             * @static
             * @param {protos.records.IPulsar} message Pulsar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Pulsar.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Pulsar message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.Pulsar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.Pulsar} Pulsar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Pulsar.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.Pulsar(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.key = reader.string();
                        break;
                    case 3:
                        message.topic = reader.string();
                        break;
                    case 4:
                        if (message.properties === $util.emptyObject)
                            message.properties = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.properties[key] = value;
                        break;
                    case 5:
                        message.redeliveryCount = reader.uint32();
                        break;
                    case 6:
                        message.eventTime = reader.string();
                        break;
                    case 7:
                        message.isReplicated = reader.bool();
                        break;
                    case 8:
                        message.orderingKey = reader.string();
                        break;
                    case 9:
                        message.producerName = reader.string();
                        break;
                    case 10:
                        message.publishTime = reader.string();
                        break;
                    case 11:
                        message.timestamp = reader.int64();
                        break;
                    case 12:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Pulsar message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.Pulsar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.Pulsar} Pulsar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Pulsar.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Pulsar message.
             * @function verify
             * @memberof protos.records.Pulsar
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Pulsar.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.topic != null && message.hasOwnProperty("topic"))
                    if (!$util.isString(message.topic))
                        return "topic: string expected";
                if (message.properties != null && message.hasOwnProperty("properties")) {
                    if (!$util.isObject(message.properties))
                        return "properties: object expected";
                    var key = Object.keys(message.properties);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.properties[key[i]]))
                            return "properties: string{k:string} expected";
                }
                if (message.redeliveryCount != null && message.hasOwnProperty("redeliveryCount"))
                    if (!$util.isInteger(message.redeliveryCount))
                        return "redeliveryCount: integer expected";
                if (message.eventTime != null && message.hasOwnProperty("eventTime"))
                    if (!$util.isString(message.eventTime))
                        return "eventTime: string expected";
                if (message.isReplicated != null && message.hasOwnProperty("isReplicated"))
                    if (typeof message.isReplicated !== "boolean")
                        return "isReplicated: boolean expected";
                if (message.orderingKey != null && message.hasOwnProperty("orderingKey"))
                    if (!$util.isString(message.orderingKey))
                        return "orderingKey: string expected";
                if (message.producerName != null && message.hasOwnProperty("producerName"))
                    if (!$util.isString(message.producerName))
                        return "producerName: string expected";
                if (message.publishTime != null && message.hasOwnProperty("publishTime"))
                    if (!$util.isString(message.publishTime))
                        return "publishTime: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a Pulsar message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.Pulsar
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.Pulsar} Pulsar
             */
            Pulsar.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.Pulsar)
                    return object;
                var message = new $root.protos.records.Pulsar();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.key != null)
                    message.key = String(object.key);
                if (object.topic != null)
                    message.topic = String(object.topic);
                if (object.properties) {
                    if (typeof object.properties !== "object")
                        throw TypeError(".protos.records.Pulsar.properties: object expected");
                    message.properties = {};
                    for (var keys = Object.keys(object.properties), i = 0; i < keys.length; ++i)
                        message.properties[keys[i]] = String(object.properties[keys[i]]);
                }
                if (object.redeliveryCount != null)
                    message.redeliveryCount = object.redeliveryCount >>> 0;
                if (object.eventTime != null)
                    message.eventTime = String(object.eventTime);
                if (object.isReplicated != null)
                    message.isReplicated = Boolean(object.isReplicated);
                if (object.orderingKey != null)
                    message.orderingKey = String(object.orderingKey);
                if (object.producerName != null)
                    message.producerName = String(object.producerName);
                if (object.publishTime != null)
                    message.publishTime = String(object.publishTime);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a Pulsar message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.Pulsar
             * @static
             * @param {protos.records.Pulsar} message Pulsar
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Pulsar.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.properties = {};
                if (options.defaults) {
                    object.id = "";
                    object.key = "";
                    object.topic = "";
                    object.redeliveryCount = 0;
                    object.eventTime = "";
                    object.isReplicated = false;
                    object.orderingKey = "";
                    object.producerName = "";
                    object.publishTime = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.topic != null && message.hasOwnProperty("topic"))
                    object.topic = message.topic;
                var keys2;
                if (message.properties && (keys2 = Object.keys(message.properties)).length) {
                    object.properties = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.properties[keys2[j]] = message.properties[keys2[j]];
                }
                if (message.redeliveryCount != null && message.hasOwnProperty("redeliveryCount"))
                    object.redeliveryCount = message.redeliveryCount;
                if (message.eventTime != null && message.hasOwnProperty("eventTime"))
                    object.eventTime = message.eventTime;
                if (message.isReplicated != null && message.hasOwnProperty("isReplicated"))
                    object.isReplicated = message.isReplicated;
                if (message.orderingKey != null && message.hasOwnProperty("orderingKey"))
                    object.orderingKey = message.orderingKey;
                if (message.producerName != null && message.hasOwnProperty("producerName"))
                    object.producerName = message.producerName;
                if (message.publishTime != null && message.hasOwnProperty("publishTime"))
                    object.publishTime = message.publishTime;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Pulsar to JSON.
             * @function toJSON
             * @memberof protos.records.Pulsar
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Pulsar.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Pulsar;
        })();

        records.RabbitHeader = (function() {

            /**
             * Properties of a RabbitHeader.
             * @memberof protos.records
             * @interface IRabbitHeader
             * @property {string|null} [key] RabbitHeader key
             * @property {string|null} [value] RabbitHeader value
             */

            /**
             * Constructs a new RabbitHeader.
             * @memberof protos.records
             * @classdesc Represents a RabbitHeader.
             * @implements IRabbitHeader
             * @constructor
             * @param {protos.records.IRabbitHeader=} [properties] Properties to set
             */
            function RabbitHeader(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitHeader key.
             * @member {string} key
             * @memberof protos.records.RabbitHeader
             * @instance
             */
            RabbitHeader.prototype.key = "";

            /**
             * RabbitHeader value.
             * @member {string} value
             * @memberof protos.records.RabbitHeader
             * @instance
             */
            RabbitHeader.prototype.value = "";

            /**
             * Creates a new RabbitHeader instance using the specified properties.
             * @function create
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {protos.records.IRabbitHeader=} [properties] Properties to set
             * @returns {protos.records.RabbitHeader} RabbitHeader instance
             */
            RabbitHeader.create = function create(properties) {
                return new RabbitHeader(properties);
            };

            /**
             * Encodes the specified RabbitHeader message. Does not implicitly {@link protos.records.RabbitHeader.verify|verify} messages.
             * @function encode
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {protos.records.IRabbitHeader} message RabbitHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitHeader.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };

            /**
             * Encodes the specified RabbitHeader message, length delimited. Does not implicitly {@link protos.records.RabbitHeader.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {protos.records.IRabbitHeader} message RabbitHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitHeader.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitHeader message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.RabbitHeader} RabbitHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitHeader.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.RabbitHeader();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitHeader message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.RabbitHeader} RabbitHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitHeader.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitHeader message.
             * @function verify
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitHeader.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };

            /**
             * Creates a RabbitHeader message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.RabbitHeader} RabbitHeader
             */
            RabbitHeader.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.RabbitHeader)
                    return object;
                var message = new $root.protos.records.RabbitHeader();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };

            /**
             * Creates a plain object from a RabbitHeader message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.RabbitHeader
             * @static
             * @param {protos.records.RabbitHeader} message RabbitHeader
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitHeader.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.value = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this RabbitHeader to JSON.
             * @function toJSON
             * @memberof protos.records.RabbitHeader
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitHeader.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitHeader;
        })();

        records.Rabbit = (function() {

            /**
             * Properties of a Rabbit.
             * @memberof protos.records
             * @interface IRabbit
             * @property {Uint8Array|null} [body] Rabbit body
             * @property {number|Long|null} [timestamp] Rabbit timestamp
             * @property {string|null} [type] Rabbit type
             * @property {string|null} [exchange] Rabbit exchange
             * @property {string|null} [routingKey] Rabbit routingKey
             * @property {string|null} [contentType] Rabbit contentType
             * @property {string|null} [contentEncoding] Rabbit contentEncoding
             * @property {number|null} [priority] Rabbit priority
             * @property {string|null} [expiration] Rabbit expiration
             * @property {string|null} [messageId] Rabbit messageId
             * @property {string|null} [userId] Rabbit userId
             * @property {string|null} [appId] Rabbit appId
             * @property {string|null} [replyTo] Rabbit replyTo
             * @property {string|null} [correlationId] Rabbit correlationId
             * @property {Array.<protos.records.IRabbitHeader>|null} [headers] Rabbit headers
             */

            /**
             * Constructs a new Rabbit.
             * @memberof protos.records
             * @classdesc Represents a Rabbit.
             * @implements IRabbit
             * @constructor
             * @param {protos.records.IRabbit=} [properties] Properties to set
             */
            function Rabbit(properties) {
                this.headers = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Rabbit body.
             * @member {Uint8Array} body
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.body = $util.newBuffer([]);

            /**
             * Rabbit timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Rabbit type.
             * @member {string} type
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.type = "";

            /**
             * Rabbit exchange.
             * @member {string} exchange
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.exchange = "";

            /**
             * Rabbit routingKey.
             * @member {string} routingKey
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.routingKey = "";

            /**
             * Rabbit contentType.
             * @member {string} contentType
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.contentType = "";

            /**
             * Rabbit contentEncoding.
             * @member {string} contentEncoding
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.contentEncoding = "";

            /**
             * Rabbit priority.
             * @member {number} priority
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.priority = 0;

            /**
             * Rabbit expiration.
             * @member {string} expiration
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.expiration = "";

            /**
             * Rabbit messageId.
             * @member {string} messageId
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.messageId = "";

            /**
             * Rabbit userId.
             * @member {string} userId
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.userId = "";

            /**
             * Rabbit appId.
             * @member {string} appId
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.appId = "";

            /**
             * Rabbit replyTo.
             * @member {string} replyTo
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.replyTo = "";

            /**
             * Rabbit correlationId.
             * @member {string} correlationId
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.correlationId = "";

            /**
             * Rabbit headers.
             * @member {Array.<protos.records.IRabbitHeader>} headers
             * @memberof protos.records.Rabbit
             * @instance
             */
            Rabbit.prototype.headers = $util.emptyArray;

            /**
             * Creates a new Rabbit instance using the specified properties.
             * @function create
             * @memberof protos.records.Rabbit
             * @static
             * @param {protos.records.IRabbit=} [properties] Properties to set
             * @returns {protos.records.Rabbit} Rabbit instance
             */
            Rabbit.create = function create(properties) {
                return new Rabbit(properties);
            };

            /**
             * Encodes the specified Rabbit message. Does not implicitly {@link protos.records.Rabbit.verify|verify} messages.
             * @function encode
             * @memberof protos.records.Rabbit
             * @static
             * @param {protos.records.IRabbit} message Rabbit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Rabbit.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.body);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.type);
                if (message.exchange != null && Object.hasOwnProperty.call(message, "exchange"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.exchange);
                if (message.routingKey != null && Object.hasOwnProperty.call(message, "routingKey"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.routingKey);
                if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.contentType);
                if (message.contentEncoding != null && Object.hasOwnProperty.call(message, "contentEncoding"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.contentEncoding);
                if (message.priority != null && Object.hasOwnProperty.call(message, "priority"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.priority);
                if (message.expiration != null && Object.hasOwnProperty.call(message, "expiration"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.expiration);
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.messageId);
                if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.userId);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.appId);
                if (message.replyTo != null && Object.hasOwnProperty.call(message, "replyTo"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.replyTo);
                if (message.correlationId != null && Object.hasOwnProperty.call(message, "correlationId"))
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.correlationId);
                if (message.headers != null && message.headers.length)
                    for (var i = 0; i < message.headers.length; ++i)
                        $root.protos.records.RabbitHeader.encode(message.headers[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Rabbit message, length delimited. Does not implicitly {@link protos.records.Rabbit.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.Rabbit
             * @static
             * @param {protos.records.IRabbit} message Rabbit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Rabbit.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Rabbit message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.Rabbit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.Rabbit} Rabbit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Rabbit.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.Rabbit();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.body = reader.bytes();
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    case 3:
                        message.type = reader.string();
                        break;
                    case 4:
                        message.exchange = reader.string();
                        break;
                    case 5:
                        message.routingKey = reader.string();
                        break;
                    case 6:
                        message.contentType = reader.string();
                        break;
                    case 7:
                        message.contentEncoding = reader.string();
                        break;
                    case 8:
                        message.priority = reader.int32();
                        break;
                    case 9:
                        message.expiration = reader.string();
                        break;
                    case 10:
                        message.messageId = reader.string();
                        break;
                    case 11:
                        message.userId = reader.string();
                        break;
                    case 12:
                        message.appId = reader.string();
                        break;
                    case 13:
                        message.replyTo = reader.string();
                        break;
                    case 14:
                        message.correlationId = reader.string();
                        break;
                    case 15:
                        if (!(message.headers && message.headers.length))
                            message.headers = [];
                        message.headers.push($root.protos.records.RabbitHeader.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Rabbit message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.Rabbit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.Rabbit} Rabbit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Rabbit.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Rabbit message.
             * @function verify
             * @memberof protos.records.Rabbit
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Rabbit.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.body != null && message.hasOwnProperty("body"))
                    if (!(message.body && typeof message.body.length === "number" || $util.isString(message.body)))
                        return "body: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isString(message.type))
                        return "type: string expected";
                if (message.exchange != null && message.hasOwnProperty("exchange"))
                    if (!$util.isString(message.exchange))
                        return "exchange: string expected";
                if (message.routingKey != null && message.hasOwnProperty("routingKey"))
                    if (!$util.isString(message.routingKey))
                        return "routingKey: string expected";
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    if (!$util.isString(message.contentType))
                        return "contentType: string expected";
                if (message.contentEncoding != null && message.hasOwnProperty("contentEncoding"))
                    if (!$util.isString(message.contentEncoding))
                        return "contentEncoding: string expected";
                if (message.priority != null && message.hasOwnProperty("priority"))
                    if (!$util.isInteger(message.priority))
                        return "priority: integer expected";
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    if (!$util.isString(message.expiration))
                        return "expiration: string expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                if (message.userId != null && message.hasOwnProperty("userId"))
                    if (!$util.isString(message.userId))
                        return "userId: string expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!$util.isString(message.appId))
                        return "appId: string expected";
                if (message.replyTo != null && message.hasOwnProperty("replyTo"))
                    if (!$util.isString(message.replyTo))
                        return "replyTo: string expected";
                if (message.correlationId != null && message.hasOwnProperty("correlationId"))
                    if (!$util.isString(message.correlationId))
                        return "correlationId: string expected";
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    if (!Array.isArray(message.headers))
                        return "headers: array expected";
                    for (var i = 0; i < message.headers.length; ++i) {
                        var error = $root.protos.records.RabbitHeader.verify(message.headers[i]);
                        if (error)
                            return "headers." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Rabbit message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.Rabbit
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.Rabbit} Rabbit
             */
            Rabbit.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.Rabbit)
                    return object;
                var message = new $root.protos.records.Rabbit();
                if (object.body != null)
                    if (typeof object.body === "string")
                        $util.base64.decode(object.body, message.body = $util.newBuffer($util.base64.length(object.body)), 0);
                    else if (object.body.length)
                        message.body = object.body;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.type != null)
                    message.type = String(object.type);
                if (object.exchange != null)
                    message.exchange = String(object.exchange);
                if (object.routingKey != null)
                    message.routingKey = String(object.routingKey);
                if (object.contentType != null)
                    message.contentType = String(object.contentType);
                if (object.contentEncoding != null)
                    message.contentEncoding = String(object.contentEncoding);
                if (object.priority != null)
                    message.priority = object.priority | 0;
                if (object.expiration != null)
                    message.expiration = String(object.expiration);
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.userId != null)
                    message.userId = String(object.userId);
                if (object.appId != null)
                    message.appId = String(object.appId);
                if (object.replyTo != null)
                    message.replyTo = String(object.replyTo);
                if (object.correlationId != null)
                    message.correlationId = String(object.correlationId);
                if (object.headers) {
                    if (!Array.isArray(object.headers))
                        throw TypeError(".protos.records.Rabbit.headers: array expected");
                    message.headers = [];
                    for (var i = 0; i < object.headers.length; ++i) {
                        if (typeof object.headers[i] !== "object")
                            throw TypeError(".protos.records.Rabbit.headers: object expected");
                        message.headers[i] = $root.protos.records.RabbitHeader.fromObject(object.headers[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Rabbit message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.Rabbit
             * @static
             * @param {protos.records.Rabbit} message Rabbit
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Rabbit.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.headers = [];
                if (options.defaults) {
                    if (options.bytes === String)
                        object.body = "";
                    else {
                        object.body = [];
                        if (options.bytes !== Array)
                            object.body = $util.newBuffer(object.body);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    object.type = "";
                    object.exchange = "";
                    object.routingKey = "";
                    object.contentType = "";
                    object.contentEncoding = "";
                    object.priority = 0;
                    object.expiration = "";
                    object.messageId = "";
                    object.userId = "";
                    object.appId = "";
                    object.replyTo = "";
                    object.correlationId = "";
                }
                if (message.body != null && message.hasOwnProperty("body"))
                    object.body = options.bytes === String ? $util.base64.encode(message.body, 0, message.body.length) : options.bytes === Array ? Array.prototype.slice.call(message.body) : message.body;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.exchange != null && message.hasOwnProperty("exchange"))
                    object.exchange = message.exchange;
                if (message.routingKey != null && message.hasOwnProperty("routingKey"))
                    object.routingKey = message.routingKey;
                if (message.contentType != null && message.hasOwnProperty("contentType"))
                    object.contentType = message.contentType;
                if (message.contentEncoding != null && message.hasOwnProperty("contentEncoding"))
                    object.contentEncoding = message.contentEncoding;
                if (message.priority != null && message.hasOwnProperty("priority"))
                    object.priority = message.priority;
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    object.expiration = message.expiration;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                if (message.userId != null && message.hasOwnProperty("userId"))
                    object.userId = message.userId;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = message.appId;
                if (message.replyTo != null && message.hasOwnProperty("replyTo"))
                    object.replyTo = message.replyTo;
                if (message.correlationId != null && message.hasOwnProperty("correlationId"))
                    object.correlationId = message.correlationId;
                if (message.headers && message.headers.length) {
                    object.headers = [];
                    for (var j = 0; j < message.headers.length; ++j)
                        object.headers[j] = $root.protos.records.RabbitHeader.toObject(message.headers[j], options);
                }
                return object;
            };

            /**
             * Converts this Rabbit to JSON.
             * @function toJSON
             * @memberof protos.records.Rabbit
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Rabbit.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Rabbit;
        })();

        records.RabbitStreams = (function() {

            /**
             * Properties of a RabbitStreams.
             * @memberof protos.records
             * @interface IRabbitStreams
             * @property {string|null} [deliveryTag] RabbitStreams deliveryTag
             * @property {number|null} [format] RabbitStreams format
             * @property {protos.records.IRabbitStreamsHeader|null} [header] RabbitStreams header
             * @property {Object.<string,string>|null} [deliveryAnnotations] RabbitStreams deliveryAnnotations
             * @property {boolean|null} [sendSettled] RabbitStreams sendSettled
             * @property {string|null} [streamName] RabbitStreams streamName
             * @property {number|Long|null} [timestamp] RabbitStreams timestamp
             * @property {Uint8Array|null} [value] RabbitStreams value
             */

            /**
             * Constructs a new RabbitStreams.
             * @memberof protos.records
             * @classdesc Represents a RabbitStreams.
             * @implements IRabbitStreams
             * @constructor
             * @param {protos.records.IRabbitStreams=} [properties] Properties to set
             */
            function RabbitStreams(properties) {
                this.deliveryAnnotations = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreams deliveryTag.
             * @member {string} deliveryTag
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.deliveryTag = "";

            /**
             * RabbitStreams format.
             * @member {number} format
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.format = 0;

            /**
             * RabbitStreams header.
             * @member {protos.records.IRabbitStreamsHeader|null|undefined} header
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.header = null;

            /**
             * RabbitStreams deliveryAnnotations.
             * @member {Object.<string,string>} deliveryAnnotations
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.deliveryAnnotations = $util.emptyObject;

            /**
             * RabbitStreams sendSettled.
             * @member {boolean} sendSettled
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.sendSettled = false;

            /**
             * RabbitStreams streamName.
             * @member {string} streamName
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.streamName = "";

            /**
             * RabbitStreams timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * RabbitStreams value.
             * @member {Uint8Array} value
             * @memberof protos.records.RabbitStreams
             * @instance
             */
            RabbitStreams.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new RabbitStreams instance using the specified properties.
             * @function create
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {protos.records.IRabbitStreams=} [properties] Properties to set
             * @returns {protos.records.RabbitStreams} RabbitStreams instance
             */
            RabbitStreams.create = function create(properties) {
                return new RabbitStreams(properties);
            };

            /**
             * Encodes the specified RabbitStreams message. Does not implicitly {@link protos.records.RabbitStreams.verify|verify} messages.
             * @function encode
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {protos.records.IRabbitStreams} message RabbitStreams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreams.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deliveryTag != null && Object.hasOwnProperty.call(message, "deliveryTag"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.deliveryTag);
                if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.format);
                if (message.header != null && Object.hasOwnProperty.call(message, "header"))
                    $root.protos.records.RabbitStreamsHeader.encode(message.header, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.deliveryAnnotations != null && Object.hasOwnProperty.call(message, "deliveryAnnotations"))
                    for (var keys = Object.keys(message.deliveryAnnotations), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.deliveryAnnotations[keys[i]]).ldelim();
                if (message.sendSettled != null && Object.hasOwnProperty.call(message, "sendSettled"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.sendSettled);
                if (message.streamName != null && Object.hasOwnProperty.call(message, "streamName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.streamName);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified RabbitStreams message, length delimited. Does not implicitly {@link protos.records.RabbitStreams.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {protos.records.IRabbitStreams} message RabbitStreams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreams.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreams message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.RabbitStreams} RabbitStreams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreams.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.RabbitStreams(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.deliveryTag = reader.string();
                        break;
                    case 2:
                        message.format = reader.uint32();
                        break;
                    case 3:
                        message.header = $root.protos.records.RabbitStreamsHeader.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (message.deliveryAnnotations === $util.emptyObject)
                            message.deliveryAnnotations = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.deliveryAnnotations[key] = value;
                        break;
                    case 5:
                        message.sendSettled = reader.bool();
                        break;
                    case 6:
                        message.streamName = reader.string();
                        break;
                    case 7:
                        message.timestamp = reader.int64();
                        break;
                    case 8:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreams message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.RabbitStreams} RabbitStreams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreams.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreams message.
             * @function verify
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreams.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deliveryTag != null && message.hasOwnProperty("deliveryTag"))
                    if (!$util.isString(message.deliveryTag))
                        return "deliveryTag: string expected";
                if (message.format != null && message.hasOwnProperty("format"))
                    if (!$util.isInteger(message.format))
                        return "format: integer expected";
                if (message.header != null && message.hasOwnProperty("header")) {
                    var error = $root.protos.records.RabbitStreamsHeader.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                if (message.deliveryAnnotations != null && message.hasOwnProperty("deliveryAnnotations")) {
                    if (!$util.isObject(message.deliveryAnnotations))
                        return "deliveryAnnotations: object expected";
                    var key = Object.keys(message.deliveryAnnotations);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.deliveryAnnotations[key[i]]))
                            return "deliveryAnnotations: string{k:string} expected";
                }
                if (message.sendSettled != null && message.hasOwnProperty("sendSettled"))
                    if (typeof message.sendSettled !== "boolean")
                        return "sendSettled: boolean expected";
                if (message.streamName != null && message.hasOwnProperty("streamName"))
                    if (!$util.isString(message.streamName))
                        return "streamName: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a RabbitStreams message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.RabbitStreams} RabbitStreams
             */
            RabbitStreams.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.RabbitStreams)
                    return object;
                var message = new $root.protos.records.RabbitStreams();
                if (object.deliveryTag != null)
                    message.deliveryTag = String(object.deliveryTag);
                if (object.format != null)
                    message.format = object.format >>> 0;
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".protos.records.RabbitStreams.header: object expected");
                    message.header = $root.protos.records.RabbitStreamsHeader.fromObject(object.header);
                }
                if (object.deliveryAnnotations) {
                    if (typeof object.deliveryAnnotations !== "object")
                        throw TypeError(".protos.records.RabbitStreams.deliveryAnnotations: object expected");
                    message.deliveryAnnotations = {};
                    for (var keys = Object.keys(object.deliveryAnnotations), i = 0; i < keys.length; ++i)
                        message.deliveryAnnotations[keys[i]] = String(object.deliveryAnnotations[keys[i]]);
                }
                if (object.sendSettled != null)
                    message.sendSettled = Boolean(object.sendSettled);
                if (object.streamName != null)
                    message.streamName = String(object.streamName);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreams message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.RabbitStreams
             * @static
             * @param {protos.records.RabbitStreams} message RabbitStreams
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreams.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.deliveryAnnotations = {};
                if (options.defaults) {
                    object.deliveryTag = "";
                    object.format = 0;
                    object.header = null;
                    object.sendSettled = false;
                    object.streamName = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.deliveryTag != null && message.hasOwnProperty("deliveryTag"))
                    object.deliveryTag = message.deliveryTag;
                if (message.format != null && message.hasOwnProperty("format"))
                    object.format = message.format;
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.protos.records.RabbitStreamsHeader.toObject(message.header, options);
                var keys2;
                if (message.deliveryAnnotations && (keys2 = Object.keys(message.deliveryAnnotations)).length) {
                    object.deliveryAnnotations = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.deliveryAnnotations[keys2[j]] = message.deliveryAnnotations[keys2[j]];
                }
                if (message.sendSettled != null && message.hasOwnProperty("sendSettled"))
                    object.sendSettled = message.sendSettled;
                if (message.streamName != null && message.hasOwnProperty("streamName"))
                    object.streamName = message.streamName;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this RabbitStreams to JSON.
             * @function toJSON
             * @memberof protos.records.RabbitStreams
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreams.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreams;
        })();

        records.RabbitStreamsHeader = (function() {

            /**
             * Properties of a RabbitStreamsHeader.
             * @memberof protos.records
             * @interface IRabbitStreamsHeader
             * @property {boolean|null} [durable] RabbitStreamsHeader durable
             * @property {number|null} [priority] RabbitStreamsHeader priority
             * @property {number|Long|null} [ttl] RabbitStreamsHeader ttl
             * @property {boolean|null} [firstAcquirer] RabbitStreamsHeader firstAcquirer
             * @property {number|null} [deliveryCount] RabbitStreamsHeader deliveryCount
             */

            /**
             * Constructs a new RabbitStreamsHeader.
             * @memberof protos.records
             * @classdesc Represents a RabbitStreamsHeader.
             * @implements IRabbitStreamsHeader
             * @constructor
             * @param {protos.records.IRabbitStreamsHeader=} [properties] Properties to set
             */
            function RabbitStreamsHeader(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RabbitStreamsHeader durable.
             * @member {boolean} durable
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.durable = false;

            /**
             * RabbitStreamsHeader priority.
             * @member {number} priority
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.priority = 0;

            /**
             * RabbitStreamsHeader ttl.
             * @member {number|Long} ttl
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.ttl = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * RabbitStreamsHeader firstAcquirer.
             * @member {boolean} firstAcquirer
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.firstAcquirer = false;

            /**
             * RabbitStreamsHeader deliveryCount.
             * @member {number} deliveryCount
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             */
            RabbitStreamsHeader.prototype.deliveryCount = 0;

            /**
             * Creates a new RabbitStreamsHeader instance using the specified properties.
             * @function create
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {protos.records.IRabbitStreamsHeader=} [properties] Properties to set
             * @returns {protos.records.RabbitStreamsHeader} RabbitStreamsHeader instance
             */
            RabbitStreamsHeader.create = function create(properties) {
                return new RabbitStreamsHeader(properties);
            };

            /**
             * Encodes the specified RabbitStreamsHeader message. Does not implicitly {@link protos.records.RabbitStreamsHeader.verify|verify} messages.
             * @function encode
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {protos.records.IRabbitStreamsHeader} message RabbitStreamsHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsHeader.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.durable != null && Object.hasOwnProperty.call(message, "durable"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.durable);
                if (message.priority != null && Object.hasOwnProperty.call(message, "priority"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.priority);
                if (message.ttl != null && Object.hasOwnProperty.call(message, "ttl"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.ttl);
                if (message.firstAcquirer != null && Object.hasOwnProperty.call(message, "firstAcquirer"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.firstAcquirer);
                if (message.deliveryCount != null && Object.hasOwnProperty.call(message, "deliveryCount"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.deliveryCount);
                return writer;
            };

            /**
             * Encodes the specified RabbitStreamsHeader message, length delimited. Does not implicitly {@link protos.records.RabbitStreamsHeader.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {protos.records.IRabbitStreamsHeader} message RabbitStreamsHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RabbitStreamsHeader.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RabbitStreamsHeader message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.RabbitStreamsHeader} RabbitStreamsHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsHeader.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.RabbitStreamsHeader();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.durable = reader.bool();
                        break;
                    case 2:
                        message.priority = reader.uint32();
                        break;
                    case 3:
                        message.ttl = reader.int64();
                        break;
                    case 4:
                        message.firstAcquirer = reader.bool();
                        break;
                    case 5:
                        message.deliveryCount = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RabbitStreamsHeader message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.RabbitStreamsHeader} RabbitStreamsHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RabbitStreamsHeader.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RabbitStreamsHeader message.
             * @function verify
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RabbitStreamsHeader.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.durable != null && message.hasOwnProperty("durable"))
                    if (typeof message.durable !== "boolean")
                        return "durable: boolean expected";
                if (message.priority != null && message.hasOwnProperty("priority"))
                    if (!$util.isInteger(message.priority))
                        return "priority: integer expected";
                if (message.ttl != null && message.hasOwnProperty("ttl"))
                    if (!$util.isInteger(message.ttl) && !(message.ttl && $util.isInteger(message.ttl.low) && $util.isInteger(message.ttl.high)))
                        return "ttl: integer|Long expected";
                if (message.firstAcquirer != null && message.hasOwnProperty("firstAcquirer"))
                    if (typeof message.firstAcquirer !== "boolean")
                        return "firstAcquirer: boolean expected";
                if (message.deliveryCount != null && message.hasOwnProperty("deliveryCount"))
                    if (!$util.isInteger(message.deliveryCount))
                        return "deliveryCount: integer expected";
                return null;
            };

            /**
             * Creates a RabbitStreamsHeader message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.RabbitStreamsHeader} RabbitStreamsHeader
             */
            RabbitStreamsHeader.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.RabbitStreamsHeader)
                    return object;
                var message = new $root.protos.records.RabbitStreamsHeader();
                if (object.durable != null)
                    message.durable = Boolean(object.durable);
                if (object.priority != null)
                    message.priority = object.priority >>> 0;
                if (object.ttl != null)
                    if ($util.Long)
                        (message.ttl = $util.Long.fromValue(object.ttl)).unsigned = false;
                    else if (typeof object.ttl === "string")
                        message.ttl = parseInt(object.ttl, 10);
                    else if (typeof object.ttl === "number")
                        message.ttl = object.ttl;
                    else if (typeof object.ttl === "object")
                        message.ttl = new $util.LongBits(object.ttl.low >>> 0, object.ttl.high >>> 0).toNumber();
                if (object.firstAcquirer != null)
                    message.firstAcquirer = Boolean(object.firstAcquirer);
                if (object.deliveryCount != null)
                    message.deliveryCount = object.deliveryCount >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a RabbitStreamsHeader message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.RabbitStreamsHeader
             * @static
             * @param {protos.records.RabbitStreamsHeader} message RabbitStreamsHeader
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RabbitStreamsHeader.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.durable = false;
                    object.priority = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ttl = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ttl = options.longs === String ? "0" : 0;
                    object.firstAcquirer = false;
                    object.deliveryCount = 0;
                }
                if (message.durable != null && message.hasOwnProperty("durable"))
                    object.durable = message.durable;
                if (message.priority != null && message.hasOwnProperty("priority"))
                    object.priority = message.priority;
                if (message.ttl != null && message.hasOwnProperty("ttl"))
                    if (typeof message.ttl === "number")
                        object.ttl = options.longs === String ? String(message.ttl) : message.ttl;
                    else
                        object.ttl = options.longs === String ? $util.Long.prototype.toString.call(message.ttl) : options.longs === Number ? new $util.LongBits(message.ttl.low >>> 0, message.ttl.high >>> 0).toNumber() : message.ttl;
                if (message.firstAcquirer != null && message.hasOwnProperty("firstAcquirer"))
                    object.firstAcquirer = message.firstAcquirer;
                if (message.deliveryCount != null && message.hasOwnProperty("deliveryCount"))
                    object.deliveryCount = message.deliveryCount;
                return object;
            };

            /**
             * Converts this RabbitStreamsHeader to JSON.
             * @function toJSON
             * @memberof protos.records.RabbitStreamsHeader
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RabbitStreamsHeader.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RabbitStreamsHeader;
        })();

        records.RedisPubsub = (function() {

            /**
             * Properties of a RedisPubsub.
             * @memberof protos.records
             * @interface IRedisPubsub
             * @property {Object.<string,string>|null} [metadata] RedisPubsub metadata
             * @property {Uint8Array|null} [value] RedisPubsub value
             * @property {number|Long|null} [timestamp] RedisPubsub timestamp
             */

            /**
             * Constructs a new RedisPubsub.
             * @memberof protos.records
             * @classdesc Represents a RedisPubsub.
             * @implements IRedisPubsub
             * @constructor
             * @param {protos.records.IRedisPubsub=} [properties] Properties to set
             */
            function RedisPubsub(properties) {
                this.metadata = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisPubsub metadata.
             * @member {Object.<string,string>} metadata
             * @memberof protos.records.RedisPubsub
             * @instance
             */
            RedisPubsub.prototype.metadata = $util.emptyObject;

            /**
             * RedisPubsub value.
             * @member {Uint8Array} value
             * @memberof protos.records.RedisPubsub
             * @instance
             */
            RedisPubsub.prototype.value = $util.newBuffer([]);

            /**
             * RedisPubsub timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.RedisPubsub
             * @instance
             */
            RedisPubsub.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new RedisPubsub instance using the specified properties.
             * @function create
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {protos.records.IRedisPubsub=} [properties] Properties to set
             * @returns {protos.records.RedisPubsub} RedisPubsub instance
             */
            RedisPubsub.create = function create(properties) {
                return new RedisPubsub(properties);
            };

            /**
             * Encodes the specified RedisPubsub message. Does not implicitly {@link protos.records.RedisPubsub.verify|verify} messages.
             * @function encode
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {protos.records.IRedisPubsub} message RedisPubsub message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubsub.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    for (var keys = Object.keys(message.metadata), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.metadata[keys[i]]).ldelim();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified RedisPubsub message, length delimited. Does not implicitly {@link protos.records.RedisPubsub.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {protos.records.IRedisPubsub} message RedisPubsub message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisPubsub.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisPubsub message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.RedisPubsub} RedisPubsub
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubsub.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.RedisPubsub(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.metadata === $util.emptyObject)
                            message.metadata = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.metadata[key] = value;
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    case 3:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisPubsub message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.RedisPubsub} RedisPubsub
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisPubsub.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisPubsub message.
             * @function verify
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisPubsub.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    if (!$util.isObject(message.metadata))
                        return "metadata: object expected";
                    var key = Object.keys(message.metadata);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.metadata[key[i]]))
                            return "metadata: string{k:string} expected";
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a RedisPubsub message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.RedisPubsub} RedisPubsub
             */
            RedisPubsub.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.RedisPubsub)
                    return object;
                var message = new $root.protos.records.RedisPubsub();
                if (object.metadata) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".protos.records.RedisPubsub.metadata: object expected");
                    message.metadata = {};
                    for (var keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i)
                        message.metadata[keys[i]] = String(object.metadata[keys[i]]);
                }
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a RedisPubsub message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.RedisPubsub
             * @static
             * @param {protos.records.RedisPubsub} message RedisPubsub
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisPubsub.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.metadata = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                var keys2;
                if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                    object.metadata = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.metadata[keys2[j]] = message.metadata[keys2[j]];
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this RedisPubsub to JSON.
             * @function toJSON
             * @memberof protos.records.RedisPubsub
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisPubsub.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisPubsub;
        })();

        records.RedisStreams = (function() {

            /**
             * Properties of a RedisStreams.
             * @memberof protos.records
             * @interface IRedisStreams
             * @property {string|null} [id] RedisStreams id
             * @property {string|null} [key] RedisStreams key
             * @property {string|null} [value] RedisStreams value
             * @property {string|null} [stream] RedisStreams stream
             * @property {number|Long|null} [timestamp] RedisStreams timestamp
             */

            /**
             * Constructs a new RedisStreams.
             * @memberof protos.records
             * @classdesc Represents a RedisStreams.
             * @implements IRedisStreams
             * @constructor
             * @param {protos.records.IRedisStreams=} [properties] Properties to set
             */
            function RedisStreams(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RedisStreams id.
             * @member {string} id
             * @memberof protos.records.RedisStreams
             * @instance
             */
            RedisStreams.prototype.id = "";

            /**
             * RedisStreams key.
             * @member {string} key
             * @memberof protos.records.RedisStreams
             * @instance
             */
            RedisStreams.prototype.key = "";

            /**
             * RedisStreams value.
             * @member {string} value
             * @memberof protos.records.RedisStreams
             * @instance
             */
            RedisStreams.prototype.value = "";

            /**
             * RedisStreams stream.
             * @member {string} stream
             * @memberof protos.records.RedisStreams
             * @instance
             */
            RedisStreams.prototype.stream = "";

            /**
             * RedisStreams timestamp.
             * @member {number|Long} timestamp
             * @memberof protos.records.RedisStreams
             * @instance
             */
            RedisStreams.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new RedisStreams instance using the specified properties.
             * @function create
             * @memberof protos.records.RedisStreams
             * @static
             * @param {protos.records.IRedisStreams=} [properties] Properties to set
             * @returns {protos.records.RedisStreams} RedisStreams instance
             */
            RedisStreams.create = function create(properties) {
                return new RedisStreams(properties);
            };

            /**
             * Encodes the specified RedisStreams message. Does not implicitly {@link protos.records.RedisStreams.verify|verify} messages.
             * @function encode
             * @memberof protos.records.RedisStreams
             * @static
             * @param {protos.records.IRedisStreams} message RedisStreams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreams.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.value);
                if (message.stream != null && Object.hasOwnProperty.call(message, "stream"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.stream);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified RedisStreams message, length delimited. Does not implicitly {@link protos.records.RedisStreams.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.records.RedisStreams
             * @static
             * @param {protos.records.IRedisStreams} message RedisStreams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedisStreams.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RedisStreams message from the specified reader or buffer.
             * @function decode
             * @memberof protos.records.RedisStreams
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.records.RedisStreams} RedisStreams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreams.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.records.RedisStreams();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.key = reader.string();
                        break;
                    case 3:
                        message.value = reader.string();
                        break;
                    case 4:
                        message.stream = reader.string();
                        break;
                    case 5:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RedisStreams message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.records.RedisStreams
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.records.RedisStreams} RedisStreams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedisStreams.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RedisStreams message.
             * @function verify
             * @memberof protos.records.RedisStreams
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RedisStreams.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                if (message.stream != null && message.hasOwnProperty("stream"))
                    if (!$util.isString(message.stream))
                        return "stream: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a RedisStreams message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.records.RedisStreams
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.records.RedisStreams} RedisStreams
             */
            RedisStreams.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.records.RedisStreams)
                    return object;
                var message = new $root.protos.records.RedisStreams();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    message.value = String(object.value);
                if (object.stream != null)
                    message.stream = String(object.stream);
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a RedisStreams message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.records.RedisStreams
             * @static
             * @param {protos.records.RedisStreams} message RedisStreams
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RedisStreams.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    object.key = "";
                    object.value = "";
                    object.stream = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                if (message.stream != null && message.hasOwnProperty("stream"))
                    object.stream = message.stream;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this RedisStreams to JSON.
             * @function toJSON
             * @memberof protos.records.RedisStreams
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RedisStreams.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RedisStreams;
        })();

        return records;
    })();

    return protos;
})();

module.exports = $root;
